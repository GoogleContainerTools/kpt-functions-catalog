{
  "definitions": {
    "com.google.cloud.cnrm.accesscontextmanager.v1beta1.AccessContextManagerAccessLevel": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["accesscontextmanager.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["AccessContextManagerAccessLevel"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["accessPolicyRef", "title"],
          "properties": {
            "accessPolicyRef": {
              "description": "The AccessContextManagerAccessPolicy this\nAccessContextManagerAccessLevel lives in.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "A string of the format \"accessPolicies/{{value}}\", where {{value}} is the name of an AccessContextManagerAccessPolicy.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "basic": {
              "description": "A set of predefined conditions for the access level and a combining function.",
              "type": "object",
              "required": ["conditions"],
              "properties": {
                "combiningFunction": {
                  "description": "How the conditions list should be combined to determine if a request\nis granted this AccessLevel. If AND is used, each Condition in\nconditions must be satisfied for the AccessLevel to be applied. If\nOR is used, at least one Condition in conditions must be satisfied\nfor the AccessLevel to be applied. Default value: \"AND\" Possible values: [\"AND\", \"OR\"].",
                  "type": "string"
                },
                "conditions": {
                  "description": "A set of requirements for the AccessLevel to be granted.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "devicePolicy": {
                        "description": "Device specific restrictions, all restrictions must hold for\nthe Condition to be true. If not specified, all devices are\nallowed.",
                        "type": "object",
                        "properties": {
                          "allowedDeviceManagementLevels": {
                            "description": "A list of allowed device management levels.\nAn empty list allows all management levels. Possible values: [\"MANAGEMENT_UNSPECIFIED\", \"NONE\", \"BASIC\", \"COMPLETE\"].",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "allowedEncryptionStatuses": {
                            "description": "A list of allowed encryptions statuses.\nAn empty list allows all statuses. Possible values: [\"ENCRYPTION_UNSPECIFIED\", \"ENCRYPTION_UNSUPPORTED\", \"UNENCRYPTED\", \"ENCRYPTED\"].",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "osConstraints": {
                            "description": "A list of allowed OS versions.\nAn empty list allows all types and all versions.",
                            "type": "array",
                            "items": {
                              "type": "object",
                              "required": ["osType"],
                              "properties": {
                                "minimumVersion": {
                                  "description": "The minimum allowed OS version. If not set, any version\nof this OS satisfies the constraint.\nFormat: \"major.minor.patch\" such as \"10.5.301\", \"9.2.1\".",
                                  "type": "string"
                                },
                                "osType": {
                                  "description": "The operating system type of the device. Possible values: [\"OS_UNSPECIFIED\", \"DESKTOP_MAC\", \"DESKTOP_WINDOWS\", \"DESKTOP_LINUX\", \"DESKTOP_CHROME_OS\", \"ANDROID\", \"IOS\"].",
                                  "type": "string"
                                },
                                "requireVerifiedChromeOs": {
                                  "description": "If you specify DESKTOP_CHROME_OS for osType, you can optionally include requireVerifiedChromeOs to require Chrome Verified Access.",
                                  "type": "boolean"
                                }
                              }
                            }
                          },
                          "requireAdminApproval": {
                            "description": "Whether the device needs to be approved by the customer admin.",
                            "type": "boolean"
                          },
                          "requireCorpOwned": {
                            "description": "Whether the device needs to be corp owned.",
                            "type": "boolean"
                          },
                          "requireScreenLock": {
                            "description": "Whether or not screenlock is required for the DevicePolicy\nto be true. Defaults to false.",
                            "type": "boolean"
                          }
                        }
                      },
                      "ipSubnetworks": {
                        "description": "A list of CIDR block IP subnetwork specification. May be IPv4\nor IPv6.\nNote that for a CIDR IP address block, the specified IP address\nportion must be properly truncated (i.e. all the host bits must\nbe zero) or the input is considered malformed. For example,\n\"192.0.2.0/24\" is accepted but \"192.0.2.1/24\" is not. Similarly,\nfor IPv6, \"2001:db8::/32\" is accepted whereas \"2001:db8::1/32\"\nis not. The originating IP of a request must be in one of the\nlisted subnets in order for this Condition to be true.\nIf empty, all IP addresses are allowed.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "members": {
                        "type": "array",
                        "items": {
                          "description": "An allowed list of members (users, service accounts).\nUsing groups is not supported.\n\nThe signed-in user originating the request must be a part of one\nof the provided members. If not specified, a request may come\nfrom any user (logged in/not logged in, not present in any\ngroups, etc.).",
                          "type": "object",
                          "properties": {
                            "serviceAccountRef": {
                              "type": "object",
                              "properties": {
                                "external": {
                                  "description": "A string of the format \"serviceAccount:{{value}}\", where {{value}} is the email of an IAMServiceAccount.",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                  "type": "string"
                                },
                                "namespace": {
                                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                  "type": "string"
                                }
                              }
                            },
                            "user": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "negate": {
                        "description": "Whether to negate the Condition. If true, the Condition becomes\na NAND over its non-empty fields, each field must be false for\nthe Condition overall to be satisfied. Defaults to false.",
                        "type": "boolean"
                      },
                      "regions": {
                        "description": "The request must originate from one of the provided\ncountries/regions.\nFormat: A valid ISO 3166-1 alpha-2 code.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "requiredAccessLevels": {
                        "type": "array",
                        "items": {
                          "description": "A list of other access levels defined in the same policy.\nReferencing an AccessContextManagerAccessLevel which does not exist\nis an error. All access levels listed must be granted for the\ncondition to be true.",
                          "type": "object",
                          "properties": {
                            "external": {
                              "description": "The name of an AccessContextManagerAccessLevel.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                              "type": "string"
                            },
                            "namespace": {
                              "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "custom": {
              "description": "Custom access level conditions are set using the Cloud Common Expression Language to represent the necessary conditions for the level to apply to a request. \nSee CEL spec at: https://github.com/google/cel-spec.",
              "type": "object",
              "required": ["expr"],
              "properties": {
                "expr": {
                  "description": "Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language.\nThis page details the objects and attributes that are used to the build the CEL expressions for \ncustom access levels - https://cloud.google.com/access-context-manager/docs/custom-access-level-spec.",
                  "type": "object",
                  "required": ["expression"],
                  "properties": {
                    "description": {
                      "description": "Description of the expression.",
                      "type": "string"
                    },
                    "expression": {
                      "description": "Textual representation of an expression in Common Expression Language syntax.",
                      "type": "string"
                    },
                    "location": {
                      "description": "String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.",
                      "type": "string"
                    },
                    "title": {
                      "description": "Title for the expression, i.e. a short string describing its purpose.",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "description": {
              "description": "Description of the AccessLevel and its use. Does not affect behavior.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "title": {
              "description": "Human readable title. Must be unique within the Policy.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "accesscontextmanager.cnrm.cloud.google.com",
          "kind": "AccessContextManagerAccessLevel",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.accesscontextmanager.v1beta1.AccessContextManagerAccessLevelList": {
      "description": "AccessContextManagerAccessLevelList is a list of AccessContextManagerAccessLevel",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["accesscontextmanager.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of accesscontextmanageraccesslevels. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.accesscontextmanager.v1beta1.AccessContextManagerAccessLevel"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["AccessContextManagerAccessLevelList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "accesscontextmanager.cnrm.cloud.google.com",
          "kind": "AccessContextManagerAccessLevelList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.accesscontextmanager.v1beta1.AccessContextManagerAccessPolicy": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["accesscontextmanager.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["AccessContextManagerAccessPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["title"],
          "properties": {
            "resourceID": {
              "description": "Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            },
            "title": {
              "description": "Human readable title. Does not affect behavior.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Time the AccessPolicy was created in UTC.",
              "type": "string"
            },
            "name": {
              "description": "Resource name of the AccessPolicy. Format: {policy_id}.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Time the AccessPolicy was updated in UTC.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "accesscontextmanager.cnrm.cloud.google.com",
          "kind": "AccessContextManagerAccessPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.accesscontextmanager.v1beta1.AccessContextManagerAccessPolicyList": {
      "description": "AccessContextManagerAccessPolicyList is a list of AccessContextManagerAccessPolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["accesscontextmanager.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of accesscontextmanageraccesspolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.accesscontextmanager.v1beta1.AccessContextManagerAccessPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["AccessContextManagerAccessPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "accesscontextmanager.cnrm.cloud.google.com",
          "kind": "AccessContextManagerAccessPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.accesscontextmanager.v1beta1.AccessContextManagerServicePerimeter": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["accesscontextmanager.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["AccessContextManagerServicePerimeter"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["accessPolicyRef", "title"],
          "properties": {
            "accessPolicyRef": {
              "description": "The AccessContextManagerAccessPolicy this\nAccessContextManagerServicePerimeter lives in.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "A string of the format \"accessPolicies/{{value}}\", where {{value}} is the name of an AccessContextManagerAccessPolicy.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "description": {
              "description": "Description of the ServicePerimeter and its use. Does not affect\nbehavior.",
              "type": "string"
            },
            "perimeterType": {
              "description": "Immutable. Specifies the type of the Perimeter. There are two types: regular and\nbridge. Regular Service Perimeter contains resources, access levels,\nand restricted services. Every resource can be in at most\nONE regular Service Perimeter.\n\nIn addition to being in a regular service perimeter, a resource can also\nbe in zero or more perimeter bridges. A perimeter bridge only contains\nresources. Cross project operations are permitted if all effected\nresources share some perimeter (whether bridge or regular). Perimeter\nBridge does not contain access levels or services: those are governed\nentirely by the regular perimeter that resource is in.\n\nPerimeter Bridges are typically useful when building more complex\ntopologies with many independent perimeters that need to share some data\nwith a common perimeter, but should not be able to share data among\nthemselves. Default value: \"PERIMETER_TYPE_REGULAR\" Possible values: [\"PERIMETER_TYPE_REGULAR\", \"PERIMETER_TYPE_BRIDGE\"].",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "spec": {
              "description": "Proposed (or dry run) ServicePerimeter configuration.\nThis configuration allows to specify and test ServicePerimeter configuration\nwithout enforcing actual access restrictions. Only allowed to be set when\nthe 'useExplicitDryRunSpec' flag is set.",
              "type": "object",
              "properties": {
                "accessLevels": {
                  "type": "array",
                  "items": {
                    "description": "(Optional) A list of AccessLevel resource names that allow resources within\nthe ServicePerimeter to be accessed from the internet. AccessLevels listed\nmust be in the same policy as this ServicePerimeter.\nReferencing a nonexistent AccessLevel is a syntax error. If no\nAccessLevel names are listed, resources within the perimeter can\nonly be accessed via GCP calls with request origins within the\nperimeter. For Service Perimeter Bridge, must be empty.",
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "A string of the format \"{{parent}}/accessLevels/{{value}}\", where {{value}} is the name of an AccessContextManagerAccessLevel.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  }
                },
                "egressPolicies": {
                  "description": "List of EgressPolicies to apply to the perimeter. A perimeter may \nhave multiple EgressPolicies, each of which is evaluated separately.\nAccess is granted if any EgressPolicy grants it. Must be empty for \na perimeter bridge.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "egressFrom": {
                        "description": "Defines conditions on the source of a request causing this 'EgressPolicy' to apply.",
                        "type": "object",
                        "properties": {
                          "identities": {
                            "type": "array",
                            "items": {
                              "description": "(Optional) A list of identities that are allowed access through this\nEgressPolicy. Should be in the format of email address. The email\naddress should represent individual user or service account only.",
                              "type": "object",
                              "properties": {
                                "serviceAccountRef": {
                                  "type": "object",
                                  "properties": {
                                    "external": {
                                      "description": "A string of the format \"serviceAccount:{{value}}\", where {{value}} is the email of an IAMServiceAccount.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                      "type": "string"
                                    }
                                  }
                                },
                                "user": {
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "identityType": {
                            "description": "Specifies the type of identities that are allowed access to outside the \nperimeter. If left unspecified, then members of 'identities' field will \nbe allowed access. Possible values: [\"IDENTITY_TYPE_UNSPECIFIED\", \"ANY_IDENTITY\", \"ANY_USER_ACCOUNT\", \"ANY_SERVICE_ACCOUNT\"].",
                            "type": "string"
                          }
                        }
                      },
                      "egressTo": {
                        "description": "Defines the conditions on the 'ApiOperation' and destination resources that \ncause this 'EgressPolicy' to apply.",
                        "type": "object",
                        "properties": {
                          "operations": {
                            "description": "A list of 'ApiOperations' that this egress rule applies to. A request matches \nif it contains an operation/service in this list.",
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "methodSelectors": {
                                  "description": "API methods or permissions to allow. Method or permission must belong \nto the service specified by 'serviceName' field. A single MethodSelector \nentry with '*' specified for the 'method' field will allow all methods \nAND permissions for the service specified in 'serviceName'.",
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "method": {
                                        "description": "Value for 'method' should be a valid method name for the corresponding \n'serviceName' in 'ApiOperation'. If '*' used as value for method, \nthen ALL methods and permissions are allowed.",
                                        "type": "string"
                                      },
                                      "permission": {
                                        "description": "Value for permission should be a valid Cloud IAM permission for the \ncorresponding 'serviceName' in 'ApiOperation'.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                },
                                "serviceName": {
                                  "description": "The name of the API whose methods or permissions the 'IngressPolicy' or \n'EgressPolicy' want to allow. A single 'ApiOperation' with serviceName \nfield set to '*' will allow all methods AND permissions for all services.",
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "resources": {
                            "type": "array",
                            "items": {
                              "description": "(Optional) A list of resources, currently only projects in the form\n\"projects/{project_number}\". A request\nmatches if it contains a resource in this list.",
                              "type": "object",
                              "properties": {
                                "projectRef": {
                                  "type": "object",
                                  "properties": {
                                    "external": {
                                      "description": "A string of the format \"projects/{{value}}\", where {{value}} is the number of a Project.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "ingressPolicies": {
                  "description": "List of 'IngressPolicies' to apply to the perimeter. A perimeter may\nhave multiple 'IngressPolicies', each of which is evaluated\nseparately. Access is granted if any 'Ingress Policy' grants it.\nMust be empty for a perimeter bridge.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "ingressFrom": {
                        "description": "Defines the conditions on the source of a request causing this 'IngressPolicy'\nto apply.",
                        "type": "object",
                        "properties": {
                          "identities": {
                            "type": "array",
                            "items": {
                              "description": "(Optional) A list of identities that are allowed access through this\nEgressPolicy. Should be in the format of email address. The email\naddress should represent individual user or service account only.",
                              "type": "object",
                              "properties": {
                                "serviceAccountRef": {
                                  "type": "object",
                                  "properties": {
                                    "external": {
                                      "description": "A string of the format \"serviceAccount:{{value}}\", where {{value}} is the email of an IAMServiceAccount.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                      "type": "string"
                                    }
                                  }
                                },
                                "user": {
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "identityType": {
                            "description": "Specifies the type of identities that are allowed access from outside the \nperimeter. If left unspecified, then members of 'identities' field will be \nallowed access. Possible values: [\"IDENTITY_TYPE_UNSPECIFIED\", \"ANY_IDENTITY\", \"ANY_USER_ACCOUNT\", \"ANY_SERVICE_ACCOUNT\"].",
                            "type": "string"
                          },
                          "sources": {
                            "description": "Sources that this 'IngressPolicy' authorizes access from.",
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "accessLevelRef": {
                                  "description": "An AccessLevel resource name that allow resources within the\nServicePerimeters to be accessed from the internet. AccessLevels\nlisted must be in the same policy as this ServicePerimeter.\nReferencing a nonexistent AccessLevel will cause an error. If no\nAccessLevel names are listed, resources within the perimeter can\nonly be accessed via Google Cloud calls with request origins within\nthe perimeter.",
                                  "type": "object",
                                  "properties": {
                                    "external": {
                                      "description": "A string of the format \"{{parent}}/accessLevels/{{value}}\", where {{value}} is the name of an AccessContextManagerAccessLevel.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                      "type": "string"
                                    }
                                  }
                                },
                                "projectRef": {
                                  "description": "(Optional) A Google Cloud resource that is allowed to ingress the\nperimeter. Requests from these resources will be allowed to access\nperimeter data. Currently only projects are allowed. Format\n\"projects/{project_number}\" The project may be in any Google Cloud\norganization, not just the organization that the perimeter is defined in.",
                                  "type": "object",
                                  "properties": {
                                    "external": {
                                      "description": "A string of the format \"projects/{{value}}\", where {{value}} is the number of a Project.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "ingressTo": {
                        "description": "Defines the conditions on the 'ApiOperation' and request destination that cause\nthis 'IngressPolicy' to apply.",
                        "type": "object",
                        "properties": {
                          "operations": {
                            "description": "A list of 'ApiOperations' the sources specified in corresponding 'IngressFrom' \nare allowed to perform in this 'ServicePerimeter'.",
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "methodSelectors": {
                                  "description": "API methods or permissions to allow. Method or permission must belong to \nthe service specified by serviceName field. A single 'MethodSelector' entry \nwith '*' specified for the method field will allow all methods AND \npermissions for the service specified in 'serviceName'.",
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "method": {
                                        "description": "Value for method should be a valid method name for the corresponding \nserviceName in 'ApiOperation'. If '*' used as value for 'method', then \nALL methods and permissions are allowed.",
                                        "type": "string"
                                      },
                                      "permission": {
                                        "description": "Value for permission should be a valid Cloud IAM permission for the \ncorresponding 'serviceName' in 'ApiOperation'.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                },
                                "serviceName": {
                                  "description": "The name of the API whose methods or permissions the 'IngressPolicy' or \n'EgressPolicy' want to allow. A single 'ApiOperation' with 'serviceName' \nfield set to '*' will allow all methods AND permissions for all services.",
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "resources": {
                            "type": "array",
                            "items": {
                              "description": "A list of resources, currently only projects in the form\n\"projects/{project_number}\", protected by this ServicePerimeter\nthat are allowed to be accessed by sources defined in the\ncorresponding IngressFrom. A request matches if it contains a\nresource in this list.",
                              "type": "object",
                              "properties": {
                                "projectRef": {
                                  "type": "object",
                                  "properties": {
                                    "external": {
                                      "description": "A string of the format \"projects/{{value}}\", where {{value}} is the number of a Project.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "resources": {
                  "type": "array",
                  "items": {
                    "description": "(Optional) A list of GCP resources that are inside of the service perimeter.\nCurrently only projects are allowed.",
                    "type": "object",
                    "properties": {
                      "projectRef": {
                        "type": "object",
                        "properties": {
                          "external": {
                            "description": "A string of the format \"projects/{{value}}\", where {{value}} is the number of a Project.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                },
                "restrictedServices": {
                  "description": "GCP services that are subject to the Service Perimeter\nrestrictions. Must contain a list of services. For example, if\n'storage.googleapis.com' is specified, access to the storage\nbuckets inside the perimeter must meet the perimeter's access\nrestrictions.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "vpcAccessibleServices": {
                  "description": "Specifies how APIs are allowed to communicate within the Service\nPerimeter.",
                  "type": "object",
                  "properties": {
                    "allowedServices": {
                      "description": "The list of APIs usable within the Service Perimeter.\nMust be empty unless 'enableRestriction' is True.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "enableRestriction": {
                      "description": "Whether to restrict API calls within the Service Perimeter to the\nlist of APIs specified in 'allowedServices'.",
                      "type": "boolean"
                    }
                  }
                }
              }
            },
            "status": {
              "description": "ServicePerimeter configuration. Specifies sets of resources,\nrestricted services and access levels that determine\nperimeter content and boundaries.",
              "type": "object",
              "properties": {
                "accessLevels": {
                  "type": "array",
                  "items": {
                    "description": "(Optional) A list of AccessLevel resource names that allow resources within\nthe ServicePerimeter to be accessed from the internet. AccessLevels listed\nmust be in the same policy as this ServicePerimeter.\nReferencing a nonexistent AccessLevel is a syntax error. If no\nAccessLevel names are listed, resources within the perimeter can\nonly be accessed via GCP calls with request origins within the\nperimeter. For Service Perimeter Bridge, must be empty.",
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "A string of the format \"{{parent}}/accessLevels/{{value}}\", where {{value}} is the name of an AccessContextManagerAccessLevel.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  }
                },
                "egressPolicies": {
                  "description": "List of EgressPolicies to apply to the perimeter. A perimeter may \nhave multiple EgressPolicies, each of which is evaluated separately.\nAccess is granted if any EgressPolicy grants it. Must be empty for \na perimeter bridge.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "egressFrom": {
                        "description": "Defines conditions on the source of a request causing this 'EgressPolicy' to apply.",
                        "type": "object",
                        "properties": {
                          "identities": {
                            "type": "array",
                            "items": {
                              "description": "(Optional) A list of identities that are allowed access through this\nEgressPolicy. Should be in the format of email address. The email\naddress should represent individual user or service account only.",
                              "type": "object",
                              "properties": {
                                "serviceAccountRef": {
                                  "type": "object",
                                  "properties": {
                                    "external": {
                                      "description": "A string of the format \"serviceAccount:{{value}}\", where {{value}} is the email of an IAMServiceAccount.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                      "type": "string"
                                    }
                                  }
                                },
                                "user": {
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "identityType": {
                            "description": "Specifies the type of identities that are allowed access to outside the \nperimeter. If left unspecified, then members of 'identities' field will \nbe allowed access. Possible values: [\"IDENTITY_TYPE_UNSPECIFIED\", \"ANY_IDENTITY\", \"ANY_USER_ACCOUNT\", \"ANY_SERVICE_ACCOUNT\"].",
                            "type": "string"
                          }
                        }
                      },
                      "egressTo": {
                        "description": "Defines the conditions on the 'ApiOperation' and destination resources that \ncause this 'EgressPolicy' to apply.",
                        "type": "object",
                        "properties": {
                          "operations": {
                            "description": "A list of 'ApiOperations' that this egress rule applies to. A request matches \nif it contains an operation/service in this list.",
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "methodSelectors": {
                                  "description": "API methods or permissions to allow. Method or permission must belong \nto the service specified by 'serviceName' field. A single MethodSelector \nentry with '*' specified for the 'method' field will allow all methods \nAND permissions for the service specified in 'serviceName'.",
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "method": {
                                        "description": "Value for 'method' should be a valid method name for the corresponding \n'serviceName' in 'ApiOperation'. If '*' used as value for method, \nthen ALL methods and permissions are allowed.",
                                        "type": "string"
                                      },
                                      "permission": {
                                        "description": "Value for permission should be a valid Cloud IAM permission for the \ncorresponding 'serviceName' in 'ApiOperation'.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                },
                                "serviceName": {
                                  "description": "The name of the API whose methods or permissions the 'IngressPolicy' or \n'EgressPolicy' want to allow. A single 'ApiOperation' with serviceName \nfield set to '*' will allow all methods AND permissions for all services.",
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "resources": {
                            "type": "array",
                            "items": {
                              "description": "(Optional) A list of resources, currently only projects in the form\n\"projects/{project_number}\". A request\nmatches if it contains a resource in this list.",
                              "type": "object",
                              "properties": {
                                "projectRef": {
                                  "type": "object",
                                  "properties": {
                                    "external": {
                                      "description": "A string of the format \"projects/{{value}}\", where {{value}} is the number of a Project.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "ingressPolicies": {
                  "description": "List of 'IngressPolicies' to apply to the perimeter. A perimeter may\nhave multiple 'IngressPolicies', each of which is evaluated\nseparately. Access is granted if any 'Ingress Policy' grants it.\nMust be empty for a perimeter bridge.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "ingressFrom": {
                        "description": "Defines the conditions on the source of a request causing this 'IngressPolicy'\nto apply.",
                        "type": "object",
                        "properties": {
                          "identities": {
                            "type": "array",
                            "items": {
                              "description": "(Optional) A list of identities that are allowed access through this\nEgressPolicy. Should be in the format of email address. The email\naddress should represent individual user or service account only.",
                              "type": "object",
                              "properties": {
                                "serviceAccountRef": {
                                  "type": "object",
                                  "properties": {
                                    "external": {
                                      "description": "A string of the format \"serviceAccount:{{value}}\", where {{value}} is the email of an IAMServiceAccount.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                      "type": "string"
                                    }
                                  }
                                },
                                "user": {
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "identityType": {
                            "description": "Specifies the type of identities that are allowed access from outside the \nperimeter. If left unspecified, then members of 'identities' field will be \nallowed access. Possible values: [\"IDENTITY_TYPE_UNSPECIFIED\", \"ANY_IDENTITY\", \"ANY_USER_ACCOUNT\", \"ANY_SERVICE_ACCOUNT\"].",
                            "type": "string"
                          },
                          "sources": {
                            "description": "Sources that this 'IngressPolicy' authorizes access from.",
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "accessLevelRef": {
                                  "description": "An AccessLevel resource name that allow resources within the\nServicePerimeters to be accessed from the internet. AccessLevels\nlisted must be in the same policy as this ServicePerimeter.\nReferencing a nonexistent AccessLevel will cause an error. If no\nAccessLevel names are listed, resources within the perimeter can\nonly be accessed via Google Cloud calls with request origins within\nthe perimeter.",
                                  "type": "object",
                                  "properties": {
                                    "external": {
                                      "description": "A string of the format \"{{parent}}/accessLevels/{{value}}\", where {{value}} is the name of an AccessContextManagerAccessLevel.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                      "type": "string"
                                    }
                                  }
                                },
                                "projectRef": {
                                  "description": "(Optional) A Google Cloud resource that is allowed to ingress the\nperimeter. Requests from these resources will be allowed to access\nperimeter data. Currently only projects are allowed. Format\n\"projects/{project_number}\" The project may be in any Google Cloud\norganization, not just the organization that the perimeter is defined in.",
                                  "type": "object",
                                  "properties": {
                                    "external": {
                                      "description": "A string of the format \"projects/{{value}}\", where {{value}} is the number of a Project.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "ingressTo": {
                        "description": "Defines the conditions on the 'ApiOperation' and request destination that cause\nthis 'IngressPolicy' to apply.",
                        "type": "object",
                        "properties": {
                          "operations": {
                            "description": "A list of 'ApiOperations' the sources specified in corresponding 'IngressFrom' \nare allowed to perform in this 'ServicePerimeter'.",
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "methodSelectors": {
                                  "description": "API methods or permissions to allow. Method or permission must belong to \nthe service specified by serviceName field. A single 'MethodSelector' entry \nwith '*' specified for the method field will allow all methods AND \npermissions for the service specified in 'serviceName'.",
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "method": {
                                        "description": "Value for method should be a valid method name for the corresponding \nserviceName in 'ApiOperation'. If '*' used as value for 'method', then \nALL methods and permissions are allowed.",
                                        "type": "string"
                                      },
                                      "permission": {
                                        "description": "Value for permission should be a valid Cloud IAM permission for the \ncorresponding 'serviceName' in 'ApiOperation'.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                },
                                "serviceName": {
                                  "description": "The name of the API whose methods or permissions the 'IngressPolicy' or \n'EgressPolicy' want to allow. A single 'ApiOperation' with 'serviceName' \nfield set to '*' will allow all methods AND permissions for all services.",
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "resources": {
                            "type": "array",
                            "items": {
                              "description": "A list of resources, currently only projects in the form\n\"projects/{project_number}\", protected by this ServicePerimeter\nthat are allowed to be accessed by sources defined in the\ncorresponding IngressFrom. A request matches if it contains a\nresource in this list.",
                              "type": "object",
                              "properties": {
                                "projectRef": {
                                  "type": "object",
                                  "properties": {
                                    "external": {
                                      "description": "A string of the format \"projects/{{value}}\", where {{value}} is the number of a Project.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "resources": {
                  "type": "array",
                  "items": {
                    "description": "(Optional) A list of GCP resources that are inside of the service perimeter.\nCurrently only projects are allowed.",
                    "type": "object",
                    "properties": {
                      "projectRef": {
                        "type": "object",
                        "properties": {
                          "external": {
                            "description": "A string of the format \"projects/{{value}}\", where {{value}} is the number of a Project.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                },
                "restrictedServices": {
                  "description": "GCP services that are subject to the Service Perimeter\nrestrictions. Must contain a list of services. For example, if\n'storage.googleapis.com' is specified, access to the storage\nbuckets inside the perimeter must meet the perimeter's access\nrestrictions.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "vpcAccessibleServices": {
                  "description": "Specifies how APIs are allowed to communicate within the Service\nPerimeter.",
                  "type": "object",
                  "properties": {
                    "allowedServices": {
                      "description": "The list of APIs usable within the Service Perimeter.\nMust be empty unless 'enableRestriction' is True.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "enableRestriction": {
                      "description": "Whether to restrict API calls within the Service Perimeter to the\nlist of APIs specified in 'allowedServices'.",
                      "type": "boolean"
                    }
                  }
                }
              }
            },
            "title": {
              "description": "Human readable title. Must be unique within the Policy.",
              "type": "string"
            },
            "useExplicitDryRunSpec": {
              "description": "Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly exists\nfor all Service Perimeters, and that spec is identical to the status for those\nService Perimeters. When this flag is set, it inhibits the generation of the\nimplicit spec, thereby allowing the user to explicitly provide a\nconfiguration (\"spec\") to use in a dry-run version of the Service Perimeter.\nThis allows the user to test changes to the enforced config (\"status\") without\nactually enforcing them. This testing is done through analyzing the differences\nbetween currently enforced and suggested restrictions. useExplicitDryRunSpec must\nbet set to True if any of the fields in the spec are set to non-default values.",
              "type": "boolean"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Time the AccessPolicy was created in UTC.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Time the AccessPolicy was updated in UTC.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "accesscontextmanager.cnrm.cloud.google.com",
          "kind": "AccessContextManagerServicePerimeter",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.accesscontextmanager.v1beta1.AccessContextManagerServicePerimeterList": {
      "description": "AccessContextManagerServicePerimeterList is a list of AccessContextManagerServicePerimeter",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["accesscontextmanager.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of accesscontextmanagerserviceperimeters. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.accesscontextmanager.v1beta1.AccessContextManagerServicePerimeter"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["AccessContextManagerServicePerimeterList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "accesscontextmanager.cnrm.cloud.google.com",
          "kind": "AccessContextManagerServicePerimeterList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.artifactregistry.v1beta1.ArtifactRegistryRepository": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["artifactregistry.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ArtifactRegistryRepository"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["format", "location"],
          "properties": {
            "description": {
              "description": "The user-provided description of the repository.",
              "type": "string"
            },
            "format": {
              "description": "Immutable. The format of packages that are stored in the repository. You can only create\nalpha formats if you are a member of the [alpha user group](https://cloud.google.com/artifact-registry/docs/supported-formats#alpha-access).\n\n- DOCKER\n- MAVEN ([Preview](https://cloud.google.com/products#product-launch-stages))\n- NPM ([Preview](https://cloud.google.com/products#product-launch-stages))\n- PYTHON ([Preview](https://cloud.google.com/products#product-launch-stages))\n- APT ([alpha](https://cloud.google.com/products#product-launch-stages))\n- YUM ([alpha](https://cloud.google.com/products#product-launch-stages))\n- HELM ([alpha](https://cloud.google.com/products#product-launch-stages)).",
              "type": "string"
            },
            "kmsKeyRef": {
              "description": "The customer managed encryption key that\u2019s used to encrypt the\ncontents of the Repository.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a KMSCryptoKey.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "location": {
              "description": "Immutable. The name of the location this repository is located in.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The repositoryId of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "The time when the repository was created.",
              "type": "string"
            },
            "name": {
              "description": "The name of the repository, for example:\n\"projects/p1/locations/us-central1/repositories/repo1\".",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "The time when the repository was last updated.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "artifactregistry.cnrm.cloud.google.com",
          "kind": "ArtifactRegistryRepository",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.artifactregistry.v1beta1.ArtifactRegistryRepositoryList": {
      "description": "ArtifactRegistryRepositoryList is a list of ArtifactRegistryRepository",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["artifactregistry.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of artifactregistryrepositories. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.artifactregistry.v1beta1.ArtifactRegistryRepository"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ArtifactRegistryRepositoryList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "artifactregistry.cnrm.cloud.google.com",
          "kind": "ArtifactRegistryRepositoryList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.bigquery.v1beta1.BigQueryDataset": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["bigquery.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BigQueryDataset"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "access": {
              "description": "An array of objects that define dataset access for one or more entities.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "domain": {
                    "description": "A domain to grant access to. Any users signed in with the\ndomain specified will be granted the specified access.",
                    "type": "string"
                  },
                  "groupByEmail": {
                    "description": "An email address of a Google Group to grant access to.",
                    "type": "string"
                  },
                  "role": {
                    "description": "Describes the rights granted to the user specified by the other\nmember of the access object. Basic, predefined, and custom roles\nare supported. Predefined roles that have equivalent basic roles\nare swapped by the API to their basic counterparts. See\n[official docs](https://cloud.google.com/bigquery/docs/access-control).",
                    "type": "string"
                  },
                  "specialGroup": {
                    "description": "A special group to grant access to. Possible values include:\n\n\n* 'projectOwners': Owners of the enclosing project.\n\n\n* 'projectReaders': Readers of the enclosing project.\n\n\n* 'projectWriters': Writers of the enclosing project.\n\n\n* 'allAuthenticatedUsers': All authenticated BigQuery users.",
                    "type": "string"
                  },
                  "userByEmail": {
                    "description": "An email address of a user to grant access to. For example:\nfred@example.com.",
                    "type": "string"
                  },
                  "view": {
                    "description": "A view from a different dataset to grant access to. Queries\nexecuted against that view will have read access to tables in\nthis dataset. The role field is not required when this field is\nset. If that view is updated by any user, access to the view\nneeds to be granted again via an update operation.",
                    "type": "object",
                    "required": ["datasetId", "projectId", "tableId"],
                    "properties": {
                      "datasetId": {
                        "description": "The ID of the dataset containing this table.",
                        "type": "string"
                      },
                      "projectId": {
                        "description": "The ID of the project containing this table.",
                        "type": "string"
                      },
                      "tableId": {
                        "description": "The ID of the table. The ID must contain only letters (a-z,\nA-Z), numbers (0-9), or underscores (_). The maximum length\nis 1,024 characters.",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "defaultEncryptionConfiguration": {
              "description": "The default encryption key for all tables in the dataset. Once this property is set,\nall newly-created partitioned tables in the dataset will have encryption key set to\nthis value, unless table creation request (or query) overrides the key.",
              "type": "object",
              "required": ["kmsKeyRef"],
              "properties": {
                "kmsKeyRef": {
                  "description": "Describes the Cloud KMS encryption key that will be used to protect destination\nBigQuery table. The BigQuery Service Account associated with your project requires\naccess to this encryption key.",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a KMSCryptoKey.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "defaultPartitionExpirationMs": {
              "description": "The default partition expiration for all partitioned tables in\nthe dataset, in milliseconds.\n\n\nOnce this property is set, all newly-created partitioned tables in\nthe dataset will have an 'expirationMs' property in the 'timePartitioning'\nsettings set to this value, and changing the value will only\naffect new tables, not existing ones. The storage in a partition will\nhave an expiration time of its partition time plus this value.\nSetting this property overrides the use of 'defaultTableExpirationMs'\nfor partitioned tables: only one of 'defaultTableExpirationMs' and\n'defaultPartitionExpirationMs' will be used for any new partitioned\ntable. If you provide an explicit 'timePartitioning.expirationMs' when\ncreating or updating a partitioned table, that value takes precedence\nover the default partition expiration time indicated by this property.",
              "type": "integer"
            },
            "defaultTableExpirationMs": {
              "description": "The default lifetime of all tables in the dataset, in milliseconds.\nThe minimum value is 3600000 milliseconds (one hour).\n\n\nOnce this property is set, all newly-created tables in the dataset\nwill have an 'expirationTime' property set to the creation time plus\nthe value in this property, and changing the value will only affect\nnew tables, not existing ones. When the 'expirationTime' for a given\ntable is reached, that table will be deleted automatically.\nIf a table's 'expirationTime' is modified or removed before the\ntable expires, or if you provide an explicit 'expirationTime' when\ncreating a table, that value takes precedence over the default\nexpiration time indicated by this property.",
              "type": "integer"
            },
            "description": {
              "description": "A user-friendly description of the dataset.",
              "type": "string"
            },
            "friendlyName": {
              "description": "A descriptive name for the dataset.",
              "type": "string"
            },
            "location": {
              "description": "Immutable. The geographic location where the dataset should reside.\nSee [official docs](https://cloud.google.com/bigquery/docs/dataset-locations).\n\n\nThere are two types of locations, regional or multi-regional. A regional\nlocation is a specific geographic place, such as Tokyo, and a multi-regional\nlocation is a large geographic area, such as the United States, that\ncontains at least two geographic places.\n\n\nThe default value is multi-regional location 'US'.\nChanging this forces a new resource to be created.",
              "type": "string"
            },
            "projectRef": {
              "description": "The project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a Project.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The datasetId of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTime": {
              "description": "The time when this dataset was created, in milliseconds since the\nepoch.",
              "type": "integer"
            },
            "etag": {
              "description": "A hash of the resource.",
              "type": "string"
            },
            "lastModifiedTime": {
              "description": "The date when this dataset or any of its tables was last modified, in\nmilliseconds since the epoch.",
              "type": "integer"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "bigquery.cnrm.cloud.google.com",
          "kind": "BigQueryDataset",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.bigquery.v1beta1.BigQueryDatasetList": {
      "description": "BigQueryDatasetList is a list of BigQueryDataset",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["bigquery.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of bigquerydatasets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.bigquery.v1beta1.BigQueryDataset"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BigQueryDatasetList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "bigquery.cnrm.cloud.google.com",
          "kind": "BigQueryDatasetList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.bigquery.v1beta1.BigQueryJob": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["bigquery.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BigQueryJob"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "copy": {
              "description": "Immutable. Copies a table.",
              "type": "object",
              "required": ["sourceTables"],
              "properties": {
                "createDisposition": {
                  "description": "Immutable. Specifies whether the job is allowed to create new tables. The following values are supported:\nCREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table.\nCREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result.\nCreation, truncation and append actions occur as one atomic update upon job completion Default value: \"CREATE_NEVER\" Possible values: [\"CREATE_IF_NEEDED\", \"CREATE_NEVER\"].",
                  "type": "string"
                },
                "destinationEncryptionConfiguration": {
                  "description": "Immutable. Custom encryption configuration (e.g., Cloud KMS keys).",
                  "type": "object",
                  "required": ["kmsKeyRef"],
                  "properties": {
                    "kmsKeyRef": {
                      "description": "Describes the Cloud KMS encryption key that will be used to protect\ndestination BigQuery table. The BigQuery Service Account associated\nwith your project requires access to this encryption key.",
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "The selfLink of a KMSCryptoKey.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    },
                    "kmsKeyVersion": {
                      "description": "Describes the Cloud KMS encryption key version used to protect destination BigQuery table.",
                      "type": "string"
                    }
                  }
                },
                "destinationTable": {
                  "description": "Immutable. The destination table.",
                  "type": "object",
                  "required": ["tableRef"],
                  "properties": {
                    "tableRef": {
                      "description": "A reference to the table.",
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "The selfLink of a BigQueryTable.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "sourceTables": {
                  "description": "Immutable. Source tables to copy.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["tableRef"],
                    "properties": {
                      "tableRef": {
                        "description": "A reference to the table.",
                        "type": "object",
                        "properties": {
                          "external": {
                            "description": "The selfLink of a BigQueryTable.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                },
                "writeDisposition": {
                  "description": "Immutable. Specifies the action that occurs if the destination table already exists. The following values are supported:\nWRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result.\nWRITE_APPEND: If the table already exists, BigQuery appends the data to the table.\nWRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result.\nEach action is atomic and only occurs if BigQuery is able to complete the job successfully.\nCreation, truncation and append actions occur as one atomic update upon job completion. Default value: \"WRITE_EMPTY\" Possible values: [\"WRITE_TRUNCATE\", \"WRITE_APPEND\", \"WRITE_EMPTY\"].",
                  "type": "string"
                }
              }
            },
            "extract": {
              "description": "Immutable. Configures an extract job.",
              "type": "object",
              "required": ["destinationUris"],
              "properties": {
                "compression": {
                  "description": "Immutable. The compression type to use for exported files. Possible values include GZIP, DEFLATE, SNAPPY, and NONE.\nThe default value is NONE. DEFLATE and SNAPPY are only supported for Avro.",
                  "type": "string"
                },
                "destinationFormat": {
                  "description": "Immutable. The exported file format. Possible values include CSV, NEWLINE_DELIMITED_JSON and AVRO for tables and SAVED_MODEL for models.\nThe default value for tables is CSV. Tables with nested or repeated fields cannot be exported as CSV.\nThe default value for models is SAVED_MODEL.",
                  "type": "string"
                },
                "destinationUris": {
                  "description": "Immutable. A list of fully-qualified Google Cloud Storage URIs where the extracted table should be written.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "fieldDelimiter": {
                  "description": "Immutable. When extracting data in CSV format, this defines the delimiter to use between fields in the exported data.\nDefault is ','.",
                  "type": "string"
                },
                "printHeader": {
                  "description": "Immutable. Whether to print out a header row in the results. Default is true.",
                  "type": "boolean"
                },
                "sourceTable": {
                  "description": "Immutable. A reference to the table being exported.",
                  "type": "object",
                  "required": ["tableRef"],
                  "properties": {
                    "tableRef": {
                      "description": "A reference to the table.",
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "The selfLink of a BigQueryTable.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "useAvroLogicalTypes": {
                  "description": "Immutable. Whether to use logical types when extracting to AVRO format.",
                  "type": "boolean"
                }
              }
            },
            "jobTimeoutMs": {
              "description": "Immutable. Job timeout in milliseconds. If this time limit is exceeded, BigQuery may attempt to terminate the job.",
              "type": "string"
            },
            "load": {
              "description": "Immutable. Configures a load job.",
              "type": "object",
              "required": ["destinationTable", "sourceUris"],
              "properties": {
                "allowJaggedRows": {
                  "description": "Immutable. Accept rows that are missing trailing optional columns. The missing values are treated as nulls.\nIf false, records with missing trailing columns are treated as bad records, and if there are too many bad records,\nan invalid error is returned in the job result. The default value is false. Only applicable to CSV, ignored for other formats.",
                  "type": "boolean"
                },
                "allowQuotedNewlines": {
                  "description": "Immutable. Indicates if BigQuery should allow quoted data sections that contain newline characters in a CSV file.\nThe default value is false.",
                  "type": "boolean"
                },
                "autodetect": {
                  "description": "Immutable. Indicates if we should automatically infer the options and schema for CSV and JSON sources.",
                  "type": "boolean"
                },
                "createDisposition": {
                  "description": "Immutable. Specifies whether the job is allowed to create new tables. The following values are supported:\nCREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table.\nCREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result.\nCreation, truncation and append actions occur as one atomic update upon job completion Default value: \"CREATE_NEVER\" Possible values: [\"CREATE_IF_NEEDED\", \"CREATE_NEVER\"].",
                  "type": "string"
                },
                "destinationEncryptionConfiguration": {
                  "description": "Immutable. Custom encryption configuration (e.g., Cloud KMS keys).",
                  "type": "object",
                  "required": ["kmsKeyRef"],
                  "properties": {
                    "kmsKeyRef": {
                      "description": "Describes the Cloud KMS encryption key that will be used to protect\ndestination BigQuery table. The BigQuery Service Account associated\nwith your project requires access to this encryption key.",
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "The selfLink of a KMSCryptoKey.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    },
                    "kmsKeyVersion": {
                      "description": "Describes the Cloud KMS encryption key version used to protect destination BigQuery table.",
                      "type": "string"
                    }
                  }
                },
                "destinationTable": {
                  "description": "Immutable. The destination table to load the data into.",
                  "type": "object",
                  "required": ["tableRef"],
                  "properties": {
                    "tableRef": {
                      "description": "A reference to the table.",
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "The selfLink of a BigQueryTable.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "encoding": {
                  "description": "Immutable. The character encoding of the data. The supported values are UTF-8 or ISO-8859-1.\nThe default value is UTF-8. BigQuery decodes the data after the raw, binary data\nhas been split using the values of the quote and fieldDelimiter properties.",
                  "type": "string"
                },
                "fieldDelimiter": {
                  "description": "Immutable. The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character.\nTo use a character in the range 128-255, you must encode the character as UTF8. BigQuery converts\nthe string to ISO-8859-1 encoding, and then uses the first byte of the encoded string to split the\ndata in its raw, binary state. BigQuery also supports the escape sequence \"\\t\" to specify a tab separator.\nThe default value is a comma (',').",
                  "type": "string"
                },
                "ignoreUnknownValues": {
                  "description": "Immutable. Indicates if BigQuery should allow extra values that are not represented in the table schema.\nIf true, the extra values are ignored. If false, records with extra columns are treated as bad records,\nand if there are too many bad records, an invalid error is returned in the job result.\nThe default value is false. The sourceFormat property determines what BigQuery treats as an extra value:\nCSV: Trailing columns\nJSON: Named values that don't match any column names.",
                  "type": "boolean"
                },
                "maxBadRecords": {
                  "description": "Immutable. The maximum number of bad records that BigQuery can ignore when running the job. If the number of bad records exceeds this value,\nan invalid error is returned in the job result. The default value is 0, which requires that all records are valid.",
                  "type": "integer"
                },
                "nullMarker": {
                  "description": "Immutable. Specifies a string that represents a null value in a CSV file. For example, if you specify \"\\N\", BigQuery interprets \"\\N\" as a null value\nwhen loading a CSV file. The default value is the empty string. If you set this property to a custom value, BigQuery throws an error if an\nempty string is present for all data types except for STRING and BYTE. For STRING and BYTE columns, BigQuery interprets the empty string as\nan empty value.",
                  "type": "string"
                },
                "projectionFields": {
                  "description": "Immutable. If sourceFormat is set to \"DATASTORE_BACKUP\", indicates which entity properties to load into BigQuery from a Cloud Datastore backup.\nProperty names are case sensitive and must be top-level properties. If no properties are specified, BigQuery loads all properties.\nIf any named property isn't found in the Cloud Datastore backup, an invalid error is returned in the job result.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "quote": {
                  "description": "Immutable. The value that is used to quote data sections in a CSV file. BigQuery converts the string to ISO-8859-1 encoding,\nand then uses the first byte of the encoded string to split the data in its raw, binary state.\nThe default value is a double-quote ('\"'). If your data does not contain quoted sections, set the property value to an empty string.\nIf your data contains quoted newline characters, you must also set the allowQuotedNewlines property to true.",
                  "type": "string"
                },
                "schemaUpdateOptions": {
                  "description": "Immutable. Allows the schema of the destination table to be updated as a side effect of the load job if a schema is autodetected or\nsupplied in the job configuration. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND;\nwhen writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators.\nFor normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following values are specified:\nALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.\nALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "skipLeadingRows": {
                  "description": "Immutable. The number of rows at the top of a CSV file that BigQuery will skip when loading the data.\nThe default value is 0. This property is useful if you have header rows in the file that should be skipped.\nWhen autodetect is on, the behavior is the following:\nskipLeadingRows unspecified - Autodetect tries to detect headers in the first row. If they are not detected,\nthe row is read as data. Otherwise data is read starting from the second row.\nskipLeadingRows is 0 - Instructs autodetect that there are no headers and data should be read starting from the first row.\nskipLeadingRows = N > 0 - Autodetect skips N-1 rows and tries to detect headers in row N. If headers are not detected,\nrow N is just skipped. Otherwise row N is used to extract column names for the detected schema.",
                  "type": "integer"
                },
                "sourceFormat": {
                  "description": "Immutable. The format of the data files. For CSV files, specify \"CSV\". For datastore backups, specify \"DATASTORE_BACKUP\".\nFor newline-delimited JSON, specify \"NEWLINE_DELIMITED_JSON\". For Avro, specify \"AVRO\". For parquet, specify \"PARQUET\".\nFor orc, specify \"ORC\". [Beta] For Bigtable, specify \"BIGTABLE\".\nThe default value is CSV.",
                  "type": "string"
                },
                "sourceUris": {
                  "description": "Immutable. The fully-qualified URIs that point to your data in Google Cloud.\nFor Google Cloud Storage URIs: Each URI can contain one '*' wildcard character\nand it must come after the 'bucket' name. Size limits related to load jobs apply\nto external data sources. For Google Cloud Bigtable URIs: Exactly one URI can be\nspecified and it has be a fully specified and valid HTTPS URL for a Google Cloud Bigtable table.\nFor Google Cloud Datastore backups: Exactly one URI can be specified. Also, the '*' wildcard character is not allowed.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "timePartitioning": {
                  "description": "Immutable. Time-based partitioning specification for the destination table.",
                  "type": "object",
                  "required": ["type"],
                  "properties": {
                    "expirationMs": {
                      "description": "Immutable. Number of milliseconds for which to keep the storage for a partition. A wrapper is used here because 0 is an invalid value.",
                      "type": "string"
                    },
                    "field": {
                      "description": "Immutable. If not set, the table is partitioned by pseudo column '_PARTITIONTIME'; if set, the table is partitioned by this field.\nThe field must be a top-level TIMESTAMP or DATE field. Its mode must be NULLABLE or REQUIRED.\nA wrapper is used here because an empty string is an invalid value.",
                      "type": "string"
                    },
                    "type": {
                      "description": "Immutable. The only type supported is DAY, which will generate one partition per day. Providing an empty string used to cause an error,\nbut in OnePlatform the field will be treated as unset.",
                      "type": "string"
                    }
                  }
                },
                "writeDisposition": {
                  "description": "Immutable. Specifies the action that occurs if the destination table already exists. The following values are supported:\nWRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result.\nWRITE_APPEND: If the table already exists, BigQuery appends the data to the table.\nWRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result.\nEach action is atomic and only occurs if BigQuery is able to complete the job successfully.\nCreation, truncation and append actions occur as one atomic update upon job completion. Default value: \"WRITE_EMPTY\" Possible values: [\"WRITE_TRUNCATE\", \"WRITE_APPEND\", \"WRITE_EMPTY\"].",
                  "type": "string"
                }
              }
            },
            "location": {
              "description": "Immutable. The geographic location of the job. The default value is US.",
              "type": "string"
            },
            "query": {
              "description": "Immutable. Configures a query job.",
              "type": "object",
              "required": ["query"],
              "properties": {
                "allowLargeResults": {
                  "description": "Immutable. If true and query uses legacy SQL dialect, allows the query to produce arbitrarily large result tables at a slight cost in performance.\nRequires destinationTable to be set. For standard SQL queries, this flag is ignored and large results are always allowed.\nHowever, you must still set destinationTable when result size exceeds the allowed maximum response size.",
                  "type": "boolean"
                },
                "createDisposition": {
                  "description": "Immutable. Specifies whether the job is allowed to create new tables. The following values are supported:\nCREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table.\nCREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result.\nCreation, truncation and append actions occur as one atomic update upon job completion Default value: \"CREATE_NEVER\" Possible values: [\"CREATE_IF_NEEDED\", \"CREATE_NEVER\"].",
                  "type": "string"
                },
                "defaultDataset": {
                  "description": "Immutable. Specifies the default dataset to use for unqualified table names in the query. Note that this does not alter behavior of unqualified dataset names.",
                  "type": "object",
                  "required": ["datasetRef"],
                  "properties": {
                    "datasetRef": {
                      "description": "A reference to the dataset.",
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "The selfLink of a BigQueryDataset.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "destinationEncryptionConfiguration": {
                  "description": "Immutable. Custom encryption configuration (e.g., Cloud KMS keys).",
                  "type": "object",
                  "required": ["kmsKeyRef"],
                  "properties": {
                    "kmsKeyRef": {
                      "description": "Describes the Cloud KMS encryption key that will be used to protect\ndestination BigQuery table. The BigQuery Service Account associated\nwith your project requires access to this encryption key.",
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "The selfLink of a KMSCryptoKey.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    },
                    "kmsKeyVersion": {
                      "description": "Describes the Cloud KMS encryption key version used to protect destination BigQuery table.",
                      "type": "string"
                    }
                  }
                },
                "destinationTable": {
                  "description": "Immutable. Describes the table where the query results should be stored.\nThis property must be set for large results that exceed the maximum response size.\nFor queries that produce anonymous (cached) results, this field will be populated by BigQuery.",
                  "type": "object",
                  "required": ["tableRef"],
                  "properties": {
                    "tableRef": {
                      "description": "A reference to the table.",
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "The selfLink of a BigQueryTable.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "flattenResults": {
                  "description": "Immutable. If true and query uses legacy SQL dialect, flattens all nested and repeated fields in the query results.\nallowLargeResults must be true if this is set to false. For standard SQL queries, this flag is ignored and results are never flattened.",
                  "type": "boolean"
                },
                "maximumBillingTier": {
                  "description": "Immutable. Limits the billing tier for this job. Queries that have resource usage beyond this tier will fail (without incurring a charge).\nIf unspecified, this will be set to your project default.",
                  "type": "integer"
                },
                "maximumBytesBilled": {
                  "description": "Immutable. Limits the bytes billed for this job. Queries that will have bytes billed beyond this limit will fail (without incurring a charge).\nIf unspecified, this will be set to your project default.",
                  "type": "string"
                },
                "parameterMode": {
                  "description": "Immutable. Standard SQL only. Set to POSITIONAL to use positional (?) query parameters or to NAMED to use named (@myparam) query parameters in this query.",
                  "type": "string"
                },
                "priority": {
                  "description": "Immutable. Specifies a priority for the query. Default value: \"INTERACTIVE\" Possible values: [\"INTERACTIVE\", \"BATCH\"].",
                  "type": "string"
                },
                "query": {
                  "description": "Immutable. SQL query text to execute. The useLegacySql field can be used to indicate whether the query uses legacy SQL or standard SQL.\n*NOTE*: queries containing [DML language](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-manipulation-language)\n('DELETE', 'UPDATE', 'MERGE', 'INSERT') must specify 'create_disposition = \"\"' and 'write_disposition = \"\"'.",
                  "type": "string"
                },
                "schemaUpdateOptions": {
                  "description": "Immutable. Allows the schema of the destination table to be updated as a side effect of the query job.\nSchema update options are supported in two cases: when writeDisposition is WRITE_APPEND;\nwhen writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table,\nspecified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema.\nOne or more of the following values are specified:\nALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.\nALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "scriptOptions": {
                  "description": "Immutable. Options controlling the execution of scripts.",
                  "type": "object",
                  "properties": {
                    "keyResultStatement": {
                      "description": "Immutable. Determines which statement in the script represents the \"key result\",\nused to populate the schema and query results of the script job. Possible values: [\"LAST\", \"FIRST_SELECT\"].",
                      "type": "string"
                    },
                    "statementByteBudget": {
                      "description": "Immutable. Limit on the number of bytes billed per statement. Exceeding this budget results in an error.",
                      "type": "string"
                    },
                    "statementTimeoutMs": {
                      "description": "Immutable. Timeout period for each statement in a script.",
                      "type": "string"
                    }
                  }
                },
                "useLegacySql": {
                  "description": "Immutable. Specifies whether to use BigQuery's legacy SQL dialect for this query. The default value is true.\nIf set to false, the query will use BigQuery's standard SQL.",
                  "type": "boolean"
                },
                "useQueryCache": {
                  "description": "Immutable. Whether to look for the result in the query cache. The query cache is a best-effort cache that will be flushed whenever\ntables in the query are modified. Moreover, the query cache is only available when a query does not have a destination table specified.\nThe default value is true.",
                  "type": "boolean"
                },
                "userDefinedFunctionResources": {
                  "description": "Immutable. Describes user-defined function resources used in the query.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "inlineCode": {
                        "description": "Immutable. An inline resource that contains code for a user-defined function (UDF).\nProviding a inline code resource is equivalent to providing a URI for a file containing the same code.",
                        "type": "string"
                      },
                      "resourceUri": {
                        "description": "Immutable. A code resource to load from a Google Cloud Storage URI (gs://bucket/path).",
                        "type": "string"
                      }
                    }
                  }
                },
                "writeDisposition": {
                  "description": "Immutable. Specifies the action that occurs if the destination table already exists. The following values are supported:\nWRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result.\nWRITE_APPEND: If the table already exists, BigQuery appends the data to the table.\nWRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result.\nEach action is atomic and only occurs if BigQuery is able to complete the job successfully.\nCreation, truncation and append actions occur as one atomic update upon job completion. Default value: \"WRITE_EMPTY\" Possible values: [\"WRITE_TRUNCATE\", \"WRITE_APPEND\", \"WRITE_EMPTY\"].",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The jobId of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "jobType": {
              "description": "The type of the job.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "status": {
              "description": "The status of this job. Examine this value when polling an asynchronous job to see if the job is complete.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "errorResult": {
                    "description": "Final error result of the job. If present, indicates that the job has completed and was unsuccessful.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "location": {
                          "description": "Specifies where the error occurred, if present.",
                          "type": "string"
                        },
                        "message": {
                          "description": "A human-readable description of the error.",
                          "type": "string"
                        },
                        "reason": {
                          "description": "A short error code that summarizes the error.",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "errors": {
                    "description": "The first errors encountered during the running of the job. The final message\nincludes the number of errors that caused the process to stop. Errors here do\nnot necessarily mean that the job has not completed or was unsuccessful.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "location": {
                          "description": "Specifies where the error occurred, if present.",
                          "type": "string"
                        },
                        "message": {
                          "description": "A human-readable description of the error.",
                          "type": "string"
                        },
                        "reason": {
                          "description": "A short error code that summarizes the error.",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "state": {
                    "description": "Running state of the job. Valid states include 'PENDING', 'RUNNING', and 'DONE'.",
                    "type": "string"
                  }
                }
              }
            },
            "userEmail": {
              "description": "Email address of the user who ran the job.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "bigquery.cnrm.cloud.google.com",
          "kind": "BigQueryJob",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.bigquery.v1beta1.BigQueryJobList": {
      "description": "BigQueryJobList is a list of BigQueryJob",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["bigquery.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of bigqueryjobs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.bigquery.v1beta1.BigQueryJob"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BigQueryJobList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "bigquery.cnrm.cloud.google.com",
          "kind": "BigQueryJobList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.bigquery.v1beta1.BigQueryTable": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["bigquery.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BigQueryTable"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["datasetRef"],
          "properties": {
            "clustering": {
              "description": "Specifies column names to use for data clustering. Up to four top-level columns are allowed, and should be specified in descending priority order.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "datasetRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a BigQueryDataset.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "description": {
              "description": "The field description.",
              "type": "string"
            },
            "encryptionConfiguration": {
              "description": "Immutable. Specifies how the table should be encrypted. If left blank, the table will be encrypted with a Google-managed key; that process is transparent to the user.",
              "type": "object",
              "required": ["kmsKeyRef"],
              "properties": {
                "kmsKeyRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a KMSCryptoKey.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "kmsKeyVersion": {
                  "description": "The self link or full name of the kms key version used to encrypt this table.",
                  "type": "string"
                }
              }
            },
            "expirationTime": {
              "description": "The time when this table expires, in milliseconds since the epoch. If not present, the table will persist indefinitely. Expired tables will be deleted and their storage reclaimed.",
              "type": "integer"
            },
            "externalDataConfiguration": {
              "description": "Describes the data format, location, and other properties of a table stored outside of BigQuery. By defining these properties, the data source can then be queried as if it were a standard BigQuery table.",
              "type": "object",
              "required": ["autodetect", "sourceFormat", "sourceUris"],
              "properties": {
                "autodetect": {
                  "description": "Let BigQuery try to autodetect the schema and format of the table.",
                  "type": "boolean"
                },
                "compression": {
                  "description": "The compression type of the data source. Valid values are \"NONE\" or \"GZIP\".",
                  "type": "string"
                },
                "csvOptions": {
                  "description": "Additional properties to set if source_format is set to \"CSV\".",
                  "type": "object",
                  "required": ["quote"],
                  "properties": {
                    "allowJaggedRows": {
                      "description": "Indicates if BigQuery should accept rows that are missing trailing optional columns.",
                      "type": "boolean"
                    },
                    "allowQuotedNewlines": {
                      "description": "Indicates if BigQuery should allow quoted data sections that contain newline characters in a CSV file. The default value is false.",
                      "type": "boolean"
                    },
                    "encoding": {
                      "description": "The character encoding of the data. The supported values are UTF-8 or ISO-8859-1.",
                      "type": "string"
                    },
                    "fieldDelimiter": {
                      "description": "The separator for fields in a CSV file.",
                      "type": "string"
                    },
                    "quote": {
                      "type": "string"
                    },
                    "skipLeadingRows": {
                      "description": "The number of rows at the top of a CSV file that BigQuery will skip when reading the data.",
                      "type": "integer"
                    }
                  }
                },
                "googleSheetsOptions": {
                  "description": "Additional options if source_format is set to \"GOOGLE_SHEETS\".",
                  "type": "object",
                  "properties": {
                    "range": {
                      "description": "Range of a sheet to query from. Only used when non-empty. At least one of range or skip_leading_rows must be set. Typical format: \"sheet_name!top_left_cell_id:bottom_right_cell_id\" For example: \"sheet1!A1:B20\".",
                      "type": "string"
                    },
                    "skipLeadingRows": {
                      "description": "The number of rows at the top of the sheet that BigQuery will skip when reading the data. At least one of range or skip_leading_rows must be set.",
                      "type": "integer"
                    }
                  }
                },
                "hivePartitioningOptions": {
                  "description": "When set, configures hive partitioning support. Not all storage formats support hive partitioning -- requesting hive partitioning on an unsupported format will lead to an error, as will providing an invalid specification.",
                  "type": "object",
                  "properties": {
                    "mode": {
                      "description": "When set, what mode of hive partitioning to use when reading data.",
                      "type": "string"
                    },
                    "requirePartitionFilter": {
                      "description": "If set to true, queries over this table require a partition filter that can be used for partition elimination to be specified.",
                      "type": "boolean"
                    },
                    "sourceUriPrefix": {
                      "description": "When hive partition detection is requested, a common for all source uris must be required. The prefix must end immediately before the partition key encoding begins.",
                      "type": "string"
                    }
                  }
                },
                "ignoreUnknownValues": {
                  "description": "Indicates if BigQuery should allow extra values that are not represented in the table schema. If true, the extra values are ignored. If false, records with extra columns are treated as bad records, and if there are too many bad records, an invalid error is returned in the job result. The default value is false.",
                  "type": "boolean"
                },
                "maxBadRecords": {
                  "description": "The maximum number of bad records that BigQuery can ignore when reading data.",
                  "type": "integer"
                },
                "schema": {
                  "description": "Immutable. A JSON schema for the external table. Schema is required for CSV and JSON formats and is disallowed for Google Cloud Bigtable, Cloud Datastore backups, and Avro formats when using external tables.",
                  "type": "string"
                },
                "sourceFormat": {
                  "description": "The data format. Supported values are: \"CSV\", \"GOOGLE_SHEETS\", \"NEWLINE_DELIMITED_JSON\", \"AVRO\", \"PARQUET\", \"ORC\" and \"DATASTORE_BACKUP\". To use \"GOOGLE_SHEETS\" the scopes must include \"googleapis.com/auth/drive.readonly\".",
                  "type": "string"
                },
                "sourceUris": {
                  "description": "A list of the fully-qualified URIs that point to your data in Google Cloud.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "friendlyName": {
              "description": "A descriptive name for the table.",
              "type": "string"
            },
            "materializedView": {
              "description": "If specified, configures this table as a materialized view.",
              "type": "object",
              "required": ["query"],
              "properties": {
                "enableRefresh": {
                  "description": "Specifies if BigQuery should automatically refresh materialized view when the base table is updated. The default is true.",
                  "type": "boolean"
                },
                "query": {
                  "description": "Immutable. A query whose result is persisted.",
                  "type": "string"
                },
                "refreshIntervalMs": {
                  "description": "Specifies maximum frequency at which this materialized view will be refreshed. The default is 1800000.",
                  "type": "integer"
                }
              }
            },
            "rangePartitioning": {
              "description": "If specified, configures range-based partitioning for this table.",
              "type": "object",
              "required": ["field", "range"],
              "properties": {
                "field": {
                  "description": "Immutable. The field used to determine how to create a range-based partition.",
                  "type": "string"
                },
                "range": {
                  "description": "Information required to partition based on ranges. Structure is documented below.",
                  "type": "object",
                  "required": ["end", "interval", "start"],
                  "properties": {
                    "end": {
                      "description": "End of the range partitioning, exclusive.",
                      "type": "integer"
                    },
                    "interval": {
                      "description": "The width of each range within the partition.",
                      "type": "integer"
                    },
                    "start": {
                      "description": "Start of the range partitioning, inclusive.",
                      "type": "integer"
                    }
                  }
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The tableId of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "schema": {
              "description": "A JSON schema for the table.",
              "type": "string"
            },
            "timePartitioning": {
              "description": "If specified, configures time-based partitioning for this table.",
              "type": "object",
              "required": ["type"],
              "properties": {
                "expirationMs": {
                  "description": "Number of milliseconds for which to keep the storage for a partition.",
                  "type": "integer"
                },
                "field": {
                  "description": "Immutable. The field used to determine how to create a time-based partition. If time-based partitioning is enabled without this value, the table is partitioned based on the load time.",
                  "type": "string"
                },
                "requirePartitionFilter": {
                  "description": "If set to true, queries over this table require a partition filter that can be used for partition elimination to be specified.",
                  "type": "boolean"
                },
                "type": {
                  "description": "The supported types are DAY, HOUR, MONTH, and YEAR, which will generate one partition per day, hour, month, and year, respectively.",
                  "type": "string"
                }
              }
            },
            "view": {
              "description": "If specified, configures this table as a view.",
              "type": "object",
              "required": ["query"],
              "properties": {
                "query": {
                  "description": "A query that BigQuery executes when the view is referenced.",
                  "type": "string"
                },
                "useLegacySql": {
                  "description": "Specifies whether to use BigQuery's legacy SQL for this view. The default value is true. If set to false, the view will use BigQuery's standard SQL.",
                  "type": "boolean"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTime": {
              "description": "The time when this table was created, in milliseconds since the epoch.",
              "type": "integer"
            },
            "etag": {
              "description": "A hash of the resource.",
              "type": "string"
            },
            "lastModifiedTime": {
              "description": "The time when this table was last modified, in milliseconds since the epoch.",
              "type": "integer"
            },
            "location": {
              "description": "The geographic location where the table resides. This value is inherited from the dataset.",
              "type": "string"
            },
            "numBytes": {
              "description": "The geographic location where the table resides. This value is inherited from the dataset.",
              "type": "integer"
            },
            "numLongTermBytes": {
              "description": "The number of bytes in the table that are considered \"long-term storage\".",
              "type": "integer"
            },
            "numRows": {
              "description": "The number of rows of data in this table, excluding any data in the streaming buffer.",
              "type": "integer"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "description": "The URI of the created resource.",
              "type": "string"
            },
            "type": {
              "description": "Describes the table type.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "bigquery.cnrm.cloud.google.com",
          "kind": "BigQueryTable",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.bigquery.v1beta1.BigQueryTableList": {
      "description": "BigQueryTableList is a list of BigQueryTable",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["bigquery.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of bigquerytables. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.bigquery.v1beta1.BigQueryTable"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BigQueryTableList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "bigquery.cnrm.cloud.google.com",
          "kind": "BigQueryTableList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.bigtable.v1beta1.BigtableAppProfile": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["bigtable.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BigtableAppProfile"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "description": {
              "description": "Long form description of the use case for this app profile.",
              "type": "string"
            },
            "instanceRef": {
              "description": "The instance to create the app profile within.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a BigtableInstance.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "multiClusterRoutingUseAny": {
              "description": "Immutable. If true, read/write requests are routed to the nearest cluster in the instance, and will fail over to the nearest cluster that is available\nin the event of transient errors or delays. Clusters in a region are considered equidistant. Choosing this option sacrifices read-your-writes\nconsistency to improve availability.",
              "type": "boolean"
            },
            "resourceID": {
              "description": "Immutable. Optional. The appProfileId of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "singleClusterRouting": {
              "description": "Use a single-cluster routing policy.",
              "type": "object",
              "required": ["clusterId"],
              "properties": {
                "allowTransactionalWrites": {
                  "description": "If true, CheckAndMutateRow and ReadModifyWriteRow requests are allowed by this app profile.\nIt is unsafe to send these requests to the same table/row/column in multiple clusters.",
                  "type": "boolean"
                },
                "clusterId": {
                  "description": "The cluster to which read/write requests should be routed.",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "name": {
              "description": "The unique name of the requested app profile. Values are of the form 'projects/<project>/instances/<instance>/appProfiles/<appProfileId>'.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "bigtable.cnrm.cloud.google.com",
          "kind": "BigtableAppProfile",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.bigtable.v1beta1.BigtableAppProfileList": {
      "description": "BigtableAppProfileList is a list of BigtableAppProfile",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["bigtable.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of bigtableappprofiles. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.bigtable.v1beta1.BigtableAppProfile"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BigtableAppProfileList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "bigtable.cnrm.cloud.google.com",
          "kind": "BigtableAppProfileList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.bigtable.v1beta1.BigtableGCPolicy": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["bigtable.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BigtableGCPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["columnFamily", "instanceRef", "tableRef"],
          "properties": {
            "columnFamily": {
              "description": "Immutable. The name of the column family.",
              "type": "string"
            },
            "instanceRef": {
              "description": "The name of the Bigtable instance.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a BigtableInstance.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "maxAge": {
              "description": "Immutable. GC policy that applies to all cells older than the given age.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "days": {
                    "description": "DEPRECATED \u2014 Deprecated in favor of duration. Immutable. Number of days before applying GC policy.",
                    "type": "integer"
                  },
                  "duration": {
                    "description": "Immutable. Duration before applying GC policy.",
                    "type": "string"
                  }
                }
              }
            },
            "maxVersion": {
              "description": "Immutable. GC policy that applies to all versions of a cell except for the most recent.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["number"],
                "properties": {
                  "number": {
                    "description": "Immutable. Number of version before applying the GC policy.",
                    "type": "integer"
                  }
                }
              }
            },
            "mode": {
              "description": "Immutable. If multiple policies are set, you should choose between UNION OR INTERSECTION.",
              "type": "string"
            },
            "tableRef": {
              "description": "The name of the table.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a BigtableTable.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "bigtable.cnrm.cloud.google.com",
          "kind": "BigtableGCPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.bigtable.v1beta1.BigtableGCPolicyList": {
      "description": "BigtableGCPolicyList is a list of BigtableGCPolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["bigtable.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of bigtablegcpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.bigtable.v1beta1.BigtableGCPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BigtableGCPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "bigtable.cnrm.cloud.google.com",
          "kind": "BigtableGCPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.bigtable.v1beta1.BigtableInstance": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["bigtable.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BigtableInstance"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "cluster": {
              "description": "A block of cluster configuration options. This can be specified at least once.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["clusterId", "zone"],
                "properties": {
                  "clusterId": {
                    "description": "The ID of the Cloud Bigtable cluster.",
                    "type": "string"
                  },
                  "kmsKeyRef": {
                    "description": "Describes the Cloud KMS encryption key that will be used to protect the destination Bigtable\ncluster. The requirements for this key are: 1) The Cloud Bigtable service account associated with the project that contains\nthis cluster must be granted the cloudkms.cryptoKeyEncrypterDecrypter role on the CMEK key.\n2) Only regional keys can be used and the region of the CMEK key must match the region of the cluster.\n3) All clusters within an instance must use the same CMEK key access to this encryption key.",
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The selfLink of a KMSCryptoKey.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  },
                  "numNodes": {
                    "description": "The number of nodes in your Cloud Bigtable cluster. For PRODUCTION instances where the numNodes will be managed by Config Connector, this field is required with a minimum of 1. For a DEVELOPMENT instance or for an existing instance where the numNodes is managed outside of Config Connector, this field must be left unset.",
                    "type": "integer"
                  },
                  "storageType": {
                    "description": "The storage type to use. One of \"SSD\" or \"HDD\". Defaults to \"SSD\".",
                    "type": "string"
                  },
                  "zone": {
                    "description": "The zone to create the Cloud Bigtable cluster in. Each cluster must have a different zone in the same region. Zones that support Bigtable instances are noted on the Cloud Bigtable locations page.",
                    "type": "string"
                  }
                }
              }
            },
            "deletionProtection": {
              "description": "DEPRECATED \u2014 This field no longer serves any function and is intended to be dropped in a later version of the resource.",
              "type": "boolean"
            },
            "displayName": {
              "description": "The human-readable display name of the Bigtable instance. Defaults to the instance name.",
              "type": "string"
            },
            "instanceType": {
              "description": "DEPRECATED \u2014 It is recommended to leave this field unspecified since the distinction between \"DEVELOPMENT\" and \"PRODUCTION\" instances is going away, and all instances will become \"PRODUCTION\" instances. This means that new and existing \"DEVELOPMENT\" instances will be converted to \"PRODUCTION\" instances. It is recommended for users to use \"PRODUCTION\" instances in any case, since a 1-node \"PRODUCTION\" instance is functionally identical to a \"DEVELOPMENT\" instance, but without the accompanying restrictions. The instance type to create. One of \"DEVELOPMENT\" or \"PRODUCTION\". Defaults to \"PRODUCTION\".",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "bigtable.cnrm.cloud.google.com",
          "kind": "BigtableInstance",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.bigtable.v1beta1.BigtableInstanceList": {
      "description": "BigtableInstanceList is a list of BigtableInstance",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["bigtable.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of bigtableinstances. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.bigtable.v1beta1.BigtableInstance"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BigtableInstanceList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "bigtable.cnrm.cloud.google.com",
          "kind": "BigtableInstanceList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.bigtable.v1beta1.BigtableTable": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["bigtable.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BigtableTable"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["instanceRef"],
          "properties": {
            "columnFamily": {
              "description": "A group of columns within a table which share a common configuration. This can be specified multiple times.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["family"],
                "properties": {
                  "family": {
                    "description": "The name of the column family.",
                    "type": "string"
                  }
                }
              }
            },
            "instanceRef": {
              "description": "The name of the Bigtable instance.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a BigtableInstance.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "splitKeys": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "bigtable.cnrm.cloud.google.com",
          "kind": "BigtableTable",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.bigtable.v1beta1.BigtableTableList": {
      "description": "BigtableTableList is a list of BigtableTable",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["bigtable.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of bigtabletables. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.bigtable.v1beta1.BigtableTable"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BigtableTableList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "bigtable.cnrm.cloud.google.com",
          "kind": "BigtableTableList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.binaryauthorization.v1beta1.BinaryAuthorizationAttestor": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["binaryauthorization.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BinaryAuthorizationAttestor"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["projectRef"],
          "properties": {
            "description": {
              "description": "Optional. A descriptive comment. This field may be updated. The field may be displayed in chooser dialogs.",
              "type": "string"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "userOwnedDrydockNote": {
              "description": "This specifies how an attestation will be read, and how it will be used during policy enforcement.",
              "type": "object",
              "required": ["noteRef"],
              "properties": {
                "noteRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "Required. The Drydock resource name of a Attestation. Authority Note, created by the user, in the format: `projects/*/notes/*`. This field may not be updated. An attestation by this attestor is stored as a Grafeas Attestation. Authority Occurrence that names a container image and that links to this Note. Grafeas is an external dependency.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "publicKeys": {
                  "description": "Optional. Public keys that verify attestations signed by this attestor. This field may be updated. If this field is non-empty, one of the specified public keys must verify that an attestation was signed by this attestor for the image specified in the admission request. If this field is empty, this attestor always returns that no valid attestations exist.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "asciiArmoredPgpPublicKey": {
                        "description": "ASCII-armored representation of a PGP public key, as the entire output by the command `gpg --export --armor foo@example.com` (either LF or CRLF line endings). When using this field, `id` should be left blank. The BinAuthz API handlers will calculate the ID and fill it in automatically. BinAuthz computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as upper-case hex. If `id` is provided by the caller, it will be overwritten by the API-calculated ID.",
                        "type": "string"
                      },
                      "comment": {
                        "description": "Optional. A descriptive comment. This field may be updated.",
                        "type": "string"
                      },
                      "id": {
                        "description": "The ID of this public key. Signatures verified by BinAuthz must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. Additional restrictions on this field can be imposed based on which public key type is encapsulated. See the documentation on `public_key` cases below for details.",
                        "type": "string"
                      },
                      "pkixPublicKey": {
                        "description": "A raw PKIX SubjectPublicKeyInfo format public key. NOTE: `id` may be explicitly provided by the caller when using this type of public key, but it MUST be a valid RFC3986 URI. If `id` is left blank, a default one will be computed based on the digest of the DER encoding of the public key.",
                        "type": "object",
                        "properties": {
                          "publicKeyPem": {
                            "description": "A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13",
                            "type": "string"
                          },
                          "signatureAlgorithm": {
                            "description": "The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key). Possible values: SIGNATURE_ALGORITHM_UNSPECIFIED, RSA_PSS_2048_SHA256, RSA_PSS_3072_SHA256, RSA_PSS_4096_SHA256, RSA_PSS_4096_SHA512, RSA_SIGN_PKCS1_2048_SHA256, RSA_SIGN_PKCS1_3072_SHA256, RSA_SIGN_PKCS1_4096_SHA256, RSA_SIGN_PKCS1_4096_SHA512, ECDSA_P256_SHA256, EC_SIGN_P256_SHA256, ECDSA_P384_SHA384, EC_SIGN_P384_SHA384, ECDSA_P521_SHA512, EC_SIGN_P521_SHA512",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Output only. Time when the attestor was last updated.",
              "type": "string",
              "format": "date-time"
            },
            "userOwnedDrydockNote": {
              "type": "object",
              "properties": {
                "delegationServiceAccountEmail": {
                  "description": "Output only. This field will contain the service account email address that this Attestor will use as the principal when querying Container Analysis. Attestor administrators must grant this service account the IAM role needed to read attestations from the in Container Analysis (`containeranalysis.notes.occurrences.viewer`). This email address is fixed for the lifetime of the Attestor, but callers should not make any other assumptions about the service account email; future versions may use an email based on a different naming pattern.",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "binaryauthorization.cnrm.cloud.google.com",
          "kind": "BinaryAuthorizationAttestor",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.binaryauthorization.v1beta1.BinaryAuthorizationAttestorList": {
      "description": "BinaryAuthorizationAttestorList is a list of BinaryAuthorizationAttestor",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["binaryauthorization.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of binaryauthorizationattestors. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.binaryauthorization.v1beta1.BinaryAuthorizationAttestor"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BinaryAuthorizationAttestorList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "binaryauthorization.cnrm.cloud.google.com",
          "kind": "BinaryAuthorizationAttestorList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.binaryauthorization.v1beta1.BinaryAuthorizationPolicy": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["binaryauthorization.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BinaryAuthorizationPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["defaultAdmissionRule", "projectRef"],
          "properties": {
            "admissionWhitelistPatterns": {
              "description": "Optional. Admission policy allowlisting. A matching admission request will always be permitted. This feature is typically used to exclude Google or third-party infrastructure images from Binary Authorization policies.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "namePattern": {
                    "description": "An image name pattern to allowlist, in the form `registry/path/to/image`. This supports a trailing `*` as a wildcard, but this is allowed only in text after the `registry/` part.",
                    "type": "string"
                  }
                }
              }
            },
            "clusterAdmissionRules": {
              "description": "Optional. Per-cluster admission rules. Cluster spec format: location.clusterId. There can be at most one admission rule per cluster spec. A location is either a compute zone (e.g. us-central1-a) or a region (e.g. us-central1). For clusterId syntax restrictions see https://cloud.google.com/container-engine/reference/rest/v1/projects.zones.clusters.",
              "type": "object",
              "additionalProperties": {
                "description": "Required. Default admission rule for a cluster without a per-cluster, per-kubernetes-service-account, or per-istio-service-identity admission rule.",
                "type": "object",
                "required": ["enforcementMode", "evaluationMode"],
                "properties": {
                  "enforcementMode": {
                    "description": "Required. The action when a pod creation is denied by the admission rule. Possible values: ENFORCEMENT_MODE_UNSPECIFIED, ENFORCED_BLOCK_AND_AUDIT_LOG, DRYRUN_AUDIT_LOG_ONLY",
                    "type": "string"
                  },
                  "evaluationMode": {
                    "description": "Required. How this admission rule will be evaluated. Possible values: ALWAYS_ALLOW, ALWAYS_DENY, REQUIRE_ATTESTATION",
                    "type": "string"
                  },
                  "requireAttestationsBy": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "defaultAdmissionRule": {
              "description": "Required. Default admission rule for a cluster without a per-cluster, per-kubernetes-service-account, or per-istio-service-identity admission rule.",
              "type": "object",
              "required": ["enforcementMode", "evaluationMode"],
              "properties": {
                "enforcementMode": {
                  "description": "Required. The action when a pod creation is denied by the admission rule. Possible values: ENFORCEMENT_MODE_UNSPECIFIED, ENFORCED_BLOCK_AND_AUDIT_LOG, DRYRUN_AUDIT_LOG_ONLY",
                  "type": "string"
                },
                "evaluationMode": {
                  "description": "Required. How this admission rule will be evaluated. Possible values: ALWAYS_ALLOW, ALWAYS_DENY, REQUIRE_ATTESTATION",
                  "type": "string"
                },
                "requireAttestationsBy": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "description": {
              "description": "Optional. A descriptive comment.",
              "type": "string"
            },
            "globalPolicyEvaluationMode": {
              "description": "Optional. Controls the evaluation of a Google-maintained global admission policy for common system-level images. Images not covered by the global policy will be subject to the project admission policy. This setting has no effect when specified inside a global admission policy. Possible values: GLOBAL_POLICY_EVALUATION_MODE_UNSPECIFIED, ENABLE, DISABLE",
              "type": "string"
            },
            "istioServiceIdentityAdmissionRules": {
              "description": "Optional. Per-istio-service-identity admission rules. Istio service identity spec format: spiffe:///ns//sa/ or /ns//sa/ e.g. spiffe://example.com/ns/test-ns/sa/default",
              "type": "object",
              "additionalProperties": {
                "description": "Required. Default admission rule for a cluster without a per-cluster, per-kubernetes-service-account, or per-istio-service-identity admission rule.",
                "type": "object",
                "required": ["enforcementMode", "evaluationMode"],
                "properties": {
                  "enforcementMode": {
                    "description": "Required. The action when a pod creation is denied by the admission rule. Possible values: ENFORCEMENT_MODE_UNSPECIFIED, ENFORCED_BLOCK_AND_AUDIT_LOG, DRYRUN_AUDIT_LOG_ONLY",
                    "type": "string"
                  },
                  "evaluationMode": {
                    "description": "Required. How this admission rule will be evaluated. Possible values: ALWAYS_ALLOW, ALWAYS_DENY, REQUIRE_ATTESTATION",
                    "type": "string"
                  },
                  "requireAttestationsBy": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "kubernetesNamespaceAdmissionRules": {
              "description": "Optional. Per-kubernetes-namespace admission rules. K8s namespace spec format: [a-z.-]+, e.g. 'some-namespace'",
              "type": "object",
              "additionalProperties": {
                "description": "Required. Default admission rule for a cluster without a per-cluster, per-kubernetes-service-account, or per-istio-service-identity admission rule.",
                "type": "object",
                "required": ["enforcementMode", "evaluationMode"],
                "properties": {
                  "enforcementMode": {
                    "description": "Required. The action when a pod creation is denied by the admission rule. Possible values: ENFORCEMENT_MODE_UNSPECIFIED, ENFORCED_BLOCK_AND_AUDIT_LOG, DRYRUN_AUDIT_LOG_ONLY",
                    "type": "string"
                  },
                  "evaluationMode": {
                    "description": "Required. How this admission rule will be evaluated. Possible values: ALWAYS_ALLOW, ALWAYS_DENY, REQUIRE_ATTESTATION",
                    "type": "string"
                  },
                  "requireAttestationsBy": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "kubernetesServiceAccountAdmissionRules": {
              "description": "Optional. Per-kubernetes-service-account admission rules. Service account spec format: namespace:serviceaccount. e.g. 'test-ns:default'",
              "type": "object",
              "additionalProperties": {
                "description": "Required. Default admission rule for a cluster without a per-cluster, per-kubernetes-service-account, or per-istio-service-identity admission rule.",
                "type": "object",
                "required": ["enforcementMode", "evaluationMode"],
                "properties": {
                  "enforcementMode": {
                    "description": "Required. The action when a pod creation is denied by the admission rule. Possible values: ENFORCEMENT_MODE_UNSPECIFIED, ENFORCED_BLOCK_AND_AUDIT_LOG, DRYRUN_AUDIT_LOG_ONLY",
                    "type": "string"
                  },
                  "evaluationMode": {
                    "description": "Required. How this admission rule will be evaluated. Possible values: ALWAYS_ALLOW, ALWAYS_DENY, REQUIRE_ATTESTATION",
                    "type": "string"
                  },
                  "requireAttestationsBy": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project of the resource.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "description": "Output only. The resource name, in the format `projects/*/policy`. There is at most one policy per project.",
              "type": "string"
            },
            "updateTime": {
              "description": "Output only. Time when the policy was last updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "binaryauthorization.cnrm.cloud.google.com",
          "kind": "BinaryAuthorizationPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.binaryauthorization.v1beta1.BinaryAuthorizationPolicyList": {
      "description": "BinaryAuthorizationPolicyList is a list of BinaryAuthorizationPolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["binaryauthorization.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of binaryauthorizationpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.binaryauthorization.v1beta1.BinaryAuthorizationPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BinaryAuthorizationPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "binaryauthorization.cnrm.cloud.google.com",
          "kind": "BinaryAuthorizationPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.cloudbuild.v1beta1.CloudBuildTrigger": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["cloudbuild.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CloudBuildTrigger"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "build": {
              "description": "Contents of the build template. Either a filename or build template must be provided.",
              "type": "object",
              "required": ["step"],
              "properties": {
                "artifacts": {
                  "description": "Artifacts produced by the build that should be uploaded upon successful completion of all build steps.",
                  "type": "object",
                  "properties": {
                    "images": {
                      "description": "A list of images to be pushed upon the successful completion of all build steps.\n\nThe images will be pushed using the builder service account's credentials.\n\nThe digests of the pushed images will be stored in the Build resource's results field.\n\nIf any of the images fail to be pushed, the build is marked FAILURE.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "objects": {
                      "description": "A list of objects to be uploaded to Cloud Storage upon successful completion of all build steps.\n\nFiles in the workspace matching specified paths globs will be uploaded to the\nCloud Storage location using the builder service account's credentials.\n\nThe location and generation of the uploaded objects will be stored in the Build resource's results field.\n\nIf any objects fail to be pushed, the build is marked FAILURE.",
                      "type": "object",
                      "properties": {
                        "location": {
                          "description": "Cloud Storage bucket and optional object path, in the form \"gs://bucket/path/to/somewhere/\".\n\nFiles in the workspace matching any path pattern will be uploaded to Cloud Storage with\nthis location as a prefix.",
                          "type": "string"
                        },
                        "paths": {
                          "description": "Path globs used to match files in the build's workspace.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "timing": {
                          "description": "Output only. Stores timing information for pushing all artifact objects.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "endTime": {
                                "description": "End of time span.\n\nA timestamp in RFC3339 UTC \"Zulu\" format, with nanosecond resolution and up to\nnine fractional digits. Examples: \"2014-10-02T15:01:23Z\" and \"2014-10-02T15:01:23.045123456Z\".",
                                "type": "string"
                              },
                              "startTime": {
                                "description": "Start of time span.\n\nA timestamp in RFC3339 UTC \"Zulu\" format, with nanosecond resolution and up to\nnine fractional digits. Examples: \"2014-10-02T15:01:23Z\" and \"2014-10-02T15:01:23.045123456Z\".",
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "availableSecrets": {
                  "description": "Secrets and secret environment variables.",
                  "type": "object",
                  "required": ["secretManager"],
                  "properties": {
                    "secretManager": {
                      "description": "Pairs a secret environment variable with a SecretVersion in Secret Manager.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": ["env", "versionRef"],
                        "properties": {
                          "env": {
                            "description": "Environment variable name to associate with the secret. Secret environment\nvariables must be unique across all of a build's secrets, and must be used\nby at least one build step.",
                            "type": "string"
                          },
                          "versionRef": {
                            "type": "object",
                            "properties": {
                              "external": {
                                "description": "The name of a SecretManagerSecretVersion.",
                                "type": "string"
                              },
                              "name": {
                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                "type": "string"
                              },
                              "namespace": {
                                "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "images": {
                  "description": "A list of images to be pushed upon the successful completion of all build steps.\nThe images are pushed using the builder service account's credentials.\nThe digests of the pushed images will be stored in the Build resource's results field.\nIf any of the images fail to be pushed, the build status is marked FAILURE.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "logsBucketRef": {
                  "description": "Google Cloud Storage bucket where logs should be written. Logs file\nnames will be of the format ${logsBucket}/log-${build_id}.txt.",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The url of a StorageBucket.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "options": {
                  "description": "Special options for this build.",
                  "type": "object",
                  "properties": {
                    "diskSizeGb": {
                      "description": "Requested disk size for the VM that runs the build. Note that this is NOT \"disk free\";\nsome of the space will be used by the operating system and build utilities.\nAlso note that this is the minimum disk size that will be allocated for the build --\nthe build may run with a larger disk than requested. At present, the maximum disk size\nis 1000GB; builds that request more than the maximum are rejected with an error.",
                      "type": "integer"
                    },
                    "dynamicSubstitutions": {
                      "description": "Option to specify whether or not to apply bash style string operations to the substitutions.\n\nNOTE this is always enabled for triggered builds and cannot be overridden in the build configuration file.",
                      "type": "boolean"
                    },
                    "env": {
                      "description": "A list of global environment variable definitions that will exist for all build steps\nin this build. If a variable is defined in both globally and in a build step,\nthe variable will use the build step value.\n\nThe elements are of the form \"KEY=VALUE\" for the environment variable \"KEY\" being given the value \"VALUE\".",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "logStreamingOption": {
                      "description": "Option to define build log streaming behavior to Google Cloud Storage. Possible values: [\"STREAM_DEFAULT\", \"STREAM_ON\", \"STREAM_OFF\"].",
                      "type": "string"
                    },
                    "logging": {
                      "description": "Option to specify the logging mode, which determines if and where build logs are stored. Possible values: [\"LOGGING_UNSPECIFIED\", \"LEGACY\", \"GCS_ONLY\", \"STACKDRIVER_ONLY\", \"NONE\"].",
                      "type": "string"
                    },
                    "machineType": {
                      "description": "Compute Engine machine type on which to run the build. Possible values: [\"UNSPECIFIED\", \"N1_HIGHCPU_8\", \"N1_HIGHCPU_32\", \"E2_HIGHCPU_8\", \"E2_HIGHCPU_32\"].",
                      "type": "string"
                    },
                    "requestedVerifyOption": {
                      "description": "Requested verifiability options. Possible values: [\"NOT_VERIFIED\", \"VERIFIED\"].",
                      "type": "string"
                    },
                    "secretEnv": {
                      "description": "A list of global environment variables, which are encrypted using a Cloud Key Management\nService crypto key. These values must be specified in the build's Secret. These variables\nwill be available to all build steps in this build.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "sourceProvenanceHash": {
                      "description": "Requested hash for SourceProvenance. Possible values: [\"NONE\", \"SHA256\", \"MD5\"].",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "substitutionOption": {
                      "description": "Option to specify behavior when there is an error in the substitution checks.\n\nNOTE this is always set to ALLOW_LOOSE for triggered builds and cannot be overridden\nin the build configuration file. Possible values: [\"MUST_MATCH\", \"ALLOW_LOOSE\"].",
                      "type": "string"
                    },
                    "volumes": {
                      "description": "Global list of volumes to mount for ALL build steps\n\nEach volume is created as an empty volume prior to starting the build process.\nUpon completion of the build, volumes and their contents are discarded. Global\nvolume names and paths cannot conflict with the volumes defined a build step.\n\nUsing a global volume in a build with only one step is not valid as it is indicative\nof a build request with an incorrect configuration.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "name": {
                            "description": "Name of the volume to mount.\n\nVolume names must be unique per build step and must be valid names for Docker volumes.\nEach named volume must be used by at least two build steps.",
                            "type": "string"
                          },
                          "path": {
                            "description": "Path at which to mount the volume.\n\nPaths must be absolute and cannot conflict with other volume paths on the same\nbuild step or with certain reserved volume paths.",
                            "type": "string"
                          }
                        }
                      }
                    },
                    "workerPool": {
                      "description": "Option to specify a WorkerPool for the build. Format projects/{project}/workerPools/{workerPool}\n\nThis field is experimental.",
                      "type": "string"
                    }
                  }
                },
                "queueTtl": {
                  "description": "TTL in queue for this build. If provided and the build is enqueued longer than this value, \nthe build will expire and the build status will be EXPIRED.\nThe TTL starts ticking from createTime.\nA duration in seconds with up to nine fractional digits, terminated by 's'. Example: \"3.5s\".",
                  "type": "string"
                },
                "secret": {
                  "description": "Secrets to decrypt using Cloud Key Management Service.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["kmsKeyRef"],
                    "properties": {
                      "kmsKeyRef": {
                        "description": "KMS crypto key to use to decrypt these envs.",
                        "type": "object",
                        "properties": {
                          "external": {
                            "description": "The selfLink of a KMSCryptoKey.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          }
                        }
                      },
                      "secretEnv": {
                        "description": "Map of environment variable name to its encrypted value.\nSecret environment variables must be unique across all of a build's secrets, \nand must be used by at least one build step. Values can be at most 64 KB in size. \nThere can be at most 100 secret values across all of a build's secrets.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "source": {
                  "description": "The location of the source files to build.\n\nOne of 'storageSource' or 'repoSource' must be provided.",
                  "type": "object",
                  "properties": {
                    "repoSource": {
                      "description": "Location of the source in a Google Cloud Source Repository.",
                      "type": "object",
                      "required": ["repoRef"],
                      "properties": {
                        "branchName": {
                          "description": "Regex matching branches to build. Exactly one a of branch name, tag, or commit SHA must be provided.\nThe syntax of the regular expressions accepted is the syntax accepted by RE2 and \ndescribed at https://github.com/google/re2/wiki/Syntax.",
                          "type": "string"
                        },
                        "commitSha": {
                          "description": "Explicit commit SHA to build. Exactly one a of branch name, tag, or commit SHA must be provided.",
                          "type": "string"
                        },
                        "dir": {
                          "description": "Directory, relative to the source root, in which to run the build.\nThis must be a relative path. If a step's dir is specified and is an absolute path, \nthis value is ignored for that step's execution.",
                          "type": "string"
                        },
                        "invertRegex": {
                          "description": "Only trigger a build if the revision regex does NOT match the revision regex.",
                          "type": "boolean"
                        },
                        "projectId": {
                          "description": "ID of the project that owns the Cloud Source Repository. \nIf omitted, the project ID requesting the build is assumed.",
                          "type": "string"
                        },
                        "repoRef": {
                          "description": "The desired Cloud Source Repository. If omitted, \"default\" is\nassumed.",
                          "type": "object",
                          "properties": {
                            "external": {
                              "description": "The name of a SourceRepoRepository.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                              "type": "string"
                            },
                            "namespace": {
                              "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                              "type": "string"
                            }
                          }
                        },
                        "substitutions": {
                          "description": "Substitutions to use in a triggered build. Should only be used with triggers.run.",
                          "type": "object",
                          "additionalProperties": {
                            "type": "string"
                          }
                        },
                        "tagName": {
                          "description": "Regex matching tags to build. Exactly one a of branch name, tag, or commit SHA must be provided.\nThe syntax of the regular expressions accepted is the syntax accepted by RE2 and \ndescribed at https://github.com/google/re2/wiki/Syntax.",
                          "type": "string"
                        }
                      }
                    },
                    "storageSource": {
                      "description": "Location of the source in an archive file in Google Cloud Storage.",
                      "type": "object",
                      "required": ["bucketRef", "object"],
                      "properties": {
                        "bucketRef": {
                          "description": "Google Cloud Storage bucket containing the source.",
                          "type": "object",
                          "properties": {
                            "external": {
                              "description": "The name of a StorageBucket.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                              "type": "string"
                            },
                            "namespace": {
                              "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                              "type": "string"
                            }
                          }
                        },
                        "generation": {
                          "description": "Google Cloud Storage generation for the object. \nIf the generation is omitted, the latest generation will be used.",
                          "type": "string"
                        },
                        "object": {
                          "description": "Google Cloud Storage object containing the source.\nThis object must be a gzipped archive file (.tar.gz) containing source to build.",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "step": {
                  "description": "The operations to be performed on the workspace.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["name"],
                    "properties": {
                      "args": {
                        "description": "A list of arguments that will be presented to the step when it is started.\n\nIf the image used to run the step's container has an entrypoint, the args\nare used as arguments to that entrypoint. If the image does not define an\nentrypoint, the first element in args is used as the entrypoint, and the\nremainder will be used as arguments.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "dir": {
                        "description": "Working directory to use when running this step's container.\n\nIf this value is a relative path, it is relative to the build's working\ndirectory. If this value is absolute, it may be outside the build's working\ndirectory, in which case the contents of the path may not be persisted\nacross build step executions, unless a 'volume' for that path is specified.\n\nIf the build specifies a 'RepoSource' with 'dir' and a step with a\n'dir',\nwhich specifies an absolute path, the 'RepoSource' 'dir' is ignored\nfor the step's execution.",
                        "type": "string"
                      },
                      "entrypoint": {
                        "description": "Entrypoint to be used instead of the build step image's\ndefault entrypoint.\nIf unset, the image's default entrypoint is used.",
                        "type": "string"
                      },
                      "env": {
                        "description": "A list of environment variable definitions to be used when\nrunning a step.\n\nThe elements are of the form \"KEY=VALUE\" for the environment variable\n\"KEY\" being given the value \"VALUE\".",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "id": {
                        "description": "Unique identifier for this build step, used in 'wait_for' to\nreference this build step as a dependency.",
                        "type": "string"
                      },
                      "name": {
                        "description": "The name of the container image that will run this particular build step.\n\nIf the image is available in the host's Docker daemon's cache, it will be\nrun directly. If not, the host will attempt to pull the image first, using\nthe builder service account's credentials if necessary.\n\nThe Docker daemon's cache will already have the latest versions of all of\nthe officially supported build steps (see https://github.com/GoogleCloudPlatform/cloud-builders \nfor images and examples).\nThe Docker daemon will also have cached many of the layers for some popular\nimages, like \"ubuntu\", \"debian\", but they will be refreshed at the time\nyou attempt to use them.\n\nIf you built an image in a previous build step, it will be stored in the\nhost's Docker daemon's cache and is available to use as the name for a\nlater build step.",
                        "type": "string"
                      },
                      "secretEnv": {
                        "description": "A list of environment variables which are encrypted using\na Cloud Key\nManagement Service crypto key. These values must be specified in\nthe build's 'Secret'.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "timeout": {
                        "description": "Time limit for executing this build step. If not defined,\nthe step has no\ntime limit and will be allowed to continue to run until either it\ncompletes or the build itself times out.",
                        "type": "string"
                      },
                      "timing": {
                        "description": "Output only. Stores timing information for executing this\nbuild step.",
                        "type": "string"
                      },
                      "volumes": {
                        "description": "List of volumes to mount into the build step.\n\nEach volume is created as an empty volume prior to execution of the\nbuild step. Upon completion of the build, volumes and their contents\nare discarded.\n\nUsing a named volume in only one step is not valid as it is\nindicative of a build request with an incorrect configuration.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "required": ["name", "path"],
                          "properties": {
                            "name": {
                              "description": "Name of the volume to mount.\n\nVolume names must be unique per build step and must be valid names for\nDocker volumes. Each named volume must be used by at least two build steps.",
                              "type": "string"
                            },
                            "path": {
                              "description": "Path at which to mount the volume.\n\nPaths must be absolute and cannot conflict with other volume paths on\nthe same build step or with certain reserved volume paths.",
                              "type": "string"
                            }
                          }
                        }
                      },
                      "waitFor": {
                        "description": "The ID(s) of the step(s) that this build step depends on.\n\nThis build step will not start until all the build steps in 'wait_for'\nhave completed successfully. If 'wait_for' is empty, this build step\nwill start when all previous build steps in the 'Build.Steps' list\nhave completed successfully.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "substitutions": {
                  "description": "Substitutions data for Build resource.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "tags": {
                  "description": "Tags for annotation of a Build. These are not docker tags.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "timeout": {
                  "description": "Amount of time that this build should be allowed to run, to second granularity.\nIf this amount of time elapses, work on the build will cease and the build status will be TIMEOUT.\nThis timeout must be equal to or greater than the sum of the timeouts for build steps within the build.\nThe expected format is the number of seconds followed by s.\nDefault time is ten minutes (600s).",
                  "type": "string"
                }
              }
            },
            "description": {
              "description": "Human-readable description of the trigger.",
              "type": "string"
            },
            "disabled": {
              "description": "Whether the trigger is disabled or not. If true, the trigger will never result in a build.",
              "type": "boolean"
            },
            "filename": {
              "description": "Path, from the source root, to a file whose contents is used for the template. Either a filename or build template must be provided.",
              "type": "string"
            },
            "github": {
              "description": "Describes the configuration of a trigger that creates a build whenever a GitHub event is received.\n\nOne of 'trigger_template', 'github', 'pubsub_config' or 'webhook_config' must be provided.",
              "type": "object",
              "properties": {
                "name": {
                  "description": "Name of the repository. For example: The name for\nhttps://github.com/googlecloudplatform/cloud-builders is \"cloud-builders\".",
                  "type": "string"
                },
                "owner": {
                  "description": "Owner of the repository. For example: The owner for\nhttps://github.com/googlecloudplatform/cloud-builders is \"googlecloudplatform\".",
                  "type": "string"
                },
                "pullRequest": {
                  "description": "filter to match changes in pull requests.  Specify only one of pullRequest or push.",
                  "type": "object",
                  "required": ["branch"],
                  "properties": {
                    "branch": {
                      "description": "Regex of branches to match.",
                      "type": "string"
                    },
                    "commentControl": {
                      "description": "Whether to block builds on a \"/gcbrun\" comment from a repository owner or collaborator. Possible values: [\"COMMENTS_DISABLED\", \"COMMENTS_ENABLED\", \"COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY\"].",
                      "type": "string"
                    },
                    "invertRegex": {
                      "description": "If true, branches that do NOT match the git_ref will trigger a build.",
                      "type": "boolean"
                    }
                  }
                },
                "push": {
                  "description": "filter to match changes in refs, like branches or tags.  Specify only one of pullRequest or push.",
                  "type": "object",
                  "properties": {
                    "branch": {
                      "description": "Regex of branches to match.  Specify only one of branch or tag.",
                      "type": "string"
                    },
                    "invertRegex": {
                      "description": "When true, only trigger a build if the revision regex does NOT match the git_ref regex.",
                      "type": "boolean"
                    },
                    "tag": {
                      "description": "Regex of tags to match.  Specify only one of branch or tag.",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "ignoredFiles": {
              "description": "ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match\nextended with support for '**'.\n\nIf ignoredFiles and changed files are both empty, then they are not\nused to determine whether or not to trigger a build.\n\nIf ignoredFiles is not empty, then we ignore any files that match any\nof the ignored_file globs. If the change has no files that are outside\nof the ignoredFiles globs, then we do not trigger a build.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "includedFiles": {
              "description": "ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match\nextended with support for '**'.\n\nIf any of the files altered in the commit pass the ignoredFiles filter\nand includedFiles is empty, then as far as this filter is concerned, we\nshould trigger the build.\n\nIf any of the files altered in the commit pass the ignoredFiles filter\nand includedFiles is not empty, then we make sure that at least one of\nthose files matches a includedFiles glob. If not, then we do not trigger\na build.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "pubsubConfig": {
              "description": "PubsubConfig describes the configuration of a trigger that creates \na build whenever a Pub/Sub message is published.\n\nOne of 'trigger_template', 'github', 'pubsub_config' or 'webhook_config' must be provided.",
              "type": "object",
              "required": ["topicRef"],
              "properties": {
                "serviceAccountRef": {
                  "description": "Service account that will make the push request.",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The email of an IAMServiceAccount.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "state": {
                  "description": "Potential issues with the underlying Pub/Sub subscription configuration.\nOnly populated on get requests.",
                  "type": "string"
                },
                "subscription": {
                  "description": "Output only. Name of the subscription.",
                  "type": "string"
                },
                "topicRef": {
                  "description": "The name of the topic from which this subscription\nis receiving messages.",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The name of a PubSubTopic.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "serviceAccountRef": {
              "description": "The service account used for all user-controlled operations including\ntriggers.patch, triggers.run, builds.create, and builds.cancel.\n\nIf no service account is set, then the standard Cloud Build service account\n([PROJECT_NUM]@system.gserviceaccount.com) will be used instead.\n\nWhen populating via the external field, the following format is supported:\nprojects/{PROJECT_ID}/serviceAccounts/{SERVICE_ACCOUNT_EMAIL}",
              "type": "object",
              "properties": {
                "external": {
                  "description": "A string of the format \"projects/{{project}}/serviceAccounts/{{value}}\", where {{value}} is the email of an IAMServiceAccount.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "substitutions": {
              "description": "Substitutions data for Build resource.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "tags": {
              "description": "Tags for annotation of a BuildTrigger.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "triggerTemplate": {
              "description": "Template describing the types of source changes to trigger a build.\n\nBranch and tag names in trigger templates are interpreted as regular\nexpressions. Any branch or tag change that matches that regular\nexpression will trigger a build.\n\nOne of 'trigger_template', 'github', 'pubsub_config' or 'webhook_config' must be provided.",
              "type": "object",
              "properties": {
                "branchName": {
                  "description": "Name of the branch to build. Exactly one a of branch name, tag, or commit SHA must be provided.\nThis field is a regular expression.",
                  "type": "string"
                },
                "commitSha": {
                  "description": "Explicit commit SHA to build. Exactly one of a branch name, tag, or commit SHA must be provided.",
                  "type": "string"
                },
                "dir": {
                  "description": "Directory, relative to the source root, in which to run the build.\n\nThis must be a relative path. If a step's dir is specified and\nis an absolute path, this value is ignored for that step's\nexecution.",
                  "type": "string"
                },
                "invertRegex": {
                  "description": "Only trigger a build if the revision regex does NOT match the revision regex.",
                  "type": "boolean"
                },
                "repoRef": {
                  "description": "The Cloud Source Repository to build. If omitted, the repo with\nname \"default\" is assumed.",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The name of a SourceRepoRepository.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "tagName": {
                  "description": "Name of the tag to build. Exactly one of a branch name, tag, or commit SHA must be provided.\nThis field is a regular expression.",
                  "type": "string"
                }
              }
            },
            "webhookConfig": {
              "description": "WebhookConfig describes the configuration of a trigger that creates \na build whenever a webhook is sent to a trigger's webhook URL.\n\nOne of 'trigger_template', 'github', 'pubsub_config' or 'webhook_config' must be provided.",
              "type": "object",
              "required": ["secretRef"],
              "properties": {
                "secretRef": {
                  "description": "The secret required",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The name of a SecretManagerSecret.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "state": {
                  "description": "Potential issues with the underlying Pub/Sub subscription configuration.\nOnly populated on get requests.",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Time when the trigger was created.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "triggerId": {
              "description": "The unique identifier for the trigger.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "cloudbuild.cnrm.cloud.google.com",
          "kind": "CloudBuildTrigger",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.cloudbuild.v1beta1.CloudBuildTriggerList": {
      "description": "CloudBuildTriggerList is a list of CloudBuildTrigger",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["cloudbuild.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of cloudbuildtriggers. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.cloudbuild.v1beta1.CloudBuildTrigger"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CloudBuildTriggerList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "cloudbuild.cnrm.cloud.google.com",
          "kind": "CloudBuildTriggerList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.cloudidentity.v1beta1.CloudIdentityGroup": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["cloudidentity.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CloudIdentityGroup"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["groupKey", "labels", "parent"],
          "properties": {
            "description": {
              "description": "An extended description to help users determine the purpose of a Group.\nMust not be longer than 4,096 characters.",
              "type": "string"
            },
            "displayName": {
              "description": "The display name of the Group.",
              "type": "string"
            },
            "groupKey": {
              "description": "Immutable. EntityKey of the Group.",
              "type": "object",
              "required": ["id"],
              "properties": {
                "id": {
                  "description": "Immutable. The ID of the entity.\n\nFor Google-managed entities, the id must be the email address of an existing\ngroup or user.\n\nFor external-identity-mapped entities, the id must be a string conforming\nto the Identity Source's requirements.\n\nMust be unique within a namespace.",
                  "type": "string"
                },
                "namespace": {
                  "description": "Immutable. The namespace in which the entity exists.\n\nIf not specified, the EntityKey represents a Google-managed entity\nsuch as a Google user or a Google Group.\n\nIf specified, the EntityKey represents an external-identity-mapped group.\nThe namespace must correspond to an identity source created in Admin Console\nand must be in the form of 'identitysources/{identity_source_id}'.",
                  "type": "string"
                }
              }
            },
            "initialGroupConfig": {
              "description": "Immutable. The initial configuration options for creating a Group.\n\nSee the\n[API reference](https://cloud.google.com/identity/docs/reference/rest/v1beta1/groups/create#initialgroupconfig)\nfor possible values. Default value: \"EMPTY\" Possible values: [\"INITIAL_GROUP_CONFIG_UNSPECIFIED\", \"WITH_INITIAL_OWNER\", \"EMPTY\"].",
              "type": "string"
            },
            "labels": {
              "description": "Immutable. The labels that apply to the Group.\n\nMust not contain more than one entry. Must contain the entry\n'cloudidentity.googleapis.com/groups.discussion_forum': '' if the Group is a Google Group or\n'system/groups/external': '' if the Group is an external-identity-mapped group.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "parent": {
              "description": "Immutable. The resource name of the entity under which this Group resides in the\nCloud Identity resource hierarchy.\n\nMust be of the form identitysources/{identity_source_id} for external-identity-mapped\ngroups or customers/{customer_id} for Google Groups.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "The time when the Group was created.",
              "type": "string"
            },
            "name": {
              "description": "Resource name of the Group in the format: groups/{group_id}, where group_id\nis the unique ID assigned to the Group.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "The time when the Group was last updated.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "cloudidentity.cnrm.cloud.google.com",
          "kind": "CloudIdentityGroup",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.cloudidentity.v1beta1.CloudIdentityGroupList": {
      "description": "CloudIdentityGroupList is a list of CloudIdentityGroup",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["cloudidentity.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of cloudidentitygroups. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.cloudidentity.v1beta1.CloudIdentityGroup"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CloudIdentityGroupList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "cloudidentity.cnrm.cloud.google.com",
          "kind": "CloudIdentityGroupList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.cloudidentity.v1beta1.CloudIdentityMembership": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["cloudidentity.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CloudIdentityMembership"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["groupRef", "preferredMemberKey", "roles"],
          "properties": {
            "groupRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The group for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "memberKey": {
              "description": "Immutable. The `EntityKey` of the member. Either `member_key` or `preferred_member_key` must be set when calling MembershipsService.CreateMembership but not both; both shall be set when returned.",
              "type": "object",
              "properties": {
                "id": {
                  "description": "The ID of the entity. For Google-managed entities, the `id` must be the email address of an existing group or user. For external-identity-mapped entities, the `id` must be a string conforming to the Identity Source's requirements. Must be unique within a `namespace`.",
                  "type": "string"
                },
                "namespace": {
                  "description": "The namespace in which the entity exists. If not specified, the `EntityKey` represents a Google-managed entity such as a Google user or a Google Group. If specified, the `EntityKey` represents an external-identity-mapped group. The namespace must correspond to an identity source created in Admin Console and must be in the form of `identitysources/{identity_source_id}`.",
                  "type": "string"
                }
              }
            },
            "preferredMemberKey": {
              "description": "Required. Immutable. The `EntityKey` of the member.",
              "type": "object",
              "required": ["id"],
              "properties": {
                "id": {
                  "description": "The ID of the entity. For Google-managed entities, the `id` must be the email address of a group or user. For external-identity-mapped entities, the `id` must be a string conforming to the Identity Source's requirements. Must be unique within a `namespace`.",
                  "type": "string"
                },
                "namespace": {
                  "description": "The namespace in which the entity exists. If not specified, the `EntityKey` represents a Google-managed entity such as a Google user or a Google Group. If specified, the `EntityKey` represents an external-identity-mapped group. The namespace must correspond to an identity source created in Admin Console and must be in the form of `identitysources/{identity_source_id}`.",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            },
            "roles": {
              "description": "The `MembershipRole`s that apply to the `Membership`. If unspecified, defaults to a single `MembershipRole` with `name` `MEMBER`. Must not contain duplicate `MembershipRole`s with the same `name`.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["name"],
                "properties": {
                  "expiryDetail": {
                    "description": "The expiry details of the `MembershipRole`. Expiry details are only supported for `MEMBER` `MembershipRoles`. May be set if `name` is `MEMBER`. Must not be set if `name` is any other value.",
                    "type": "object",
                    "properties": {
                      "expireTime": {
                        "description": "The time at which the `MembershipRole` will expire.",
                        "type": "string",
                        "format": "date-time"
                      }
                    }
                  },
                  "name": {
                    "type": "string"
                  },
                  "restrictionEvaluations": {
                    "description": "Evaluations of restrictions applied to parent group on this membership.",
                    "type": "object",
                    "properties": {
                      "memberRestrictionEvaluation": {
                        "description": "Evaluation of the member restriction applied to this membership. Empty if the user lacks permission to view the restriction evaluation.",
                        "type": "object",
                        "properties": {
                          "state": {
                            "description": "Output only. The current state of the restriction Possible values: ENCRYPTION_STATE_UNSPECIFIED, UNSUPPORTED_BY_DEVICE, ENCRYPTED, NOT_ENCRYPTED",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The time when the `Membership` was created.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "type": {
              "description": "Output only. The type of the membership. Possible values: OWNER_TYPE_UNSPECIFIED, OWNER_TYPE_CUSTOMER, OWNER_TYPE_PARTNER",
              "type": "string"
            },
            "updateTime": {
              "description": "Output only. The time when the `Membership` was last updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "cloudidentity.cnrm.cloud.google.com",
          "kind": "CloudIdentityMembership",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.cloudidentity.v1beta1.CloudIdentityMembershipList": {
      "description": "CloudIdentityMembershipList is a list of CloudIdentityMembership",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["cloudidentity.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of cloudidentitymemberships. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.cloudidentity.v1beta1.CloudIdentityMembership"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CloudIdentityMembershipList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "cloudidentity.cnrm.cloud.google.com",
          "kind": "CloudIdentityMembershipList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.cloudscheduler.v1beta1.CloudSchedulerJob": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["cloudscheduler.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CloudSchedulerJob"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location"],
          "properties": {
            "appEngineHttpTarget": {
              "description": "App Engine HTTP target.",
              "type": "object",
              "properties": {
                "appEngineRouting": {
                  "description": "App Engine Routing setting for the job.",
                  "type": "object",
                  "properties": {
                    "instance": {
                      "description": "App instance. By default, the job is sent to an instance which is available when the job is attempted. Requests can only be sent to a specific instance if [manual scaling is used in App Engine Standard](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine?hl=en_US#scaling_types_and_instance_classes). App Engine Flex does not support instances. For more information, see [App Engine Standard request routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed) and [App Engine Flex request routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).",
                      "type": "string"
                    },
                    "service": {
                      "description": "App service. By default, the job is sent to the service which is the default service when the job is attempted.",
                      "type": "string"
                    },
                    "version": {
                      "description": "App version. By default, the job is sent to the version which is the default version when the job is attempted.",
                      "type": "string"
                    }
                  }
                },
                "body": {
                  "description": "Body. HTTP request body. A request body is allowed only if the HTTP method is POST or PUT. It will result in invalid argument error to set a body on a job with an incompatible HttpMethod.",
                  "type": "string"
                },
                "headers": {
                  "description": "HTTP request headers. This map contains the header field names and values. Headers can be set when the job is created. Cloud Scheduler sets some headers to default values: * `User-Agent`: By default, this header is `\"App Engine-Google; (+http://code.google.com/appengine)\"`. This header can be modified, but Cloud Scheduler will append `\"App Engine-Google; (+http://code.google.com/appengine)\"` to the modified `User-Agent`. * `X-CloudScheduler`: This header will be set to true. The headers below are output only. They cannot be set or overridden: * `X-Google-*`: For Google internal use only. * `X-App Engine-*`: For Google internal use only. In addition, some App Engine headers, which contain job-specific information, are also be sent to the job handler.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "httpMethod": {
                  "description": "The HTTP method to use for the request. PATCH and OPTIONS are not permitted. Possible values: HTTP_METHOD_UNSPECIFIED, POST, GET, HEAD, PUT, DELETE, PATCH, OPTIONS",
                  "type": "string"
                },
                "relativeUri": {
                  "description": "The relative URI. The relative URL must begin with \"/\" and must be a valid HTTP relative URL. It can contain a path, query string arguments, and `#` fragments. If the relative URL is empty, then the root path \"/\" will be used. No spaces are allowed, and the maximum length allowed is 2083 characters.",
                  "type": "string"
                }
              }
            },
            "attemptDeadline": {
              "description": "The deadline for job attempts. If the request handler does not respond by this deadline then the request is cancelled and the attempt is marked as a `DEADLINE_EXCEEDED` failure. The failed attempt can be viewed in execution logs. Cloud Scheduler will retry the job according to the RetryConfig. The allowed duration for this deadline is: * For HTTP targets, between 15 seconds and 30 minutes. * For App Engine HTTP targets, between 15 seconds and 24 hours.",
              "type": "string"
            },
            "description": {
              "description": "Optionally caller-specified in CreateJob or UpdateJob. A human-readable description for the job. This string must not contain more than 500 characters.",
              "type": "string"
            },
            "httpTarget": {
              "description": "HTTP target.",
              "type": "object",
              "required": ["uri"],
              "properties": {
                "body": {
                  "description": "HTTP request body. A request body is allowed only if the HTTP method is POST, PUT, or PATCH. It is an error to set body on a job with an incompatible HttpMethod.",
                  "type": "string"
                },
                "headers": {
                  "description": "The user can specify HTTP request headers to send with the job's HTTP request. This map contains the header field names and values. Repeated headers are not supported, but a header value can contain commas. These headers represent a subset of the headers that will accompany the job's HTTP request. Some HTTP request headers will be ignored or replaced. A partial list of headers that will be ignored or replaced is below: - Host: This will be computed by Cloud Scheduler and derived from uri. * `Content-Length`: This will be computed by Cloud Scheduler. * `User-Agent`: This will be set to `\"Google-Cloud-Scheduler\"`. * `X-Google-*`: Google internal use only. * `X-appengine-*`: Google internal use only. The total size of headers must be less than 80KB.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "httpMethod": {
                  "description": "Which HTTP method to use for the request. Possible values: HTTP_METHOD_UNSPECIFIED, POST, GET, HEAD, PUT, DELETE, PATCH, OPTIONS",
                  "type": "string"
                },
                "oauthToken": {
                  "description": "If specified, an [OAuth token](https://developers.google.com/identity/protocols/OAuth2) will be generated and attached as an `Authorization` header in the HTTP request. This type of authorization should generally only be used when calling Google APIs hosted on *.googleapis.com.",
                  "type": "object",
                  "properties": {
                    "scope": {
                      "description": "OAuth scope to be used for generating OAuth access token. If not specified, \"https://www.googleapis.com/auth/cloud-platform\" will be used.",
                      "type": "string"
                    },
                    "serviceAccountRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "[Service account email](https://cloud.google.com/iam/docs/service-accounts) to be used for generating OAuth token. The service account must be within the same project as the job. The caller must have iam.serviceAccounts.actAs permission for the service account.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "oidcToken": {
                  "description": "If specified, an [OIDC](https://developers.google.com/identity/protocols/OpenIDConnect) token will be generated and attached as an `Authorization` header in the HTTP request. This type of authorization can be used for many scenarios, including calling Cloud Run, or endpoints where you intend to validate the token yourself.",
                  "type": "object",
                  "properties": {
                    "audience": {
                      "description": "Audience to be used when generating OIDC token. If not specified, the URI specified in target will be used.",
                      "type": "string"
                    },
                    "serviceAccountRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "[Service account email](https://cloud.google.com/iam/docs/service-accounts) to be used for generating OIDC token. The service account must be within the same project as the job. The caller must have iam.serviceAccounts.actAs permission for the service account.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "uri": {
                  "description": "Required. The full URI path that the request will be sent to. This string must begin with either \"http://\" or \"https://\". Some examples of valid values for uri are: `http://acme.com` and `https://acme.com/sales:8080`. Cloud Scheduler will encode some characters for safety and compatibility. The maximum allowed URL length is 2083 characters after encoding.",
                  "type": "string"
                }
              }
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "pubsubTarget": {
              "description": "Pub/Sub target.",
              "type": "object",
              "required": ["topicRef"],
              "properties": {
                "attributes": {
                  "description": "Attributes for PubsubMessage. Pubsub message must contain either non-empty data, or at least one attribute.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "data": {
                  "description": "The message payload for PubsubMessage. Pubsub message must contain either non-empty data, or at least one attribute.",
                  "type": "string"
                },
                "topicRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "Required. The name of the Cloud Pub/Sub topic to which messages will be published when a job is delivered. The topic name must be in the same format as required by Pub/Sub's [PublishRequest.name](https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#publishrequest), for example `projects/PROJECT_ID/topics/TOPIC_ID`. The topic must be in the same project as the Cloud Scheduler job.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "retryConfig": {
              "description": "Settings that determine the retry behavior.",
              "type": "object",
              "properties": {
                "maxBackoffDuration": {
                  "description": "The maximum amount of time to wait before retrying a job after it fails. The default value of this field is 1 hour.",
                  "type": "string"
                },
                "maxDoublings": {
                  "description": "The time between retries will double `max_doublings` times. A job's retry interval starts at min_backoff_duration, then doubles `max_doublings` times, then increases linearly, and finally retries at intervals of max_backoff_duration up to retry_count times. For example, if min_backoff_duration is 10s, max_backoff_duration is 300s, and `max_doublings` is 3, then the a job will first be retried in 10s. The retry interval will double three times, and then increase linearly by 2^3 * 10s. Finally, the job will retry at intervals of max_backoff_duration until the job has been attempted retry_count times. Thus, the requests will retry at 10s, 20s, 40s, 80s, 160s, 240s, 300s, 300s, .... The default value of this field is 5.",
                  "type": "integer",
                  "format": "int64"
                },
                "maxRetryDuration": {
                  "description": "The time limit for retrying a failed job, measured from time when an execution was first attempted. If specified with retry_count, the job will be retried until both limits are reached. The default value for max_retry_duration is zero, which means retry duration is unlimited.",
                  "type": "string"
                },
                "minBackoffDuration": {
                  "description": "The minimum amount of time to wait before retrying a job after it fails. The default value of this field is 5 seconds.",
                  "type": "string"
                },
                "retryCount": {
                  "description": "The number of attempts that the system will make to run a job using the exponential backoff procedure described by max_doublings. The default value of retry_count is zero. If retry_count is zero, a job attempt will *not* be retried if it fails. Instead the Cloud Scheduler system will wait for the next scheduled execution time. If retry_count is set to a non-zero number then Cloud Scheduler will retry failed attempts, using exponential backoff, retry_count times, or until the next scheduled execution time, whichever comes first. Values greater than 5 and negative values are not allowed.",
                  "type": "integer",
                  "format": "int64"
                }
              }
            },
            "schedule": {
              "description": "Required, except when used with UpdateJob. Describes the schedule on which the job will be executed. The schedule can be either of the following types: * [Crontab](http://en.wikipedia.org/wiki/Cron#Overview) * English-like [schedule](https://cloud.google.com/scheduler/docs/configuring/cron-job-schedules) As a general rule, execution `n + 1` of a job will not begin until execution `n` has finished. Cloud Scheduler will never allow two simultaneously outstanding executions. For example, this implies that if the `n+1`th execution is scheduled to run at 16:00 but the `n`th execution takes until 16:15, the `n+1`th execution will not start until `16:15`. A scheduled start time will be delayed if the previous execution has not ended when its scheduled time occurs. If retry_count > 0 and a job attempt fails, the job will be tried a total of retry_count times, with exponential backoff, until the next scheduled start time.",
              "type": "string"
            },
            "timeZone": {
              "description": "Specifies the time zone to be used in interpreting schedule. The value of this field must be a time zone name from the [tz database](http://en.wikipedia.org/wiki/Tz_database). Note that some time zones include a provision for daylight savings time. The rules for daylight saving time are determined by the chosen tz. For UTC use the string \"utc\". If a time zone is not specified, the default will be in UTC (also known as GMT).",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "appEngineHttpTarget": {
              "type": "object",
              "properties": {
                "appEngineRouting": {
                  "type": "object",
                  "properties": {
                    "host": {
                      "description": "Output only. The host that the job is sent to. For more information about how App Engine requests are routed, see [here](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed). The host is constructed as: * `host = [application_domain_name]` `| [service] + '.' + [application_domain_name]` `| [version] + '.' + [application_domain_name]` `| [version_dot_service]+ '.' + [application_domain_name]` `| [instance] + '.' + [application_domain_name]` `| [instance_dot_service] + '.' + [application_domain_name]` `| [instance_dot_version] + '.' + [application_domain_name]` `| [instance_dot_version_dot_service] + '.' + [application_domain_name]` * `application_domain_name` = The domain name of the app, for example .appspot.com, which is associated with the job's project ID. * `service =` service * `version =` version * `version_dot_service =` version `+ '.' +` service * `instance =` instance * `instance_dot_service =` instance `+ '.' +` service * `instance_dot_version =` instance `+ '.' +` version * `instance_dot_version_dot_service =` instance `+ '.' +` version `+ '.' +` service If service is empty, then the job will be sent to the service which is the default service when the job is attempted. If version is empty, then the job will be sent to the version which is the default version when the job is attempted. If instance is empty, then the job will be sent to an instance which is available when the job is attempted. If service, version, or instance is invalid, then the job will be sent to the default version of the default service when the job is attempted.",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "lastAttemptTime": {
              "description": "Output only. The time the last job attempt started.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "scheduleTime": {
              "description": "Output only. The next time the job is scheduled. Note that this may be a retry of a previously failed attempt or the next execution time according to the schedule.",
              "type": "string",
              "format": "date-time"
            },
            "state": {
              "description": "Output only. State of the job. Possible values: STATE_UNSPECIFIED, ENABLED, PAUSED, DISABLED, UPDATE_FAILED",
              "type": "string"
            },
            "status": {
              "description": "Output only. The response from the target for the last attempted execution.",
              "type": "object",
              "properties": {
                "code": {
                  "description": "The status code, which should be an enum value of google.rpc.Code.",
                  "type": "integer",
                  "format": "int64"
                },
                "details": {
                  "description": "A list of messages that carry the error details. There is a common set of message types for APIs to use.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "typeUrl": {
                        "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a google.protobuf.Type value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the URL, or have them precompiled into a binary to avoid any lookup. Therefore, binary compatibility needs to be preserved on changes to types. (Use versioned type names to manage breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                        "type": "string"
                      },
                      "value": {
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "type": "string"
                      }
                    }
                  }
                },
                "message": {
                  "description": "A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.",
                  "type": "string"
                }
              }
            },
            "userUpdateTime": {
              "description": "Output only. The creation time of the job.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "cloudscheduler.cnrm.cloud.google.com",
          "kind": "CloudSchedulerJob",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.cloudscheduler.v1beta1.CloudSchedulerJobList": {
      "description": "CloudSchedulerJobList is a list of CloudSchedulerJob",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["cloudscheduler.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of cloudschedulerjobs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.cloudscheduler.v1beta1.CloudSchedulerJob"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CloudSchedulerJobList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "cloudscheduler.cnrm.cloud.google.com",
          "kind": "CloudSchedulerJobList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeAddress": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeAddress"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location"],
          "properties": {
            "address": {
              "description": "Immutable. The static external IP address represented by this resource. Only\nIPv4 is supported. An address may only be specified for INTERNAL\naddress types. The IP address must be inside the specified subnetwork,\nif any.",
              "type": "string"
            },
            "addressType": {
              "description": "Immutable. The type of address to reserve. Default value: \"EXTERNAL\" Possible values: [\"INTERNAL\", \"EXTERNAL\"].",
              "type": "string"
            },
            "description": {
              "description": "Immutable. An optional description of this resource.",
              "type": "string"
            },
            "ipVersion": {
              "description": "Immutable. The IP Version that will be used by this address. The default value is 'IPV4'. Possible values: [\"IPV4\", \"IPV6\"].",
              "type": "string"
            },
            "location": {
              "description": "Location represents the geographical location of the ComputeAddress. Specify a region name or \"global\" for global resources. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)",
              "type": "string"
            },
            "networkRef": {
              "description": "The network in which to reserve the address. If global, the address\nmust be within the RFC1918 IP space. The network cannot be deleted\nif there are any reserved IP ranges referring to it. This field can\nonly be used with INTERNAL type with the VPC_PEERING and\nIPSEC_INTERCONNECT purposes.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "networkTier": {
              "description": "Immutable. The networking tier used for configuring this address. If this field is not\nspecified, it is assumed to be PREMIUM. Possible values: [\"PREMIUM\", \"STANDARD\"].",
              "type": "string"
            },
            "prefixLength": {
              "description": "Immutable. The prefix length if the resource represents an IP range.",
              "type": "integer"
            },
            "purpose": {
              "description": "Immutable. The purpose of this resource, which can be one of the following values:\n\n* GCE_ENDPOINT for addresses that are used by VM instances, alias IP\n  ranges, internal load balancers, and similar resources.\n\n* SHARED_LOADBALANCER_VIP for an address that can be used by multiple\n  internal load balancers.\n\n* VPC_PEERING for addresses that are reserved for VPC peer networks.\n\n* IPSEC_INTERCONNECT for addresses created from a private IP range\n  that are reserved for a VLAN attachment in an IPsec-encrypted Cloud\n  Interconnect configuration. These addresses are regional resources.\n\n* PRIVATE_SERVICE_CONNECT for a private network address that is used\nto configure Private Service Connect. Only global internal addresses\ncan use this purpose.\n\nThis should only be set when using an Internal address.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "subnetworkRef": {
              "description": "The subnetwork in which to reserve the address. If an IP address is\nspecified, it must be within the subnetwork's IP range.  This field\ncan only be used with INTERNAL type with GCE_ENDPOINT/DNS_RESOLVER\npurposes.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeSubnetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "labelFingerprint": {
              "description": "The fingerprint used for optimistic locking of this resource.  Used\ninternally during updates.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            },
            "users": {
              "description": "The URLs of the resources that are using this address.",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeAddress",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeAddressList": {
      "description": "ComputeAddressList is a list of ComputeAddress",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computeaddresses. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeAddress"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeAddressList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeAddressList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeBackendBucket": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeBackendBucket"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["bucketRef"],
          "properties": {
            "bucketRef": {
              "description": "Reference to the bucket.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a StorageBucket.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "cdnPolicy": {
              "description": "Cloud CDN configuration for this Backend Bucket.",
              "type": "object",
              "properties": {
                "cacheMode": {
                  "description": "Specifies the cache setting for all responses from this backend.\nThe possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC Possible values: [\"USE_ORIGIN_HEADERS\", \"FORCE_CACHE_ALL\", \"CACHE_ALL_STATIC\"].",
                  "type": "string"
                },
                "clientTtl": {
                  "description": "Specifies the maximum allowed TTL for cached content served by this origin.",
                  "type": "integer"
                },
                "defaultTtl": {
                  "description": "Specifies the default TTL for cached content served by this origin for responses\nthat do not have an existing valid TTL (max-age or s-max-age).",
                  "type": "integer"
                },
                "maxTtl": {
                  "description": "Specifies the maximum allowed TTL for cached content served by this origin.",
                  "type": "integer"
                },
                "negativeCaching": {
                  "description": "Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.",
                  "type": "boolean"
                },
                "negativeCachingPolicy": {
                  "description": "Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.\nOmitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "code": {
                        "description": "The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501\ncan be specified as values, and you cannot specify a status code more than once.",
                        "type": "integer"
                      },
                      "ttl": {
                        "description": "The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s\n(30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.",
                        "type": "integer"
                      }
                    }
                  }
                },
                "serveWhileStale": {
                  "description": "Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.",
                  "type": "integer"
                },
                "signedUrlCacheMaxAgeSec": {
                  "description": "Maximum number of seconds the response to a signed URL request will\nbe considered fresh. After this time period,\nthe response will be revalidated before being served.\nWhen serving responses to signed URL requests,\nCloud CDN will internally behave as though\nall responses from this backend had a \"Cache-Control: public,\nmax-age=[TTL]\" header, regardless of any existing Cache-Control\nheader. The actual headers served in responses will not be altered.",
                  "type": "integer"
                }
              }
            },
            "customResponseHeaders": {
              "description": "Headers that the HTTP/S load balancer should add to proxied responses.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "description": {
              "description": "An optional textual description of the resource; provided by the\nclient when the resource is created.",
              "type": "string"
            },
            "enableCdn": {
              "description": "If true, enable Cloud CDN for this BackendBucket.",
              "type": "boolean"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeBackendBucket",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeBackendBucketList": {
      "description": "ComputeBackendBucketList is a list of ComputeBackendBucket",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computebackendbuckets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeBackendBucket"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeBackendBucketList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeBackendBucketList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeBackendService": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeBackendService"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location"],
          "properties": {
            "affinityCookieTtlSec": {
              "description": "Lifetime of cookies in seconds if session_affinity is\nGENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts\nonly until the end of the browser session (or equivalent). The\nmaximum allowed value for TTL is one day.\n\nWhen the load balancing scheme is INTERNAL, this field is not used.",
              "type": "integer"
            },
            "backend": {
              "description": "The set of backends that serve this BackendService.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["group"],
                "properties": {
                  "balancingMode": {
                    "description": "Specifies the balancing mode for this backend.\n\nFor global HTTP(S) or TCP/SSL load balancing, the default is\nUTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S))\nand CONNECTION (for TCP/SSL). Default value: \"UTILIZATION\" Possible values: [\"UTILIZATION\", \"RATE\", \"CONNECTION\"].",
                    "type": "string"
                  },
                  "capacityScaler": {
                    "description": "A multiplier applied to the group's maximum servicing capacity\n(based on UTILIZATION, RATE or CONNECTION).\n\nDefault value is 1, which means the group will serve up to 100%\nof its configured capacity (depending on balancingMode). A\nsetting of 0 means the group is completely drained, offering\n0% of its available Capacity. Valid range is [0.0,1.0].",
                    "type": "number"
                  },
                  "description": {
                    "description": "An optional description of this resource.\nProvide this property when you create the resource.",
                    "type": "string"
                  },
                  "failover": {
                    "description": "This field designates whether this is a failover backend. More\nthan one failover backend can be configured for a given RegionBackendService.",
                    "type": "boolean"
                  },
                  "group": {
                    "description": "Reference to a ComputeInstanceGroup or ComputeNetworkEndpointGroup\nresource. In case of instance group this defines the list of\ninstances that serve traffic. Member virtual machine instances from\neach instance group must live in the same zone as the instance\ngroup itself. No two backends in a backend service are allowed to\nuse same Instance Group resource.\n\nFor Network Endpoint Groups this defines list of endpoints. All\nendpoints of Network Endpoint Group must be hosted on instances\nlocated in the same zone as the Network Endpoint Group.\n\nBackend services cannot mix Instance Group and Network Endpoint\nGroup backends.\n\nWhen the 'load_balancing_scheme' is INTERNAL, only instance groups\nare supported.",
                    "type": "object",
                    "properties": {
                      "instanceGroupRef": {
                        "type": "object",
                        "properties": {
                          "external": {
                            "description": "The selfLink of a ComputeInstanceGroup.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          }
                        }
                      },
                      "networkEndpointGroupRef": {
                        "type": "object",
                        "properties": {
                          "external": {
                            "description": "The selfLink of a ComputeNetworkEndpointGroup.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "maxConnections": {
                    "description": "The max number of simultaneous connections for the group. Can\nbe used with either CONNECTION or UTILIZATION balancing modes.\n\nFor CONNECTION mode, either maxConnections or one\nof maxConnectionsPerInstance or maxConnectionsPerEndpoint,\nas appropriate for group type, must be set.",
                    "type": "integer"
                  },
                  "maxConnectionsPerEndpoint": {
                    "description": "The max number of simultaneous connections that a single backend\nnetwork endpoint can handle. This is used to calculate the\ncapacity of the group. Can be used in either CONNECTION or\nUTILIZATION balancing modes.\n\nFor CONNECTION mode, either\nmaxConnections or maxConnectionsPerEndpoint must be set.",
                    "type": "integer"
                  },
                  "maxConnectionsPerInstance": {
                    "description": "The max number of simultaneous connections that a single\nbackend instance can handle. This is used to calculate the\ncapacity of the group. Can be used in either CONNECTION or\nUTILIZATION balancing modes.\n\nFor CONNECTION mode, either maxConnections or\nmaxConnectionsPerInstance must be set.",
                    "type": "integer"
                  },
                  "maxRate": {
                    "description": "The max requests per second (RPS) of the group.\n\nCan be used with either RATE or UTILIZATION balancing modes,\nbut required if RATE mode. For RATE mode, either maxRate or one\nof maxRatePerInstance or maxRatePerEndpoint, as appropriate for\ngroup type, must be set.",
                    "type": "integer"
                  },
                  "maxRatePerEndpoint": {
                    "description": "The max requests per second (RPS) that a single backend network\nendpoint can handle. This is used to calculate the capacity of\nthe group. Can be used in either balancing mode. For RATE mode,\neither maxRate or maxRatePerEndpoint must be set.",
                    "type": "number"
                  },
                  "maxRatePerInstance": {
                    "description": "The max requests per second (RPS) that a single backend\ninstance can handle. This is used to calculate the capacity of\nthe group. Can be used in either balancing mode. For RATE mode,\neither maxRate or maxRatePerInstance must be set.",
                    "type": "number"
                  },
                  "maxUtilization": {
                    "description": "Used when balancingMode is UTILIZATION. This ratio defines the\nCPU utilization target for the group. Valid range is [0.0, 1.0].",
                    "type": "number"
                  }
                }
              }
            },
            "cdnPolicy": {
              "description": "Cloud CDN configuration for this BackendService.",
              "type": "object",
              "properties": {
                "cacheKeyPolicy": {
                  "description": "The CacheKeyPolicy for this CdnPolicy.",
                  "type": "object",
                  "properties": {
                    "includeHost": {
                      "description": "If true requests to different hosts will be cached separately.",
                      "type": "boolean"
                    },
                    "includeProtocol": {
                      "description": "If true, http and https requests will be cached separately.",
                      "type": "boolean"
                    },
                    "includeQueryString": {
                      "description": "If true, include query string parameters in the cache key\naccording to query_string_whitelist and\nquery_string_blacklist. If neither is set, the entire query\nstring will be included.\n\nIf false, the query string will be excluded from the cache\nkey entirely.",
                      "type": "boolean"
                    },
                    "queryStringBlacklist": {
                      "description": "Names of query string parameters to exclude in cache keys.\n\nAll other parameters will be included. Either specify\nquery_string_whitelist or query_string_blacklist, not both.\n'&' and '=' will be percent encoded and not treated as\ndelimiters.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "queryStringWhitelist": {
                      "description": "Names of query string parameters to include in cache keys.\n\nAll other parameters will be excluded. Either specify\nquery_string_whitelist or query_string_blacklist, not both.\n'&' and '=' will be percent encoded and not treated as\ndelimiters.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                },
                "cacheMode": {
                  "description": "Specifies the cache setting for all responses from this backend.\nThe possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC Possible values: [\"USE_ORIGIN_HEADERS\", \"FORCE_CACHE_ALL\", \"CACHE_ALL_STATIC\"].",
                  "type": "string"
                },
                "clientTtl": {
                  "description": "Specifies the maximum allowed TTL for cached content served by this origin.",
                  "type": "integer"
                },
                "defaultTtl": {
                  "description": "Specifies the default TTL for cached content served by this origin for responses\nthat do not have an existing valid TTL (max-age or s-max-age).",
                  "type": "integer"
                },
                "maxTtl": {
                  "description": "Specifies the maximum allowed TTL for cached content served by this origin.",
                  "type": "integer"
                },
                "negativeCaching": {
                  "description": "Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.",
                  "type": "boolean"
                },
                "negativeCachingPolicy": {
                  "description": "Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.\nOmitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "code": {
                        "description": "The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501\ncan be specified as values, and you cannot specify a status code more than once.",
                        "type": "integer"
                      },
                      "ttl": {
                        "description": "The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s\n(30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.",
                        "type": "integer"
                      }
                    }
                  }
                },
                "serveWhileStale": {
                  "description": "Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.",
                  "type": "integer"
                },
                "signedUrlCacheMaxAgeSec": {
                  "description": "Maximum number of seconds the response to a signed URL request\nwill be considered fresh, defaults to 1hr (3600s). After this\ntime period, the response will be revalidated before\nbeing served.\n\nWhen serving responses to signed URL requests, Cloud CDN will\ninternally behave as though all responses from this backend had a\n\"Cache-Control: public, max-age=[TTL]\" header, regardless of any\nexisting Cache-Control header. The actual headers served in\nresponses will not be altered.",
                  "type": "integer"
                }
              }
            },
            "circuitBreakers": {
              "description": "Settings controlling the volume of connections to a backend service. This field\nis applicable only when the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.",
              "type": "object",
              "properties": {
                "connectTimeout": {
                  "description": "The timeout for new network connections to hosts.",
                  "type": "object",
                  "required": ["seconds"],
                  "properties": {
                    "nanos": {
                      "description": "Span of time that's a fraction of a second at nanosecond\nresolution. Durations less than one second are represented\nwith a 0 seconds field and a positive nanos field. Must\nbe from 0 to 999,999,999 inclusive.",
                      "type": "integer"
                    },
                    "seconds": {
                      "description": "Span of time at a resolution of a second.\nMust be from 0 to 315,576,000,000 inclusive.",
                      "type": "integer"
                    }
                  }
                },
                "maxConnections": {
                  "description": "The maximum number of connections to the backend cluster.\nDefaults to 1024.",
                  "type": "integer"
                },
                "maxPendingRequests": {
                  "description": "The maximum number of pending requests to the backend cluster.\nDefaults to 1024.",
                  "type": "integer"
                },
                "maxRequests": {
                  "description": "The maximum number of parallel requests to the backend cluster.\nDefaults to 1024.",
                  "type": "integer"
                },
                "maxRequestsPerConnection": {
                  "description": "Maximum requests for a single backend connection. This parameter\nis respected by both the HTTP/1.1 and HTTP/2 implementations. If\nnot specified, there is no limit. Setting this parameter to 1\nwill effectively disable keep alive.",
                  "type": "integer"
                },
                "maxRetries": {
                  "description": "The maximum number of parallel retries to the backend cluster.\nDefaults to 3.",
                  "type": "integer"
                }
              }
            },
            "connectionDrainingTimeoutSec": {
              "description": "Time for which instance will be drained (not accept new\nconnections, but still work to finish started).",
              "type": "integer"
            },
            "connectionTrackingPolicy": {
              "description": "Connection Tracking configuration for this BackendService.\nThis is available only for Layer 4 Internal Load Balancing and\nNetwork Load Balancing.",
              "type": "object",
              "properties": {
                "connectionPersistenceOnUnhealthyBackends": {
                  "description": "Specifies connection persistence when backends are unhealthy.\n\nIf set to 'DEFAULT_FOR_PROTOCOL', the existing connections persist on\nunhealthy backends only for connection-oriented protocols (TCP and SCTP)\nand only if the Tracking Mode is PER_CONNECTION (default tracking mode)\nor the Session Affinity is configured for 5-tuple. They do not persist\nfor UDP.\n\nIf set to 'NEVER_PERSIST', after a backend becomes unhealthy, the existing\nconnections on the unhealthy backend are never persisted on the unhealthy\nbackend. They are always diverted to newly selected healthy backends\n(unless all backends are unhealthy).\n\nIf set to 'ALWAYS_PERSIST', existing connections always persist on\nunhealthy backends regardless of protocol and session affinity. It is\ngenerally not recommended to use this mode overriding the default. Default value: \"DEFAULT_FOR_PROTOCOL\" Possible values: [\"DEFAULT_FOR_PROTOCOL\", \"NEVER_PERSIST\", \"ALWAYS_PERSIST\"].",
                  "type": "string"
                },
                "idleTimeoutSec": {
                  "description": "Specifies how long to keep a Connection Tracking entry while there is\nno matching traffic (in seconds). \n\nFor L4 ILB the minimum(default) is 10 minutes and maximum is 16 hours.\n\nFor NLB the minimum(default) is 60 seconds and the maximum is 16 hours.",
                  "type": "integer"
                },
                "trackingMode": {
                  "description": "Specifies the key used for connection tracking. There are two options:\n'PER_CONNECTION': The Connection Tracking is performed as per the\nConnection Key (default Hash Method) for the specific protocol.\n\n'PER_SESSION': The Connection Tracking is performed as per the\nconfigured Session Affinity. It matches the configured Session Affinity. Default value: \"PER_CONNECTION\" Possible values: [\"PER_CONNECTION\", \"PER_SESSION\"].",
                  "type": "string"
                }
              }
            },
            "consistentHash": {
              "description": "Consistent Hash-based load balancing can be used to provide soft session\naffinity based on HTTP headers, cookies or other properties. This load balancing\npolicy is applicable only for HTTP connections. The affinity to a particular\ndestination host will be lost when one or more hosts are added/removed from the\ndestination service. This field specifies parameters that control consistent\nhashing. This field only applies if the load_balancing_scheme is set to\nINTERNAL_SELF_MANAGED. This field is only applicable when locality_lb_policy is\nset to MAGLEV or RING_HASH.",
              "type": "object",
              "properties": {
                "httpCookie": {
                  "description": "Hash is based on HTTP Cookie. This field describes a HTTP cookie\nthat will be used as the hash key for the consistent hash load\nbalancer. If the cookie is not present, it will be generated.\nThis field is applicable if the sessionAffinity is set to HTTP_COOKIE.",
                  "type": "object",
                  "properties": {
                    "name": {
                      "description": "Name of the cookie.",
                      "type": "string"
                    },
                    "path": {
                      "description": "Path to set for the cookie.",
                      "type": "string"
                    },
                    "ttl": {
                      "description": "Lifetime of the cookie.",
                      "type": "object",
                      "required": ["seconds"],
                      "properties": {
                        "nanos": {
                          "description": "Span of time that's a fraction of a second at nanosecond\nresolution. Durations less than one second are represented\nwith a 0 seconds field and a positive nanos field. Must\nbe from 0 to 999,999,999 inclusive.",
                          "type": "integer"
                        },
                        "seconds": {
                          "description": "Span of time at a resolution of a second.\nMust be from 0 to 315,576,000,000 inclusive.",
                          "type": "integer"
                        }
                      }
                    }
                  }
                },
                "httpHeaderName": {
                  "description": "The hash based on the value of the specified header field.\nThis field is applicable if the sessionAffinity is set to HEADER_FIELD.",
                  "type": "string"
                },
                "minimumRingSize": {
                  "description": "The minimum number of virtual nodes to use for the hash ring.\nLarger ring sizes result in more granular load\ndistributions. If the number of hosts in the load balancing pool\nis larger than the ring size, each host will be assigned a single\nvirtual node.\nDefaults to 1024.",
                  "type": "integer"
                }
              }
            },
            "customRequestHeaders": {
              "description": "Headers that the HTTP/S load balancer should add to proxied\nrequests.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "customResponseHeaders": {
              "description": "Headers that the HTTP/S load balancer should add to proxied\nresponses.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "description": {
              "description": "An optional description of this resource.",
              "type": "string"
            },
            "enableCdn": {
              "description": "If true, enable Cloud CDN for this BackendService.",
              "type": "boolean"
            },
            "failoverPolicy": {
              "description": "Policy for failovers.",
              "type": "object",
              "properties": {
                "disableConnectionDrainOnFailover": {
                  "description": "On failover or failback, this field indicates whether connection drain\nwill be honored. Setting this to true has the following effect: connections\nto the old active pool are not drained. Connections to the new active pool\nuse the timeout of 10 min (currently fixed). Setting to false has the\nfollowing effect: both old and new connections will have a drain timeout\nof 10 min.\nThis can be set to true only if the protocol is TCP.\nThe default is false.",
                  "type": "boolean"
                },
                "dropTrafficIfUnhealthy": {
                  "description": "This option is used only when no healthy VMs are detected in the primary\nand backup instance groups. When set to true, traffic is dropped. When\nset to false, new connections are sent across all VMs in the primary group.\nThe default is false.",
                  "type": "boolean"
                },
                "failoverRatio": {
                  "description": "The value of the field must be in [0, 1]. If the ratio of the healthy\nVMs in the primary backend is at or below this number, traffic arriving\nat the load-balanced IP will be directed to the failover backend.\nIn case where 'failoverRatio' is not set or all the VMs in the backup\nbackend are unhealthy, the traffic will be directed back to the primary\nbackend in the \"force\" mode, where traffic will be spread to the healthy\nVMs with the best effort, or to all VMs when no VM is healthy.\nThis field is only used with l4 load balancing.",
                  "type": "number"
                }
              }
            },
            "healthChecks": {
              "type": "array",
              "items": {
                "description": "The health check resources for health checking this\nComputeBackendService. Currently at most one health check can be\nspecified, and a health check is required.",
                "type": "object",
                "properties": {
                  "healthCheckRef": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The selfLink of a ComputeHealthCheck.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  },
                  "httpHealthCheckRef": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The selfLink of a ComputeHTTPHealthCheck.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "iap": {
              "description": "Settings for enabling Cloud Identity Aware Proxy.",
              "type": "object",
              "required": ["oauth2ClientId"],
              "properties": {
                "oauth2ClientId": {
                  "description": "OAuth2 Client ID for IAP.",
                  "type": "string"
                },
                "oauth2ClientSecret": {
                  "description": "OAuth2 Client Secret for IAP.",
                  "type": "object",
                  "properties": {
                    "value": {
                      "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                      "type": "string"
                    },
                    "valueFrom": {
                      "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                      "type": "object",
                      "properties": {
                        "secretKeyRef": {
                          "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                          "type": "object",
                          "required": ["key", "name"],
                          "properties": {
                            "key": {
                              "description": "Key that identifies the value to be extracted.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the Secret to extract a value from.",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "oauth2ClientSecretSha256": {
                  "description": "OAuth2 Client Secret SHA-256 for IAP.",
                  "type": "string"
                }
              }
            },
            "loadBalancingScheme": {
              "description": "Immutable. Indicates whether the backend service will be used with internal or\nexternal load balancing. A backend service created for one type of\nload balancing cannot be used with the other. Default value: \"EXTERNAL\" Possible values: [\"EXTERNAL\", \"INTERNAL_SELF_MANAGED\"].",
              "type": "string"
            },
            "localityLbPolicy": {
              "description": "The load balancing algorithm used within the scope of the locality.\nThe possible values are -\n\n* ROUND_ROBIN - This is a simple policy in which each healthy backend\n                is selected in round robin order.\n\n* LEAST_REQUEST - An O(1) algorithm which selects two random healthy\n                  hosts and picks the host which has fewer active requests.\n\n* RING_HASH - The ring/modulo hash load balancer implements consistent\n              hashing to backends. The algorithm has the property that the\n              addition/removal of a host from a set of N hosts only affects\n              1/N of the requests.\n\n* RANDOM - The load balancer selects a random healthy host.\n\n* ORIGINAL_DESTINATION - Backend host is selected based on the client\n                         connection metadata, i.e., connections are opened\n                         to the same address as the destination address of\n                         the incoming connection before the connection\n                         was redirected to the load balancer.\n\n* MAGLEV - used as a drop in replacement for the ring hash load balancer.\n           Maglev is not as stable as ring hash but has faster table lookup\n           build times and host selection times. For more information about\n           Maglev, refer to https://ai.google/research/pubs/pub44824\n\nThis field is applicable only when the load_balancing_scheme is set to\nINTERNAL_SELF_MANAGED. Possible values: [\"ROUND_ROBIN\", \"LEAST_REQUEST\", \"RING_HASH\", \"RANDOM\", \"ORIGINAL_DESTINATION\", \"MAGLEV\"].",
              "type": "string"
            },
            "location": {
              "description": "Location represents the geographical location of the ComputeBackendService. Specify a region name or \"global\" for global resources. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)",
              "type": "string"
            },
            "logConfig": {
              "description": "This field denotes the logging options for the load balancer traffic served by this backend service.\nIf logging is enabled, logs will be exported to Stackdriver.",
              "type": "object",
              "properties": {
                "enable": {
                  "description": "Whether to enable logging for the load balancer traffic served by this backend service.",
                  "type": "boolean"
                },
                "sampleRate": {
                  "description": "This field can only be specified if logging is enabled for this backend service. The value of\nthe field must be in [0, 1]. This configures the sampling rate of requests to the load balancer\nwhere 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.\nThe default value is 1.0.",
                  "type": "number"
                }
              }
            },
            "networkRef": {
              "description": "The network to which this backend service belongs.  This field can\nonly be specified when the load balancing scheme is set to\nINTERNAL.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "outlierDetection": {
              "description": "Settings controlling eviction of unhealthy hosts from the load balancing pool.\nThis field is applicable only when the load_balancing_scheme is set\nto INTERNAL_SELF_MANAGED.",
              "type": "object",
              "properties": {
                "baseEjectionTime": {
                  "description": "The base time that a host is ejected for. The real time is equal to the base\ntime multiplied by the number of times the host has been ejected. Defaults to\n30000ms or 30s.",
                  "type": "object",
                  "required": ["seconds"],
                  "properties": {
                    "nanos": {
                      "description": "Span of time that's a fraction of a second at nanosecond resolution. Durations\nless than one second are represented with a 0 'seconds' field and a positive\n'nanos' field. Must be from 0 to 999,999,999 inclusive.",
                      "type": "integer"
                    },
                    "seconds": {
                      "description": "Span of time at a resolution of a second. Must be from 0 to 315,576,000,000\ninclusive.",
                      "type": "integer"
                    }
                  }
                },
                "consecutiveErrors": {
                  "description": "Number of errors before a host is ejected from the connection pool. When the\nbackend host is accessed over HTTP, a 5xx return code qualifies as an error.\nDefaults to 5.",
                  "type": "integer"
                },
                "consecutiveGatewayFailure": {
                  "description": "The number of consecutive gateway failures (502, 503, 504 status or connection\nerrors that are mapped to one of those status codes) before a consecutive\ngateway failure ejection occurs. Defaults to 5.",
                  "type": "integer"
                },
                "enforcingConsecutiveErrors": {
                  "description": "The percentage chance that a host will be actually ejected when an outlier\nstatus is detected through consecutive 5xx. This setting can be used to disable\nejection or to ramp it up slowly. Defaults to 100.",
                  "type": "integer"
                },
                "enforcingConsecutiveGatewayFailure": {
                  "description": "The percentage chance that a host will be actually ejected when an outlier\nstatus is detected through consecutive gateway failures. This setting can be\nused to disable ejection or to ramp it up slowly. Defaults to 0.",
                  "type": "integer"
                },
                "enforcingSuccessRate": {
                  "description": "The percentage chance that a host will be actually ejected when an outlier\nstatus is detected through success rate statistics. This setting can be used to\ndisable ejection or to ramp it up slowly. Defaults to 100.",
                  "type": "integer"
                },
                "interval": {
                  "description": "Time interval between ejection sweep analysis. This can result in both new\nejections as well as hosts being returned to service. Defaults to 10 seconds.",
                  "type": "object",
                  "required": ["seconds"],
                  "properties": {
                    "nanos": {
                      "description": "Span of time that's a fraction of a second at nanosecond resolution. Durations\nless than one second are represented with a 0 'seconds' field and a positive\n'nanos' field. Must be from 0 to 999,999,999 inclusive.",
                      "type": "integer"
                    },
                    "seconds": {
                      "description": "Span of time at a resolution of a second. Must be from 0 to 315,576,000,000\ninclusive.",
                      "type": "integer"
                    }
                  }
                },
                "maxEjectionPercent": {
                  "description": "Maximum percentage of hosts in the load balancing pool for the backend service\nthat can be ejected. Defaults to 10%.",
                  "type": "integer"
                },
                "successRateMinimumHosts": {
                  "description": "The number of hosts in a cluster that must have enough request volume to detect\nsuccess rate outliers. If the number of hosts is less than this setting, outlier\ndetection via success rate statistics is not performed for any host in the\ncluster. Defaults to 5.",
                  "type": "integer"
                },
                "successRateRequestVolume": {
                  "description": "The minimum number of total requests that must be collected in one interval (as\ndefined by the interval duration above) to include this host in success rate\nbased outlier detection. If the volume is lower than this setting, outlier\ndetection via success rate statistics is not performed for that host. Defaults\nto 100.",
                  "type": "integer"
                },
                "successRateStdevFactor": {
                  "description": "This factor is used to determine the ejection threshold for success rate outlier\nejection. The ejection threshold is the difference between the mean success\nrate, and the product of this factor and the standard deviation of the mean\nsuccess rate: mean - (stdev * success_rate_stdev_factor). This factor is divided\nby a thousand to get a double. That is, if the desired factor is 1.9, the\nruntime value should be 1900. Defaults to 1900.",
                  "type": "integer"
                }
              }
            },
            "portName": {
              "description": "Name of backend port. The same name should appear in the instance\ngroups referenced by this service. Required when the load balancing\nscheme is EXTERNAL.",
              "type": "string"
            },
            "protocol": {
              "description": "The protocol this BackendService uses to communicate with backends.\nThe default is HTTP. **NOTE**: HTTP2 is only valid for beta HTTP/2 load balancer\ntypes and may result in errors if used with the GA API. Possible values: [\"HTTP\", \"HTTPS\", \"HTTP2\", \"TCP\", \"SSL\", \"GRPC\"].",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "securityPolicyRef": {
              "description": "The security policy associated with this backend service.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeSecurityPolicy.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "securitySettings": {
              "description": "The security settings that apply to this backend service. This field is applicable to either\na regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and\nload_balancing_scheme set to INTERNAL_MANAGED; or a global backend service with the\nload_balancing_scheme set to INTERNAL_SELF_MANAGED.",
              "type": "object",
              "required": ["clientTLSPolicyRef", "subjectAltNames"],
              "properties": {
                "clientTLSPolicyRef": {
                  "description": "ClientTlsPolicy is a resource that specifies how a client should\nauthenticate connections to backends of a service. This resource itself\ndoes not affect configuration unless it is attached to a backend\nservice resource. *ConfigConnector only supports `external`\nreferences for this field.*",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The name of a NetworkSecurityClientTLSPolicy.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "subjectAltNames": {
                  "description": "A list of alternate names to verify the subject identity in the certificate.\nIf specified, the client will verify that the server certificate's subject\nalt name matches one of the specified values.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "sessionAffinity": {
              "description": "Type of session affinity to use. The default is NONE. Session affinity is\nnot applicable if the protocol is UDP. Possible values: [\"NONE\", \"CLIENT_IP\", \"CLIENT_IP_PORT_PROTO\", \"CLIENT_IP_PROTO\", \"GENERATED_COOKIE\", \"HEADER_FIELD\", \"HTTP_COOKIE\"].",
              "type": "string"
            },
            "timeoutSec": {
              "description": "How many seconds to wait for the backend before considering it a\nfailed request. Default is 30 seconds. Valid range is [1, 86400].",
              "type": "integer"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "fingerprint": {
              "description": "Fingerprint of this resource. A hash of the contents stored in this\nobject. This field is used in optimistic locking.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeBackendService",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeBackendServiceList": {
      "description": "ComputeBackendServiceList is a list of ComputeBackendService",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computebackendservices. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeBackendService"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeBackendServiceList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeBackendServiceList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeDisk": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeDisk"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location"],
          "properties": {
            "description": {
              "description": "Immutable. An optional description of this resource. Provide this property when\nyou create the resource.",
              "type": "string"
            },
            "diskEncryptionKey": {
              "description": "Immutable. Encrypts the disk using a customer-supplied encryption key.\n\nAfter you encrypt a disk with a customer-supplied key, you must\nprovide the same key if you use the disk later (e.g. to create a disk\nsnapshot or an image, or to attach the disk to a virtual machine).\n\nCustomer-supplied encryption keys do not protect access to metadata of\nthe disk.\n\nIf you do not provide an encryption key when creating the disk, then\nthe disk will be encrypted using an automatically generated key and\nyou do not need to provide a key to use the disk later.",
              "type": "object",
              "properties": {
                "kmsKeyRef": {
                  "description": "The encryption key used to encrypt the disk. Your project's Compute\nEngine System service account\n('service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com')\nmust have 'roles/cloudkms.cryptoKeyEncrypterDecrypter' to use this\nfeature. See\nhttps://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a KMSCryptoKey.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "kmsKeyServiceAccountRef": {
                  "description": "The service account used for the encryption request for the given KMS key.\nIf absent, the Compute Engine Service Agent service account is used.",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The email of an IAMServiceAccount.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "rawKey": {
                  "description": "Immutable. Specifies a 256-bit customer-supplied encryption key, encoded in\nRFC 4648 base64 to either encrypt or decrypt this resource.",
                  "type": "object",
                  "properties": {
                    "value": {
                      "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                      "type": "string"
                    },
                    "valueFrom": {
                      "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                      "type": "object",
                      "properties": {
                        "secretKeyRef": {
                          "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                          "type": "object",
                          "required": ["key", "name"],
                          "properties": {
                            "key": {
                              "description": "Key that identifies the value to be extracted.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the Secret to extract a value from.",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "sha256": {
                  "description": "The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied\nencryption key that protects this resource.",
                  "type": "string"
                }
              }
            },
            "imageRef": {
              "description": "The image from which to initialize this disk.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeImage.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "interface": {
              "description": "DEPRECATED \u2014 This field is no longer in use, disk interfaces will be automatically determined on attachment. To resolve this issue, remove this field from your config. Immutable. Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI.",
              "type": "string"
            },
            "location": {
              "description": "Location represents the geographical location of the ComputeDisk. Specify a region name or a zone name. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)",
              "type": "string"
            },
            "multiWriter": {
              "description": "Immutable. Indicates whether or not the disk can be read/write attached to more than one instance.",
              "type": "boolean"
            },
            "physicalBlockSizeBytes": {
              "description": "Immutable. Physical block size of the persistent disk, in bytes. If not present\nin a request, a default value is used. Currently supported sizes\nare 4096 and 16384, other sizes may be added in the future.\nIf an unsupported value is requested, the error message will list\nthe supported values for the caller's project.",
              "type": "integer"
            },
            "projectRef": {
              "description": "The project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a Project.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "provisionedIops": {
              "description": "Immutable. Indicates how many IOPS must be provisioned for the disk.",
              "type": "integer"
            },
            "replicaZones": {
              "description": "Immutable. URLs of the zones where the disk should be replicated to.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "resourcePolicies": {
              "type": "array",
              "items": {
                "description": "Resource policies applied to this disk for automatic snapshot creations.",
                "type": "object",
                "properties": {
                  "external": {
                    "description": "The selfLink of a ComputeResourcePolicy.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "size": {
              "description": "Size of the persistent disk, specified in GB. You can specify this\nfield when creating a persistent disk using the 'image' or\n'snapshot' parameter, or specify it alone to create an empty\npersistent disk.\n\nIf you specify this field along with 'image' or 'snapshot',\nthe value must not be less than the size of the image\nor the size of the snapshot.\n\nUpsizing the disk is mutable, but downsizing the disk\nrequires re-creating the resource.",
              "type": "integer"
            },
            "snapshotRef": {
              "description": "The source snapshot used to create this disk.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeSnapshot.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "sourceImageEncryptionKey": {
              "description": "Immutable. The customer-supplied encryption key of the source image. Required if\nthe source image is protected by a customer-supplied encryption key.",
              "type": "object",
              "properties": {
                "kmsKeyRef": {
                  "description": "The encryption key used to encrypt the disk. Your project's Compute\nEngine System service account\n('service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com')\nmust have 'roles/cloudkms.cryptoKeyEncrypterDecrypter' to use this\nfeature. See\nhttps://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a KMSCryptoKey.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "kmsKeyServiceAccountRef": {
                  "description": "The service account used for the encryption request for the given KMS key.\nIf absent, the Compute Engine Service Agent service account is used.",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The email of an IAMServiceAccount.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "rawKey": {
                  "description": "Immutable. Specifies a 256-bit customer-supplied encryption key, encoded in\nRFC 4648 base64 to either encrypt or decrypt this resource.",
                  "type": "string"
                },
                "sha256": {
                  "description": "The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied\nencryption key that protects this resource.",
                  "type": "string"
                }
              }
            },
            "sourceSnapshotEncryptionKey": {
              "description": "Immutable. The customer-supplied encryption key of the source snapshot. Required\nif the source snapshot is protected by a customer-supplied encryption\nkey.",
              "type": "object",
              "properties": {
                "kmsKeyRef": {
                  "description": "The encryption key used to encrypt the disk. Your project's Compute\nEngine System service account\n('service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com')\nmust have 'roles/cloudkms.cryptoKeyEncrypterDecrypter' to use this\nfeature. See\nhttps://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a KMSCryptoKey.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "kmsKeyServiceAccountRef": {
                  "description": "The service account used for the encryption request for the given KMS key.\nIf absent, the Compute Engine Service Agent service account is used.",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The email of an IAMServiceAccount.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "rawKey": {
                  "description": "Immutable. Specifies a 256-bit customer-supplied encryption key, encoded in\nRFC 4648 base64 to either encrypt or decrypt this resource.",
                  "type": "string"
                },
                "sha256": {
                  "description": "The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied\nencryption key that protects this resource.",
                  "type": "string"
                }
              }
            },
            "type": {
              "description": "Immutable. URL of the disk type resource describing which disk type to use to\ncreate the disk. Provide this when creating the disk.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "labelFingerprint": {
              "description": "The fingerprint used for optimistic locking of this resource.  Used\ninternally during updates.",
              "type": "string"
            },
            "lastAttachTimestamp": {
              "description": "Last attach timestamp in RFC3339 text format.",
              "type": "string"
            },
            "lastDetachTimestamp": {
              "description": "Last detach timestamp in RFC3339 text format.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            },
            "sourceImageId": {
              "description": "The ID value of the image used to create this disk. This value\nidentifies the exact image that was used to create this persistent\ndisk. For example, if you created the persistent disk from an image\nthat was later deleted and recreated under the same name, the source\nimage ID would identify the exact version of the image that was used.",
              "type": "string"
            },
            "sourceSnapshotId": {
              "description": "The unique ID of the snapshot used to create this disk. This value\nidentifies the exact snapshot that was used to create this persistent\ndisk. For example, if you created the persistent disk from a snapshot\nthat was later deleted and recreated under the same name, the source\nsnapshot ID would identify the exact version of the snapshot that was\nused.",
              "type": "string"
            },
            "users": {
              "description": "Links to the users of the disk (attached instances) in form:\nproject/zones/zone/instances/instance.",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeDisk",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeDiskList": {
      "description": "ComputeDiskList is a list of ComputeDisk",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computedisks. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeDisk"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeDiskList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeDiskList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeExternalVPNGateway": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeExternalVPNGateway"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "description": {
              "description": "Immutable. An optional description of this resource.",
              "type": "string"
            },
            "interface": {
              "description": "Immutable. A list of interfaces on this external VPN gateway.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "id": {
                    "description": "Immutable. The numeric ID for this interface. Allowed values are based on the redundancy type\nof this external VPN gateway\n* '0 - SINGLE_IP_INTERNALLY_REDUNDANT'\n* '0, 1 - TWO_IPS_REDUNDANCY'\n* '0, 1, 2, 3 - FOUR_IPS_REDUNDANCY'.",
                    "type": "integer"
                  },
                  "ipAddress": {
                    "description": "Immutable. IP address of the interface in the external VPN gateway.\nOnly IPv4 is supported. This IP address can be either from\nyour on-premise gateway or another Cloud provider's VPN gateway,\nit cannot be an IP address from Google Compute Engine.",
                    "type": "string"
                  }
                }
              }
            },
            "redundancyType": {
              "description": "Immutable. Indicates the redundancy type of this external VPN gateway Possible values: [\"FOUR_IPS_REDUNDANCY\", \"SINGLE_IP_INTERNALLY_REDUNDANT\", \"TWO_IPS_REDUNDANCY\"].",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeExternalVPNGateway",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeExternalVPNGatewayList": {
      "description": "ComputeExternalVPNGatewayList is a list of ComputeExternalVPNGateway",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computeexternalvpngateways. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeExternalVPNGateway"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeExternalVPNGatewayList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeExternalVPNGatewayList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeFirewall": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeFirewall"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["networkRef"],
          "properties": {
            "allow": {
              "description": "The list of ALLOW rules specified by this firewall. Each rule\nspecifies a protocol and port-range tuple that describes a permitted\nconnection.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["protocol"],
                "properties": {
                  "ports": {
                    "description": "An optional list of ports to which this rule applies. This field\nis only applicable for UDP or TCP protocol. Each entry must be\neither an integer or a range. If not specified, this rule\napplies to connections through any port.\n\nExample inputs include: [\"22\"], [\"80\",\"443\"], and\n[\"12345-12349\"].",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "protocol": {
                    "description": "The IP protocol to which this rule applies. The protocol type is\nrequired when creating a firewall rule. This value can either be\none of the following well known protocol strings (tcp, udp,\nicmp, esp, ah, sctp, ipip, all), or the IP protocol number.",
                    "type": "string"
                  }
                }
              }
            },
            "deny": {
              "description": "The list of DENY rules specified by this firewall. Each rule specifies\na protocol and port-range tuple that describes a denied connection.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["protocol"],
                "properties": {
                  "ports": {
                    "description": "An optional list of ports to which this rule applies. This field\nis only applicable for UDP or TCP protocol. Each entry must be\neither an integer or a range. If not specified, this rule\napplies to connections through any port.\n\nExample inputs include: [\"22\"], [\"80\",\"443\"], and\n[\"12345-12349\"].",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "protocol": {
                    "description": "The IP protocol to which this rule applies. The protocol type is\nrequired when creating a firewall rule. This value can either be\none of the following well known protocol strings (tcp, udp,\nicmp, esp, ah, sctp, ipip, all), or the IP protocol number.",
                    "type": "string"
                  }
                }
              }
            },
            "description": {
              "description": "An optional description of this resource. Provide this property when\nyou create the resource.",
              "type": "string"
            },
            "destinationRanges": {
              "description": "If destination ranges are specified, the firewall will apply only to\ntraffic that has destination IP address in these ranges. These ranges\nmust be expressed in CIDR format. Only IPv4 is supported.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "direction": {
              "description": "Immutable. Direction of traffic to which this firewall applies; default is\nINGRESS. Note: For INGRESS traffic, it is NOT supported to specify\ndestinationRanges; For EGRESS traffic, it is NOT supported to specify\n'source_ranges' OR 'source_tags'. For INGRESS traffic, one of 'source_ranges',\n'source_tags' or 'source_service_accounts' is required. Possible values: [\"INGRESS\", \"EGRESS\"].",
              "type": "string"
            },
            "disabled": {
              "description": "Denotes whether the firewall rule is disabled, i.e not applied to the\nnetwork it is associated with. When set to true, the firewall rule is\nnot enforced and the network behaves as if it did not exist. If this\nis unspecified, the firewall rule will be enabled.",
              "type": "boolean"
            },
            "enableLogging": {
              "description": "DEPRECATED \u2014 Deprecated in favor of log_config. This field denotes whether to enable logging for a particular firewall rule. If logging is enabled, logs will be exported to Stackdriver.",
              "type": "boolean"
            },
            "logConfig": {
              "description": "This field denotes the logging options for a particular firewall rule.\nIf defined, logging is enabled, and logs will be exported to Cloud Logging.",
              "type": "object",
              "required": ["metadata"],
              "properties": {
                "metadata": {
                  "description": "This field denotes whether to include or exclude metadata for firewall logs. Possible values: [\"EXCLUDE_ALL_METADATA\", \"INCLUDE_ALL_METADATA\"].",
                  "type": "string"
                }
              }
            },
            "networkRef": {
              "description": "The network to attach this firewall to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "priority": {
              "description": "Priority for this rule. This is an integer between 0 and 65535, both\ninclusive. When not specified, the value assumed is 1000. Relative\npriorities determine precedence of conflicting rules. Lower value of\npriority implies higher precedence (eg, a rule with priority 0 has\nhigher precedence than a rule with priority 1). DENY rules take\nprecedence over ALLOW rules having equal priority.",
              "type": "integer"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "sourceRanges": {
              "description": "If source ranges are specified, the firewall will apply only to\ntraffic that has source IP address in these ranges. These ranges must\nbe expressed in CIDR format. One or both of sourceRanges and\nsourceTags may be set. If both properties are set, the firewall will\napply to traffic that has source IP address within sourceRanges OR the\nsource IP that belongs to a tag listed in the sourceTags property. The\nconnection does not need to match both properties for the firewall to\napply. Only IPv4 is supported. For INGRESS traffic, one of 'source_ranges',\n'source_tags' or 'source_service_accounts' is required.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "sourceServiceAccounts": {
              "type": "array",
              "items": {
                "description": "If source service accounts are specified, the firewall will apply only\nto traffic originating from an instance with a service account in this\nlist. Source service accounts cannot be used to control traffic to an\ninstance's external IP address because service accounts are associated\nwith an instance, not an IP address. sourceRanges can be set at the\nsame time as sourceServiceAccounts. If both are set, the firewall will\napply to traffic that has source IP address within sourceRanges OR the\nsource IP belongs to an instance with service account listed in\nsourceServiceAccount. The connection does not need to match both\nproperties for the firewall to apply. sourceServiceAccounts cannot be\nused at the same time as sourceTags or targetTags.",
                "type": "object",
                "properties": {
                  "external": {
                    "description": "The email of an IAMServiceAccount.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "sourceTags": {
              "description": "If source tags are specified, the firewall will apply only to traffic\nwith source IP that belongs to a tag listed in source tags. Source\ntags cannot be used to control traffic to an instance's external IP\naddress. Because tags are associated with an instance, not an IP\naddress. One or both of sourceRanges and sourceTags may be set. If\nboth properties are set, the firewall will apply to traffic that has\nsource IP address within sourceRanges OR the source IP that belongs to\na tag listed in the sourceTags property. The connection does not need\nto match both properties for the firewall to apply. For INGRESS traffic,\none of 'source_ranges', 'source_tags' or 'source_service_accounts' is required.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "targetServiceAccounts": {
              "type": "array",
              "items": {
                "description": "A list of service accounts indicating sets of instances located in the\nnetwork that may make network connections as specified in allowed[].\ntargetServiceAccounts cannot be used at the same time as targetTags or\nsourceTags. If neither targetServiceAccounts nor targetTags are\nspecified, the firewall rule applies to all instances on the specified\nnetwork.",
                "type": "object",
                "properties": {
                  "external": {
                    "description": "The email of an IAMServiceAccount.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "targetTags": {
              "description": "A list of instance tags indicating sets of instances located in the\nnetwork that may make network connections as specified in allowed[].\nIf no targetTags are specified, the firewall rule applies to all\ninstances on the specified network.",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeFirewall",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeFirewallList": {
      "description": "ComputeFirewallList is a list of ComputeFirewall",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computefirewalls. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeFirewall"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeFirewallList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeFirewallList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeFirewallPolicy": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeFirewallPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["shortName"],
          "properties": {
            "description": {
              "description": "An optional description of this resource. Provide this property when you create the resource.",
              "type": "string"
            },
            "folderRef": {
              "description": "The Folder that this resource belongs to. Only one of [folderRef, organizationRef] may be specified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The ID of a Folder in format folders/{folder_id}.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "organizationRef": {
              "description": "The Organization that this resource belongs to. Only one of [folderRef, organizationRef] may be specified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The ID of an Organization in format organizations/{organization_id}.",
                  "type": "string"
                },
                "name": {
                  "description": "[WARNING] Organization not yet supported in Config Connector, use 'external' field to reference existing resources.\nName of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            },
            "shortName": {
              "description": "User-provided name of the Organization firewall policy. The name should be unique in the organization in which the firewall policy is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "fingerprint": {
              "description": "Fingerprint of the resource. This field is used internally during updates of this resource.",
              "type": "string"
            },
            "id": {
              "description": "The unique identifier for the resource. This identifier is defined by the server.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "ruleTupleCount": {
              "description": "Total count of all firewall policy rule tuples. A firewall policy can not exceed a set number of tuples.",
              "type": "integer",
              "format": "int64"
            },
            "selfLink": {
              "description": "Server-defined URL for the resource.",
              "type": "string"
            },
            "selfLinkWithId": {
              "description": "Server-defined URL for this resource with the resource id.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeFirewallPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeFirewallPolicyList": {
      "description": "ComputeFirewallPolicyList is a list of ComputeFirewallPolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computefirewallpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeFirewallPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeFirewallPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeFirewallPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeFirewallPolicyRule": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeFirewallPolicyRule"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": [
            "action",
            "direction",
            "firewallPolicyRef",
            "match",
            "priority"
          ],
          "properties": {
            "action": {
              "description": "The Action to perform when the client connection triggers the rule. Can currently be either \"allow\" or \"deny()\" where valid values for status are 403, 404, and 502.",
              "type": "string"
            },
            "description": {
              "description": "An optional description for this resource.",
              "type": "string"
            },
            "direction": {
              "description": "The direction in which this rule applies. Possible values: INGRESS, EGRESS",
              "type": "string"
            },
            "disabled": {
              "description": "Denotes whether the firewall policy rule is disabled. When set to true, the firewall policy rule is not enforced and traffic behaves as if it did not exist. If this is unspecified, the firewall policy rule will be enabled.",
              "type": "boolean"
            },
            "enableLogging": {
              "description": "Denotes whether to enable logging for a particular rule. If logging is enabled, logs will be exported to the configured export destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you cannot enable logging on \"goto_next\" rules.",
              "type": "boolean"
            },
            "firewallPolicyRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The firewall policy of the resource.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "match": {
              "description": "A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.",
              "type": "object",
              "required": ["layer4Configs"],
              "properties": {
                "destIPRanges": {
                  "description": "CIDR IP address range. Maximum number of destination CIDR IP ranges allowed is 256.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "layer4Configs": {
                  "description": "Pairs of IP protocols and ports that the rule should match.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["ipProtocol"],
                    "properties": {
                      "ipProtocol": {
                        "description": "The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule. This value can either be one of the following well known protocol strings (`tcp`, `udp`, `icmp`, `esp`, `ah`, `ipip`, `sctp`), or the IP protocol number.",
                        "type": "string"
                      },
                      "ports": {
                        "description": "An optional list of ports to which this rule applies. This field is only applicable for UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port. Example inputs include: ``.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "srcIPRanges": {
                  "description": "CIDR IP address range. Maximum number of source CIDR IP ranges allowed is 256.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "priority": {
              "description": "An integer indicating the priority of a rule in the list. The priority must be a positive value between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest prority.",
              "type": "integer",
              "format": "int64"
            },
            "targetResources": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "external": {
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "targetServiceAccounts": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "external": {
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "kind": {
              "description": "Type of the resource. Always `compute#firewallPolicyRule` for firewall policy rules",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "ruleTupleCount": {
              "description": "Calculation of the complexity of a single firewall policy rule.",
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeFirewallPolicyRule",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeFirewallPolicyRuleList": {
      "description": "ComputeFirewallPolicyRuleList is a list of ComputeFirewallPolicyRule",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computefirewallpolicyrules. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeFirewallPolicyRule"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeFirewallPolicyRuleList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeFirewallPolicyRuleList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeForwardingRule": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeForwardingRule"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location"],
          "properties": {
            "allPorts": {
              "description": "Immutable. This field is used along with the `backend_service` field for internal load balancing or with the `target` field for internal TargetInstance. This field cannot be used with `port` or `portRange` fields. When the load balancing scheme is `INTERNAL` and protocol is TCP/UDP, specify this field to allow packets addressed to any ports will be forwarded to the backends configured with this forwarding rule.",
              "type": "boolean"
            },
            "allowGlobalAccess": {
              "description": "This field is used along with the `backend_service` field for internal load balancing or with the `target` field for internal TargetInstance. If the field is set to `TRUE`, clients can access ILB from all regions. Otherwise only allows access from clients in the same region as the internal load balancer.",
              "type": "boolean"
            },
            "backendServiceRef": {
              "description": "A ComputeBackendService to receive the matched traffic. This is\nused only for internal load balancing.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeBackendService.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "description": {
              "description": "Immutable. An optional description of this resource. Provide this property when you create the resource.",
              "type": "string"
            },
            "ipAddress": {
              "description": "The IP address that this forwarding rule is serving on behalf of.\n\nAddresses are restricted based on the forwarding rule's load\nbalancing scheme (EXTERNAL or INTERNAL) and scope (global or\nregional).\n\nWhen the load balancing scheme is EXTERNAL, for global forwarding\nrules, the address must be a global IP, and for regional forwarding\nrules, the address must live in the same region as the forwarding\nrule. If this field is empty, an ephemeral IPv4 address from the\nsame scope (global or regional) will be assigned. A regional\nforwarding rule supports IPv4 only. A global forwarding rule\nsupports either IPv4 or IPv6.\n\nWhen the load balancing scheme is INTERNAL, this can only be an RFC\n1918 IP address belonging to the network/subnet configured for the\nforwarding rule. By default, if this field is empty, an ephemeral\ninternal IP address will be automatically allocated from the IP\nrange of the subnet or network configured for this forwarding rule.",
              "type": "object",
              "properties": {
                "addressRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The address of a ComputeAddress.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "ip": {
                  "type": "string"
                }
              }
            },
            "ipProtocol": {
              "description": "Immutable. The IP protocol to which this rule applies. For protocol forwarding, valid options are `TCP`, `UDP`, `ESP`, `AH`, `SCTP` or `ICMP`. For Internal TCP/UDP Load Balancing, the load balancing scheme is `INTERNAL`, and one of `TCP` or `UDP` are valid. For Traffic Director, the load balancing scheme is `INTERNAL_SELF_MANAGED`, and only `TCP`is valid. For Internal HTTP(S) Load Balancing, the load balancing scheme is `INTERNAL_MANAGED`, and only `TCP` is valid. For HTTP(S), SSL Proxy, and TCP Proxy Load Balancing, the load balancing scheme is `EXTERNAL` and only `TCP` is valid. For Network TCP/UDP Load Balancing, the load balancing scheme is `EXTERNAL`, and one of `TCP` or `UDP` is valid.",
              "type": "string"
            },
            "ipVersion": {
              "description": "Immutable. The IP Version that will be used by this forwarding rule. Valid options are `IPV4` or `IPV6`. This can only be specified for an external global forwarding rule. Possible values: UNSPECIFIED_VERSION, IPV4, IPV6.",
              "type": "string"
            },
            "isMirroringCollector": {
              "description": "Immutable. Indicates whether or not this load balancer can be used as a collector for packet mirroring. To prevent mirroring loops, instances behind this load balancer will not have their traffic mirrored even if a `PacketMirroring` rule applies to them. This can only be set to true for load balancers that have their `loadBalancingScheme` set to `INTERNAL`.",
              "type": "boolean"
            },
            "loadBalancingScheme": {
              "description": "Immutable. Specifies the forwarding rule type.\n\n*   `EXTERNAL` is used for:\n    *   Classic Cloud VPN gateways\n    *   Protocol forwarding to VMs from an external IP address\n    *   The following load balancers: HTTP(S), SSL Proxy, TCP Proxy, and Network TCP/UDP\n*   `INTERNAL` is used for:\n    *   Protocol forwarding to VMs from an internal IP address\n    *   Internal TCP/UDP load balancers\n*   `INTERNAL_MANAGED` is used for:\n    *   Internal HTTP(S) load balancers\n*   `INTERNAL_SELF_MANAGED` is used for:\n    *   Traffic Director\n\nFor more information about forwarding rules, refer to [Forwarding rule concepts](/load-balancing/docs/forwarding-rule-concepts). Possible values: INVALID, INTERNAL, INTERNAL_MANAGED, INTERNAL_SELF_MANAGED, EXTERNAL.",
              "type": "string"
            },
            "location": {
              "description": "Location represents the geographical location of the ComputeForwardingRule. Specify a region name or \"global\" for global resources. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)",
              "type": "string"
            },
            "metadataFilters": {
              "description": "Immutable. Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of [xDS](https://github.com/envoyproxy/data-plane-api/blob/master/XDS_PROTOCOL.md) compliant clients. In their xDS requests to Loadbalancer, xDS clients present [node metadata](https://github.com/envoyproxy/data-plane-api/search?q=%22message+Node%22+in%3A%2Fenvoy%2Fapi%2Fv2%2Fcore%2Fbase.proto&). If a match takes place, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. `TargetHttpProxy`, `UrlMap`) referenced by the `ForwardingRule` will not be visible to those proxies.\n\nFor each `metadataFilter` in this list, if its `filterMatchCriteria` is set to MATCH_ANY, at least one of the `filterLabel`s must match the corresponding label provided in the metadata. If its `filterMatchCriteria` is set to MATCH_ALL, then all of its `filterLabel`s must match with corresponding labels provided in the metadata.\n\n`metadataFilters` specified here will be applifed before those specified in the `UrlMap` that this `ForwardingRule` references.\n\n`metadataFilters` only applies to Loadbalancers that have their loadBalancingScheme set to `INTERNAL_SELF_MANAGED`.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["filterLabels", "filterMatchCriteria"],
                "properties": {
                  "filterLabels": {
                    "description": "Immutable. The list of label value pairs that must match labels in the provided metadata based on `filterMatchCriteria`\n\nThis list must not be empty and can have at the most 64 entries.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": ["name", "value"],
                      "properties": {
                        "name": {
                          "description": "Immutable. Name of metadata label.\n\nThe name can have a maximum length of 1024 characters and must be at least 1 character long.",
                          "type": "string"
                        },
                        "value": {
                          "description": "Immutable. The value of the label must match the specified value.\n\nvalue can have a maximum length of 1024 characters.",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "filterMatchCriteria": {
                    "description": "Immutable. Specifies how individual `filterLabel` matches within the list of `filterLabel`s contribute towards the overall `metadataFilter` match.\n\nSupported values are:\n\n*   MATCH_ANY: At least one of the `filterLabels` must have a matching label in the provided metadata.\n*   MATCH_ALL: All `filterLabels` must have matching labels in the provided metadata. Possible values: NOT_SET, MATCH_ALL, MATCH_ANY.",
                    "type": "string"
                  }
                }
              }
            },
            "networkRef": {
              "description": "This field is not used for external load balancing. For internal\nload balancing, this field identifies the network that the load\nbalanced IP should belong to for this forwarding rule. If this\nfield is not specified, the default network will be used.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "networkTier": {
              "description": "Immutable. This signifies the networking tier used for configuring this load balancer and can only take the following values: `PREMIUM`, `STANDARD`. For regional ForwardingRule, the valid values are `PREMIUM` and `STANDARD`. For GlobalForwardingRule, the valid value is `PREMIUM`. If this field is not specified, it is assumed to be `PREMIUM`. If `IPAddress` is specified, this value must be equal to the networkTier of the Address.",
              "type": "string"
            },
            "portRange": {
              "description": "Immutable. When the load balancing scheme is `EXTERNAL`, `INTERNAL_SELF_MANAGED` and `INTERNAL_MANAGED`, you can specify a `port_range`. Use with a forwarding rule that points to a target proxy or a target pool. Do not use with a forwarding rule that points to a backend service. This field is used along with the `target` field for TargetHttpProxy, TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway, TargetPool, TargetInstance. Applicable only when `IPProtocol` is `TCP`, `UDP`, or `SCTP`, only packets addressed to ports in the specified range will be forwarded to `target`. Forwarding rules with the same `[IPAddress, IPProtocol]` pair must have disjoint port ranges. Some types of forwarding target have constraints on the acceptable ports:\n\n*   TargetHttpProxy: 80, 8080\n*   TargetHttpsProxy: 443\n*   TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222\n*   TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222\n*   TargetVpnGateway: 500, 4500\n\n@pattern: d+(?:-d+)?.",
              "type": "string"
            },
            "ports": {
              "description": "Immutable. This field is used along with the `backend_service` field for internal load balancing. When the load balancing scheme is `INTERNAL`, a list of ports can be configured, for example, ['80'], ['8000','9000']. Only packets addressed to these ports are forwarded to the backends configured with the forwarding rule. If the forwarding rule's loadBalancingScheme is INTERNAL, you can specify ports in one of the following ways: * A list of up to five ports, which can be non-contiguous * Keyword `ALL`, which causes the forwarding rule to forward traffic on any port of the forwarding rule's protocol. @pattern: d+(?:-d+)? For more information, refer to [Port specifications](/load-balancing/docs/forwarding-rule-concepts#port_specifications).",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "serviceLabel": {
              "description": "Immutable. An optional prefix to the service name for this Forwarding Rule. If specified, the prefix is the first label of the fully qualified service name. The label must be 1-63 characters long, and comply with [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Specifically, the label must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash. This field is only used for internal load balancing.",
              "type": "string"
            },
            "subnetworkRef": {
              "description": "The subnetwork that the load balanced IP should belong to for this\nforwarding rule. This field is only used for internal load\nbalancing.\n\nIf the network specified is in auto subnet mode, this field is\noptional. However, if the network is in custom subnet mode, a\nsubnetwork must be specified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a ComputeSubnetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "target": {
              "description": "The target resource to receive the matched traffic. The forwarded\ntraffic must be of a type appropriate to the target object. For\nINTERNAL_SELF_MANAGED load balancing, only HTTP and HTTPS targets\nare valid.",
              "type": "object",
              "properties": {
                "targetGRPCProxyRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a ComputeTargetGRPCProxy.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "targetHTTPProxyRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a ComputeTargetHTTPProxy.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "targetHTTPSProxyRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a ComputeTargetHTTPSProxy.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "targetSSLProxyRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a ComputeTargetSSLProxy.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "targetTCPProxyRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a ComputeTargetTCPProxy.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "targetVPNGatewayRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a ComputeTargetVPNGateway.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "[Output Only] Creation timestamp in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.",
              "type": "string"
            },
            "labelFingerprint": {
              "description": "Used internally during label updates.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "description": "[Output Only] Server-defined URL for the resource.",
              "type": "string"
            },
            "serviceName": {
              "description": "[Output Only] The internal fully qualified service name for this Forwarding Rule. This field is only used for internal load balancing.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeForwardingRule",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeForwardingRuleList": {
      "description": "ComputeForwardingRuleList is a list of ComputeForwardingRule",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computeforwardingrules. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeForwardingRule"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeForwardingRuleList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeForwardingRuleList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeHTTPHealthCheck": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeHTTPHealthCheck"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "checkIntervalSec": {
              "description": "How often (in seconds) to send a health check. The default value is 5\nseconds.",
              "type": "integer"
            },
            "description": {
              "description": "An optional description of this resource. Provide this property when\nyou create the resource.",
              "type": "string"
            },
            "healthyThreshold": {
              "description": "A so-far unhealthy instance will be marked healthy after this many\nconsecutive successes. The default value is 2.",
              "type": "integer"
            },
            "host": {
              "description": "The value of the host header in the HTTP health check request. If\nleft empty (default value), the public IP on behalf of which this\nhealth check is performed will be used.",
              "type": "string"
            },
            "port": {
              "description": "The TCP port number for the HTTP health check request.\nThe default value is 80.",
              "type": "integer"
            },
            "requestPath": {
              "description": "The request path of the HTTP health check request.\nThe default value is /.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "timeoutSec": {
              "description": "How long (in seconds) to wait before claiming failure.\nThe default value is 5 seconds.  It is invalid for timeoutSec to have\ngreater value than checkIntervalSec.",
              "type": "integer"
            },
            "unhealthyThreshold": {
              "description": "A so-far healthy instance will be marked unhealthy after this many\nconsecutive failures. The default value is 2.",
              "type": "integer"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeHTTPHealthCheck",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeHTTPHealthCheckList": {
      "description": "ComputeHTTPHealthCheckList is a list of ComputeHTTPHealthCheck",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computehttphealthchecks. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeHTTPHealthCheck"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeHTTPHealthCheckList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeHTTPHealthCheckList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeHTTPSHealthCheck": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeHTTPSHealthCheck"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "checkIntervalSec": {
              "description": "How often (in seconds) to send a health check. The default value is 5\nseconds.",
              "type": "integer"
            },
            "description": {
              "description": "An optional description of this resource. Provide this property when\nyou create the resource.",
              "type": "string"
            },
            "healthyThreshold": {
              "description": "A so-far unhealthy instance will be marked healthy after this many\nconsecutive successes. The default value is 2.",
              "type": "integer"
            },
            "host": {
              "description": "The value of the host header in the HTTPS health check request. If\nleft empty (default value), the public IP on behalf of which this\nhealth check is performed will be used.",
              "type": "string"
            },
            "port": {
              "description": "The TCP port number for the HTTPS health check request.\nThe default value is 443.",
              "type": "integer"
            },
            "requestPath": {
              "description": "The request path of the HTTPS health check request.\nThe default value is /.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "timeoutSec": {
              "description": "How long (in seconds) to wait before claiming failure.\nThe default value is 5 seconds.  It is invalid for timeoutSec to have\ngreater value than checkIntervalSec.",
              "type": "integer"
            },
            "unhealthyThreshold": {
              "description": "A so-far healthy instance will be marked unhealthy after this many\nconsecutive failures. The default value is 2.",
              "type": "integer"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeHTTPSHealthCheck",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeHTTPSHealthCheckList": {
      "description": "ComputeHTTPSHealthCheckList is a list of ComputeHTTPSHealthCheck",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computehttpshealthchecks. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeHTTPSHealthCheck"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeHTTPSHealthCheckList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeHTTPSHealthCheckList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeHealthCheck": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeHealthCheck"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location"],
          "properties": {
            "checkIntervalSec": {
              "description": "How often (in seconds) to send a health check. The default value is 5\nseconds.",
              "type": "integer"
            },
            "description": {
              "description": "An optional description of this resource. Provide this property when\nyou create the resource.",
              "type": "string"
            },
            "grpcHealthCheck": {
              "description": "A nested object resource.",
              "type": "object",
              "properties": {
                "grpcServiceName": {
                  "description": "The gRPC service name for the health check.\nThe value of grpcServiceName has the following meanings by convention:\n  - Empty serviceName means the overall status of all services at the backend.\n  - Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.\nThe grpcServiceName can only be ASCII.",
                  "type": "string"
                },
                "port": {
                  "description": "The port number for the health check request.\nMust be specified if portName and portSpecification are not set\nor if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.",
                  "type": "integer"
                },
                "portName": {
                  "description": "Port name as defined in InstanceGroup#NamedPort#name. If both port and\nport_name are defined, port takes precedence.",
                  "type": "string"
                },
                "portSpecification": {
                  "description": "Specifies how port is selected for health checking, can be one of the\nfollowing values:\n\n  * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.\n\n  * 'USE_NAMED_PORT': The 'portName' is used for health checking.\n\n  * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each\n  network endpoint is used for health checking. For other backends, the\n  port or named port specified in the Backend Service is used for health\n  checking.\n\nIf not specified, gRPC health check follows behavior specified in 'port' and\n'portName' fields. Possible values: [\"USE_FIXED_PORT\", \"USE_NAMED_PORT\", \"USE_SERVING_PORT\"].",
                  "type": "string"
                }
              }
            },
            "healthyThreshold": {
              "description": "A so-far unhealthy instance will be marked healthy after this many\nconsecutive successes. The default value is 2.",
              "type": "integer"
            },
            "http2HealthCheck": {
              "description": "A nested object resource.",
              "type": "object",
              "properties": {
                "host": {
                  "description": "The value of the host header in the HTTP2 health check request.\nIf left empty (default value), the public IP on behalf of which this health\ncheck is performed will be used.",
                  "type": "string"
                },
                "port": {
                  "description": "The TCP port number for the HTTP2 health check request.\nThe default value is 443.",
                  "type": "integer"
                },
                "portName": {
                  "description": "Port name as defined in InstanceGroup#NamedPort#name. If both port and\nport_name are defined, port takes precedence.",
                  "type": "string"
                },
                "portSpecification": {
                  "description": "Specifies how port is selected for health checking, can be one of the\nfollowing values:\n\n  * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.\n\n  * 'USE_NAMED_PORT': The 'portName' is used for health checking.\n\n  * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each\n  network endpoint is used for health checking. For other backends, the\n  port or named port specified in the Backend Service is used for health\n  checking.\n\nIf not specified, HTTP2 health check follows behavior specified in 'port' and\n'portName' fields. Possible values: [\"USE_FIXED_PORT\", \"USE_NAMED_PORT\", \"USE_SERVING_PORT\"].",
                  "type": "string"
                },
                "proxyHeader": {
                  "description": "Specifies the type of proxy header to append before sending data to the\nbackend. Default value: \"NONE\" Possible values: [\"NONE\", \"PROXY_V1\"].",
                  "type": "string"
                },
                "requestPath": {
                  "description": "The request path of the HTTP2 health check request.\nThe default value is /.",
                  "type": "string"
                },
                "response": {
                  "description": "The bytes to match against the beginning of the response data. If left empty\n(the default value), any response will indicate health. The response data\ncan only be ASCII.",
                  "type": "string"
                }
              }
            },
            "httpHealthCheck": {
              "description": "A nested object resource.",
              "type": "object",
              "properties": {
                "host": {
                  "description": "The value of the host header in the HTTP health check request.\nIf left empty (default value), the public IP on behalf of which this health\ncheck is performed will be used.",
                  "type": "string"
                },
                "port": {
                  "description": "The TCP port number for the HTTP health check request.\nThe default value is 80.",
                  "type": "integer"
                },
                "portName": {
                  "description": "Port name as defined in InstanceGroup#NamedPort#name. If both port and\nport_name are defined, port takes precedence.",
                  "type": "string"
                },
                "portSpecification": {
                  "description": "Specifies how port is selected for health checking, can be one of the\nfollowing values:\n\n  * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.\n\n  * 'USE_NAMED_PORT': The 'portName' is used for health checking.\n\n  * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each\n  network endpoint is used for health checking. For other backends, the\n  port or named port specified in the Backend Service is used for health\n  checking.\n\nIf not specified, HTTP health check follows behavior specified in 'port' and\n'portName' fields. Possible values: [\"USE_FIXED_PORT\", \"USE_NAMED_PORT\", \"USE_SERVING_PORT\"].",
                  "type": "string"
                },
                "proxyHeader": {
                  "description": "Specifies the type of proxy header to append before sending data to the\nbackend. Default value: \"NONE\" Possible values: [\"NONE\", \"PROXY_V1\"].",
                  "type": "string"
                },
                "requestPath": {
                  "description": "The request path of the HTTP health check request.\nThe default value is /.",
                  "type": "string"
                },
                "response": {
                  "description": "The bytes to match against the beginning of the response data. If left empty\n(the default value), any response will indicate health. The response data\ncan only be ASCII.",
                  "type": "string"
                }
              }
            },
            "httpsHealthCheck": {
              "description": "A nested object resource.",
              "type": "object",
              "properties": {
                "host": {
                  "description": "The value of the host header in the HTTPS health check request.\nIf left empty (default value), the public IP on behalf of which this health\ncheck is performed will be used.",
                  "type": "string"
                },
                "port": {
                  "description": "The TCP port number for the HTTPS health check request.\nThe default value is 443.",
                  "type": "integer"
                },
                "portName": {
                  "description": "Port name as defined in InstanceGroup#NamedPort#name. If both port and\nport_name are defined, port takes precedence.",
                  "type": "string"
                },
                "portSpecification": {
                  "description": "Specifies how port is selected for health checking, can be one of the\nfollowing values:\n\n  * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.\n\n  * 'USE_NAMED_PORT': The 'portName' is used for health checking.\n\n  * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each\n  network endpoint is used for health checking. For other backends, the\n  port or named port specified in the Backend Service is used for health\n  checking.\n\nIf not specified, HTTPS health check follows behavior specified in 'port' and\n'portName' fields. Possible values: [\"USE_FIXED_PORT\", \"USE_NAMED_PORT\", \"USE_SERVING_PORT\"].",
                  "type": "string"
                },
                "proxyHeader": {
                  "description": "Specifies the type of proxy header to append before sending data to the\nbackend. Default value: \"NONE\" Possible values: [\"NONE\", \"PROXY_V1\"].",
                  "type": "string"
                },
                "requestPath": {
                  "description": "The request path of the HTTPS health check request.\nThe default value is /.",
                  "type": "string"
                },
                "response": {
                  "description": "The bytes to match against the beginning of the response data. If left empty\n(the default value), any response will indicate health. The response data\ncan only be ASCII.",
                  "type": "string"
                }
              }
            },
            "location": {
              "description": "Location represents the geographical location of the ComputeHealthCheck. Specify a region name or \"global\" for global resources. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)",
              "type": "string"
            },
            "logConfig": {
              "description": "Configure logging on this health check.",
              "type": "object",
              "properties": {
                "enable": {
                  "description": "Indicates whether or not to export logs. This is false by default,\nwhich means no health check logging will be done.",
                  "type": "boolean"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "sslHealthCheck": {
              "description": "A nested object resource.",
              "type": "object",
              "properties": {
                "port": {
                  "description": "The TCP port number for the SSL health check request.\nThe default value is 443.",
                  "type": "integer"
                },
                "portName": {
                  "description": "Port name as defined in InstanceGroup#NamedPort#name. If both port and\nport_name are defined, port takes precedence.",
                  "type": "string"
                },
                "portSpecification": {
                  "description": "Specifies how port is selected for health checking, can be one of the\nfollowing values:\n\n  * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.\n\n  * 'USE_NAMED_PORT': The 'portName' is used for health checking.\n\n  * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each\n  network endpoint is used for health checking. For other backends, the\n  port or named port specified in the Backend Service is used for health\n  checking.\n\nIf not specified, SSL health check follows behavior specified in 'port' and\n'portName' fields. Possible values: [\"USE_FIXED_PORT\", \"USE_NAMED_PORT\", \"USE_SERVING_PORT\"].",
                  "type": "string"
                },
                "proxyHeader": {
                  "description": "Specifies the type of proxy header to append before sending data to the\nbackend. Default value: \"NONE\" Possible values: [\"NONE\", \"PROXY_V1\"].",
                  "type": "string"
                },
                "request": {
                  "description": "The application data to send once the SSL connection has been\nestablished (default value is empty). If both request and response are\nempty, the connection establishment alone will indicate health. The request\ndata can only be ASCII.",
                  "type": "string"
                },
                "response": {
                  "description": "The bytes to match against the beginning of the response data. If left empty\n(the default value), any response will indicate health. The response data\ncan only be ASCII.",
                  "type": "string"
                }
              }
            },
            "tcpHealthCheck": {
              "description": "A nested object resource.",
              "type": "object",
              "properties": {
                "port": {
                  "description": "The TCP port number for the TCP health check request.\nThe default value is 443.",
                  "type": "integer"
                },
                "portName": {
                  "description": "Port name as defined in InstanceGroup#NamedPort#name. If both port and\nport_name are defined, port takes precedence.",
                  "type": "string"
                },
                "portSpecification": {
                  "description": "Specifies how port is selected for health checking, can be one of the\nfollowing values:\n\n  * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.\n\n  * 'USE_NAMED_PORT': The 'portName' is used for health checking.\n\n  * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each\n  network endpoint is used for health checking. For other backends, the\n  port or named port specified in the Backend Service is used for health\n  checking.\n\nIf not specified, TCP health check follows behavior specified in 'port' and\n'portName' fields. Possible values: [\"USE_FIXED_PORT\", \"USE_NAMED_PORT\", \"USE_SERVING_PORT\"].",
                  "type": "string"
                },
                "proxyHeader": {
                  "description": "Specifies the type of proxy header to append before sending data to the\nbackend. Default value: \"NONE\" Possible values: [\"NONE\", \"PROXY_V1\"].",
                  "type": "string"
                },
                "request": {
                  "description": "The application data to send once the TCP connection has been\nestablished (default value is empty). If both request and response are\nempty, the connection establishment alone will indicate health. The request\ndata can only be ASCII.",
                  "type": "string"
                },
                "response": {
                  "description": "The bytes to match against the beginning of the response data. If left empty\n(the default value), any response will indicate health. The response data\ncan only be ASCII.",
                  "type": "string"
                }
              }
            },
            "timeoutSec": {
              "description": "How long (in seconds) to wait before claiming failure.\nThe default value is 5 seconds.  It is invalid for timeoutSec to have\ngreater value than checkIntervalSec.",
              "type": "integer"
            },
            "unhealthyThreshold": {
              "description": "A so-far healthy instance will be marked unhealthy after this many\nconsecutive failures. The default value is 2.",
              "type": "integer"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            },
            "type": {
              "description": "The type of the health check. One of HTTP, HTTPS, TCP, or SSL.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeHealthCheck",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeHealthCheckList": {
      "description": "ComputeHealthCheckList is a list of ComputeHealthCheck",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computehealthchecks. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeHealthCheck"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeHealthCheckList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeHealthCheckList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeImage": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeImage"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "description": {
              "description": "Immutable. An optional description of this resource. Provide this property when\nyou create the resource.",
              "type": "string"
            },
            "diskRef": {
              "description": "The source disk to create this image based on.\nYou must provide either this property or the\nrawDisk.source property but not both to create an image.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeDisk.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "diskSizeGb": {
              "description": "Immutable. Size of the image when restored onto a persistent disk (in GB).",
              "type": "integer"
            },
            "family": {
              "description": "Immutable. The name of the image family to which this image belongs. You can\ncreate disks by specifying an image family instead of a specific\nimage name. The image family always returns its latest image that is\nnot deprecated. The name of the image family must comply with\nRFC1035.",
              "type": "string"
            },
            "guestOsFeatures": {
              "description": "Immutable. A list of features to enable on the guest operating system.\nApplicable only for bootable images.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["type"],
                "properties": {
                  "type": {
                    "description": "Immutable. The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options. Possible values: [\"MULTI_IP_SUBNET\", \"SECURE_BOOT\", \"SEV_CAPABLE\", \"UEFI_COMPATIBLE\", \"VIRTIO_SCSI_MULTIQUEUE\", \"WINDOWS\", \"GVNIC\"].",
                    "type": "string"
                  }
                }
              }
            },
            "licenses": {
              "description": "Immutable. Any applicable license URI.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "rawDisk": {
              "description": "Immutable. The parameters of the raw disk image.",
              "type": "object",
              "required": ["source"],
              "properties": {
                "containerType": {
                  "description": "Immutable. The format used to encode and transmit the block device, which\nshould be TAR. This is just a container and transmission format\nand not a runtime format. Provided by the client when the disk\nimage is created. Default value: \"TAR\" Possible values: [\"TAR\"].",
                  "type": "string"
                },
                "sha1": {
                  "description": "Immutable. An optional SHA1 checksum of the disk image before unpackaging.\nThis is provided by the client when the disk image is created.",
                  "type": "string"
                },
                "source": {
                  "description": "Immutable. The full Google Cloud Storage URL where disk storage is stored\nYou must provide either this property or the sourceDisk property\nbut not both.",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "sourceImageRef": {
              "description": "The source image used to create this image.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeImage.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "sourceSnapshotRef": {
              "description": "The source snapshot used to create this image.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeSnapshot.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "archiveSizeBytes": {
              "description": "Size of the image tar.gz archive stored in Google Cloud Storage (in\nbytes).",
              "type": "integer"
            },
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "labelFingerprint": {
              "description": "The fingerprint used for optimistic locking of this resource. Used\ninternally during updates.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeImage",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeImageList": {
      "description": "ComputeImageList is a list of ComputeImage",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computeimages. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeImage"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeImageList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeImageList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeInstance": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeInstance"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "advancedMachineFeatures": {
              "description": "Controls for advanced machine-related behavior features.",
              "type": "object",
              "properties": {
                "enableNestedVirtualization": {
                  "description": "Whether to enable nested virtualization or not.",
                  "type": "boolean"
                },
                "threadsPerCore": {
                  "description": "The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.",
                  "type": "integer"
                }
              }
            },
            "attachedDisk": {
              "description": "List of disks attached to the instance.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["sourceDiskRef"],
                "properties": {
                  "deviceName": {
                    "description": "Name with which the attached disk is accessible under /dev/disk/by-id/.",
                    "type": "string"
                  },
                  "diskEncryptionKeyRaw": {
                    "description": "A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link and disk_encryption_key_raw may be set.",
                    "type": "object",
                    "properties": {
                      "value": {
                        "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                        "type": "string"
                      },
                      "valueFrom": {
                        "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                        "type": "object",
                        "properties": {
                          "secretKeyRef": {
                            "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                            "type": "object",
                            "required": ["name", "key"],
                            "properties": {
                              "key": {
                                "description": "Key that identifies the value to be extracted.",
                                "type": "string"
                              },
                              "name": {
                                "description": "Name of the Secret to extract a value from.",
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "diskEncryptionKeySha256": {
                    "description": "The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.",
                    "type": "string"
                  },
                  "kmsKeyRef": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The selfLink of a KMSCryptoKey.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  },
                  "mode": {
                    "description": "Read/write mode for the disk. One of \"READ_ONLY\" or \"READ_WRITE\".",
                    "type": "string"
                  },
                  "sourceDiskRef": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The selfLink of a ComputeDisk.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "bootDisk": {
              "description": "Immutable. The boot disk for the instance.",
              "type": "object",
              "properties": {
                "autoDelete": {
                  "description": "Immutable. Whether the disk will be auto-deleted when the instance is deleted.",
                  "type": "boolean"
                },
                "deviceName": {
                  "description": "Immutable. Name with which attached disk will be accessible under /dev/disk/by-id/.",
                  "type": "string"
                },
                "diskEncryptionKeyRaw": {
                  "description": "Immutable. A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link and disk_encryption_key_raw may be set.",
                  "type": "object",
                  "properties": {
                    "value": {
                      "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                      "type": "string"
                    },
                    "valueFrom": {
                      "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                      "type": "object",
                      "properties": {
                        "secretKeyRef": {
                          "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                          "type": "object",
                          "required": ["name", "key"],
                          "properties": {
                            "key": {
                              "description": "Key that identifies the value to be extracted.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the Secret to extract a value from.",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "diskEncryptionKeySha256": {
                  "description": "The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.",
                  "type": "string"
                },
                "initializeParams": {
                  "description": "Immutable. Parameters with which a disk was created alongside the instance.",
                  "type": "object",
                  "properties": {
                    "labels": {
                      "description": "Immutable. A set of key/value label pairs assigned to the disk.",
                      "x-kubernetes-preserve-unknown-fields": true
                    },
                    "size": {
                      "description": "Immutable. The size of the image in gigabytes.",
                      "type": "integer"
                    },
                    "sourceImageRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "The selfLink of a ComputeImage.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    },
                    "type": {
                      "description": "Immutable. The Google Compute Engine disk type. One of pd-standard, pd-ssd or pd-balanced.",
                      "type": "string"
                    }
                  }
                },
                "kmsKeyRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a KMSCryptoKey.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "mode": {
                  "description": "Immutable. Read/write mode for the disk. One of \"READ_ONLY\" or \"READ_WRITE\".",
                  "type": "string"
                },
                "sourceDiskRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a ComputeDisk.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "canIpForward": {
              "description": "Whether sending and receiving of packets with non-matching source or destination IPs is allowed.",
              "type": "boolean"
            },
            "confidentialInstanceConfig": {
              "description": "Immutable. The Confidential VM config being used by the instance.  on_host_maintenance has to be set to TERMINATE or this will fail to create.",
              "type": "object",
              "required": ["enableConfidentialCompute"],
              "properties": {
                "enableConfidentialCompute": {
                  "description": "Defines whether the instance should have confidential compute enabled.",
                  "type": "boolean"
                }
              }
            },
            "deletionProtection": {
              "description": "Whether deletion protection is enabled on this instance.",
              "type": "boolean"
            },
            "description": {
              "description": "Immutable. A brief description of the resource.",
              "type": "string"
            },
            "desiredStatus": {
              "description": "Desired status of the instance. Either \"RUNNING\" or \"TERMINATED\".",
              "type": "string"
            },
            "enableDisplay": {
              "description": "Whether the instance has virtual displays enabled.",
              "type": "boolean"
            },
            "guestAccelerator": {
              "description": "Immutable. List of the type and count of accelerator cards attached to the instance.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["count", "type"],
                "properties": {
                  "count": {
                    "description": "Immutable. The number of the guest accelerator cards exposed to this instance.",
                    "type": "integer"
                  },
                  "type": {
                    "description": "Immutable. The accelerator type resource exposed to this instance. E.g. nvidia-tesla-k80.",
                    "type": "string"
                  }
                }
              }
            },
            "hostname": {
              "description": "Immutable. A custom hostname for the instance. Must be a fully qualified DNS name and RFC-1035-valid. Valid format is a series of labels 1-63 characters long matching the regular expression [a-z]([-a-z0-9]*[a-z0-9]), concatenated with periods. The entire hostname must not exceed 253 characters. Changing this forces a new resource to be created.",
              "type": "string"
            },
            "instanceTemplateRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeInstanceTemplate.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "machineType": {
              "description": "The machine type to create.",
              "type": "string"
            },
            "metadata": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["key", "value"],
                "properties": {
                  "key": {
                    "type": "string"
                  },
                  "value": {
                    "type": "string"
                  }
                }
              }
            },
            "metadataStartupScript": {
              "description": "Immutable. Metadata startup scripts made available within the instance.",
              "type": "string"
            },
            "minCpuPlatform": {
              "description": "The minimum CPU platform specified for the VM instance.",
              "type": "string"
            },
            "networkInterface": {
              "description": "Immutable. The networks attached to the instance.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "accessConfig": {
                    "description": "Access configurations, i.e. IPs via which this instance can be accessed via the Internet.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "natIpRef": {
                          "type": "object",
                          "properties": {
                            "external": {
                              "description": "The address of a ComputeAddress.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                              "type": "string"
                            },
                            "namespace": {
                              "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                              "type": "string"
                            }
                          }
                        },
                        "networkTier": {
                          "description": "The networking tier used for configuring this instance. One of PREMIUM or STANDARD.",
                          "type": "string"
                        },
                        "publicPtrDomainName": {
                          "description": "The DNS domain name for the public PTR record.",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "aliasIpRange": {
                    "description": "An array of alias IP ranges for this network interface.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": ["ipCidrRange"],
                      "properties": {
                        "ipCidrRange": {
                          "description": "The IP CIDR range represented by this alias IP range.",
                          "type": "string"
                        },
                        "subnetworkRangeName": {
                          "description": "The subnetwork secondary range name specifying the secondary range from which to allocate the IP CIDR range for this alias IP range.",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "ipv6AccessConfig": {
                    "description": "An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": ["networkTier"],
                      "properties": {
                        "externalIpv6": {
                          "description": "The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. The field is output only, an IPv6 address from a subnetwork associated with the instance will be allocated dynamically.",
                          "type": "string"
                        },
                        "externalIpv6PrefixLength": {
                          "description": "The prefix length of the external IPv6 range.",
                          "type": "string"
                        },
                        "networkTier": {
                          "description": "The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6.",
                          "type": "string"
                        },
                        "publicPtrDomainName": {
                          "description": "The domain name to be used when creating DNSv6 records for the external IPv6 ranges.",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "ipv6AccessType": {
                    "description": "One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.",
                    "type": "string"
                  },
                  "name": {
                    "description": "The name of the interface.",
                    "type": "string"
                  },
                  "networkIp": {
                    "description": "The private IP address assigned to the instance.",
                    "type": "string"
                  },
                  "networkRef": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The selfLink of a ComputeNetwork.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  },
                  "nicType": {
                    "description": "Immutable. The type of vNIC to be used on this interface. Possible values:GVNIC, VIRTIO_NET.",
                    "type": "string"
                  },
                  "queueCount": {
                    "description": "Immutable. The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.",
                    "type": "integer"
                  },
                  "stackType": {
                    "description": "The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.",
                    "type": "string"
                  },
                  "subnetworkProject": {
                    "description": "The project in which the subnetwork belongs.",
                    "type": "string"
                  },
                  "subnetworkRef": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The selfLink of a ComputeSubnetwork.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "networkPerformanceConfig": {
              "description": "Immutable. Configures network performance settings for the instance. If not specified, the instance will be created with its default network performance configuration.",
              "type": "object",
              "required": ["totalEgressBandwidthTier"],
              "properties": {
                "totalEgressBandwidthTier": {
                  "description": "Immutable. The egress bandwidth tier to enable. Possible values:TIER_1, DEFAULT.",
                  "type": "string"
                }
              }
            },
            "reservationAffinity": {
              "description": "Immutable. Specifies the reservations that this instance can consume from.",
              "type": "object",
              "required": ["type"],
              "properties": {
                "specificReservation": {
                  "description": "Immutable. Specifies the label selector for the reservation to use.",
                  "type": "object",
                  "required": ["key", "values"],
                  "properties": {
                    "key": {
                      "description": "Immutable. Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.",
                      "type": "string"
                    },
                    "values": {
                      "description": "Immutable. Corresponds to the label values of a reservation resource.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                },
                "type": {
                  "description": "Immutable. The type of reservation from which this instance can consume resources.",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "resourcePolicies": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "external": {
                    "description": "The selfLink of a ComputeResourcePolicy.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "scheduling": {
              "description": "The scheduling strategy being used by the instance.",
              "type": "object",
              "properties": {
                "automaticRestart": {
                  "description": "Specifies if the instance should be restarted if it was terminated by Compute Engine (not a user).",
                  "type": "boolean"
                },
                "minNodeCpus": {
                  "type": "integer"
                },
                "nodeAffinities": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "value": {
                        "x-kubernetes-preserve-unknown-fields": true
                      }
                    }
                  }
                },
                "onHostMaintenance": {
                  "description": "Describes maintenance behavior for the instance. One of MIGRATE or TERMINATE,.",
                  "type": "string"
                },
                "preemptible": {
                  "description": "Immutable. Whether the instance is preemptible.",
                  "type": "boolean"
                }
              }
            },
            "scratchDisk": {
              "description": "Immutable. The scratch disks attached to the instance.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["interface"],
                "properties": {
                  "interface": {
                    "description": "The disk interface used for attaching this disk. One of SCSI or NVME.",
                    "type": "string"
                  }
                }
              }
            },
            "serviceAccount": {
              "description": "The service account to attach to the instance.",
              "type": "object",
              "required": ["scopes"],
              "properties": {
                "scopes": {
                  "description": "A list of service scopes.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "serviceAccountRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The email of an IAMServiceAccount.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "shieldedInstanceConfig": {
              "description": "The shielded vm config being used by the instance.",
              "type": "object",
              "properties": {
                "enableIntegrityMonitoring": {
                  "description": "Whether integrity monitoring is enabled for the instance.",
                  "type": "boolean"
                },
                "enableSecureBoot": {
                  "description": "Whether secure boot is enabled for the instance.",
                  "type": "boolean"
                },
                "enableVtpm": {
                  "description": "Whether the instance uses vTPM.",
                  "type": "boolean"
                }
              }
            },
            "tags": {
              "description": "The list of tags attached to the instance.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "zone": {
              "description": "Immutable. The zone of the instance. If self_link is provided, this value is ignored. If neither self_link nor zone are provided, the provider zone is used.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "cpuPlatform": {
              "description": "The CPU platform used by this instance.",
              "type": "string"
            },
            "currentStatus": {
              "description": "Current status of the instance.",
              "type": "string"
            },
            "instanceId": {
              "description": "The server-assigned unique identifier of this instance.",
              "type": "string"
            },
            "labelFingerprint": {
              "description": "The unique fingerprint of the labels.",
              "type": "string"
            },
            "metadataFingerprint": {
              "description": "The unique fingerprint of the metadata.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "description": "The URI of the created resource.",
              "type": "string"
            },
            "tagsFingerprint": {
              "description": "The unique fingerprint of the tags.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeInstance",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeInstanceGroup": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeInstanceGroup"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["zone"],
          "properties": {
            "description": {
              "description": "Immutable. An optional textual description of the instance group.",
              "type": "string"
            },
            "instances": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "external": {
                    "description": "The selfLink of a ComputeInstance.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "namedPort": {
              "description": "The named port configuration.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["name", "port"],
                "properties": {
                  "name": {
                    "description": "The name which the port will be mapped to.",
                    "type": "string"
                  },
                  "port": {
                    "description": "The port number to map the name to.",
                    "type": "integer"
                  }
                }
              }
            },
            "networkRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "zone": {
              "description": "Immutable. The zone that this instance group should be created in.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "description": "The URI of the created resource.",
              "type": "string"
            },
            "size": {
              "description": "The number of instances in the group.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeInstanceGroup",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeInstanceGroupList": {
      "description": "ComputeInstanceGroupList is a list of ComputeInstanceGroup",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computeinstancegroups. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeInstanceGroup"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeInstanceGroupList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeInstanceGroupList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeInstanceGroupManager": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeInstanceGroupManager"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["projectRef"],
          "properties": {
            "autoHealingPolicies": {
              "description": "The autohealing policy for this managed instance group. You can specify only one value.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "healthCheckRef": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The URL for the health check that signals autohealing.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  },
                  "initialDelaySec": {
                    "description": "The number of seconds that the managed instance group waits before it applies autohealing policies to new instances or recently recreated instances. This initial delay allows instances to initialize and run their startup scripts before the instance group determines that they are UNHEALTHY. This prevents the managed instance group from recreating its instances prematurely. This value must be from range [0, 3600].",
                    "type": "integer",
                    "format": "int64"
                  }
                }
              }
            },
            "baseInstanceName": {
              "description": "The base instance name to use for instances in this group. The value must be 1-58 characters long. Instances are named by appending a hyphen and a random four-character string to the base instance name. The base instance name must comply with [RFC1035](https://www.ietf.org/rfc/rfc1035.txt).",
              "type": "string"
            },
            "description": {
              "description": "An optional description of this resource.",
              "type": "string"
            },
            "distributionPolicy": {
              "description": "Policy specifying the intended distribution of managed instances across zones in a regional managed instance group.",
              "type": "object",
              "properties": {
                "targetShape": {
                  "description": "The distribution shape to which the group converges either proactively or on resize events (depending on the value set in `updatePolicy.instanceRedistributionType`). Possible values: TARGET_SHAPE_UNSPECIFIED, ANY, BALANCED, ANY_SINGLE_ZONE",
                  "type": "string"
                },
                "zones": {
                  "description": "Zones where the regional managed instance group will create and manage its instances.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "zone": {
                        "description": "The URL of the [zone](/compute/docs/regions-zones/#available). The zone must exist in the region where the managed instance group is located.",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "failoverAction": {
              "description": "The action to perform in case of zone failure. Only one value is supported, `NO_FAILOVER`. The default is `NO_FAILOVER`. Possible values: UNKNOWN, NO_FAILOVER",
              "type": "string"
            },
            "instanceTemplateRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The URL of the instance template that is specified for this managed instance group. The group uses this template to create all new instances in the managed instance group. The templates for existing instances in the group do not change unless you run `recreateInstances`, run `applyUpdatesToInstances`, or set the group's `updatePolicy.type` to `PROACTIVE`.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "location": {
              "description": "The location of this resource.",
              "type": "string"
            },
            "namedPorts": {
              "description": "Named ports configured for the Instance Groups complementary to this Instance Group Manager.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "description": "The name for this named port. The name must be 1-63 characters long, and comply with [RFC1035](https://www.ietf.org/rfc/rfc1035.txt).",
                    "type": "string"
                  },
                  "port": {
                    "description": "The port number, which can be a value between 1 and 65535.",
                    "type": "integer",
                    "format": "int64"
                  }
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "serviceAccountRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The service account to be used as credentials for all operations performed by the managed instance group on instances. The service accounts needs all permissions required to create and delete instances. By default, the service account: {projectNumber}@cloudservices.gserviceaccount.com is used.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "statefulPolicy": {
              "description": "Stateful configuration for this Instanced Group Manager",
              "type": "object",
              "properties": {
                "preservedState": {
                  "type": "object",
                  "properties": {
                    "disks": {
                      "description": "Disks created on the instances that will be preserved on instance delete, update, etc. This map is keyed with the device names of the disks.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "object",
                        "properties": {
                          "autoDelete": {
                            "description": "These stateful disks will never be deleted during autohealing, update or VM instance recreate operations. This flag is used to configure if the disk should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted. Note: disks attached in READ_ONLY mode cannot be auto-deleted. Possible values: NEVER, ON_PERMANENT_INSTANCE_DELETION",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "targetPools": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "external": {
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "targetSize": {
              "description": "The target number of running instances for this managed instance group. You can reduce this number by using the instanceGroupManager deleteInstances or abandonInstances methods. Resizing the group also changes this number.",
              "type": "integer",
              "format": "int64"
            },
            "updatePolicy": {
              "description": "The update policy for this managed instance group.",
              "type": "object",
              "properties": {
                "instanceRedistributionType": {
                  "description": "The [instance redistribution policy](/compute/docs/instance-groups/regional-migs#proactive_instance_redistribution) for regional managed instance groups. Valid values are: - `PROACTIVE` (default): The group attempts to maintain an even distribution of VM instances across zones in the region. - `NONE`: For non-autoscaled groups, proactive redistribution is disabled.",
                  "type": "string"
                },
                "maxSurge": {
                  "description": "Specifies the intended number of instances to be created from the `instanceTemplate`. The final number of instances created from the template will be equal to: - If expressed as a fixed number, the minimum of either `targetSize.fixed` or `instanceGroupManager.targetSize` is used. - if expressed as a `percent`, the `targetSize` would be `(targetSize.percent/100 * InstanceGroupManager.targetSize)` If there is a remainder, the number is rounded. If unset, this version will update any remaining instances not updated by another `version`. Read [Starting a canary update](/compute/docs/instance-groups/rolling-out-updates-to-managed-instance-groups#starting_a_canary_update) for more information.",
                  "type": "object",
                  "properties": {
                    "fixed": {
                      "description": "Specifies a fixed number of VM instances. This must be a positive integer.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "percent": {
                      "description": "Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify `80` for 80%.",
                      "type": "integer",
                      "format": "int64"
                    }
                  }
                },
                "maxUnavailable": {
                  "description": "Specifies the intended number of instances to be created from the `instanceTemplate`. The final number of instances created from the template will be equal to: - If expressed as a fixed number, the minimum of either `targetSize.fixed` or `instanceGroupManager.targetSize` is used. - if expressed as a `percent`, the `targetSize` would be `(targetSize.percent/100 * InstanceGroupManager.targetSize)` If there is a remainder, the number is rounded. If unset, this version will update any remaining instances not updated by another `version`. Read [Starting a canary update](/compute/docs/instance-groups/rolling-out-updates-to-managed-instance-groups#starting_a_canary_update) for more information.",
                  "type": "object",
                  "properties": {
                    "fixed": {
                      "description": "Specifies a fixed number of VM instances. This must be a positive integer.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "percent": {
                      "description": "Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify `80` for 80%.",
                      "type": "integer",
                      "format": "int64"
                    }
                  }
                },
                "minReadySec": {
                  "description": "Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600].",
                  "type": "integer",
                  "format": "int64"
                },
                "minimalAction": {
                  "description": "Minimal action to be taken on an instance. You can specify either `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `RESTART`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.",
                  "type": "string"
                },
                "mostDisruptiveAllowedAction": {
                  "description": "Most disruptive action that is allowed to be taken on an instance. You can specify either `NONE` to forbid any actions, `REFRESH` to allow actions that do not need instance restart, `RESTART` to allow actions that can be applied without instance replacing or `REPLACE` to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.",
                  "type": "string"
                },
                "replacementMethod": {
                  "description": "What action should be used to replace instances. See minimal_action.REPLACE Possible values: SUBSTITUTE, RECREATE",
                  "type": "string"
                },
                "type": {
                  "description": "The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or `recreateInstances` calls).",
                  "type": "string"
                }
              }
            },
            "versions": {
              "description": "Specifies the instance templates used by this managed instance group to create instances. Each version is defined by an `instanceTemplate` and a `name`. Every version can appear at most once per instance group. This field overrides the top-level `instanceTemplate` field. Read more about the [relationships between these fields](/compute/docs/instance-groups/rolling-out-updates-to-managed-instance-groups#relationship_between_versions_and_instancetemplate_properties_for_a_managed_instance_group). Exactly one `version` must leave the `targetSize` field unset. That version will be applied to all remaining instances. For more information, read about [canary updates](/compute/docs/instance-groups/rolling-out-updates-to-managed-instance-groups#starting_a_canary_update).",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "instanceTemplateRef": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The URL of the instance template that is specified for this managed instance group. The group uses this template to create new instances in the managed instance group until the `targetSize` for this version is reached. The templates for existing instances in the group do not change unless you run `recreateInstances`, run `applyUpdatesToInstances`, or set the group's `updatePolicy.type` to `PROACTIVE`; in those cases, existing instances are updated until the `targetSize` for this version is reached.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  },
                  "name": {
                    "description": "Name of the version. Unique among all versions in the scope of this managed instance group.",
                    "type": "string"
                  },
                  "targetSize": {
                    "description": "Specifies the intended number of instances to be created from the `instanceTemplate`. The final number of instances created from the template will be equal to: - If expressed as a fixed number, the minimum of either `targetSize.fixed` or `instanceGroupManager.targetSize` is used. - if expressed as a `percent`, the `targetSize` would be `(targetSize.percent/100 * InstanceGroupManager.targetSize)` If there is a remainder, the number is rounded. If unset, this version will update any remaining instances not updated by another `version`. Read [Starting a canary update](/compute/docs/instance-groups/rolling-out-updates-to-managed-instance-groups#starting_a_canary_update) for more information.",
                    "type": "object",
                    "properties": {
                      "calculated": {
                        "description": "[Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is `fixed`, then the `calculated` value is equal to the `fixed` value. - If the value is a `percent`, then the `calculated` value is `percent`/100 * `targetSize`. For example, the `calculated` value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded.",
                        "type": "integer",
                        "format": "int64"
                      },
                      "fixed": {
                        "description": "Specifies a fixed number of VM instances. This must be a positive integer.",
                        "type": "integer",
                        "format": "int64"
                      },
                      "percent": {
                        "description": "Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify `80` for 80%.",
                        "type": "integer",
                        "format": "int64"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "The creation timestamp for this managed instance group in \\[RFC3339\\](https://www.ietf.org/rfc/rfc3339.txt) text format.",
              "type": "string"
            },
            "currentActions": {
              "description": "[Output Only] The list of instance actions and the number of instances in this managed instance group that are scheduled for each of those actions.",
              "type": "object",
              "properties": {
                "abandoning": {
                  "description": "[Output Only] The total number of instances in the managed instance group that are scheduled to be abandoned. Abandoning an instance removes it from the managed instance group without deleting it.",
                  "type": "integer",
                  "format": "int64"
                },
                "creating": {
                  "description": "[Output Only] The number of instances in the managed instance group that are scheduled to be created or are currently being created. If the group fails to create any of these instances, it tries again until it creates the instance successfully. If you have disabled creation retries, this field will not be populated; instead, the `creatingWithoutRetries` field will be populated.",
                  "type": "integer",
                  "format": "int64"
                },
                "creatingWithoutRetries": {
                  "description": "[Output Only] The number of instances that the managed instance group will attempt to create. The group attempts to create each instance only once. If the group fails to create any of these instances, it decreases the group's `targetSize` value accordingly.",
                  "type": "integer",
                  "format": "int64"
                },
                "deleting": {
                  "description": "[Output Only] The number of instances in the managed instance group that are scheduled to be deleted or are currently being deleted.",
                  "type": "integer",
                  "format": "int64"
                },
                "none": {
                  "description": "[Output Only] The number of instances in the managed instance group that are running and have no scheduled actions.",
                  "type": "integer",
                  "format": "int64"
                },
                "recreating": {
                  "description": "[Output Only] The number of instances in the managed instance group that are scheduled to be recreated or are currently being being recreated. Recreating an instance deletes the existing root persistent disk and creates a new disk from the image that is defined in the instance template.",
                  "type": "integer",
                  "format": "int64"
                },
                "refreshing": {
                  "description": "[Output Only] The number of instances in the managed instance group that are being reconfigured with properties that do not require a restart or a recreate action. For example, setting or removing target pools for the instance.",
                  "type": "integer",
                  "format": "int64"
                },
                "restarting": {
                  "description": "[Output Only] The number of instances in the managed instance group that are scheduled to be restarted or are currently being restarted.",
                  "type": "integer",
                  "format": "int64"
                },
                "verifying": {
                  "description": "[Output Only] The number of instances in the managed instance group that are being verified. See the `managedInstances[].currentAction` property in the `listManagedInstances` method documentation.",
                  "type": "integer",
                  "format": "int64"
                }
              }
            },
            "fingerprint": {
              "description": "Fingerprint of this resource. This field may be used in optimistic locking. It will be ignored when inserting an InstanceGroupManager. An up-to-date fingerprint must be provided in order to update the InstanceGroupManager, otherwise the request will fail with error `412 conditionNotMet`. To see the latest fingerprint, make a `get()` request to retrieve an InstanceGroupManager.",
              "type": "string"
            },
            "id": {
              "description": "[Output Only] A unique identifier for this resource type. The server generates this identifier.",
              "type": "integer",
              "format": "int64"
            },
            "instanceGroup": {
              "description": "[Output Only] The URL of the Instance Group resource.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "region": {
              "description": "[Output Only] The URL of the [region](/compute/docs/regions-zones/#available) where the managed instance group resides (for regional resources).",
              "type": "string"
            },
            "selfLink": {
              "description": "[Output Only] The URL for this managed instance group. The server defines this URL.",
              "type": "string"
            },
            "status": {
              "description": "[Output Only] The status of this managed instance group.",
              "type": "object",
              "properties": {
                "autoscaler": {
                  "description": "[Output Only] The URL of the [Autoscaler](/compute/docs/autoscaler/) that targets this instance group manager.",
                  "type": "string"
                },
                "isStable": {
                  "description": "[Output Only] A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.",
                  "type": "boolean"
                },
                "stateful": {
                  "description": "[Output Only] Stateful status of the given Instance Group Manager.",
                  "type": "object",
                  "properties": {
                    "hasStatefulConfig": {
                      "description": "[Output Only] A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful config even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.",
                      "type": "boolean"
                    },
                    "isStateful": {
                      "description": "[Output Only] A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful config even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions. This field is deprecated in favor of has_stateful_config.",
                      "type": "boolean"
                    },
                    "perInstanceConfigs": {
                      "description": "[Output Only] Status of per-instance configs on the instance.",
                      "type": "object",
                      "properties": {
                        "allEffective": {
                          "description": "A bit indicating if all of the group's per-instance configs (listed in the output of a listPerInstanceConfigs API call) have status `EFFECTIVE` or there are no per-instance-configs.",
                          "type": "boolean"
                        }
                      }
                    }
                  }
                },
                "versionTarget": {
                  "description": "[Output Only] A status of consistency of Instances' versions with their target version specified by `version` field on Instance Group Manager.",
                  "type": "object",
                  "properties": {
                    "isReached": {
                      "description": "[Output Only] A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by `version` field on Instance Group Manager.",
                      "type": "boolean"
                    }
                  }
                }
              }
            },
            "updatePolicy": {
              "type": "object",
              "properties": {
                "maxSurge": {
                  "type": "object",
                  "properties": {
                    "calculated": {
                      "description": "[Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is `fixed`, then the `calculated` value is equal to the `fixed` value. - If the value is a `percent`, then the `calculated` value is `percent`/100 * `targetSize`. For example, the `calculated` value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded.",
                      "type": "integer",
                      "format": "int64"
                    }
                  }
                },
                "maxUnavailable": {
                  "type": "object",
                  "properties": {
                    "calculated": {
                      "description": "[Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is `fixed`, then the `calculated` value is equal to the `fixed` value. - If the value is a `percent`, then the `calculated` value is `percent`/100 * `targetSize`. For example, the `calculated` value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded.",
                      "type": "integer",
                      "format": "int64"
                    }
                  }
                }
              }
            },
            "zone": {
              "description": "[Output Only] The URL of a [zone](/compute/docs/regions-zones/#available) where the managed instance group is located (for zonal resources).",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeInstanceGroupManager",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeInstanceGroupManagerList": {
      "description": "ComputeInstanceGroupManagerList is a list of ComputeInstanceGroupManager",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computeinstancegroupmanagers. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeInstanceGroupManager"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeInstanceGroupManagerList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeInstanceGroupManagerList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeInstanceList": {
      "description": "ComputeInstanceList is a list of ComputeInstance",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computeinstances. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeInstance"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeInstanceList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeInstanceList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeInstanceTemplate": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeInstanceTemplate"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["disk", "machineType"],
          "properties": {
            "advancedMachineFeatures": {
              "description": "Immutable. Controls for advanced machine-related behavior features.",
              "type": "object",
              "properties": {
                "enableNestedVirtualization": {
                  "description": "Immutable. Whether to enable nested virtualization or not.",
                  "type": "boolean"
                },
                "threadsPerCore": {
                  "description": "Immutable. The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.",
                  "type": "integer"
                }
              }
            },
            "canIpForward": {
              "description": "Immutable. Whether to allow sending and receiving of packets with non-matching source or destination IPs. This defaults to false.",
              "type": "boolean"
            },
            "confidentialInstanceConfig": {
              "description": "Immutable. The Confidential VM config being used by the instance. on_host_maintenance has to be set to TERMINATE or this will fail to create.",
              "type": "object",
              "required": ["enableConfidentialCompute"],
              "properties": {
                "enableConfidentialCompute": {
                  "description": "Immutable. Defines whether the instance should have confidential compute enabled.",
                  "type": "boolean"
                }
              }
            },
            "description": {
              "description": "Immutable. A brief description of this resource.",
              "type": "string"
            },
            "disk": {
              "description": "Immutable. Disks to attach to instances created from this template. This can be specified multiple times for multiple disks.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "autoDelete": {
                    "description": "Immutable. Whether or not the disk should be auto-deleted. This defaults to true.",
                    "type": "boolean"
                  },
                  "boot": {
                    "description": "Immutable. Indicates that this is a boot disk.",
                    "type": "boolean"
                  },
                  "deviceName": {
                    "description": "Immutable. A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance. If not specified, the server chooses a default device name to apply to this disk.",
                    "type": "string"
                  },
                  "diskEncryptionKey": {
                    "description": "Immutable. Encrypts or decrypts a disk using a customer-supplied encryption key.",
                    "type": "object",
                    "required": ["kmsKeyRef"],
                    "properties": {
                      "kmsKeyRef": {
                        "type": "object",
                        "properties": {
                          "external": {
                            "description": "The selfLink of a KMSCryptoKey.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "diskName": {
                    "description": "Immutable. Name of the disk. When not provided, this defaults to the name of the instance.",
                    "type": "string"
                  },
                  "diskSizeGb": {
                    "description": "Immutable. The size of the image in gigabytes. If not specified, it will inherit the size of its base image. For SCRATCH disks, the size must be exactly 375GB.",
                    "type": "integer"
                  },
                  "diskType": {
                    "description": "Immutable. The Google Compute Engine disk type. Can be either \"pd-ssd\", \"local-ssd\", \"pd-balanced\" or \"pd-standard\".",
                    "type": "string"
                  },
                  "interface": {
                    "description": "Immutable. Specifies the disk interface to use for attaching this disk.",
                    "type": "string"
                  },
                  "labels": {
                    "description": "Immutable. A set of key/value label pairs to assign to disks,.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "mode": {
                    "description": "Immutable. The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If you are attaching or creating a boot disk, this must read-write mode.",
                    "type": "string"
                  },
                  "resourcePolicies": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "The selfLink of a ComputeResourcePolicy.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "sourceDiskRef": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The name of a ComputeDisk.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  },
                  "sourceImageRef": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The selfLink of a ComputeImage.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  },
                  "type": {
                    "description": "Immutable. The type of Google Compute Engine disk, can be either \"SCRATCH\" or \"PERSISTENT\".",
                    "type": "string"
                  }
                }
              }
            },
            "enableDisplay": {
              "description": "Immutable. Enable Virtual Displays on this instance. Note: allow_stopping_for_update must be set to true in order to update this field.",
              "type": "boolean"
            },
            "guestAccelerator": {
              "description": "Immutable. List of the type and count of accelerator cards attached to the instance.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["count", "type"],
                "properties": {
                  "count": {
                    "description": "Immutable. The number of the guest accelerator cards exposed to this instance.",
                    "type": "integer"
                  },
                  "type": {
                    "description": "Immutable. The accelerator type resource to expose to this instance. E.g. nvidia-tesla-k80.",
                    "type": "string"
                  }
                }
              }
            },
            "instanceDescription": {
              "description": "Immutable. A description of the instance.",
              "type": "string"
            },
            "machineType": {
              "description": "Immutable. The machine type to create. To create a machine with a custom type (such as extended memory), format the value like custom-VCPUS-MEM_IN_MB like custom-6-20480 for 6 vCPU and 20GB of RAM.",
              "type": "string"
            },
            "metadata": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["key", "value"],
                "properties": {
                  "key": {
                    "type": "string"
                  },
                  "value": {
                    "type": "string"
                  }
                }
              }
            },
            "metadataStartupScript": {
              "description": "Immutable. An alternative to using the startup-script metadata key, mostly to match the compute_instance resource. This replaces the startup-script metadata key on the created instance and thus the two mechanisms are not allowed to be used simultaneously.",
              "type": "string"
            },
            "minCpuPlatform": {
              "description": "Immutable. Specifies a minimum CPU platform. Applicable values are the friendly names of CPU platforms, such as Intel Haswell or Intel Skylake.",
              "type": "string"
            },
            "namePrefix": {
              "description": "Immutable. Creates a unique name beginning with the specified prefix. Conflicts with name.",
              "type": "string"
            },
            "networkInterface": {
              "description": "Immutable. Networks to attach to instances created from this template. This can be specified multiple times for multiple networks.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "accessConfig": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "natIpRef": {
                          "type": "object",
                          "properties": {
                            "external": {
                              "description": "The address of a ComputeAddress.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                              "type": "string"
                            },
                            "namespace": {
                              "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                              "type": "string"
                            }
                          }
                        },
                        "networkTier": {
                          "description": "Immutable. The networking tier used for configuring this instance template. This field can take the following values: PREMIUM or STANDARD. If this field is not specified, it is assumed to be PREMIUM.",
                          "type": "string"
                        },
                        "publicPtrDomainName": {
                          "description": "The DNS domain name for the public PTR record.The DNS domain name for the public PTR record.",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "aliasIpRange": {
                    "description": "Immutable. An array of alias IP ranges for this network interface. Can only be specified for network interfaces on subnet-mode networks.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": ["ipCidrRange"],
                      "properties": {
                        "ipCidrRange": {
                          "description": "Immutable. The IP CIDR range represented by this alias IP range. This IP CIDR range must belong to the specified subnetwork and cannot contain IP addresses reserved by system or used by other network interfaces. At the time of writing only a netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API error.",
                          "type": "string"
                        },
                        "subnetworkRangeName": {
                          "description": "Immutable. The subnetwork secondary range name specifying the secondary range from which to allocate the IP CIDR range for this alias IP range. If left unspecified, the primary range of the subnetwork will be used.",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "ipv6AccessConfig": {
                    "description": "An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": ["networkTier"],
                      "properties": {
                        "externalIpv6": {
                          "description": "The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. The field is output only, an IPv6 address from a subnetwork associated with the instance will be allocated dynamically.",
                          "type": "string"
                        },
                        "externalIpv6PrefixLength": {
                          "description": "The prefix length of the external IPv6 range.",
                          "type": "string"
                        },
                        "networkTier": {
                          "description": "The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6.",
                          "type": "string"
                        },
                        "publicPtrDomainName": {
                          "description": "The domain name to be used when creating DNSv6 records for the external IPv6 ranges.",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "ipv6AccessType": {
                    "description": "One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.",
                    "type": "string"
                  },
                  "name": {
                    "description": "The name of the network_interface.",
                    "type": "string"
                  },
                  "networkIp": {
                    "description": "Immutable. The private IP address to assign to the instance. If empty, the address will be automatically assigned.",
                    "type": "string"
                  },
                  "networkRef": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The selfLink of a ComputeNetwork.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  },
                  "nicType": {
                    "description": "Immutable. The type of vNIC to be used on this interface. Possible values:GVNIC, VIRTIO_NET.",
                    "type": "string"
                  },
                  "queueCount": {
                    "description": "Immutable. The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.",
                    "type": "integer"
                  },
                  "stackType": {
                    "description": "The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.",
                    "type": "string"
                  },
                  "subnetworkProject": {
                    "description": "Immutable. The ID of the project in which the subnetwork belongs. If it is not provided, the provider project is used.",
                    "type": "string"
                  },
                  "subnetworkRef": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The selfLink of a ComputeSubnetwork.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "networkPerformanceConfig": {
              "description": "Immutable. Configures network performance settings for the instance. If not specified, the instance will be created with its default network performance configuration.",
              "type": "object",
              "required": ["totalEgressBandwidthTier"],
              "properties": {
                "totalEgressBandwidthTier": {
                  "description": "Immutable. The egress bandwidth tier to enable. Possible values:TIER_1, DEFAULT.",
                  "type": "string"
                }
              }
            },
            "region": {
              "description": "Immutable. An instance template is a global resource that is not bound to a zone or a region. However, you can still specify some regional resources in an instance template, which restricts the template to the region where that resource resides. For example, a custom subnetwork resource is tied to a specific region. Defaults to the region of the Provider if no value is given.",
              "type": "string"
            },
            "reservationAffinity": {
              "description": "Immutable. Specifies the reservations that this instance can consume from.",
              "type": "object",
              "required": ["type"],
              "properties": {
                "specificReservation": {
                  "description": "Immutable. Specifies the label selector for the reservation to use.",
                  "type": "object",
                  "required": ["key", "values"],
                  "properties": {
                    "key": {
                      "description": "Immutable. Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.",
                      "type": "string"
                    },
                    "values": {
                      "description": "Immutable. Corresponds to the label values of a reservation resource.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                },
                "type": {
                  "description": "Immutable. The type of reservation from which this instance can consume resources.",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "scheduling": {
              "description": "Immutable. The scheduling strategy to use.",
              "type": "object",
              "properties": {
                "automaticRestart": {
                  "description": "Immutable. Specifies whether the instance should be automatically restarted if it is terminated by Compute Engine (not terminated by a user). This defaults to true.",
                  "type": "boolean"
                },
                "minNodeCpus": {
                  "description": "Minimum number of cpus for the instance.",
                  "type": "integer"
                },
                "nodeAffinities": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "value": {
                        "x-kubernetes-preserve-unknown-fields": true
                      }
                    }
                  }
                },
                "onHostMaintenance": {
                  "description": "Immutable. Defines the maintenance behavior for this instance.",
                  "type": "string"
                },
                "preemptible": {
                  "description": "Immutable. Allows instance to be preempted. This defaults to false.",
                  "type": "boolean"
                }
              }
            },
            "serviceAccount": {
              "description": "Immutable. Service account to attach to the instance.",
              "type": "object",
              "required": ["scopes"],
              "properties": {
                "scopes": {
                  "description": "Immutable. A list of service scopes. Both OAuth2 URLs and gcloud short names are supported. To allow full access to all Cloud APIs, use the cloud-platform scope.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "serviceAccountRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The email of an IAMServiceAccount.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "shieldedInstanceConfig": {
              "description": "Immutable. Enable Shielded VM on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Note: shielded_instance_config can only be used with boot images with shielded vm support.",
              "type": "object",
              "properties": {
                "enableIntegrityMonitoring": {
                  "description": "Immutable. Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.",
                  "type": "boolean"
                },
                "enableSecureBoot": {
                  "description": "Immutable. Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.",
                  "type": "boolean"
                },
                "enableVtpm": {
                  "description": "Immutable. Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.",
                  "type": "boolean"
                }
              }
            },
            "tags": {
              "description": "Immutable. Tags to attach to the instance.",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "metadataFingerprint": {
              "description": "The unique fingerprint of the metadata.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "description": "The URI of the created resource.",
              "type": "string"
            },
            "tagsFingerprint": {
              "description": "The unique fingerprint of the tags.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeInstanceTemplate",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeInstanceTemplateList": {
      "description": "ComputeInstanceTemplateList is a list of ComputeInstanceTemplate",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computeinstancetemplates. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeInstanceTemplate"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeInstanceTemplateList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeInstanceTemplateList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeInterconnectAttachment": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeInterconnectAttachment"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["region", "routerRef"],
          "properties": {
            "adminEnabled": {
              "description": "Whether the VLAN attachment is enabled or disabled.  When using\nPARTNER type this will Pre-Activate the interconnect attachment.",
              "type": "boolean"
            },
            "bandwidth": {
              "description": "Provisioned bandwidth capacity for the interconnect attachment.\nFor attachments of type DEDICATED, the user can set the bandwidth.\nFor attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth.\nOutput only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED,\nDefaults to BPS_10G Possible values: [\"BPS_50M\", \"BPS_100M\", \"BPS_200M\", \"BPS_300M\", \"BPS_400M\", \"BPS_500M\", \"BPS_1G\", \"BPS_2G\", \"BPS_5G\", \"BPS_10G\", \"BPS_20G\", \"BPS_50G\"].",
              "type": "string"
            },
            "candidateSubnets": {
              "description": "Immutable. Up to 16 candidate prefixes that can be used to restrict the allocation\nof cloudRouterIpAddress and customerRouterIpAddress for this attachment.\nAll prefixes must be within link-local address space (169.254.0.0/16)\nand must be /29 or shorter (/28, /27, etc). Google will attempt to select\nan unused /29 from the supplied candidate prefix(es). The request will\nfail if all possible /29s are in use on Google's edge. If not supplied,\nGoogle will randomly select an unused /29 from all of link-local space.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "description": {
              "description": "An optional description of this resource.",
              "type": "string"
            },
            "edgeAvailabilityDomain": {
              "description": "Immutable. Desired availability domain for the attachment. Only available for type\nPARTNER, at creation time. For improved reliability, customers should\nconfigure a pair of attachments with one per availability domain. The\nselected availability domain will be provided to the Partner via the\npairing key so that the provisioned circuit will lie in the specified\ndomain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.",
              "type": "string"
            },
            "encryption": {
              "description": "Immutable. Indicates the user-supplied encryption option of this interconnect\nattachment:\n\nNONE is the default value, which means that the attachment carries\nunencrypted traffic. VMs can send traffic to, or receive traffic\nfrom, this type of attachment.\n\nIPSEC indicates that the attachment carries only traffic encrypted by\nan IPsec device such as an HA VPN gateway. VMs cannot directly send\ntraffic to, or receive traffic from, such an attachment. To use\nIPsec-encrypted Cloud Interconnect create the attachment using this\noption.\n\nNot currently available publicly. Default value: \"NONE\" Possible values: [\"NONE\", \"IPSEC\"].",
              "type": "string"
            },
            "interconnect": {
              "description": "Immutable. URL of the underlying Interconnect object that this attachment's\ntraffic will traverse through. Required if type is DEDICATED, must not\nbe set if type is PARTNER.",
              "type": "string"
            },
            "ipsecInternalAddresses": {
              "type": "array",
              "items": {
                "description": "Immutable. The addresses that have been reserved for the\ninterconnect attachment. Used only for interconnect attachment that\nhas the encryption option as IPSEC.\n\nThe addresses must be RFC 1918 IP address ranges. When creating HA\nVPN gateway over the interconnect attachment, if the attachment is\nconfigured to use an RFC 1918 IP address, then the VPN gateway's IP\naddress will be allocated from the IP address range specified\nhere.\n\nFor example, if the HA VPN gateway's interface 0 is paired to this\ninterconnect attachment, then an RFC 1918 IP address for the VPN\ngateway interface 0 will be allocated from the IP address specified\nfor this interconnect attachment.\n\nIf this field is not specified for interconnect attachment that has\nencryption option as IPSEC, later on when creating HA VPN gateway on\nthis interconnect attachment, the HA VPN gateway's IP address will\nbe allocated from regional external IP address pool.",
                "type": "object",
                "properties": {
                  "external": {
                    "description": "The selfLink of a ComputeAddress.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "mtu": {
              "description": "Maximum Transmission Unit (MTU), in bytes, of packets passing through\nthis interconnect attachment. Currently, only 1440 and 1500 are allowed. If not specified, the value will default to 1440.",
              "type": "string"
            },
            "region": {
              "description": "Region where the regional interconnect attachment resides.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "routerRef": {
              "description": "The Cloud Router to be used for dynamic routing. This router must\nbe in the same region as this ComputeInterconnectAttachment. The\nComputeInterconnectAttachment will automatically connect the\ninterconnect to the network & region within which the Cloud Router\nis configured.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeRouter.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "type": {
              "description": "Immutable. The type of InterconnectAttachment you wish to create. Defaults to\nDEDICATED. Possible values: [\"DEDICATED\", \"PARTNER\", \"PARTNER_PROVIDER\"].",
              "type": "string"
            },
            "vlanTag8021q": {
              "description": "Immutable. The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094. When\nusing PARTNER type this will be managed upstream.",
              "type": "integer"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "cloudRouterIpAddress": {
              "description": "IPv4 address + prefix length to be configured on Cloud Router\nInterface for this interconnect attachment.",
              "type": "string"
            },
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "customerRouterIpAddress": {
              "description": "IPv4 address + prefix length to be configured on the customer\nrouter subinterface for this interconnect attachment.",
              "type": "string"
            },
            "googleReferenceId": {
              "description": "Google reference ID, to be used when raising support tickets with\nGoogle or otherwise to debug backend connectivity issues.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "pairingKey": {
              "description": "[Output only for type PARTNER. Not present for DEDICATED]. The opaque\nidentifier of an PARTNER attachment used to initiate provisioning with\na selected partner. Of the form \"XXXXX/region/domain\".",
              "type": "string"
            },
            "partnerAsn": {
              "description": "[Output only for type PARTNER. Not present for DEDICATED]. Optional\nBGP ASN for the router that should be supplied by a layer 3 Partner if\nthey configured BGP on behalf of the customer.",
              "type": "string"
            },
            "privateInterconnectInfo": {
              "description": "Information specific to an InterconnectAttachment. This property\nis populated if the interconnect that this is attached to is of type DEDICATED.",
              "type": "object",
              "properties": {
                "tag8021q": {
                  "description": "802.1q encapsulation tag to be used for traffic between\nGoogle and the customer, going to and from this network and region.",
                  "type": "integer"
                }
              }
            },
            "selfLink": {
              "type": "string"
            },
            "state": {
              "description": "[Output Only] The current state of this attachment's functionality.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeInterconnectAttachment",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeInterconnectAttachmentList": {
      "description": "ComputeInterconnectAttachmentList is a list of ComputeInterconnectAttachment",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computeinterconnectattachments. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeInterconnectAttachment"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeInterconnectAttachmentList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeInterconnectAttachmentList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeNetwork": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeNetwork"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "autoCreateSubnetworks": {
              "description": "Immutable. When set to 'true', the network is created in \"auto subnet mode\" and\nit will create a subnet for each region automatically across the\n'10.128.0.0/9' address range.\n\nWhen set to 'false', the network is created in \"custom subnet mode\" so\nthe user can explicitly connect subnetwork resources.",
              "type": "boolean"
            },
            "deleteDefaultRoutesOnCreate": {
              "type": "boolean"
            },
            "description": {
              "description": "Immutable. An optional description of this resource. The resource must be\nrecreated to modify this field.",
              "type": "string"
            },
            "mtu": {
              "description": "Immutable. Maximum Transmission Unit in bytes. The minimum value for this field is 1460\nand the maximum value is 1500 bytes.",
              "type": "integer"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "routingMode": {
              "description": "The network-wide routing mode to use. If set to 'REGIONAL', this\nnetwork's cloud routers will only advertise routes with subnetworks\nof this network in the same region as the router. If set to 'GLOBAL',\nthis network's cloud routers will advertise routes with all\nsubnetworks of this network, across regions. Possible values: [\"REGIONAL\", \"GLOBAL\"].",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "gatewayIpv4": {
              "description": "The gateway address for default routing out of the network. This value\nis selected by GCP.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeNetwork",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeNetworkEndpointGroup": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeNetworkEndpointGroup"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location", "networkRef"],
          "properties": {
            "defaultPort": {
              "description": "Immutable. The default port used if the port number is not specified in the\nnetwork endpoint.",
              "type": "integer"
            },
            "description": {
              "description": "Immutable. An optional description of this resource. Provide this property when\nyou create the resource.",
              "type": "string"
            },
            "location": {
              "description": "Location represents the geographical location of the ComputeNetworkEndpointGroup. Specify a zone name. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)",
              "type": "string"
            },
            "networkEndpointType": {
              "description": "Immutable. Type of network endpoints in this network endpoint group. Default value: \"GCE_VM_IP_PORT\" Possible values: [\"GCE_VM_IP_PORT\"].",
              "type": "string"
            },
            "networkRef": {
              "description": "The network to which all network endpoints in the NEG belong. Uses\n\"default\" project network if unspecified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "subnetworkRef": {
              "description": "Optional subnetwork to which all network endpoints in the NEG belong.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeSubnetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            },
            "size": {
              "description": "Number of network endpoints in the network endpoint group.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeNetworkEndpointGroup",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeNetworkEndpointGroupList": {
      "description": "ComputeNetworkEndpointGroupList is a list of ComputeNetworkEndpointGroup",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computenetworkendpointgroups. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeNetworkEndpointGroup"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeNetworkEndpointGroupList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeNetworkEndpointGroupList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeNetworkList": {
      "description": "ComputeNetworkList is a list of ComputeNetwork",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computenetworks. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeNetwork"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeNetworkList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeNetworkList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeNetworkPeering": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeNetworkPeering"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["networkRef", "peerNetworkRef"],
          "properties": {
            "exportCustomRoutes": {
              "description": "Whether to export the custom routes to the peer network. Defaults to false.",
              "type": "boolean"
            },
            "exportSubnetRoutesWithPublicIp": {
              "description": "Immutable.",
              "type": "boolean"
            },
            "importCustomRoutes": {
              "description": "Whether to export the custom routes from the peer network. Defaults to false.",
              "type": "boolean"
            },
            "importSubnetRoutesWithPublicIp": {
              "description": "Immutable.",
              "type": "boolean"
            },
            "networkRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "peerNetworkRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "state": {
              "description": "State for the peering, either ACTIVE or INACTIVE. The peering is ACTIVE when there's a matching configuration in the peer network.",
              "type": "string"
            },
            "stateDetails": {
              "description": "Details about the current state of the peering.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeNetworkPeering",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeNetworkPeeringList": {
      "description": "ComputeNetworkPeeringList is a list of ComputeNetworkPeering",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computenetworkpeerings. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeNetworkPeering"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeNetworkPeeringList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeNetworkPeeringList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeNodeGroup": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeNodeGroup"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["nodeTemplateRef", "zone"],
          "properties": {
            "autoscalingPolicy": {
              "description": "Immutable. If you use sole-tenant nodes for your workloads, you can use the node\ngroup autoscaler to automatically manage the sizes of your node groups.",
              "type": "object",
              "properties": {
                "maxNodes": {
                  "description": "Immutable. Maximum size of the node group. Set to a value less than or equal\nto 100 and greater than or equal to min-nodes.",
                  "type": "integer"
                },
                "minNodes": {
                  "description": "Immutable. Minimum size of the node group. Must be less\nthan or equal to max-nodes. The default value is 0.",
                  "type": "integer"
                },
                "mode": {
                  "description": "Immutable. The autoscaling mode. Set to one of the following:\n  - OFF: Disables the autoscaler.\n  - ON: Enables scaling in and scaling out.\n  - ONLY_SCALE_OUT: Enables only scaling out.\n  You must use this mode if your node groups are configured to\n  restart their hosted VMs on minimal servers. Possible values: [\"OFF\", \"ON\", \"ONLY_SCALE_OUT\"].",
                  "type": "string"
                }
              }
            },
            "description": {
              "description": "Immutable. An optional textual description of the resource.",
              "type": "string"
            },
            "initialSize": {
              "description": "Immutable. The initial number of nodes in the node group. One of 'initial_size' or 'size' must be specified.",
              "type": "integer"
            },
            "maintenancePolicy": {
              "description": "Immutable. Specifies how to handle instances when a node in the group undergoes maintenance. Set to one of: DEFAULT, RESTART_IN_PLACE, or MIGRATE_WITHIN_NODE_GROUP. The default value is DEFAULT.",
              "type": "string"
            },
            "maintenanceWindow": {
              "description": "Immutable. contains properties for the timeframe of maintenance.",
              "type": "object",
              "required": ["startTime"],
              "properties": {
                "startTime": {
                  "description": "Immutable. instances.start time of the window. This must be in UTC format that resolves to one of 00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example, both 13:00-5 and 08:00 are valid.",
                  "type": "string"
                }
              }
            },
            "nodeTemplateRef": {
              "description": "The node template to which this node group belongs.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNodeTemplate.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "size": {
              "description": "Immutable. The total number of nodes in the node group. One of 'initial_size' or 'size' must be specified.",
              "type": "integer"
            },
            "zone": {
              "description": "Immutable. Zone where this node group is located.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeNodeGroup",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeNodeGroupList": {
      "description": "ComputeNodeGroupList is a list of ComputeNodeGroup",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computenodegroups. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeNodeGroup"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeNodeGroupList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeNodeGroupList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeNodeTemplate": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeNodeTemplate"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["region"],
          "properties": {
            "cpuOvercommitType": {
              "description": "Immutable. CPU overcommit. Default value: \"NONE\" Possible values: [\"ENABLED\", \"NONE\"].",
              "type": "string"
            },
            "description": {
              "description": "Immutable. An optional textual description of the resource.",
              "type": "string"
            },
            "nodeType": {
              "description": "Immutable. Node type to use for nodes group that are created from this template.\nOnly one of nodeTypeFlexibility and nodeType can be specified.",
              "type": "string"
            },
            "nodeTypeFlexibility": {
              "description": "Immutable. Flexible properties for the desired node type. Node groups that\nuse this node template will create nodes of a type that matches\nthese properties. Only one of nodeTypeFlexibility and nodeType can\nbe specified.",
              "type": "object",
              "properties": {
                "cpus": {
                  "description": "Immutable. Number of virtual CPUs to use.",
                  "type": "string"
                },
                "localSsd": {
                  "description": "Use local SSD.",
                  "type": "string"
                },
                "memory": {
                  "description": "Immutable. Physical memory available to the node, defined in MB.",
                  "type": "string"
                }
              }
            },
            "region": {
              "description": "Immutable. Region where nodes using the node template will be created.\nIf it is not provided, the provider region is used.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "serverBinding": {
              "description": "Immutable. The server binding policy for nodes using this template. Determines\nwhere the nodes should restart following a maintenance event.",
              "type": "object",
              "required": ["type"],
              "properties": {
                "type": {
                  "description": "Immutable. Type of server binding policy. If 'RESTART_NODE_ON_ANY_SERVER',\nnodes using this template will restart on any physical server\nfollowing a maintenance event.\n\nIf 'RESTART_NODE_ON_MINIMAL_SERVER', nodes using this template\nwill restart on the same physical server following a maintenance\nevent, instead of being live migrated to or restarted on a new\nphysical server. This option may be useful if you are using\nsoftware licenses tied to the underlying server characteristics\nsuch as physical sockets or cores, to avoid the need for\nadditional licenses when maintenance occurs. However, VMs on such\nnodes will experience outages while maintenance is applied. Possible values: [\"RESTART_NODE_ON_ANY_SERVER\", \"RESTART_NODE_ON_MINIMAL_SERVERS\"].",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeNodeTemplate",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeNodeTemplateList": {
      "description": "ComputeNodeTemplateList is a list of ComputeNodeTemplate",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computenodetemplates. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeNodeTemplate"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeNodeTemplateList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeNodeTemplateList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputePacketMirroring": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputePacketMirroring"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": [
            "collectorIlb",
            "location",
            "mirroredResources",
            "network",
            "projectRef"
          ],
          "properties": {
            "collectorIlb": {
              "description": "The Forwarding Rule resource of type `loadBalancingScheme=INTERNAL` that will be used as collector for mirrored traffic. The specified forwarding rule must have `isMirroringCollector` set to true.",
              "type": "object",
              "required": ["urlRef"],
              "properties": {
                "urlRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "Resource URL to the forwarding rule representing the ILB configured as destination of the mirrored traffic.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "description": {
              "description": "An optional description of this resource. Provide this property when you create the resource.",
              "type": "string"
            },
            "enable": {
              "description": "Indicates whether or not this packet mirroring takes effect. If set to FALSE, this packet mirroring policy will not be enforced on the network. The default is TRUE.",
              "type": "string"
            },
            "filter": {
              "description": "Filter for mirrored traffic. If unspecified, all traffic is mirrored.",
              "type": "object",
              "properties": {
                "cidrRanges": {
                  "description": "IP CIDR ranges that apply as filter on the source (ingress) or destination (egress) IP in the IP header. Only IPv4 is supported. If no ranges are specified, all traffic that matches the specified IPProtocols is mirrored. If neither cidrRanges nor IPProtocols is specified, all traffic is mirrored.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "direction": {
                  "description": "Direction of traffic to mirror, either INGRESS, EGRESS, or BOTH. The default is BOTH.",
                  "type": "string"
                },
                "ipProtocols": {
                  "description": "Protocols that apply as filter on mirrored traffic. If no protocols are specified, all traffic that matches the specified CIDR ranges is mirrored. If neither cidrRanges nor IPProtocols is specified, all traffic is mirrored.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "mirroredResources": {
              "description": "PacketMirroring mirroredResourceInfos. MirroredResourceInfo specifies a set of mirrored VM instances, subnetworks and/or tags for which traffic from/to all VM instances will be mirrored.",
              "type": "object",
              "properties": {
                "instances": {
                  "description": "A set of virtual machine instances that are being mirrored. They must live in zones contained in the same region as this packetMirroring. Note that this config will apply only to those network interfaces of the Instances that belong to the network specified in this packetMirroring. You may specify a maximum of 50 Instances.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "canonicalUrl": {
                        "description": "Output only. Unique identifier for the instance; defined by the server.",
                        "type": "string"
                      },
                      "urlRef": {
                        "type": "object",
                        "properties": {
                          "external": {
                            "description": "Resource URL to the virtual machine instance which is being mirrored.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                },
                "subnetworks": {
                  "description": "A set of subnetworks for which traffic from/to all VM instances will be mirrored. They must live in the same region as this packetMirroring. You may specify a maximum of 5 subnetworks.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "canonicalUrl": {
                        "description": "Output only. Unique identifier for the subnetwork; defined by the server.",
                        "type": "string"
                      },
                      "urlRef": {
                        "type": "object",
                        "properties": {
                          "external": {
                            "description": "Resource URL to the subnetwork for which traffic from/to all VM instances will be mirrored.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                },
                "tags": {
                  "description": "A set of mirrored tags. Traffic from/to all VM instances that have one or more of these tags will be mirrored.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "network": {
              "description": "Specifies the mirrored VPC network. Only packets in this network will be mirrored. All mirrored VMs should have a NIC in the given network. All mirrored subnetworks should belong to the given network.",
              "type": "object",
              "required": ["urlRef"],
              "properties": {
                "urlRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "URL of the network resource.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "priority": {
              "description": "The priority of applying this configuration. Priority is used to break ties in cases where there is more than one matching rule. In the case of two rules that apply for a given Instance, the one with the lowest-numbered priority value wins. Default value is 1000. Valid range is 0 through 65535.",
              "type": "integer",
              "format": "int64"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "collectorIlb": {
              "type": "object",
              "properties": {
                "canonicalUrl": {
                  "description": "Output only. Unique identifier for the forwarding rule; defined by the server.",
                  "type": "string"
                }
              }
            },
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "id": {
              "description": "Output only. The unique identifier for the resource. This identifier is defined by the server.",
              "type": "integer",
              "format": "int64"
            },
            "network": {
              "type": "object",
              "properties": {
                "canonicalUrl": {
                  "description": "Output only. Unique identifier for the network; defined by the server.",
                  "type": "string"
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "region": {
              "description": "URI of the region where the packetMirroring resides.",
              "type": "string"
            },
            "selfLink": {
              "description": "Server-defined URL for the resource.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputePacketMirroring",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputePacketMirroringList": {
      "description": "ComputePacketMirroringList is a list of ComputePacketMirroring",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computepacketmirrorings. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputePacketMirroring"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputePacketMirroringList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputePacketMirroringList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeProjectMetadata": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeProjectMetadata"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["metadata"],
          "properties": {
            "metadata": {
              "description": "A series of key value pairs.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeProjectMetadata",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeProjectMetadataList": {
      "description": "ComputeProjectMetadataList is a list of ComputeProjectMetadata",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computeprojectmetadatas. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeProjectMetadata"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeProjectMetadataList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeProjectMetadataList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeReservation": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeReservation"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["specificReservation", "zone"],
          "properties": {
            "description": {
              "description": "Immutable. An optional description of this resource.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "specificReservation": {
              "description": "Reservation for instances with specific machine shapes.",
              "type": "object",
              "required": ["count", "instanceProperties"],
              "properties": {
                "count": {
                  "description": "The number of resources that are allocated.",
                  "type": "integer"
                },
                "inUseCount": {
                  "description": "How many instances are in use.",
                  "type": "integer"
                },
                "instanceProperties": {
                  "description": "Immutable. The instance properties for the reservation.",
                  "type": "object",
                  "required": ["machineType"],
                  "properties": {
                    "guestAccelerators": {
                      "description": "Immutable. Guest accelerator type and count.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": ["acceleratorCount", "acceleratorType"],
                        "properties": {
                          "acceleratorCount": {
                            "description": "Immutable. The number of the guest accelerator cards exposed to\nthis instance.",
                            "type": "integer"
                          },
                          "acceleratorType": {
                            "description": "Immutable. The full or partial URL of the accelerator type to\nattach to this instance. For example:\n'projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100'\n\nIf you are creating an instance template, specify only the accelerator name.",
                            "type": "string"
                          }
                        }
                      }
                    },
                    "localSsds": {
                      "description": "Immutable. The amount of local ssd to reserve with each instance. This\nreserves disks of type 'local-ssd'.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": ["diskSizeGb"],
                        "properties": {
                          "diskSizeGb": {
                            "description": "Immutable. The size of the disk in base-2 GB.",
                            "type": "integer"
                          },
                          "interface": {
                            "description": "Immutable. The disk interface to use for attaching this disk. Default value: \"SCSI\" Possible values: [\"SCSI\", \"NVME\"].",
                            "type": "string"
                          }
                        }
                      }
                    },
                    "machineType": {
                      "description": "Immutable. The name of the machine type to reserve.",
                      "type": "string"
                    },
                    "minCpuPlatform": {
                      "description": "Immutable. The minimum CPU platform for the reservation. For example,\n'\"Intel Skylake\"'. See\nthe CPU platform availability reference](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform#availablezones)\nfor information on available CPU platforms.",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "specificReservationRequired": {
              "description": "Immutable. When set to true, only VMs that target this reservation by name can\nconsume this reservation. Otherwise, it can be consumed by VMs with\naffinity for any reservation. Defaults to false.",
              "type": "boolean"
            },
            "zone": {
              "description": "Immutable. The zone where the reservation is made.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "commitment": {
              "description": "Full or partial URL to a parent commitment. This field displays for\nreservations that are tied to a commitment.",
              "type": "string"
            },
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            },
            "status": {
              "description": "The status of the reservation.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeReservation",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeReservationList": {
      "description": "ComputeReservationList is a list of ComputeReservation",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computereservations. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeReservation"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeReservationList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeReservationList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeResourcePolicy": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeResourcePolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["region"],
          "properties": {
            "description": {
              "description": "Immutable. An optional description of this resource. Provide this property when you create the resource.",
              "type": "string"
            },
            "groupPlacementPolicy": {
              "description": "Immutable. Resource policy for instances used for placement configuration.",
              "type": "object",
              "properties": {
                "availabilityDomainCount": {
                  "description": "Immutable. The number of availability domains instances will be spread across. If two instances are in different\navailability domain, they will not be put in the same low latency network.",
                  "type": "integer"
                },
                "collocation": {
                  "description": "Immutable. Collocation specifies whether to place VMs inside the same availability domain on the same low-latency network.\nSpecify 'COLLOCATED' to enable collocation. Can only be specified with 'vm_count'. If compute instances are created\nwith a COLLOCATED policy, then exactly 'vm_count' instances must be created at the same time with the resource policy\nattached. Possible values: [\"COLLOCATED\"].",
                  "type": "string"
                },
                "vmCount": {
                  "description": "Immutable. Number of vms in this placement group.",
                  "type": "integer"
                }
              }
            },
            "instanceSchedulePolicy": {
              "description": "Immutable. Resource policy for scheduling instance operations.",
              "type": "object",
              "required": ["timeZone"],
              "properties": {
                "expirationTime": {
                  "description": "Immutable. The expiration time of the schedule. The timestamp is an RFC3339 string.",
                  "type": "string"
                },
                "startTime": {
                  "description": "Immutable. The start time of the schedule. The timestamp is an RFC3339 string.",
                  "type": "string"
                },
                "timeZone": {
                  "description": "Immutable. Specifies the time zone to be used in interpreting the schedule. The value of this field must be a time zone name\nfrom the tz database: http://en.wikipedia.org/wiki/Tz_database.",
                  "type": "string"
                },
                "vmStartSchedule": {
                  "description": "Immutable. Specifies the schedule for starting instances.",
                  "type": "object",
                  "required": ["schedule"],
                  "properties": {
                    "schedule": {
                      "description": "Immutable. Specifies the frequency for the operation, using the unix-cron format.",
                      "type": "string"
                    }
                  }
                },
                "vmStopSchedule": {
                  "description": "Immutable. Specifies the schedule for stopping instances.",
                  "type": "object",
                  "required": ["schedule"],
                  "properties": {
                    "schedule": {
                      "description": "Immutable. Specifies the frequency for the operation, using the unix-cron format.",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "region": {
              "description": "Immutable. Region where resource policy resides.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "snapshotSchedulePolicy": {
              "description": "Immutable. Policy for creating snapshots of persistent disks.",
              "type": "object",
              "required": ["schedule"],
              "properties": {
                "retentionPolicy": {
                  "description": "Immutable. Retention policy applied to snapshots created by this resource policy.",
                  "type": "object",
                  "required": ["maxRetentionDays"],
                  "properties": {
                    "maxRetentionDays": {
                      "description": "Immutable. Maximum age of the snapshot that is allowed to be kept.",
                      "type": "integer"
                    },
                    "onSourceDiskDelete": {
                      "description": "Immutable. Specifies the behavior to apply to scheduled snapshots when\nthe source disk is deleted. Default value: \"KEEP_AUTO_SNAPSHOTS\" Possible values: [\"KEEP_AUTO_SNAPSHOTS\", \"APPLY_RETENTION_POLICY\"].",
                      "type": "string"
                    }
                  }
                },
                "schedule": {
                  "description": "Immutable. Contains one of an 'hourlySchedule', 'dailySchedule', or 'weeklySchedule'.",
                  "type": "object",
                  "properties": {
                    "dailySchedule": {
                      "description": "Immutable. The policy will execute every nth day at the specified time.",
                      "type": "object",
                      "required": ["daysInCycle", "startTime"],
                      "properties": {
                        "daysInCycle": {
                          "description": "Immutable. The number of days between snapshots.",
                          "type": "integer"
                        },
                        "startTime": {
                          "description": "Immutable. This must be in UTC format that resolves to one of\n00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example,\nboth 13:00-5 and 08:00 are valid.",
                          "type": "string"
                        }
                      }
                    },
                    "hourlySchedule": {
                      "description": "Immutable. The policy will execute every nth hour starting at the specified time.",
                      "type": "object",
                      "required": ["hoursInCycle", "startTime"],
                      "properties": {
                        "hoursInCycle": {
                          "description": "Immutable. The number of hours between snapshots.",
                          "type": "integer"
                        },
                        "startTime": {
                          "description": "Immutable. Time within the window to start the operations.\nIt must be in an hourly format \"HH:MM\",\nwhere HH : [00-23] and MM : [00] GMT.\neg: 21:00.",
                          "type": "string"
                        }
                      }
                    },
                    "weeklySchedule": {
                      "description": "Immutable. Allows specifying a snapshot time for each day of the week.",
                      "type": "object",
                      "required": ["dayOfWeeks"],
                      "properties": {
                        "dayOfWeeks": {
                          "description": "Immutable. May contain up to seven (one for each day of the week) snapshot times.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "required": ["day", "startTime"],
                            "properties": {
                              "day": {
                                "description": "Immutable. The day of the week to create the snapshot. e.g. MONDAY Possible values: [\"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\", \"SATURDAY\", \"SUNDAY\"].",
                                "type": "string"
                              },
                              "startTime": {
                                "description": "Immutable. Time within the window to start the operations.\nIt must be in format \"HH:MM\", where HH : [00-23] and MM : [00-00] GMT.",
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "snapshotProperties": {
                  "description": "Immutable. Properties with which the snapshots are created, such as labels.",
                  "type": "object",
                  "properties": {
                    "guestFlush": {
                      "description": "Immutable. Whether to perform a 'guest aware' snapshot.",
                      "type": "boolean"
                    },
                    "labels": {
                      "description": "Immutable. A set of key-value pairs.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "storageLocations": {
                      "description": "Immutable. Cloud Storage bucket location to store the auto snapshot\n(regional or multi-regional).",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeResourcePolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeResourcePolicyList": {
      "description": "ComputeResourcePolicyList is a list of ComputeResourcePolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computeresourcepolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeResourcePolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeResourcePolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeResourcePolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeRoute": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeRoute"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["destRange", "networkRef"],
          "properties": {
            "description": {
              "description": "Immutable. An optional description of this resource. Provide this property\nwhen you create the resource.",
              "type": "string"
            },
            "destRange": {
              "description": "Immutable. The destination range of outgoing packets that this route applies to.\nOnly IPv4 is supported.",
              "type": "string"
            },
            "networkRef": {
              "description": "The network that this route applies to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "nextHopGateway": {
              "description": "Immutable. URL to a gateway that should handle matching packets.\nCurrently, you can only specify the internet gateway, using a full or\npartial valid URL:\n* 'https://www.googleapis.com/compute/v1/projects/project/global/gateways/default-internet-gateway'\n* 'projects/project/global/gateways/default-internet-gateway'\n* 'global/gateways/default-internet-gateway'\n* The string 'default-internet-gateway'.",
              "type": "string"
            },
            "nextHopILBRef": {
              "description": "A forwarding rule of type loadBalancingScheme=INTERNAL that should\nhandle matching packets.  Note that this can only be used when the\ndestinationRange is a public (non-RFC 1918) IP CIDR range.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeForwardingRule.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "nextHopInstanceRef": {
              "description": "Instance that should handle matching packets.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeInstance.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "nextHopIp": {
              "description": "Immutable. Network IP address of an instance that should handle matching packets.",
              "type": "string"
            },
            "nextHopVPNTunnelRef": {
              "description": "The ComputeVPNTunnel that should handle matching packets",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeVPNTunnel.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "priority": {
              "description": "Immutable. The priority of this route. Priority is used to break ties in cases\nwhere there is more than one matching route of equal prefix length.\n\nIn the case of two routes with equal prefix length, the one with the\nlowest-numbered priority value wins.\n\nDefault value is 1000. Valid range is 0 through 65535.",
              "type": "integer"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "tags": {
              "description": "Immutable. A list of instance tags to which this route applies.",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "nextHopNetwork": {
              "description": "URL to a Network that should handle matching packets.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeRoute",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeRouteList": {
      "description": "ComputeRouteList is a list of ComputeRoute",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computeroutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeRoute"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeRouteList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeRouteList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeRouter": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeRouter"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["networkRef", "region"],
          "properties": {
            "bgp": {
              "description": "BGP information specific to this router.",
              "type": "object",
              "required": ["asn"],
              "properties": {
                "advertiseMode": {
                  "description": "User-specified flag to indicate which mode to use for advertisement. Default value: \"DEFAULT\" Possible values: [\"DEFAULT\", \"CUSTOM\"].",
                  "type": "string"
                },
                "advertisedGroups": {
                  "description": "User-specified list of prefix groups to advertise in custom mode.\nThis field can only be populated if advertiseMode is CUSTOM and\nis advertised to all peers of the router. These groups will be\nadvertised in addition to any specified prefixes. Leave this field\nblank to advertise no custom groups.\n\nThis enum field has the one valid value: ALL_SUBNETS.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "advertisedIpRanges": {
                  "description": "User-specified list of individual IP ranges to advertise in\ncustom mode. This field can only be populated if advertiseMode\nis CUSTOM and is advertised to all peers of the router. These IP\nranges will be advertised in addition to any specified groups.\nLeave this field blank to advertise no custom IP ranges.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["range"],
                    "properties": {
                      "description": {
                        "description": "User-specified description for the IP range.",
                        "type": "string"
                      },
                      "range": {
                        "description": "The IP range to advertise. The value must be a\nCIDR-formatted string.",
                        "type": "string"
                      }
                    }
                  }
                },
                "asn": {
                  "description": "Local BGP Autonomous System Number (ASN). Must be an RFC6996\nprivate ASN, either 16-bit or 32-bit. The value will be fixed for\nthis router resource. All VPN tunnels that link to this router\nwill have the same local ASN.",
                  "type": "integer"
                }
              }
            },
            "description": {
              "description": "An optional description of this resource.",
              "type": "string"
            },
            "encryptedInterconnectRouter": {
              "description": "Immutable. Field to indicate if a router is dedicated to use with encrypted\nInterconnect Attachment (IPsec-encrypted Cloud Interconnect feature).\n\nNot currently available publicly.",
              "type": "boolean"
            },
            "networkRef": {
              "description": "A reference to the network to which this router belongs.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "region": {
              "description": "Immutable. Region where the router resides.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeRouter",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeRouterInterface": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeRouterInterface"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["region", "routerRef"],
          "properties": {
            "interconnectAttachmentRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a ComputeInterconnectAttachment.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "ipRange": {
              "description": "Immutable. IP address and range of the interface. The IP range must be in the RFC3927 link-local IP space. Changing this forces a new interface to be created.",
              "type": "string"
            },
            "region": {
              "description": "Immutable. The region this interface's router sits in. If not specified, the project region will be used. Changing this forces a new interface to be created.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "routerRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a ComputeRouter.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "vpnTunnelRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeVPNTunnel.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeRouterInterface",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeRouterInterfaceList": {
      "description": "ComputeRouterInterfaceList is a list of ComputeRouterInterface",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computerouterinterfaces. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeRouterInterface"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeRouterInterfaceList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeRouterInterfaceList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeRouterList": {
      "description": "ComputeRouterList is a list of ComputeRouter",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computerouters. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeRouter"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeRouterList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeRouterList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeRouterNAT": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeRouterNAT"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": [
            "natIpAllocateOption",
            "region",
            "routerRef",
            "sourceSubnetworkIpRangesToNat"
          ],
          "properties": {
            "drainNatIps": {
              "type": "array",
              "items": {
                "description": "A list of IP resources to be drained. These IPs must be valid\nstatic external IPs that have been assigned to the NAT.",
                "type": "object",
                "properties": {
                  "external": {
                    "description": "The selfLink of a ComputeAddress.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "enableEndpointIndependentMapping": {
              "description": "Specifies if endpoint independent mapping is enabled. This is enabled by default. For more information\nsee the [official documentation](https://cloud.google.com/nat/docs/overview#specs-rfcs).",
              "type": "boolean"
            },
            "icmpIdleTimeoutSec": {
              "description": "Timeout (in seconds) for ICMP connections. Defaults to 30s if not set.",
              "type": "integer"
            },
            "logConfig": {
              "description": "Configuration for logging on NAT.",
              "type": "object",
              "required": ["enable", "filter"],
              "properties": {
                "enable": {
                  "description": "Indicates whether or not to export logs.",
                  "type": "boolean"
                },
                "filter": {
                  "description": "Specifies the desired filtering of logs on this NAT. Possible values: [\"ERRORS_ONLY\", \"TRANSLATIONS_ONLY\", \"ALL\"].",
                  "type": "string"
                }
              }
            },
            "minPortsPerVm": {
              "description": "Minimum number of ports allocated to a VM from this NAT.",
              "type": "integer"
            },
            "natIpAllocateOption": {
              "description": "How external IPs should be allocated for this NAT. Valid values are\n'AUTO_ONLY' for only allowing NAT IPs allocated by Google Cloud\nPlatform, or 'MANUAL_ONLY' for only user-allocated NAT IP addresses. Possible values: [\"MANUAL_ONLY\", \"AUTO_ONLY\"].",
              "type": "string"
            },
            "natIps": {
              "type": "array",
              "items": {
                "description": "NAT IPs. Only valid if natIpAllocateOption is set to MANUAL_ONLY.",
                "type": "object",
                "properties": {
                  "external": {
                    "description": "The selfLink of a ComputeAddress.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "region": {
              "description": "Immutable. Region where the router and NAT reside.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "routerRef": {
              "description": "The Cloud Router in which this NAT will be configured.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a ComputeRouter.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "sourceSubnetworkIpRangesToNat": {
              "description": "How NAT should be configured per Subnetwork.\nIf 'ALL_SUBNETWORKS_ALL_IP_RANGES', all of the\nIP ranges in every Subnetwork are allowed to Nat.\nIf 'ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES', all of the primary IP\nranges in every Subnetwork are allowed to Nat.\n'LIST_OF_SUBNETWORKS': A list of Subnetworks are allowed to Nat\n(specified in the field subnetwork below). Note that if this field\ncontains ALL_SUBNETWORKS_ALL_IP_RANGES or\nALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES, then there should not be any\nother RouterNat section in any Router for this network in this region. Possible values: [\"ALL_SUBNETWORKS_ALL_IP_RANGES\", \"ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES\", \"LIST_OF_SUBNETWORKS\"].",
              "type": "string"
            },
            "subnetwork": {
              "description": "One or more subnetwork NAT configurations. Only used if\n'source_subnetwork_ip_ranges_to_nat' is set to 'LIST_OF_SUBNETWORKS'.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["sourceIpRangesToNat", "subnetworkRef"],
                "properties": {
                  "secondaryIpRangeNames": {
                    "description": "List of the secondary ranges of the subnetwork that are allowed\nto use NAT. This can be populated only if\n'LIST_OF_SECONDARY_IP_RANGES' is one of the values in\nsourceIpRangesToNat.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "sourceIpRangesToNat": {
                    "description": "List of options for which source IPs in the subnetwork\nshould have NAT enabled. Supported values include:\n'ALL_IP_RANGES', 'LIST_OF_SECONDARY_IP_RANGES',\n'PRIMARY_IP_RANGE'.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "subnetworkRef": {
                    "description": "The subnetwork to NAT.",
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The selfLink of a ComputeSubnetwork.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "tcpEstablishedIdleTimeoutSec": {
              "description": "Timeout (in seconds) for TCP established connections.\nDefaults to 1200s if not set.",
              "type": "integer"
            },
            "tcpTransitoryIdleTimeoutSec": {
              "description": "Timeout (in seconds) for TCP transitory connections.\nDefaults to 30s if not set.",
              "type": "integer"
            },
            "udpIdleTimeoutSec": {
              "description": "Timeout (in seconds) for UDP connections. Defaults to 30s if not set.",
              "type": "integer"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeRouterNAT",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeRouterNATList": {
      "description": "ComputeRouterNATList is a list of ComputeRouterNAT",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computerouternats. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeRouterNAT"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeRouterNATList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeRouterNATList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeRouterPeer": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeRouterPeer"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": [
            "peerAsn",
            "peerIpAddress",
            "region",
            "routerInterfaceRef",
            "routerRef"
          ],
          "properties": {
            "advertiseMode": {
              "description": "User-specified flag to indicate which mode to use for advertisement.\nValid values of this enum field are: 'DEFAULT', 'CUSTOM' Default value: \"DEFAULT\" Possible values: [\"DEFAULT\", \"CUSTOM\"].",
              "type": "string"
            },
            "advertisedGroups": {
              "description": "User-specified list of prefix groups to advertise in custom\nmode, which can take one of the following options:\n\n* 'ALL_SUBNETS': Advertises all available subnets, including peer VPC subnets.\n* 'ALL_VPC_SUBNETS': Advertises the router's own VPC subnets.\n* 'ALL_PEER_VPC_SUBNETS': Advertises peer subnets of the router's VPC network.\n\n\nNote that this field can only be populated if advertiseMode is 'CUSTOM'\nand overrides the list defined for the router (in the \"bgp\" message).\nThese groups are advertised in addition to any specified prefixes.\nLeave this field blank to advertise no custom groups.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "advertisedIpRanges": {
              "description": "User-specified list of individual IP ranges to advertise in\ncustom mode. This field can only be populated if advertiseMode\nis 'CUSTOM' and is advertised to all peers of the router. These IP\nranges will be advertised in addition to any specified groups.\nLeave this field blank to advertise no custom IP ranges.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["range"],
                "properties": {
                  "description": {
                    "description": "User-specified description for the IP range.",
                    "type": "string"
                  },
                  "range": {
                    "description": "The IP range to advertise. The value must be a\nCIDR-formatted string.",
                    "type": "string"
                  }
                }
              }
            },
            "advertisedRoutePriority": {
              "description": "The priority of routes advertised to this BGP peer.\nWhere there is more than one matching route of maximum\nlength, the routes with the lowest priority value win.",
              "type": "integer"
            },
            "bfd": {
              "description": "BFD configuration for the BGP peering.",
              "type": "object",
              "required": ["sessionInitializationMode"],
              "properties": {
                "minReceiveInterval": {
                  "description": "The minimum interval, in milliseconds, between BFD control packets\nreceived from the peer router. The actual value is negotiated\nbetween the two routers and is equal to the greater of this value\nand the transmit interval of the other router. If set, this value\nmust be between 1000 and 30000.",
                  "type": "integer"
                },
                "minTransmitInterval": {
                  "description": "The minimum interval, in milliseconds, between BFD control packets\ntransmitted to the peer router. The actual value is negotiated\nbetween the two routers and is equal to the greater of this value\nand the corresponding receive interval of the other router. If set,\nthis value must be between 1000 and 30000.",
                  "type": "integer"
                },
                "multiplier": {
                  "description": "The number of consecutive BFD packets that must be missed before\nBFD declares that a peer is unavailable. If set, the value must\nbe a value between 5 and 16.",
                  "type": "integer"
                },
                "sessionInitializationMode": {
                  "description": "The BFD session initialization mode for this BGP peer.\nIf set to 'ACTIVE', the Cloud Router will initiate the BFD session\nfor this BGP peer. If set to 'PASSIVE', the Cloud Router will wait\nfor the peer router to initiate the BFD session for this BGP peer.\nIf set to 'DISABLED', BFD is disabled for this BGP peer. Possible values: [\"ACTIVE\", \"DISABLED\", \"PASSIVE\"].",
                  "type": "string"
                }
              }
            },
            "enable": {
              "description": "The status of the BGP peer connection. If set to false, any active session\nwith the peer is terminated and all associated routing information is removed.\nIf set to true, the peer connection can be established with routing information.\nThe default is true.",
              "type": "boolean"
            },
            "ipAddress": {
              "description": "IP address of the interface inside Google Cloud Platform.\nOnly IPv4 is supported.",
              "type": "object",
              "properties": {
                "external": {
                  "type": "string"
                }
              }
            },
            "peerAsn": {
              "description": "Peer BGP Autonomous System Number (ASN).\nEach BGP interface may use a different value.",
              "type": "integer"
            },
            "peerIpAddress": {
              "description": "IP address of the BGP interface outside Google Cloud Platform.\nOnly IPv4 is supported.",
              "type": "string"
            },
            "region": {
              "description": "Immutable. Region where the router and BgpPeer reside.\nIf it is not provided, the provider region is used.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "routerInterfaceRef": {
              "description": "The interface the BGP peer is associated with.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a ComputeRouterInterface.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "routerRef": {
              "description": "The Cloud Router in which this BGP peer will be configured.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a ComputeRouter.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "managementType": {
              "description": "The resource that configures and manages this BGP peer.\n\n* 'MANAGED_BY_USER' is the default value and can be managed by\nyou or other users\n* 'MANAGED_BY_ATTACHMENT' is a BGP peer that is configured and\nmanaged by Cloud Interconnect, specifically by an\nInterconnectAttachment of type PARTNER. Google automatically\ncreates, updates, and deletes this type of BGP peer when the\nPARTNER InterconnectAttachment is created, updated,\nor deleted.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeRouterPeer",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeRouterPeerList": {
      "description": "ComputeRouterPeerList is a list of ComputeRouterPeer",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computerouterpeers. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeRouterPeer"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeRouterPeerList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeRouterPeerList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeSSLCertificate": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeSSLCertificate"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["certificate", "location", "privateKey"],
          "properties": {
            "certificate": {
              "description": "Immutable. The certificate in PEM format.\nThe certificate chain must be no greater than 5 certs long.\nThe chain must include at least one intermediate cert.",
              "type": "object",
              "properties": {
                "value": {
                  "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                  "type": "string"
                },
                "valueFrom": {
                  "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                  "type": "object",
                  "properties": {
                    "secretKeyRef": {
                      "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                      "type": "object",
                      "required": ["key", "name"],
                      "properties": {
                        "key": {
                          "description": "Key that identifies the value to be extracted.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the Secret to extract a value from.",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "description": {
              "description": "Immutable. An optional description of this resource.",
              "type": "string"
            },
            "location": {
              "description": "Location represents the geographical location of the ComputeSSLCertificate. Specify a region name or \"global\" for global resources. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)",
              "type": "string"
            },
            "privateKey": {
              "description": "Immutable. The write-only private key in PEM format.",
              "type": "object",
              "properties": {
                "value": {
                  "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                  "type": "string"
                },
                "valueFrom": {
                  "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                  "type": "object",
                  "properties": {
                    "secretKeyRef": {
                      "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                      "type": "object",
                      "required": ["key", "name"],
                      "properties": {
                        "key": {
                          "description": "Key that identifies the value to be extracted.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the Secret to extract a value from.",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "certificateId": {
              "description": "The unique identifier for the resource.",
              "type": "integer"
            },
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeSSLCertificate",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeSSLCertificateList": {
      "description": "ComputeSSLCertificateList is a list of ComputeSSLCertificate",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computesslcertificates. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeSSLCertificate"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeSSLCertificateList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeSSLCertificateList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeSSLPolicy": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeSSLPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "customFeatures": {
              "description": "Profile specifies the set of SSL features that can be used by the\nload balancer when negotiating SSL with clients. This can be one of\n'COMPATIBLE', 'MODERN', 'RESTRICTED', or 'CUSTOM'. If using 'CUSTOM',\nthe set of SSL features to enable must be specified in the\n'customFeatures' field.\n\nSee the [official documentation](https://cloud.google.com/compute/docs/load-balancing/ssl-policies#profilefeaturesupport)\nfor which ciphers are available to use. **Note**: this argument\n*must* be present when using the 'CUSTOM' profile. This argument\n*must not* be present when using any other profile.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "description": {
              "description": "Immutable. An optional description of this resource.",
              "type": "string"
            },
            "minTlsVersion": {
              "description": "The minimum version of SSL protocol that can be used by the clients\nto establish a connection with the load balancer. Default value: \"TLS_1_0\" Possible values: [\"TLS_1_0\", \"TLS_1_1\", \"TLS_1_2\"].",
              "type": "string"
            },
            "profile": {
              "description": "Profile specifies the set of SSL features that can be used by the\nload balancer when negotiating SSL with clients. If using 'CUSTOM',\nthe set of SSL features to enable must be specified in the\n'customFeatures' field.\n\nSee the [official documentation](https://cloud.google.com/compute/docs/load-balancing/ssl-policies#profilefeaturesupport)\nfor information on what cipher suites each profile provides. If\n'CUSTOM' is used, the 'custom_features' attribute **must be set**. Default value: \"COMPATIBLE\" Possible values: [\"COMPATIBLE\", \"MODERN\", \"RESTRICTED\", \"CUSTOM\"].",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "enabledFeatures": {
              "description": "The list of features enabled in the SSL policy.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "fingerprint": {
              "description": "Fingerprint of this resource. A hash of the contents stored in this\nobject. This field is used in optimistic locking.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeSSLPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeSSLPolicyList": {
      "description": "ComputeSSLPolicyList is a list of ComputeSSLPolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computesslpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeSSLPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeSSLPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeSSLPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeSecurityPolicy": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeSecurityPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "adaptiveProtectionConfig": {
              "description": "Adaptive Protection Config of this security policy.",
              "type": "object",
              "properties": {
                "layer7DdosDefenseConfig": {
                  "description": "Layer 7 DDoS Defense Config of this security policy.",
                  "type": "object",
                  "properties": {
                    "enable": {
                      "description": "If set to true, enables CAAP for L7 DDoS detection.",
                      "type": "boolean"
                    },
                    "ruleVisibility": {
                      "description": "Rule visibility. Supported values include: \"STANDARD\", \"PREMIUM\".",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "description": {
              "description": "An optional description of this security policy. Max size is 2048.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "rule": {
              "description": "The set of rules that belong to this policy. There must always be a default rule (rule with priority 2147483647 and match \"*\"). If no rules are provided when creating a security policy, a default rule with action \"allow\" will be added.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["action", "match", "priority"],
                "properties": {
                  "action": {
                    "description": "Action to take when match matches the request. Valid values:   \"allow\" : allow access to target, \"deny(status)\" : deny access to target, returns the HTTP response code specified (valid values are 403, 404 and 502).",
                    "type": "string"
                  },
                  "description": {
                    "description": "An optional description of this rule. Max size is 64.",
                    "type": "string"
                  },
                  "match": {
                    "description": "A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding action is enforced.",
                    "type": "object",
                    "properties": {
                      "config": {
                        "description": "The configuration options available when specifying versioned_expr. This field must be specified if versioned_expr is specified and cannot be specified if versioned_expr is not specified.",
                        "type": "object",
                        "required": ["srcIpRanges"],
                        "properties": {
                          "srcIpRanges": {
                            "description": "Set of IP addresses or ranges (IPV4 or IPV6) in CIDR notation to match against inbound traffic. There is a limit of 10 IP ranges per rule. A value of '*' matches all IPs (can be used to override the default behavior).",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "expr": {
                        "description": "User defined CEVAL expression. A CEVAL expression is used to specify match criteria such as origin.ip, source.region_code and contents in the request header.",
                        "type": "object",
                        "required": ["expression"],
                        "properties": {
                          "expression": {
                            "description": "Textual representation of an expression in Common Expression Language syntax. The application context of the containing message determines which well-known feature set of CEL is supported.",
                            "type": "string"
                          }
                        }
                      },
                      "versionedExpr": {
                        "description": "Predefined rule expression. If this field is specified, config must also be specified. Available options:   SRC_IPS_V1: Must specify the corresponding src_ip_ranges field in config.",
                        "type": "string"
                      }
                    }
                  },
                  "preview": {
                    "description": "When set to true, the action specified above is not enforced. Stackdriver logs for requests that trigger a preview action are annotated as such.",
                    "type": "boolean"
                  },
                  "priority": {
                    "description": "An unique positive integer indicating the priority of evaluation for a rule. Rules are evaluated from highest priority (lowest numerically) to lowest priority (highest numerically) in order.",
                    "type": "integer"
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "fingerprint": {
              "description": "Fingerprint of this resource.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "description": "The URI of the created resource.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeSecurityPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeSecurityPolicyList": {
      "description": "ComputeSecurityPolicyList is a list of ComputeSecurityPolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computesecuritypolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeSecurityPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeSecurityPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeSecurityPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeServiceAttachment": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeServiceAttachment"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": [
            "connectionPreference",
            "location",
            "natSubnets",
            "projectRef",
            "targetServiceRef"
          ],
          "properties": {
            "connectionPreference": {
              "description": "The connection preference of service attachment. The value can be set to `ACCEPT_AUTOMATIC`. An `ACCEPT_AUTOMATIC` service attachment is one that always accepts the connection from consumer forwarding rules. Possible values: CONNECTION_PREFERENCE_UNSPECIFIED, ACCEPT_AUTOMATIC, ACCEPT_MANUAL",
              "type": "string"
            },
            "consumerAcceptLists": {
              "description": "Projects that are allowed to connect to this service attachment.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["projectRef"],
                "properties": {
                  "connectionLimit": {
                    "description": "The value of the limit to set.",
                    "type": "integer",
                    "format": "int64"
                  },
                  "projectRef": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The project id or number for the project to set the limit for.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "consumerRejectLists": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "external": {
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "description": {
              "description": "An optional description of this resource. Provide this property when you create the resource.",
              "type": "string"
            },
            "enableProxyProtocol": {
              "description": "If true, enable the proxy protocol which is for supplying client TCP/IP address data in TCP connections that traverse proxies on their way to destination servers.",
              "type": "boolean"
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "natSubnets": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "external": {
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "targetServiceRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The URL of a service serving the endpoint identified by this service attachment.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "connectedEndpoints": {
              "description": "An array of connections for all the consumers connected to this service attachment.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "endpoint": {
                    "description": "The url of a connected endpoint.",
                    "type": "string"
                  },
                  "pscConnectionId": {
                    "description": "The PSC connection id of the connected endpoint.",
                    "type": "integer",
                    "format": "int64"
                  },
                  "status": {
                    "description": "The status of a connected endpoint to this service attachment. Possible values: PENDING, RUNNING, DONE",
                    "type": "string"
                  }
                }
              }
            },
            "fingerprint": {
              "description": "Fingerprint of this resource. This field is used internally during updates of this resource.",
              "type": "string"
            },
            "id": {
              "description": "The unique identifier for the resource type. The server generates this identifier.",
              "type": "integer",
              "format": "int64"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "pscServiceAttachmentId": {
              "description": "An 128-bit global unique ID of the PSC service attachment.",
              "type": "object",
              "properties": {
                "high": {
                  "type": "integer",
                  "format": "int64"
                },
                "low": {
                  "type": "integer",
                  "format": "int64"
                }
              }
            },
            "region": {
              "description": "URL of the region where the service attachment resides. This field applies only to the region resource. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.",
              "type": "string"
            },
            "selfLink": {
              "description": "Server-defined URL for the resource.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeServiceAttachment",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeServiceAttachmentList": {
      "description": "ComputeServiceAttachmentList is a list of ComputeServiceAttachment",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computeserviceattachments. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeServiceAttachment"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeServiceAttachmentList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeServiceAttachmentList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeSharedVPCHostProject": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeSharedVPCHostProject"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeSharedVPCHostProject",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeSharedVPCHostProjectList": {
      "description": "ComputeSharedVPCHostProjectList is a list of ComputeSharedVPCHostProject",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computesharedvpchostprojects. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeSharedVPCHostProject"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeSharedVPCHostProjectList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeSharedVPCHostProjectList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeSharedVPCServiceProject": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeSharedVPCServiceProject"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["projectRef"],
          "properties": {
            "projectRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a Project.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeSharedVPCServiceProject",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeSharedVPCServiceProjectList": {
      "description": "ComputeSharedVPCServiceProjectList is a list of ComputeSharedVPCServiceProject",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computesharedvpcserviceprojects. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeSharedVPCServiceProject"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeSharedVPCServiceProjectList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeSharedVPCServiceProjectList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeSnapshot": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeSnapshot"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["sourceDiskRef"],
          "properties": {
            "description": {
              "description": "Immutable. An optional description of this resource.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "snapshotEncryptionKey": {
              "description": "Immutable. The customer-supplied encryption key of the snapshot. Required if the\nsource snapshot is protected by a customer-supplied encryption key.",
              "type": "object",
              "properties": {
                "kmsKeyRef": {
                  "description": "The encryption key that is stored in Google Cloud KMS.",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a KMSCryptoKey.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "kmsKeyServiceAccountRef": {
                  "description": "The service account used for the encryption request for the given KMS key.\nIf absent, the Compute Engine Service Agent service account is used.",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The email of an IAMServiceAccount.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "rawKey": {
                  "description": "Immutable. Specifies a 256-bit customer-supplied encryption key, encoded in\nRFC 4648 base64 to either encrypt or decrypt this resource.",
                  "type": "object",
                  "properties": {
                    "value": {
                      "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                      "type": "string"
                    },
                    "valueFrom": {
                      "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                      "type": "object",
                      "properties": {
                        "secretKeyRef": {
                          "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                          "type": "object",
                          "required": ["name", "key"],
                          "properties": {
                            "key": {
                              "description": "Key that identifies the value to be extracted.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the Secret to extract a value from.",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "sha256": {
                  "description": "The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied\nencryption key that protects this resource.",
                  "type": "string"
                }
              }
            },
            "sourceDiskEncryptionKey": {
              "description": "Immutable. The customer-supplied encryption key of the source snapshot. Required\nif the source snapshot is protected by a customer-supplied encryption\nkey.",
              "type": "object",
              "properties": {
                "kmsKeyServiceAccountRef": {
                  "description": "The service account used for the encryption request for the given KMS key.\nIf absent, the Compute Engine Service Agent service account is used.",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The email of an IAMServiceAccount.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "rawKey": {
                  "description": "Immutable. Specifies a 256-bit customer-supplied encryption key, encoded in\nRFC 4648 base64 to either encrypt or decrypt this resource.",
                  "type": "object",
                  "properties": {
                    "value": {
                      "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                      "type": "string"
                    },
                    "valueFrom": {
                      "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                      "type": "object",
                      "properties": {
                        "secretKeyRef": {
                          "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                          "type": "object",
                          "required": ["name", "key"],
                          "properties": {
                            "key": {
                              "description": "Key that identifies the value to be extracted.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the Secret to extract a value from.",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "sourceDiskRef": {
              "description": "A reference to the disk used to create this snapshot.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a ComputeDisk.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "storageLocations": {
              "description": "Immutable. Cloud Storage bucket storage location of the snapshot (regional or multi-regional).",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "zone": {
              "description": "Immutable. A reference to the zone where the disk is hosted.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "diskSizeGb": {
              "description": "Size of the snapshot, specified in GB.",
              "type": "integer"
            },
            "labelFingerprint": {
              "description": "The fingerprint used for optimistic locking of this resource. Used\ninternally during updates.",
              "type": "string"
            },
            "licenses": {
              "description": "A list of public visible licenses that apply to this snapshot. This\ncan be because the original image had licenses attached (such as a\nWindows image).  snapshotEncryptionKey nested object Encrypts the\nsnapshot using a customer-supplied encryption key.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            },
            "snapshotId": {
              "description": "The unique identifier for the resource.",
              "type": "integer"
            },
            "storageBytes": {
              "description": "A size of the storage used by the snapshot. As snapshots share\nstorage, this number is expected to change with snapshot\ncreation/deletion.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeSnapshot",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeSnapshotList": {
      "description": "ComputeSnapshotList is a list of ComputeSnapshot",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computesnapshots. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeSnapshot"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeSnapshotList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeSnapshotList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeSubnetwork": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeSubnetwork"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["ipCidrRange", "networkRef", "region"],
          "properties": {
            "description": {
              "description": "Immutable. An optional description of this resource. Provide this property when\nyou create the resource. This field can be set only at resource\ncreation time.",
              "type": "string"
            },
            "ipCidrRange": {
              "description": "The range of internal addresses that are owned by this subnetwork.\nProvide this property when you create the subnetwork. For example,\n10.0.0.0/8 or 192.168.0.0/16. Ranges must be unique and\nnon-overlapping within a network. Only IPv4 is supported.",
              "type": "string"
            },
            "ipv6AccessType": {
              "description": "Immutable. The access type of IPv6 address this subnet holds. It's immutable and can only be specified during creation\nor the first time the subnet is updated into IPV4_IPV6 dual stack. If the ipv6_type is EXTERNAL then this subnet\ncannot enable direct path. Possible values: [\"EXTERNAL\"].",
              "type": "string"
            },
            "logConfig": {
              "description": "Denotes the logging options for the subnetwork flow logs. If logging is enabled\nlogs will be exported to Stackdriver. This field cannot be set if the 'purpose' of this\nsubnetwork is 'INTERNAL_HTTPS_LOAD_BALANCER'.",
              "type": "object",
              "properties": {
                "aggregationInterval": {
                  "description": "Can only be specified if VPC flow logging for this subnetwork is enabled.\nToggles the aggregation interval for collecting flow logs. Increasing the\ninterval time will reduce the amount of generated flow logs for long\nlasting connections. Default is an interval of 5 seconds per connection. Default value: \"INTERVAL_5_SEC\" Possible values: [\"INTERVAL_5_SEC\", \"INTERVAL_30_SEC\", \"INTERVAL_1_MIN\", \"INTERVAL_5_MIN\", \"INTERVAL_10_MIN\", \"INTERVAL_15_MIN\"].",
                  "type": "string"
                },
                "filterExpr": {
                  "description": "Export filter used to define which VPC flow logs should be logged, as as CEL expression. See\nhttps://cloud.google.com/vpc/docs/flow-logs#filtering for details on how to format this field.\nThe default value is 'true', which evaluates to include everything.",
                  "type": "string"
                },
                "flowSampling": {
                  "description": "Can only be specified if VPC flow logging for this subnetwork is enabled.\nThe value of the field must be in [0, 1]. Set the sampling rate of VPC\nflow logs within the subnetwork where 1.0 means all collected logs are\nreported and 0.0 means no logs are reported. Default is 0.5 which means\nhalf of all collected logs are reported.",
                  "type": "number"
                },
                "metadata": {
                  "description": "Can only be specified if VPC flow logging for this subnetwork is enabled.\nConfigures whether metadata fields should be added to the reported VPC\nflow logs. Default value: \"INCLUDE_ALL_METADATA\" Possible values: [\"EXCLUDE_ALL_METADATA\", \"INCLUDE_ALL_METADATA\", \"CUSTOM_METADATA\"].",
                  "type": "string"
                },
                "metadataFields": {
                  "description": "List of metadata fields that should be added to reported logs.\nCan only be specified if VPC flow logs for this subnetwork is enabled and \"metadata\" is set to CUSTOM_METADATA.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "networkRef": {
              "description": "The network this subnet belongs to. Only networks that are in the\ndistributed mode can have subnetworks.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "privateIpGoogleAccess": {
              "description": "When enabled, VMs in this subnetwork without external IP addresses can\naccess Google APIs and services by using Private Google Access.",
              "type": "boolean"
            },
            "privateIpv6GoogleAccess": {
              "description": "The private IPv6 google access type for the VMs in this subnet.",
              "type": "string"
            },
            "purpose": {
              "description": "Immutable. The purpose of the resource. A subnetwork with purpose set to\nINTERNAL_HTTPS_LOAD_BALANCER is a user-created subnetwork that is\nreserved for Internal HTTP(S) Load Balancing. \n\nIf set to INTERNAL_HTTPS_LOAD_BALANCER you must also set the 'role' field.",
              "type": "string"
            },
            "region": {
              "description": "Immutable. The GCP region for this subnetwork.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "role": {
              "description": "The role of subnetwork. Currently, this field is only used when\npurpose = INTERNAL_HTTPS_LOAD_BALANCER. The value can be set to ACTIVE\nor BACKUP. An ACTIVE subnetwork is one that is currently being used\nfor Internal HTTP(S) Load Balancing. A BACKUP subnetwork is one that\nis ready to be promoted to ACTIVE or is currently draining. Possible values: [\"ACTIVE\", \"BACKUP\"].",
              "type": "string"
            },
            "secondaryIpRange": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["ipCidrRange", "rangeName"],
                "properties": {
                  "ipCidrRange": {
                    "description": "The range of IP addresses belonging to this subnetwork secondary\nrange. Provide this property when you create the subnetwork.\nRanges must be unique and non-overlapping with all primary and\nsecondary IP ranges within a network. Only IPv4 is supported.",
                    "type": "string"
                  },
                  "rangeName": {
                    "description": "The name associated with this subnetwork secondary range, used\nwhen adding an alias IP range to a VM instance. The name must\nbe 1-63 characters long, and comply with RFC1035. The name\nmust be unique within the subnetwork.",
                    "type": "string"
                  }
                }
              }
            },
            "stackType": {
              "description": "The stack type for this subnet to identify whether the IPv6 feature is enabled or not.\nIf not specified IPV4_ONLY will be used. Possible values: [\"IPV4_ONLY\", \"IPV4_IPV6\"].",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "externalIpv6Prefix": {
              "description": "The range of external IPv6 addresses that are owned by this subnetwork.",
              "type": "string"
            },
            "fingerprint": {
              "description": "DEPRECATED \u2014 This field is not useful for users, and has been removed as an output. Fingerprint of this resource. This field is used internally during updates of this resource.",
              "type": "string"
            },
            "gatewayAddress": {
              "description": "The gateway address for default routes to reach destination addresses\noutside this subnetwork.",
              "type": "string"
            },
            "ipv6CidrRange": {
              "description": "The range of internal IPv6 addresses that are owned by this subnetwork.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeSubnetwork",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeSubnetworkList": {
      "description": "ComputeSubnetworkList is a list of ComputeSubnetwork",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computesubnetworks. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeSubnetwork"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeSubnetworkList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeSubnetworkList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeTargetGRPCProxy": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeTargetGRPCProxy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "description": {
              "description": "An optional description of this resource.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "urlMapRef": {
              "description": "The UrlMap resource that defines the mapping from URL to the BackendService.\nThe protocol field in the BackendService must be set to GRPC.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeURLMap.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "validateForProxyless": {
              "description": "Immutable. If true, indicates that the BackendServices referenced by\nthe urlMap may be accessed by gRPC applications without using\na sidecar proxy. This will enable configuration checks on urlMap\nand its referenced BackendServices to not allow unsupported features.\nA gRPC application must use \"xds:///\" scheme in the target URI\nof the service it is connecting to. If false, indicates that the\nBackendServices referenced by the urlMap will be accessed by gRPC\napplications via a sidecar proxy. In this case, a gRPC application\nmust not use \"xds:///\" scheme in the target URI of the service\nit is connecting to.",
              "type": "boolean"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "fingerprint": {
              "description": "Fingerprint of this resource. A hash of the contents stored in\nthis object. This field is used in optimistic locking. This field\nwill be ignored when inserting a TargetGrpcProxy. An up-to-date\nfingerprint must be provided in order to patch/update the\nTargetGrpcProxy; otherwise, the request will fail with error\n412 conditionNotMet. To see the latest fingerprint, make a get()\nrequest to retrieve the TargetGrpcProxy. A base64-encoded string.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            },
            "selfLinkWithId": {
              "description": "Server-defined URL with id for the resource.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeTargetGRPCProxy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeTargetGRPCProxyList": {
      "description": "ComputeTargetGRPCProxyList is a list of ComputeTargetGRPCProxy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computetargetgrpcproxies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeTargetGRPCProxy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeTargetGRPCProxyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeTargetGRPCProxyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeTargetHTTPProxy": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeTargetHTTPProxy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location", "urlMapRef"],
          "properties": {
            "description": {
              "description": "Immutable. An optional description of this resource.",
              "type": "string"
            },
            "location": {
              "description": "Location represents the geographical location of the ComputeTargetHTTPProxy. Specify a region name or \"global\" for global resources. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)",
              "type": "string"
            },
            "proxyBind": {
              "description": "Immutable. This field only applies when the forwarding rule that references\nthis target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.",
              "type": "boolean"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "urlMapRef": {
              "description": "A reference to the ComputeURLMap resource that defines the mapping\nfrom URL to the BackendService.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeURLMap.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "proxyId": {
              "description": "The unique identifier for the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeTargetHTTPProxy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeTargetHTTPProxyList": {
      "description": "ComputeTargetHTTPProxyList is a list of ComputeTargetHTTPProxy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computetargethttpproxies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeTargetHTTPProxy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeTargetHTTPProxyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeTargetHTTPProxyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeTargetHTTPSProxy": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeTargetHTTPSProxy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location", "sslCertificates", "urlMapRef"],
          "properties": {
            "description": {
              "description": "Immutable. An optional description of this resource.",
              "type": "string"
            },
            "location": {
              "description": "Location represents the geographical location of the ComputeTargetHTTPSProxy. Specify a region name or \"global\" for global resources. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)",
              "type": "string"
            },
            "proxyBind": {
              "description": "Immutable. This field only applies when the forwarding rule that references\nthis target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.",
              "type": "boolean"
            },
            "quicOverride": {
              "description": "Specifies the QUIC override policy for this resource. This determines\nwhether the load balancer will attempt to negotiate QUIC with clients\nor not. Can specify one of NONE, ENABLE, or DISABLE. If NONE is\nspecified, uses the QUIC policy with no user overrides, which is\nequivalent to DISABLE. Default value: \"NONE\" Possible values: [\"NONE\", \"ENABLE\", \"DISABLE\"].",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "sslCertificates": {
              "type": "array",
              "items": {
                "description": "A list of ComputeSSLCertificate resources that are used to\nauthenticate connections between users and the load balancer. At\nleast one SSL certificate must be specified.",
                "type": "object",
                "properties": {
                  "external": {
                    "description": "The selfLink of a ComputeSSLCertificate.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "sslPolicyRef": {
              "description": "A reference to the ComputeSSLPolicy resource that will be\nassociated with the ComputeTargetHTTPSProxy resource. If not set,\nthe ComputeTargetHTTPSProxy resource will not have any SSL policy\nconfigured.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeSSLPolicy.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "urlMapRef": {
              "description": "A reference to the ComputeURLMap resource that defines the mapping\nfrom URL to the BackendService.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeURLMap.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "proxyId": {
              "description": "The unique identifier for the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeTargetHTTPSProxy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeTargetHTTPSProxyList": {
      "description": "ComputeTargetHTTPSProxyList is a list of ComputeTargetHTTPSProxy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computetargethttpsproxies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeTargetHTTPSProxy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeTargetHTTPSProxyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeTargetHTTPSProxyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeTargetInstance": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeTargetInstance"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["instanceRef", "zone"],
          "properties": {
            "description": {
              "description": "Immutable. An optional description of this resource.",
              "type": "string"
            },
            "instanceRef": {
              "description": "The ComputeInstance handling traffic for this target instance.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeInstance.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "natPolicy": {
              "description": "Immutable. NAT option controlling how IPs are NAT'ed to the instance.\nCurrently only NO_NAT (default value) is supported. Default value: \"NO_NAT\" Possible values: [\"NO_NAT\"].",
              "type": "string"
            },
            "networkRef": {
              "description": "The network this target instance uses to forward\ntraffic. If not specified, the traffic will be forwarded to the network\nthat the default network interface belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "zone": {
              "description": "Immutable. URL of the zone where the target instance resides.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeTargetInstance",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeTargetInstanceList": {
      "description": "ComputeTargetInstanceList is a list of ComputeTargetInstance",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computetargetinstances. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeTargetInstance"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeTargetInstanceList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeTargetInstanceList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeTargetPool": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeTargetPool"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["region"],
          "properties": {
            "backupTargetPoolRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeTargetPool.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "description": {
              "description": "Immutable. Textual description field.",
              "type": "string"
            },
            "failoverRatio": {
              "description": "Immutable. Ratio (0 to 1) of failed nodes before using the backup pool (which must also be set).",
              "type": "number"
            },
            "healthChecks": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "httpHealthCheckRef": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The selfLink of a ComputeHTTPHealthCheck.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "instances": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "external": {
                    "description": "The selfLink of a ComputeInstance.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "region": {
              "description": "Immutable. Where the target pool resides. Defaults to project region.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "sessionAffinity": {
              "description": "Immutable. How to distribute load. Options are \"NONE\" (no affinity). \"CLIENT_IP\" (hash of the source/dest addresses / ports), and \"CLIENT_IP_PROTO\" also includes the protocol (default \"NONE\").",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "description": "The URI of the created resource.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeTargetPool",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeTargetPoolList": {
      "description": "ComputeTargetPoolList is a list of ComputeTargetPool",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computetargetpools. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeTargetPool"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeTargetPoolList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeTargetPoolList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeTargetSSLProxy": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeTargetSSLProxy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["backendServiceRef", "sslCertificates"],
          "properties": {
            "backendServiceRef": {
              "description": "A reference to the ComputeBackendService resource.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeBackendService.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "description": {
              "description": "Immutable. An optional description of this resource.",
              "type": "string"
            },
            "proxyHeader": {
              "description": "Specifies the type of proxy header to append before sending data to\nthe backend. Default value: \"NONE\" Possible values: [\"NONE\", \"PROXY_V1\"].",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "sslCertificates": {
              "type": "array",
              "items": {
                "description": "A list of ComputeSSLCertificate resources that are used to\nauthenticate connections between users and the load balancer.\nCurrently, exactly one SSL certificate must be specified.",
                "type": "object",
                "properties": {
                  "external": {
                    "description": "The selfLink of a ComputeSSLCertificate.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "sslPolicyRef": {
              "description": "A reference to the ComputeSSLPolicy resource that will be\nassociated with the TargetSslProxy resource. If not set, the\nComputeTargetSSLProxy resource will not have any SSL policy\nconfigured.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeSSLPolicy.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "proxyId": {
              "description": "The unique identifier for the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeTargetSSLProxy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeTargetSSLProxyList": {
      "description": "ComputeTargetSSLProxyList is a list of ComputeTargetSSLProxy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computetargetsslproxies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeTargetSSLProxy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeTargetSSLProxyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeTargetSSLProxyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeTargetTCPProxy": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeTargetTCPProxy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["backendServiceRef"],
          "properties": {
            "backendServiceRef": {
              "description": "A reference to the ComputeBackendService resource.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeBackendService.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "description": {
              "description": "Immutable. An optional description of this resource.",
              "type": "string"
            },
            "proxyBind": {
              "description": "Immutable. This field only applies when the forwarding rule that references\nthis target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.",
              "type": "boolean"
            },
            "proxyHeader": {
              "description": "Specifies the type of proxy header to append before sending data to\nthe backend. Default value: \"NONE\" Possible values: [\"NONE\", \"PROXY_V1\"].",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "proxyId": {
              "description": "The unique identifier for the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeTargetTCPProxy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeTargetTCPProxyList": {
      "description": "ComputeTargetTCPProxyList is a list of ComputeTargetTCPProxy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computetargettcpproxies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeTargetTCPProxy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeTargetTCPProxyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeTargetTCPProxyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeTargetVPNGateway": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeTargetVPNGateway"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["networkRef", "region"],
          "properties": {
            "description": {
              "description": "Immutable. An optional description of this resource.",
              "type": "string"
            },
            "networkRef": {
              "description": "The network this VPN gateway is accepting traffic for.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "region": {
              "description": "Immutable. The region this gateway should sit in.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "gatewayId": {
              "description": "The unique identifier for the resource.",
              "type": "integer"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeTargetVPNGateway",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeTargetVPNGatewayList": {
      "description": "ComputeTargetVPNGatewayList is a list of ComputeTargetVPNGateway",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computetargetvpngateways. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeTargetVPNGateway"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeTargetVPNGatewayList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeTargetVPNGatewayList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeURLMap": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeURLMap"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location"],
          "properties": {
            "defaultRouteAction": {
              "description": "defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions\nlike URL rewrites, header transformations, etc. prior to forwarding the request to the selected backend.\nIf defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService\nis set, defaultRouteAction cannot contain any weightedBackendServices.\n\nOnly one of defaultRouteAction or defaultUrlRedirect must be set.",
              "type": "object",
              "properties": {
                "corsPolicy": {
                  "description": "The specification for allowing client side cross-origin requests. Please see\n[W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/).",
                  "type": "object",
                  "properties": {
                    "allowCredentials": {
                      "description": "In response to a preflight request, setting this to true indicates that the actual request can include user credentials.\nThis translates to the Access-Control-Allow-Credentials header.",
                      "type": "boolean"
                    },
                    "allowHeaders": {
                      "description": "Specifies the content for the Access-Control-Allow-Headers header.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "allowMethods": {
                      "description": "Specifies the content for the Access-Control-Allow-Methods header.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "allowOriginRegexes": {
                      "description": "Specifies the regular expression patterns that match allowed origins. For regular expression grammar\nplease see en.cppreference.com/w/cpp/regex/ecmascript\nAn origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "allowOrigins": {
                      "description": "Specifies the list of origins that will be allowed to do CORS requests.\nAn origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "disabled": {
                      "description": "If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.",
                      "type": "boolean"
                    },
                    "exposeHeaders": {
                      "description": "Specifies the content for the Access-Control-Expose-Headers header.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "maxAge": {
                      "description": "Specifies how long results of a preflight request can be cached in seconds.\nThis translates to the Access-Control-Max-Age header.",
                      "type": "integer"
                    }
                  }
                },
                "faultInjectionPolicy": {
                  "description": "The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.\nAs part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a\npercentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted\nby the Loadbalancer for a percentage of requests.\n\ntimeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.",
                  "type": "object",
                  "properties": {
                    "abort": {
                      "description": "The specification for how client requests are aborted as part of fault injection.",
                      "type": "object",
                      "properties": {
                        "httpStatus": {
                          "description": "The HTTP status code used to abort the request.\nThe value must be between 200 and 599 inclusive.",
                          "type": "integer"
                        },
                        "percentage": {
                          "description": "The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.\nThe value must be between 0.0 and 100.0 inclusive.",
                          "type": "number"
                        }
                      }
                    },
                    "delay": {
                      "description": "The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.",
                      "type": "object",
                      "properties": {
                        "fixedDelay": {
                          "description": "Specifies the value of the fixed delay interval.",
                          "type": "object",
                          "properties": {
                            "nanos": {
                              "description": "Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are\nrepresented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.",
                              "type": "integer"
                            },
                            "seconds": {
                              "description": "Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.\nNote: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.",
                              "type": "string"
                            }
                          }
                        },
                        "percentage": {
                          "description": "The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.\nThe value must be between 0.0 and 100.0 inclusive.",
                          "type": "number"
                        }
                      }
                    }
                  }
                },
                "requestMirrorPolicy": {
                  "description": "Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.\nLoadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,\nthe host / authority header is suffixed with -shadow.",
                  "type": "object",
                  "required": ["backendServiceRef"],
                  "properties": {
                    "backendServiceRef": {
                      "description": "Required. The backend service resource being mirrored to.",
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "The name of a ComputeBackendService.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "retryPolicy": {
                  "description": "Specifies the retry policy associated with this route.",
                  "type": "object",
                  "properties": {
                    "numRetries": {
                      "description": "Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.",
                      "type": "integer"
                    },
                    "perTryTimeout": {
                      "description": "Specifies a non-zero timeout per retry attempt.\n\nIf not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,\nwill use the largest timeout among all backend services associated with the route.",
                      "type": "object",
                      "properties": {
                        "nanos": {
                          "description": "Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are\nrepresented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.",
                          "type": "integer"
                        },
                        "seconds": {
                          "description": "Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.\nNote: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.",
                          "type": "string"
                        }
                      }
                    },
                    "retryConditions": {
                      "description": "Specfies one or more conditions when this retry rule applies. Valid values are:\n\n* 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,\n  or if the backend service does not respond at all, example: disconnects, reset, read timeout,\n* connection failure, and refused streams.\n* gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.\n* connect-failure: Loadbalancer will retry on failures connecting to backend services,\n  for example due to connection timeouts.\n* retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.\n  Currently the only retriable error supported is 409.\n* refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.\n  This reset type indicates that it is safe to retry.\n* cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled\n* deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded\n* resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted\n* unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                },
                "timeout": {
                  "description": "Specifies the timeout for the selected route. Timeout is computed from the time the request has been\nfully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.\n\nIf not specified, will use the largest timeout among all backend services associated with the route.",
                  "type": "object",
                  "properties": {
                    "nanos": {
                      "description": "Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented\nwith a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.",
                      "type": "integer"
                    },
                    "seconds": {
                      "description": "Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.\nNote: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.",
                      "type": "string"
                    }
                  }
                },
                "urlRewrite": {
                  "description": "The spec to modify the URL of the request, prior to forwarding the request to the matched service.",
                  "type": "object",
                  "properties": {
                    "hostRewrite": {
                      "description": "Prior to forwarding the request to the selected service, the request's host header is replaced\nwith contents of hostRewrite.\n\nThe value must be between 1 and 255 characters.",
                      "type": "string"
                    },
                    "pathPrefixRewrite": {
                      "description": "Prior to forwarding the request to the selected backend service, the matching portion of the\nrequest's path is replaced by pathPrefixRewrite.\n\nThe value must be between 1 and 1024 characters.",
                      "type": "string"
                    }
                  }
                },
                "weightedBackendServices": {
                  "description": "A list of weighted backend services to send traffic to when a route match occurs.\nThe weights determine the fraction of traffic that flows to their corresponding backend service.\nIf all traffic needs to go to a single backend service, there must be one weightedBackendService\nwith weight set to a non 0 number.\n\nOnce a backendService is identified and before forwarding the request to the backend service,\nadvanced routing actions like Url rewrites and header transformations are applied depending on\nadditional settings specified in this HttpRouteAction.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "backendServiceRef": {
                        "description": "The default backend service resource.\nBefore forwarding the request to backendService, the loadbalancer\napplies any relevant headerActions specified as part of this\nbackendServiceWeight.",
                        "type": "object",
                        "properties": {
                          "external": {
                            "description": "The name of a ComputeBackendService.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          }
                        }
                      },
                      "headerAction": {
                        "description": "Specifies changes to request and response headers that need to take effect for\nthe selected backendService.\n\nheaderAction specified here take effect before headerAction in the enclosing\nHttpRouteRule, PathMatcher and UrlMap.",
                        "type": "object",
                        "properties": {
                          "requestHeadersToAdd": {
                            "description": "Headers to add to a matching request prior to forwarding the request to the backendService.",
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "headerName": {
                                  "description": "The name of the header to add.",
                                  "type": "string"
                                },
                                "headerValue": {
                                  "description": "The value of the header to add.",
                                  "type": "string"
                                },
                                "replace": {
                                  "description": "If false, headerValue is appended to any values that already exist for the header.\nIf true, headerValue is set for the header, discarding any values that were set for that header.",
                                  "type": "boolean"
                                }
                              }
                            }
                          },
                          "requestHeadersToRemove": {
                            "description": "A list of header names for headers that need to be removed from the request prior to\nforwarding the request to the backendService.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "responseHeadersToAdd": {
                            "description": "Headers to add the response prior to sending the response back to the client.",
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "headerName": {
                                  "description": "The name of the header to add.",
                                  "type": "string"
                                },
                                "headerValue": {
                                  "description": "The value of the header to add.",
                                  "type": "string"
                                },
                                "replace": {
                                  "description": "If false, headerValue is appended to any values that already exist for the header.\nIf true, headerValue is set for the header, discarding any values that were set for that header.",
                                  "type": "boolean"
                                }
                              }
                            }
                          },
                          "responseHeadersToRemove": {
                            "description": "A list of header names for headers that need to be removed from the response prior to sending the\nresponse back to the client.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "weight": {
                        "description": "Specifies the fraction of traffic sent to backendService, computed as\nweight / (sum of all weightedBackendService weights in routeAction) .\n\nThe selection of a backend service is determined only for new traffic. Once a user's request\nhas been directed to a backendService, subsequent requests will be sent to the same backendService\nas determined by the BackendService's session affinity policy.\n\nThe value must be between 0 and 1000.",
                        "type": "integer"
                      }
                    }
                  }
                }
              }
            },
            "defaultService": {
              "description": "The defaultService resource to which traffic is directed if none of\nthe hostRules match.\nFor the Global URL Map, it should be a reference to the backend\nservice or backend bucket.\nFor the Regional URL Map, it should be a reference to the backend\nservice.\nIf defaultRouteAction is additionally specified, advanced routing\nactions like URL Rewrites, etc. take effect prior to sending the\nrequest to the backend. However, if defaultService is specified,\ndefaultRouteAction cannot contain any weightedBackendServices.\nConversely, if routeAction specifies any weightedBackendServices,\nservice must not be specified. Only one of defaultService,\ndefaultUrlRedirect or defaultRouteAction.weightedBackendService\nmust be set.",
              "type": "object",
              "properties": {
                "backendBucketRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a ComputeBackendBucket.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "backendServiceRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a ComputeBackendService.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "defaultUrlRedirect": {
              "description": "When none of the specified hostRules match, the request is redirected to a URL specified\nby defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or\ndefaultRouteAction must not be set.",
              "type": "object",
              "required": ["stripQuery"],
              "properties": {
                "hostRedirect": {
                  "description": "The host that will be used in the redirect response instead of the one that was\nsupplied in the request. The value must be between 1 and 255 characters.",
                  "type": "string"
                },
                "httpsRedirect": {
                  "description": "If set to true, the URL scheme in the redirected request is set to https. If set to\nfalse, the URL scheme of the redirected request will remain the same as that of the\nrequest. This must only be set for UrlMaps used in TargetHttpProxys. Setting this\ntrue for TargetHttpsProxy is not permitted. The default is set to false.",
                  "type": "boolean"
                },
                "pathRedirect": {
                  "description": "The path that will be used in the redirect response instead of the one that was\nsupplied in the request. pathRedirect cannot be supplied together with\nprefixRedirect. Supply one alone or neither. If neither is supplied, the path of the\noriginal request will be used for the redirect. The value must be between 1 and 1024\ncharacters.",
                  "type": "string"
                },
                "prefixRedirect": {
                  "description": "The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,\nretaining the remaining portion of the URL before redirecting the request.\nprefixRedirect cannot be supplied together with pathRedirect. Supply one alone or\nneither. If neither is supplied, the path of the original request will be used for\nthe redirect. The value must be between 1 and 1024 characters.",
                  "type": "string"
                },
                "redirectResponseCode": {
                  "description": "The HTTP Status code to use for this RedirectAction. Supported values are:\n\n* MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.\n\n* FOUND, which corresponds to 302.\n\n* SEE_OTHER which corresponds to 303.\n\n* TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method\nwill be retained.\n\n* PERMANENT_REDIRECT, which corresponds to 308. In this case,\nthe request method will be retained. Possible values: [\"FOUND\", \"MOVED_PERMANENTLY_DEFAULT\", \"PERMANENT_REDIRECT\", \"SEE_OTHER\", \"TEMPORARY_REDIRECT\"].",
                  "type": "string"
                },
                "stripQuery": {
                  "description": "If set to true, any accompanying query portion of the original URL is removed prior\nto redirecting the request. If set to false, the query portion of the original URL is\nretained.\n This field is required to ensure an empty block is not set. The normal default value is false.",
                  "type": "boolean"
                }
              }
            },
            "description": {
              "description": "An optional description of this resource. Provide this property when\nyou create the resource.",
              "type": "string"
            },
            "headerAction": {
              "description": "Specifies changes to request and response headers that need to take effect for\nthe selected backendService. The headerAction specified here take effect after\nheaderAction specified under pathMatcher.",
              "type": "object",
              "properties": {
                "requestHeadersToAdd": {
                  "description": "Headers to add to a matching request prior to forwarding the request to the\nbackendService.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["headerName", "headerValue", "replace"],
                    "properties": {
                      "headerName": {
                        "description": "The name of the header.",
                        "type": "string"
                      },
                      "headerValue": {
                        "description": "The value of the header to add.",
                        "type": "string"
                      },
                      "replace": {
                        "description": "If false, headerValue is appended to any values that already exist for the\nheader. If true, headerValue is set for the header, discarding any values that\nwere set for that header.",
                        "type": "boolean"
                      }
                    }
                  }
                },
                "requestHeadersToRemove": {
                  "description": "A list of header names for headers that need to be removed from the request\nprior to forwarding the request to the backendService.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "responseHeadersToAdd": {
                  "description": "Headers to add the response prior to sending the response back to the client.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["headerName", "headerValue", "replace"],
                    "properties": {
                      "headerName": {
                        "description": "The name of the header.",
                        "type": "string"
                      },
                      "headerValue": {
                        "description": "The value of the header to add.",
                        "type": "string"
                      },
                      "replace": {
                        "description": "If false, headerValue is appended to any values that already exist for the\nheader. If true, headerValue is set for the header, discarding any values that\nwere set for that header.",
                        "type": "boolean"
                      }
                    }
                  }
                },
                "responseHeadersToRemove": {
                  "description": "A list of header names for headers that need to be removed from the response\nprior to sending the response back to the client.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "hostRule": {
              "description": "The list of HostRules to use against the URL.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["hosts", "pathMatcher"],
                "properties": {
                  "description": {
                    "description": "An optional description of this HostRule. Provide this property\nwhen you create the resource.",
                    "type": "string"
                  },
                  "hosts": {
                    "description": "The list of host patterns to match. They must be valid\nhostnames, except * will match any string of ([a-z0-9-.]*). In\nthat case, * must be the first character and must be followed in\nthe pattern by either - or ..",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "pathMatcher": {
                    "description": "The name of the PathMatcher to use to match the path portion of\nthe URL if the hostRule matches the URL's host portion.",
                    "type": "string"
                  }
                }
              }
            },
            "location": {
              "description": "Location represents the geographical location of the ComputeURLMap. Specify a region name or \"global\" for global resources. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)",
              "type": "string"
            },
            "pathMatcher": {
              "description": "The list of named PathMatchers to use against the URL.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["name"],
                "properties": {
                  "defaultRouteAction": {
                    "description": "defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs\nadvanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request\nto the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.\nConversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.\n\nOnly one of defaultRouteAction or defaultUrlRedirect must be set.",
                    "type": "object",
                    "properties": {
                      "corsPolicy": {
                        "description": "The specification for allowing client side cross-origin requests. Please see\n[W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/).",
                        "type": "object",
                        "properties": {
                          "allowCredentials": {
                            "description": "In response to a preflight request, setting this to true indicates that the actual request can include user credentials.\nThis translates to the Access-Control-Allow-Credentials header.",
                            "type": "boolean"
                          },
                          "allowHeaders": {
                            "description": "Specifies the content for the Access-Control-Allow-Headers header.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "allowMethods": {
                            "description": "Specifies the content for the Access-Control-Allow-Methods header.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "allowOriginRegexes": {
                            "description": "Specifies the regular expression patterns that match allowed origins. For regular expression grammar\nplease see en.cppreference.com/w/cpp/regex/ecmascript\nAn origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "allowOrigins": {
                            "description": "Specifies the list of origins that will be allowed to do CORS requests.\nAn origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "disabled": {
                            "description": "If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.",
                            "type": "boolean"
                          },
                          "exposeHeaders": {
                            "description": "Specifies the content for the Access-Control-Expose-Headers header.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "maxAge": {
                            "description": "Specifies how long results of a preflight request can be cached in seconds.\nThis translates to the Access-Control-Max-Age header.",
                            "type": "integer"
                          }
                        }
                      },
                      "faultInjectionPolicy": {
                        "description": "The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.\nAs part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a\npercentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted\nby the Loadbalancer for a percentage of requests.\n\ntimeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.",
                        "type": "object",
                        "properties": {
                          "abort": {
                            "description": "The specification for how client requests are aborted as part of fault injection.",
                            "type": "object",
                            "properties": {
                              "httpStatus": {
                                "description": "The HTTP status code used to abort the request.\nThe value must be between 200 and 599 inclusive.",
                                "type": "integer"
                              },
                              "percentage": {
                                "description": "The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.\nThe value must be between 0.0 and 100.0 inclusive.",
                                "type": "number"
                              }
                            }
                          },
                          "delay": {
                            "description": "The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.",
                            "type": "object",
                            "properties": {
                              "fixedDelay": {
                                "description": "Specifies the value of the fixed delay interval.",
                                "type": "object",
                                "properties": {
                                  "nanos": {
                                    "description": "Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are\nrepresented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.",
                                    "type": "integer"
                                  },
                                  "seconds": {
                                    "description": "Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.\nNote: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.",
                                    "type": "string"
                                  }
                                }
                              },
                              "percentage": {
                                "description": "The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.\nThe value must be between 0.0 and 100.0 inclusive.",
                                "type": "number"
                              }
                            }
                          }
                        }
                      },
                      "requestMirrorPolicy": {
                        "description": "Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.\nLoadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,\nthe host / authority header is suffixed with -shadow.",
                        "type": "object",
                        "required": ["backendServiceRef"],
                        "properties": {
                          "backendServiceRef": {
                            "description": "Required. The backend service resource being mirrored to.",
                            "type": "object",
                            "properties": {
                              "external": {
                                "description": "The name of a ComputeBackendService.",
                                "type": "string"
                              },
                              "name": {
                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                "type": "string"
                              },
                              "namespace": {
                                "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                "type": "string"
                              }
                            }
                          }
                        }
                      },
                      "retryPolicy": {
                        "description": "Specifies the retry policy associated with this route.",
                        "type": "object",
                        "properties": {
                          "numRetries": {
                            "description": "Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.",
                            "type": "integer"
                          },
                          "perTryTimeout": {
                            "description": "Specifies a non-zero timeout per retry attempt.\n\nIf not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,\nwill use the largest timeout among all backend services associated with the route.",
                            "type": "object",
                            "properties": {
                              "nanos": {
                                "description": "Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are\nrepresented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.",
                                "type": "integer"
                              },
                              "seconds": {
                                "description": "Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.\nNote: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.",
                                "type": "string"
                              }
                            }
                          },
                          "retryConditions": {
                            "description": "Specfies one or more conditions when this retry rule applies. Valid values are:\n\n* 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,\n  or if the backend service does not respond at all, example: disconnects, reset, read timeout,\n* connection failure, and refused streams.\n* gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.\n* connect-failure: Loadbalancer will retry on failures connecting to backend services,\n  for example due to connection timeouts.\n* retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.\n  Currently the only retriable error supported is 409.\n* refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.\n  This reset type indicates that it is safe to retry.\n* cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled\n* deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded\n* resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted\n* unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "timeout": {
                        "description": "Specifies the timeout for the selected route. Timeout is computed from the time the request has been\nfully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.\n\nIf not specified, will use the largest timeout among all backend services associated with the route.",
                        "type": "object",
                        "properties": {
                          "nanos": {
                            "description": "Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented\nwith a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.",
                            "type": "integer"
                          },
                          "seconds": {
                            "description": "Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.\nNote: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.",
                            "type": "string"
                          }
                        }
                      },
                      "urlRewrite": {
                        "description": "The spec to modify the URL of the request, prior to forwarding the request to the matched service.",
                        "type": "object",
                        "properties": {
                          "hostRewrite": {
                            "description": "Prior to forwarding the request to the selected service, the request's host header is replaced\nwith contents of hostRewrite.\n\nThe value must be between 1 and 255 characters.",
                            "type": "string"
                          },
                          "pathPrefixRewrite": {
                            "description": "Prior to forwarding the request to the selected backend service, the matching portion of the\nrequest's path is replaced by pathPrefixRewrite.\n\nThe value must be between 1 and 1024 characters.",
                            "type": "string"
                          }
                        }
                      },
                      "weightedBackendServices": {
                        "description": "A list of weighted backend services to send traffic to when a route match occurs.\nThe weights determine the fraction of traffic that flows to their corresponding backend service.\nIf all traffic needs to go to a single backend service, there must be one weightedBackendService\nwith weight set to a non 0 number.\n\nOnce a backendService is identified and before forwarding the request to the backend service,\nadvanced routing actions like Url rewrites and header transformations are applied depending on\nadditional settings specified in this HttpRouteAction.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "backendServiceRef": {
                              "description": "The default backend service resource.\nBefore forwarding the request to backendService, the loadbalancer\napplies any relevant headerActions specified as part of this\nbackendServiceWeight.",
                              "type": "object",
                              "properties": {
                                "external": {
                                  "description": "The name of a ComputeBackendService.",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                  "type": "string"
                                },
                                "namespace": {
                                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                  "type": "string"
                                }
                              }
                            },
                            "headerAction": {
                              "description": "Specifies changes to request and response headers that need to take effect for\nthe selected backendService.\n\nheaderAction specified here take effect before headerAction in the enclosing\nHttpRouteRule, PathMatcher and UrlMap.",
                              "type": "object",
                              "properties": {
                                "requestHeadersToAdd": {
                                  "description": "Headers to add to a matching request prior to forwarding the request to the backendService.",
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "headerName": {
                                        "description": "The name of the header to add.",
                                        "type": "string"
                                      },
                                      "headerValue": {
                                        "description": "The value of the header to add.",
                                        "type": "string"
                                      },
                                      "replace": {
                                        "description": "If false, headerValue is appended to any values that already exist for the header.\nIf true, headerValue is set for the header, discarding any values that were set for that header.",
                                        "type": "boolean"
                                      }
                                    }
                                  }
                                },
                                "requestHeadersToRemove": {
                                  "description": "A list of header names for headers that need to be removed from the request prior to\nforwarding the request to the backendService.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "responseHeadersToAdd": {
                                  "description": "Headers to add the response prior to sending the response back to the client.",
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "headerName": {
                                        "description": "The name of the header to add.",
                                        "type": "string"
                                      },
                                      "headerValue": {
                                        "description": "The value of the header to add.",
                                        "type": "string"
                                      },
                                      "replace": {
                                        "description": "If false, headerValue is appended to any values that already exist for the header.\nIf true, headerValue is set for the header, discarding any values that were set for that header.",
                                        "type": "boolean"
                                      }
                                    }
                                  }
                                },
                                "responseHeadersToRemove": {
                                  "description": "A list of header names for headers that need to be removed from the response prior to sending the\nresponse back to the client.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "weight": {
                              "description": "Specifies the fraction of traffic sent to backendService, computed as\nweight / (sum of all weightedBackendService weights in routeAction) .\n\nThe selection of a backend service is determined only for new traffic. Once a user's request\nhas been directed to a backendService, subsequent requests will be sent to the same backendService\nas determined by the BackendService's session affinity policy.\n\nThe value must be between 0 and 1000.",
                              "type": "integer"
                            }
                          }
                        }
                      }
                    }
                  },
                  "defaultService": {
                    "description": "The default service to use if none of the pathRules defined by this\nPathMatcher is matched by the URL's path portion.\nFor the Global URL Map, it should be a reference to the backend\nservice or backend bucket.\nFor the Regional URL Map, it should be a reference to the backend\nservice.",
                    "type": "object",
                    "properties": {
                      "backendBucketRef": {
                        "type": "object",
                        "properties": {
                          "external": {
                            "description": "The selfLink of a ComputeBackendBucket.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          }
                        }
                      },
                      "backendServiceRef": {
                        "type": "object",
                        "properties": {
                          "external": {
                            "description": "The selfLink of a ComputeBackendService.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "defaultUrlRedirect": {
                    "description": "When none of the specified hostRules match, the request is redirected to a URL specified\nby defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or\ndefaultRouteAction must not be set.",
                    "type": "object",
                    "required": ["stripQuery"],
                    "properties": {
                      "hostRedirect": {
                        "description": "The host that will be used in the redirect response instead of the one that was\nsupplied in the request. The value must be between 1 and 255 characters.",
                        "type": "string"
                      },
                      "httpsRedirect": {
                        "description": "If set to true, the URL scheme in the redirected request is set to https. If set to\nfalse, the URL scheme of the redirected request will remain the same as that of the\nrequest. This must only be set for UrlMaps used in TargetHttpProxys. Setting this\ntrue for TargetHttpsProxy is not permitted. The default is set to false.",
                        "type": "boolean"
                      },
                      "pathRedirect": {
                        "description": "The path that will be used in the redirect response instead of the one that was\nsupplied in the request. pathRedirect cannot be supplied together with\nprefixRedirect. Supply one alone or neither. If neither is supplied, the path of the\noriginal request will be used for the redirect. The value must be between 1 and 1024\ncharacters.",
                        "type": "string"
                      },
                      "prefixRedirect": {
                        "description": "The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,\nretaining the remaining portion of the URL before redirecting the request.\nprefixRedirect cannot be supplied together with pathRedirect. Supply one alone or\nneither. If neither is supplied, the path of the original request will be used for\nthe redirect. The value must be between 1 and 1024 characters.",
                        "type": "string"
                      },
                      "redirectResponseCode": {
                        "description": "The HTTP Status code to use for this RedirectAction. Supported values are:\n\n* MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.\n\n* FOUND, which corresponds to 302.\n\n* SEE_OTHER which corresponds to 303.\n\n* TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method\nwill be retained.\n\n* PERMANENT_REDIRECT, which corresponds to 308. In this case,\nthe request method will be retained. Possible values: [\"FOUND\", \"MOVED_PERMANENTLY_DEFAULT\", \"PERMANENT_REDIRECT\", \"SEE_OTHER\", \"TEMPORARY_REDIRECT\"].",
                        "type": "string"
                      },
                      "stripQuery": {
                        "description": "If set to true, any accompanying query portion of the original URL is removed prior\nto redirecting the request. If set to false, the query portion of the original URL is\nretained.\n This field is required to ensure an empty block is not set. The normal default value is false.",
                        "type": "boolean"
                      }
                    }
                  },
                  "description": {
                    "description": "An optional description of this resource.",
                    "type": "string"
                  },
                  "headerAction": {
                    "description": "Specifies changes to request and response headers that need to take effect for\nthe selected backendService. HeaderAction specified here are applied after the\nmatching HttpRouteRule HeaderAction and before the HeaderAction in the UrlMap.",
                    "type": "object",
                    "properties": {
                      "requestHeadersToAdd": {
                        "description": "Headers to add to a matching request prior to forwarding the request to the\nbackendService.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "required": ["headerName", "headerValue", "replace"],
                          "properties": {
                            "headerName": {
                              "description": "The name of the header.",
                              "type": "string"
                            },
                            "headerValue": {
                              "description": "The value of the header to add.",
                              "type": "string"
                            },
                            "replace": {
                              "description": "If false, headerValue is appended to any values that already exist for the\nheader. If true, headerValue is set for the header, discarding any values that\nwere set for that header.",
                              "type": "boolean"
                            }
                          }
                        }
                      },
                      "requestHeadersToRemove": {
                        "description": "A list of header names for headers that need to be removed from the request\nprior to forwarding the request to the backendService.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "responseHeadersToAdd": {
                        "description": "Headers to add the response prior to sending the response back to the client.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "required": ["headerName", "headerValue", "replace"],
                          "properties": {
                            "headerName": {
                              "description": "The name of the header.",
                              "type": "string"
                            },
                            "headerValue": {
                              "description": "The value of the header to add.",
                              "type": "string"
                            },
                            "replace": {
                              "description": "If false, headerValue is appended to any values that already exist for the\nheader. If true, headerValue is set for the header, discarding any values that\nwere set for that header.",
                              "type": "boolean"
                            }
                          }
                        }
                      },
                      "responseHeadersToRemove": {
                        "description": "A list of header names for headers that need to be removed from the response\nprior to sending the response back to the client.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "name": {
                    "description": "The name to which this PathMatcher is referred by the HostRule.",
                    "type": "string"
                  },
                  "pathRule": {
                    "description": "The list of path rules. Use this list instead of routeRules when routing based\non simple path matching is all that's required. The order by which path rules\nare specified does not matter. Matches are always done on the longest-path-first\nbasis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*\nirrespective of the order in which those paths appear in this list. Within a\ngiven pathMatcher, only one of pathRules or routeRules must be set.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": ["paths"],
                      "properties": {
                        "paths": {
                          "description": "The list of path patterns to match. Each must start with / and the only place a\n\\* is allowed is at the end following a /. The string fed to the path matcher\ndoes not include any text after the first ? or #, and those chars are not\nallowed here.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "routeAction": {
                          "description": "In response to a matching path, the load balancer performs advanced routing\nactions like URL rewrites, header transformations, etc. prior to forwarding the\nrequest to the selected backend. If routeAction specifies any\nweightedBackendServices, service must not be set. Conversely if service is set,\nrouteAction cannot contain any  weightedBackendServices. Only one of routeAction\nor urlRedirect must be set.",
                          "type": "object",
                          "properties": {
                            "corsPolicy": {
                              "description": "The specification for allowing client side cross-origin requests. Please see W3C\nRecommendation for Cross Origin Resource Sharing.",
                              "type": "object",
                              "required": ["disabled"],
                              "properties": {
                                "allowCredentials": {
                                  "description": "In response to a preflight request, setting this to true indicates that the\nactual request can include user credentials. This translates to the Access-\nControl-Allow-Credentials header. Defaults to false.",
                                  "type": "boolean"
                                },
                                "allowHeaders": {
                                  "description": "Specifies the content for the Access-Control-Allow-Headers header.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "allowMethods": {
                                  "description": "Specifies the content for the Access-Control-Allow-Methods header.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "allowOriginRegexes": {
                                  "description": "Specifies the regular expression patterns that match allowed origins. For\nregular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript\nAn origin is allowed if it matches either allow_origins or allow_origin_regex.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "allowOrigins": {
                                  "description": "Specifies the list of origins that will be allowed to do CORS requests. An\norigin is allowed if it matches either allow_origins or allow_origin_regex.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "disabled": {
                                  "description": "If true, specifies the CORS policy is disabled.",
                                  "type": "boolean"
                                },
                                "exposeHeaders": {
                                  "description": "Specifies the content for the Access-Control-Expose-Headers header.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "maxAge": {
                                  "description": "Specifies how long the results of a preflight request can be cached. This\ntranslates to the content for the Access-Control-Max-Age header.",
                                  "type": "integer"
                                }
                              }
                            },
                            "faultInjectionPolicy": {
                              "description": "The specification for fault injection introduced into traffic to test the\nresiliency of clients to backend service failure. As part of fault injection,\nwhen clients send requests to a backend service, delays can be introduced by\nLoadbalancer on a percentage of requests before sending those request to the\nbackend service. Similarly requests from clients can be aborted by the\nLoadbalancer for a percentage of requests. timeout and retry_policy will be\nignored by clients that are configured with a fault_injection_policy.",
                              "type": "object",
                              "properties": {
                                "abort": {
                                  "description": "The specification for how client requests are aborted as part of fault\ninjection.",
                                  "type": "object",
                                  "required": ["httpStatus", "percentage"],
                                  "properties": {
                                    "httpStatus": {
                                      "description": "The HTTP status code used to abort the request. The value must be between 200\nand 599 inclusive.",
                                      "type": "integer"
                                    },
                                    "percentage": {
                                      "description": "The percentage of traffic (connections/operations/requests) which will be\naborted as part of fault injection. The value must be between 0.0 and 100.0\ninclusive.",
                                      "type": "number"
                                    }
                                  }
                                },
                                "delay": {
                                  "description": "The specification for how client requests are delayed as part of fault\ninjection, before being sent to a backend service.",
                                  "type": "object",
                                  "required": ["fixedDelay", "percentage"],
                                  "properties": {
                                    "fixedDelay": {
                                      "description": "Specifies the value of the fixed delay interval.",
                                      "type": "object",
                                      "required": ["seconds"],
                                      "properties": {
                                        "nanos": {
                                          "description": "Span of time that's a fraction of a second at nanosecond resolution. Durations\nless than one second are represented with a 0 'seconds' field and a positive\n'nanos' field. Must be from 0 to 999,999,999 inclusive.",
                                          "type": "integer"
                                        },
                                        "seconds": {
                                          "description": "Span of time at a resolution of a second. Must be from 0 to 315,576,000,000\ninclusive.",
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "percentage": {
                                      "description": "The percentage of traffic (connections/operations/requests) on which delay will\nbe introduced as part of fault injection. The value must be between 0.0 and\n100.0 inclusive.",
                                      "type": "number"
                                    }
                                  }
                                }
                              }
                            },
                            "requestMirrorPolicy": {
                              "description": "Specifies the policy on how requests intended for the route's backends are\nshadowed to a separate mirrored backend service. Loadbalancer does not wait for\nresponses from the shadow service. Prior to sending traffic to the shadow\nservice, the host / authority header is suffixed with -shadow.",
                              "type": "object",
                              "required": ["backendServiceRef"],
                              "properties": {
                                "backendServiceRef": {
                                  "description": "Required. The backend service resource being mirrored to.",
                                  "type": "object",
                                  "properties": {
                                    "external": {
                                      "description": "The selfLink of a ComputeBackendService.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "retryPolicy": {
                              "description": "Specifies the retry policy associated with this route.",
                              "type": "object",
                              "properties": {
                                "numRetries": {
                                  "description": "Specifies the allowed number retries. This number must be > 0.",
                                  "type": "integer"
                                },
                                "perTryTimeout": {
                                  "description": "Specifies a non-zero timeout per retry attempt.",
                                  "type": "object",
                                  "required": ["seconds"],
                                  "properties": {
                                    "nanos": {
                                      "description": "Span of time that's a fraction of a second at nanosecond resolution. Durations\nless than one second are represented with a 0 'seconds' field and a positive\n'nanos' field. Must be from 0 to 999,999,999 inclusive.",
                                      "type": "integer"
                                    },
                                    "seconds": {
                                      "description": "Span of time at a resolution of a second. Must be from 0 to 315,576,000,000\ninclusive.",
                                      "type": "string"
                                    }
                                  }
                                },
                                "retryConditions": {
                                  "description": "Specifies one or more conditions when this retry rule applies. Valid values are:\n\n- 5xx: Loadbalancer will attempt a retry if the backend service responds with\nany 5xx response code, or if the backend service does not respond at all,\nexample: disconnects, reset, read timeout, connection failure, and refused\nstreams.\n- gateway-error: Similar to 5xx, but only applies to response codes\n502, 503 or 504.\n- connect-failure: Loadbalancer will retry on failures\nconnecting to backend services, for example due to connection timeouts.\n- retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.\nCurrently the only retriable error supported is 409.\n- refused-stream: Loadbalancer will retry if the backend service resets the stream with a\nREFUSED_STREAM error code. This reset type indicates that it is safe to retry.\n- cancelled: Loadbalancer will retry if the gRPC status code in the response\nheader is set to cancelled\n- deadline-exceeded: Loadbalancer will retry if the\ngRPC status code in the response header is set to deadline-exceeded\n- resource-exhausted: Loadbalancer will retry if the gRPC status code in the response\nheader is set to resource-exhausted\n- unavailable: Loadbalancer will retry if\nthe gRPC status code in the response header is set to unavailable.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "timeout": {
                              "description": "Specifies the timeout for the selected route. Timeout is computed from the time\nthe request is has been fully processed (i.e. end-of-stream) up until the\nresponse has been completely processed. Timeout includes all retries. If not\nspecified, the default value is 15 seconds.",
                              "type": "object",
                              "required": ["seconds"],
                              "properties": {
                                "nanos": {
                                  "description": "Span of time that's a fraction of a second at nanosecond resolution. Durations\nless than one second are represented with a 0 'seconds' field and a positive\n'nanos' field. Must be from 0 to 999,999,999 inclusive.",
                                  "type": "integer"
                                },
                                "seconds": {
                                  "description": "Span of time at a resolution of a second. Must be from 0 to 315,576,000,000\ninclusive.",
                                  "type": "string"
                                }
                              }
                            },
                            "urlRewrite": {
                              "description": "The spec to modify the URL of the request, prior to forwarding the request to\nthe matched service.",
                              "type": "object",
                              "properties": {
                                "hostRewrite": {
                                  "description": "Prior to forwarding the request to the selected service, the request's host\nheader is replaced with contents of hostRewrite. The value must be between 1 and\n255 characters.",
                                  "type": "string"
                                },
                                "pathPrefixRewrite": {
                                  "description": "Prior to forwarding the request to the selected backend service, the matching\nportion of the request's path is replaced by pathPrefixRewrite. The value must\nbe between 1 and 1024 characters.",
                                  "type": "string"
                                }
                              }
                            },
                            "weightedBackendServices": {
                              "description": "A list of weighted backend services to send traffic to when a route match\noccurs. The weights determine the fraction of traffic that flows to their\ncorresponding backend service. If all traffic needs to go to a single backend\nservice, there must be one  weightedBackendService with weight set to a non 0\nnumber. Once a backendService is identified and before forwarding the request to\nthe backend service, advanced routing actions like Url rewrites and header\ntransformations are applied depending on additional settings specified in this\nHttpRouteAction.",
                              "type": "array",
                              "items": {
                                "type": "object",
                                "required": ["backendServiceRef", "weight"],
                                "properties": {
                                  "backendServiceRef": {
                                    "description": "Required. The default backend service resource. Before forwarding\nthe request to backendService, the loadbalancer applies any relevant\nheaderActions specified as part of this backendServiceWeight.",
                                    "type": "object",
                                    "properties": {
                                      "external": {
                                        "description": "The selfLink of a ComputeBackendService.",
                                        "type": "string"
                                      },
                                      "name": {
                                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                        "type": "string"
                                      },
                                      "namespace": {
                                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "headerAction": {
                                    "description": "Specifies changes to request and response headers that need to take effect for\nthe selected backendService. headerAction specified here take effect before\nheaderAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.",
                                    "type": "object",
                                    "properties": {
                                      "requestHeadersToAdd": {
                                        "description": "Headers to add to a matching request prior to forwarding the request to the\nbackendService.",
                                        "type": "array",
                                        "items": {
                                          "type": "object",
                                          "required": [
                                            "headerName",
                                            "headerValue",
                                            "replace"
                                          ],
                                          "properties": {
                                            "headerName": {
                                              "description": "The name of the header.",
                                              "type": "string"
                                            },
                                            "headerValue": {
                                              "description": "The value of the header to add.",
                                              "type": "string"
                                            },
                                            "replace": {
                                              "description": "If false, headerValue is appended to any values that already exist for the\nheader. If true, headerValue is set for the header, discarding any values that\nwere set for that header.",
                                              "type": "boolean"
                                            }
                                          }
                                        }
                                      },
                                      "requestHeadersToRemove": {
                                        "description": "A list of header names for headers that need to be removed from the request\nprior to forwarding the request to the backendService.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "responseHeadersToAdd": {
                                        "description": "Headers to add the response prior to sending the response back to the client.",
                                        "type": "array",
                                        "items": {
                                          "type": "object",
                                          "required": [
                                            "headerName",
                                            "headerValue",
                                            "replace"
                                          ],
                                          "properties": {
                                            "headerName": {
                                              "description": "The name of the header.",
                                              "type": "string"
                                            },
                                            "headerValue": {
                                              "description": "The value of the header to add.",
                                              "type": "string"
                                            },
                                            "replace": {
                                              "description": "If false, headerValue is appended to any values that already exist for the\nheader. If true, headerValue is set for the header, discarding any values that\nwere set for that header.",
                                              "type": "boolean"
                                            }
                                          }
                                        }
                                      },
                                      "responseHeadersToRemove": {
                                        "description": "A list of header names for headers that need to be removed from the response\nprior to sending the response back to the client.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      }
                                    }
                                  },
                                  "weight": {
                                    "description": "Specifies the fraction of traffic sent to backendService, computed as weight /\n(sum of all weightedBackendService weights in routeAction) . The selection of a\nbackend service is determined only for new traffic. Once a user's request has\nbeen directed to a backendService, subsequent requests will be sent to the same\nbackendService as determined by the BackendService's session affinity policy.\nThe value must be between 0 and 1000.",
                                    "type": "integer"
                                  }
                                }
                              }
                            }
                          }
                        },
                        "service": {
                          "description": "The backend service to which traffic is directed if this rule is\nmatched.\nFor the Global URL Map, it should be a reference to the backend\nservice or backend bucket.\nFor the Regional URL Map, it should be a reference to the backend\nservice.\nIf routeAction is additionally specified, advanced routing actions\nlike URL Rewrites, etc. take effect prior to sending the request to\nthe backend. However, if service is specified, routeAction cannot\ncontain any weightedBackendServices. Conversely, if routeAction\nspecifies any weightedBackendServices, service must not be\nspecified. Only one of urlRedirect, service or\nrouteAction.weightedBackendService must be set.",
                          "type": "object",
                          "properties": {
                            "backendBucketRef": {
                              "type": "object",
                              "properties": {
                                "external": {
                                  "description": "The selfLink of a ComputeBackendBucket.",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                  "type": "string"
                                },
                                "namespace": {
                                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                  "type": "string"
                                }
                              }
                            },
                            "backendServiceRef": {
                              "type": "object",
                              "properties": {
                                "external": {
                                  "description": "The selfLink of a ComputeBackendService.",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                  "type": "string"
                                },
                                "namespace": {
                                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                  "type": "string"
                                }
                              }
                            }
                          }
                        },
                        "urlRedirect": {
                          "description": "When a path pattern is matched, the request is redirected to a URL specified\nby urlRedirect. If urlRedirect is specified, service or routeAction must not\nbe set.",
                          "type": "object",
                          "required": ["stripQuery"],
                          "properties": {
                            "hostRedirect": {
                              "description": "The host that will be used in the redirect response instead of the one\nthat was supplied in the request. The value must be between 1 and 255\ncharacters.",
                              "type": "string"
                            },
                            "httpsRedirect": {
                              "description": "If set to true, the URL scheme in the redirected request is set to https.\nIf set to false, the URL scheme of the redirected request will remain the\nsame as that of the request. This must only be set for UrlMaps used in\nTargetHttpProxys. Setting this true for TargetHttpsProxy is not\npermitted. The default is set to false.",
                              "type": "boolean"
                            },
                            "pathRedirect": {
                              "description": "The path that will be used in the redirect response instead of the one\nthat was supplied in the request. pathRedirect cannot be supplied\ntogether with prefixRedirect. Supply one alone or neither. If neither is\nsupplied, the path of the original request will be used for the redirect.\nThe value must be between 1 and 1024 characters.",
                              "type": "string"
                            },
                            "prefixRedirect": {
                              "description": "The prefix that replaces the prefixMatch specified in the\nHttpRouteRuleMatch, retaining the remaining portion of the URL before\nredirecting the request. prefixRedirect cannot be supplied together with\npathRedirect. Supply one alone or neither. If neither is supplied, the\npath of the original request will be used for the redirect. The value\nmust be between 1 and 1024 characters.",
                              "type": "string"
                            },
                            "redirectResponseCode": {
                              "description": "The HTTP Status code to use for this RedirectAction. Supported values are:\n\n* MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.\n\n* FOUND, which corresponds to 302.\n\n* SEE_OTHER which corresponds to 303.\n\n* TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method\nwill be retained.\n\n* PERMANENT_REDIRECT, which corresponds to 308. In this case,\nthe request method will be retained. Possible values: [\"FOUND\", \"MOVED_PERMANENTLY_DEFAULT\", \"PERMANENT_REDIRECT\", \"SEE_OTHER\", \"TEMPORARY_REDIRECT\"].",
                              "type": "string"
                            },
                            "stripQuery": {
                              "description": "If set to true, any accompanying query portion of the original URL is removed\nprior to redirecting the request. If set to false, the query portion of the\noriginal URL is retained.\n This field is required to ensure an empty block is not set. The normal default value is false.",
                              "type": "boolean"
                            }
                          }
                        }
                      }
                    }
                  },
                  "routeRules": {
                    "description": "The list of ordered HTTP route rules. Use this list instead of pathRules when\nadvanced route matching and routing actions are desired. The order of specifying\nrouteRules matters: the first rule that matches will cause its specified routing\naction to take effect. Within a given pathMatcher, only one of pathRules or\nrouteRules must be set. routeRules are not supported in UrlMaps intended for\nExternal load balancers.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": ["priority"],
                      "properties": {
                        "headerAction": {
                          "description": "Specifies changes to request and response headers that need to take effect for\nthe selected backendService. The headerAction specified here are applied before\nthe matching pathMatchers[].headerAction and after pathMatchers[].routeRules[].r\nouteAction.weightedBackendService.backendServiceWeightAction[].headerAction.",
                          "type": "object",
                          "properties": {
                            "requestHeadersToAdd": {
                              "description": "Headers to add to a matching request prior to forwarding the request to the\nbackendService.",
                              "type": "array",
                              "items": {
                                "type": "object",
                                "required": [
                                  "headerName",
                                  "headerValue",
                                  "replace"
                                ],
                                "properties": {
                                  "headerName": {
                                    "description": "The name of the header.",
                                    "type": "string"
                                  },
                                  "headerValue": {
                                    "description": "The value of the header to add.",
                                    "type": "string"
                                  },
                                  "replace": {
                                    "description": "If false, headerValue is appended to any values that already exist for the\nheader. If true, headerValue is set for the header, discarding any values that\nwere set for that header.",
                                    "type": "boolean"
                                  }
                                }
                              }
                            },
                            "requestHeadersToRemove": {
                              "description": "A list of header names for headers that need to be removed from the request\nprior to forwarding the request to the backendService.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "responseHeadersToAdd": {
                              "description": "Headers to add the response prior to sending the response back to the client.",
                              "type": "array",
                              "items": {
                                "type": "object",
                                "required": [
                                  "headerName",
                                  "headerValue",
                                  "replace"
                                ],
                                "properties": {
                                  "headerName": {
                                    "description": "The name of the header.",
                                    "type": "string"
                                  },
                                  "headerValue": {
                                    "description": "The value of the header to add.",
                                    "type": "string"
                                  },
                                  "replace": {
                                    "description": "If false, headerValue is appended to any values that already exist for the\nheader. If true, headerValue is set for the header, discarding any values that\nwere set for that header.",
                                    "type": "boolean"
                                  }
                                }
                              }
                            },
                            "responseHeadersToRemove": {
                              "description": "A list of header names for headers that need to be removed from the response\nprior to sending the response back to the client.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        },
                        "matchRules": {
                          "description": "The rules for determining a match.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "fullPathMatch": {
                                "description": "For satisfying the matchRule condition, the path of the request must exactly\nmatch the value specified in fullPathMatch after removing any query parameters\nand anchor that may be part of the original URL. FullPathMatch must be between 1\nand 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must\nbe specified.",
                                "type": "string"
                              },
                              "headerMatches": {
                                "description": "Specifies a list of header match criteria, all of which must match corresponding\nheaders in the request.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "required": ["headerName"],
                                  "properties": {
                                    "exactMatch": {
                                      "description": "The value should exactly match contents of exactMatch. Only one of exactMatch,\nprefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.",
                                      "type": "string"
                                    },
                                    "headerName": {
                                      "description": "The name of the HTTP header to match. For matching against the HTTP request's\nauthority, use a headerMatch with the header name \":authority\". For matching a\nrequest's method, use the headerName \":method\".",
                                      "type": "string"
                                    },
                                    "invertMatch": {
                                      "description": "If set to false, the headerMatch is considered a match if the match criteria\nabove are met. If set to true, the headerMatch is considered a match if the\nmatch criteria above are NOT met. Defaults to false.",
                                      "type": "boolean"
                                    },
                                    "prefixMatch": {
                                      "description": "The value of the header must start with the contents of prefixMatch. Only one of\nexactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch\nmust be set.",
                                      "type": "string"
                                    },
                                    "presentMatch": {
                                      "description": "A header with the contents of headerName must exist. The match takes place\nwhether or not the request's header has a value or not. Only one of exactMatch,\nprefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.",
                                      "type": "boolean"
                                    },
                                    "rangeMatch": {
                                      "description": "The header value must be an integer and its value must be in the range specified\nin rangeMatch. If the header does not contain an integer, number or is empty,\nthe match fails. For example for a range [-5, 0]\n\n* -3 will match\n* 0 will not match\n* 0.25 will not match\n* -3someString will not match.\n\nOnly one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or\nrangeMatch must be set.",
                                      "type": "object",
                                      "required": ["rangeEnd", "rangeStart"],
                                      "properties": {
                                        "rangeEnd": {
                                          "description": "The end of the range (exclusive).",
                                          "type": "integer"
                                        },
                                        "rangeStart": {
                                          "description": "The start of the range (inclusive).",
                                          "type": "integer"
                                        }
                                      }
                                    },
                                    "regexMatch": {
                                      "description": "The value of the header must match the regular expression specified in\nregexMatch. For regular expression grammar, please see:\nen.cppreference.com/w/cpp/regex/ecmascript  For matching against a port\nspecified in the HTTP request, use a headerMatch with headerName set to PORT and\na regular expression that satisfies the RFC2616 Host header's port specifier.\nOnly one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or\nrangeMatch must be set.",
                                      "type": "string"
                                    },
                                    "suffixMatch": {
                                      "description": "The value of the header must end with the contents of suffixMatch. Only one of\nexactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch\nmust be set.",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "ignoreCase": {
                                "description": "Specifies that prefixMatch and fullPathMatch matches are case sensitive.\nDefaults to false.",
                                "type": "boolean"
                              },
                              "metadataFilters": {
                                "description": "Opaque filter criteria used by Loadbalancer to restrict routing configuration to\na limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS\nclients present node metadata. If a match takes place, the relevant routing\nconfiguration is made available to those proxies. For each metadataFilter in\nthis list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the\nfilterLabels must match the corresponding label provided in the metadata. If its\nfilterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match\nwith corresponding labels in the provided metadata. metadataFilters specified\nhere can be overrides those specified in ForwardingRule that refers to this\nUrlMap. metadataFilters only applies to Loadbalancers that have their\nloadBalancingScheme set to INTERNAL_SELF_MANAGED.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "required": [
                                    "filterLabels",
                                    "filterMatchCriteria"
                                  ],
                                  "properties": {
                                    "filterLabels": {
                                      "description": "The list of label value pairs that must match labels in the provided metadata\nbased on filterMatchCriteria  This list must not be empty and can have at the\nmost 64 entries.",
                                      "type": "array",
                                      "items": {
                                        "type": "object",
                                        "required": ["name", "value"],
                                        "properties": {
                                          "name": {
                                            "description": "Name of metadata label. The name can have a maximum length of 1024 characters\nand must be at least 1 character long.",
                                            "type": "string"
                                          },
                                          "value": {
                                            "description": "The value of the label must match the specified value. value can have a maximum\nlength of 1024 characters.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    },
                                    "filterMatchCriteria": {
                                      "description": "Specifies how individual filterLabel matches within the list of filterLabels\ncontribute towards the overall metadataFilter match. Supported values are:\n\n* MATCH_ANY: At least one of the filterLabels must have a matching label in the\nprovided metadata.\n* MATCH_ALL: All filterLabels must have matching labels in\nthe provided metadata. Possible values: [\"MATCH_ALL\", \"MATCH_ANY\"].",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "prefixMatch": {
                                "description": "For satisfying the matchRule condition, the request's path must begin with the\nspecified prefixMatch. prefixMatch must begin with a /. The value must be\nbetween 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or\nregexMatch must be specified.",
                                "type": "string"
                              },
                              "queryParameterMatches": {
                                "description": "Specifies a list of query parameter match criteria, all of which must match\ncorresponding query parameters in the request.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "required": ["name"],
                                  "properties": {
                                    "exactMatch": {
                                      "description": "The queryParameterMatch matches if the value of the parameter exactly matches\nthe contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch\nmust be set.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "The name of the query parameter to match. The query parameter must exist in the\nrequest, in the absence of which the request match fails.",
                                      "type": "string"
                                    },
                                    "presentMatch": {
                                      "description": "Specifies that the queryParameterMatch matches if the request contains the query\nparameter, irrespective of whether the parameter has a value or not. Only one of\npresentMatch, exactMatch and regexMatch must be set.",
                                      "type": "boolean"
                                    },
                                    "regexMatch": {
                                      "description": "The queryParameterMatch matches if the value of the parameter matches the\nregular expression specified by regexMatch. For the regular expression grammar,\nplease see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,\nexactMatch and regexMatch must be set.",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "regexMatch": {
                                "description": "For satisfying the matchRule condition, the path of the request must satisfy the\nregular expression specified in regexMatch after removing any query parameters\nand anchor supplied with the original URL. For regular expression grammar please\nsee en.cppreference.com/w/cpp/regex/ecmascript  Only one of prefixMatch,\nfullPathMatch or regexMatch must be specified.",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "priority": {
                          "description": "For routeRules within a given pathMatcher, priority determines the order\nin which load balancer will interpret routeRules. RouteRules are evaluated\nin order of priority, from the lowest to highest number. The priority of\na rule decreases as its number increases (1, 2, 3, N+1). The first rule\nthat matches the request is applied.\n\nYou cannot configure two or more routeRules with the same priority.\nPriority for each rule must be set to a number between 0 and\n2147483647 inclusive.\n\nPriority numbers can have gaps, which enable you to add or remove rules\nin the future without affecting the rest of the rules. For example,\n1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which\nyou could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the\nfuture without any impact on existing rules.",
                          "type": "integer"
                        },
                        "routeAction": {
                          "description": "In response to a matching matchRule, the load balancer performs advanced routing\nactions like URL rewrites, header transformations, etc. prior to forwarding the\nrequest to the selected backend. If  routeAction specifies any\nweightedBackendServices, service must not be set. Conversely if service is set,\nrouteAction cannot contain any  weightedBackendServices. Only one of routeAction\nor urlRedirect must be set.",
                          "type": "object",
                          "properties": {
                            "corsPolicy": {
                              "description": "The specification for allowing client side cross-origin requests. Please see W3C\nRecommendation for Cross Origin Resource Sharing.",
                              "type": "object",
                              "properties": {
                                "allowCredentials": {
                                  "description": "In response to a preflight request, setting this to true indicates that the\nactual request can include user credentials. This translates to the Access-\nControl-Allow-Credentials header. Defaults to false.",
                                  "type": "boolean"
                                },
                                "allowHeaders": {
                                  "description": "Specifies the content for the Access-Control-Allow-Headers header.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "allowMethods": {
                                  "description": "Specifies the content for the Access-Control-Allow-Methods header.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "allowOriginRegexes": {
                                  "description": "Specifies the regular expression patterns that match allowed origins. For\nregular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript\nAn origin is allowed if it matches either allow_origins or allow_origin_regex.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "allowOrigins": {
                                  "description": "Specifies the list of origins that will be allowed to do CORS requests. An\norigin is allowed if it matches either allow_origins or allow_origin_regex.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "disabled": {
                                  "description": "If true, specifies the CORS policy is disabled.\nwhich indicates that the CORS policy is in effect. Defaults to false.",
                                  "type": "boolean"
                                },
                                "exposeHeaders": {
                                  "description": "Specifies the content for the Access-Control-Expose-Headers header.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "maxAge": {
                                  "description": "Specifies how long the results of a preflight request can be cached. This\ntranslates to the content for the Access-Control-Max-Age header.",
                                  "type": "integer"
                                }
                              }
                            },
                            "faultInjectionPolicy": {
                              "description": "The specification for fault injection introduced into traffic to test the\nresiliency of clients to backend service failure. As part of fault injection,\nwhen clients send requests to a backend service, delays can be introduced by\nLoadbalancer on a percentage of requests before sending those request to the\nbackend service. Similarly requests from clients can be aborted by the\nLoadbalancer for a percentage of requests. timeout and retry_policy will be\nignored by clients that are configured with a fault_injection_policy.",
                              "type": "object",
                              "properties": {
                                "abort": {
                                  "description": "The specification for how client requests are aborted as part of fault\ninjection.",
                                  "type": "object",
                                  "properties": {
                                    "httpStatus": {
                                      "description": "The HTTP status code used to abort the request. The value must be between 200\nand 599 inclusive.",
                                      "type": "integer"
                                    },
                                    "percentage": {
                                      "description": "The percentage of traffic (connections/operations/requests) which will be\naborted as part of fault injection. The value must be between 0.0 and 100.0\ninclusive.",
                                      "type": "number"
                                    }
                                  }
                                },
                                "delay": {
                                  "description": "The specification for how client requests are delayed as part of fault\ninjection, before being sent to a backend service.",
                                  "type": "object",
                                  "properties": {
                                    "fixedDelay": {
                                      "description": "Specifies the value of the fixed delay interval.",
                                      "type": "object",
                                      "required": ["seconds"],
                                      "properties": {
                                        "nanos": {
                                          "description": "Span of time that's a fraction of a second at nanosecond resolution. Durations\nless than one second are represented with a 0 'seconds' field and a positive\n'nanos' field. Must be from 0 to 999,999,999 inclusive.",
                                          "type": "integer"
                                        },
                                        "seconds": {
                                          "description": "Span of time at a resolution of a second. Must be from 0 to 315,576,000,000\ninclusive.",
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "percentage": {
                                      "description": "The percentage of traffic (connections/operations/requests) on which delay will\nbe introduced as part of fault injection. The value must be between 0.0 and\n100.0 inclusive.",
                                      "type": "number"
                                    }
                                  }
                                }
                              }
                            },
                            "requestMirrorPolicy": {
                              "description": "Specifies the policy on how requests intended for the route's backends are\nshadowed to a separate mirrored backend service. Loadbalancer does not wait for\nresponses from the shadow service. Prior to sending traffic to the shadow\nservice, the host / authority header is suffixed with -shadow.",
                              "type": "object",
                              "required": ["backendServiceRef"],
                              "properties": {
                                "backendServiceRef": {
                                  "description": "Required. The backend service resource being mirrored to.",
                                  "type": "object",
                                  "properties": {
                                    "external": {
                                      "description": "The selfLink of a ComputeBackendService.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "retryPolicy": {
                              "description": "Specifies the retry policy associated with this route.",
                              "type": "object",
                              "required": ["numRetries"],
                              "properties": {
                                "numRetries": {
                                  "description": "Specifies the allowed number retries. This number must be > 0.",
                                  "type": "integer"
                                },
                                "perTryTimeout": {
                                  "description": "Specifies a non-zero timeout per retry attempt.",
                                  "type": "object",
                                  "required": ["seconds"],
                                  "properties": {
                                    "nanos": {
                                      "description": "Span of time that's a fraction of a second at nanosecond resolution. Durations\nless than one second are represented with a 0 'seconds' field and a positive\n'nanos' field. Must be from 0 to 999,999,999 inclusive.",
                                      "type": "integer"
                                    },
                                    "seconds": {
                                      "description": "Span of time at a resolution of a second. Must be from 0 to 315,576,000,000\ninclusive.",
                                      "type": "string"
                                    }
                                  }
                                },
                                "retryConditions": {
                                  "description": "Specifies one or more conditions when this retry rule applies. Valid values are:\n\n* 5xx: Loadbalancer will attempt a retry if the backend service responds with\n  any 5xx response code, or if the backend service does not respond at all,\n  example: disconnects, reset, read timeout, connection failure, and refused\n  streams.\n* gateway-error: Similar to 5xx, but only applies to response codes\n  502, 503 or 504.\n* connect-failure: Loadbalancer will retry on failures\n  connecting to backend services, for example due to connection timeouts.\n* retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.\n  Currently the only retriable error supported is 409.\n* refused-stream: Loadbalancer will retry if the backend service resets the stream with a\n  REFUSED_STREAM error code. This reset type indicates that it is safe to retry.\n* cancelled: Loadbalancer will retry if the gRPC status code in the response\n  header is set to cancelled\n* deadline-exceeded: Loadbalancer will retry if the\n  gRPC status code in the response header is set to deadline-exceeded\n* resource-exhausted: Loadbalancer will retry if the gRPC status code in the response\n  header is set to resource-exhausted\n* unavailable: Loadbalancer will retry if the gRPC status code in\n  the response header is set to unavailable.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "timeout": {
                              "description": "Specifies the timeout for the selected route. Timeout is computed from the time\nthe request is has been fully processed (i.e. end-of-stream) up until the\nresponse has been completely processed. Timeout includes all retries. If not\nspecified, the default value is 15 seconds.",
                              "type": "object",
                              "required": ["seconds"],
                              "properties": {
                                "nanos": {
                                  "description": "Span of time that's a fraction of a second at nanosecond resolution. Durations\nless than one second are represented with a 0 'seconds' field and a positive\n'nanos' field. Must be from 0 to 999,999,999 inclusive.",
                                  "type": "integer"
                                },
                                "seconds": {
                                  "description": "Span of time at a resolution of a second. Must be from 0 to 315,576,000,000\ninclusive.",
                                  "type": "string"
                                }
                              }
                            },
                            "urlRewrite": {
                              "description": "The spec to modify the URL of the request, prior to forwarding the request to\nthe matched service.",
                              "type": "object",
                              "properties": {
                                "hostRewrite": {
                                  "description": "Prior to forwarding the request to the selected service, the request's host\nheader is replaced with contents of hostRewrite. The value must be between 1 and\n255 characters.",
                                  "type": "string"
                                },
                                "pathPrefixRewrite": {
                                  "description": "Prior to forwarding the request to the selected backend service, the matching\nportion of the request's path is replaced by pathPrefixRewrite. The value must\nbe between 1 and 1024 characters.",
                                  "type": "string"
                                }
                              }
                            },
                            "weightedBackendServices": {
                              "description": "A list of weighted backend services to send traffic to when a route match\noccurs. The weights determine the fraction of traffic that flows to their\ncorresponding backend service. If all traffic needs to go to a single backend\nservice, there must be one  weightedBackendService with weight set to a non 0\nnumber. Once a backendService is identified and before forwarding the request to\nthe backend service, advanced routing actions like Url rewrites and header\ntransformations are applied depending on additional settings specified in this\nHttpRouteAction.",
                              "type": "array",
                              "items": {
                                "type": "object",
                                "required": ["backendServiceRef", "weight"],
                                "properties": {
                                  "backendServiceRef": {
                                    "description": "Required. The default backend service resource. Before forwarding\nthe request to backendService, the loadbalancer applies any relevant\nheaderActions specified as part of this backendServiceWeight.",
                                    "type": "object",
                                    "properties": {
                                      "external": {
                                        "description": "The selfLink of a ComputeBackendService.",
                                        "type": "string"
                                      },
                                      "name": {
                                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                        "type": "string"
                                      },
                                      "namespace": {
                                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "headerAction": {
                                    "description": "Specifies changes to request and response headers that need to take effect for\nthe selected backendService. headerAction specified here take effect before\nheaderAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.",
                                    "type": "object",
                                    "properties": {
                                      "requestHeadersToAdd": {
                                        "description": "Headers to add to a matching request prior to forwarding the request to the\nbackendService.",
                                        "type": "array",
                                        "items": {
                                          "type": "object",
                                          "required": [
                                            "headerName",
                                            "headerValue",
                                            "replace"
                                          ],
                                          "properties": {
                                            "headerName": {
                                              "description": "The name of the header.",
                                              "type": "string"
                                            },
                                            "headerValue": {
                                              "description": "The value of the header to add.",
                                              "type": "string"
                                            },
                                            "replace": {
                                              "description": "If false, headerValue is appended to any values that already exist for the\nheader. If true, headerValue is set for the header, discarding any values that\nwere set for that header.",
                                              "type": "boolean"
                                            }
                                          }
                                        }
                                      },
                                      "requestHeadersToRemove": {
                                        "description": "A list of header names for headers that need to be removed from the request\nprior to forwarding the request to the backendService.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "responseHeadersToAdd": {
                                        "description": "Headers to add the response prior to sending the response back to the client.",
                                        "type": "array",
                                        "items": {
                                          "type": "object",
                                          "required": [
                                            "headerName",
                                            "headerValue",
                                            "replace"
                                          ],
                                          "properties": {
                                            "headerName": {
                                              "description": "The name of the header.",
                                              "type": "string"
                                            },
                                            "headerValue": {
                                              "description": "The value of the header to add.",
                                              "type": "string"
                                            },
                                            "replace": {
                                              "description": "If false, headerValue is appended to any values that already exist for the\nheader. If true, headerValue is set for the header, discarding any values that\nwere set for that header.",
                                              "type": "boolean"
                                            }
                                          }
                                        }
                                      },
                                      "responseHeadersToRemove": {
                                        "description": "A list of header names for headers that need to be removed from the response\nprior to sending the response back to the client.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      }
                                    }
                                  },
                                  "weight": {
                                    "description": "Specifies the fraction of traffic sent to backendService, computed as weight /\n(sum of all weightedBackendService weights in routeAction) . The selection of a\nbackend service is determined only for new traffic. Once a user's request has\nbeen directed to a backendService, subsequent requests will be sent to the same\nbackendService as determined by the BackendService's session affinity policy.\nThe value must be between 0 and 1000.",
                                    "type": "integer"
                                  }
                                }
                              }
                            }
                          }
                        },
                        "service": {
                          "description": "The region backend service resource to which traffic is\ndirected if this rule is matched. If routeAction is additionally specified,\nadvanced routing actions like URL Rewrites, etc. take effect prior to sending\nthe request to the backend. However, if service is specified, routeAction cannot\ncontain any weightedBackendService s. Conversely, if routeAction specifies any\nweightedBackendServices, service must not be specified. Only one of urlRedirect,\nservice or routeAction.weightedBackendService must be set.",
                          "type": "string"
                        },
                        "urlRedirect": {
                          "description": "When this rule is matched, the request is redirected to a URL specified by\nurlRedirect. If urlRedirect is specified, service or routeAction must not be\nset.",
                          "type": "object",
                          "properties": {
                            "hostRedirect": {
                              "description": "The host that will be used in the redirect response instead of the one\nthat was supplied in the request. The value must be between 1 and 255\ncharacters.",
                              "type": "string"
                            },
                            "httpsRedirect": {
                              "description": "If set to true, the URL scheme in the redirected request is set to https.\nIf set to false, the URL scheme of the redirected request will remain the\nsame as that of the request. This must only be set for UrlMaps used in\nTargetHttpProxys. Setting this true for TargetHttpsProxy is not\npermitted. The default is set to false.",
                              "type": "boolean"
                            },
                            "pathRedirect": {
                              "description": "The path that will be used in the redirect response instead of the one\nthat was supplied in the request. pathRedirect cannot be supplied\ntogether with prefixRedirect. Supply one alone or neither. If neither is\nsupplied, the path of the original request will be used for the redirect.\nThe value must be between 1 and 1024 characters.",
                              "type": "string"
                            },
                            "prefixRedirect": {
                              "description": "The prefix that replaces the prefixMatch specified in the\nHttpRouteRuleMatch, retaining the remaining portion of the URL before\nredirecting the request. prefixRedirect cannot be supplied together with\npathRedirect. Supply one alone or neither. If neither is supplied, the\npath of the original request will be used for the redirect. The value\nmust be between 1 and 1024 characters.",
                              "type": "string"
                            },
                            "redirectResponseCode": {
                              "description": "The HTTP Status code to use for this RedirectAction. Supported values are:\n\n* MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.\n\n* FOUND, which corresponds to 302.\n\n* SEE_OTHER which corresponds to 303.\n\n* TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method\nwill be retained.\n\n* PERMANENT_REDIRECT, which corresponds to 308. In this case,\nthe request method will be retained. Possible values: [\"FOUND\", \"MOVED_PERMANENTLY_DEFAULT\", \"PERMANENT_REDIRECT\", \"SEE_OTHER\", \"TEMPORARY_REDIRECT\"].",
                              "type": "string"
                            },
                            "stripQuery": {
                              "description": "If set to true, any accompanying query portion of the original URL is\nremoved prior to redirecting the request. If set to false, the query\nportion of the original URL is retained. The default value is false.",
                              "type": "boolean"
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "test": {
              "description": "The list of expected URL mappings. Requests to update this UrlMap will\nsucceed only if all of the test cases pass.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["host", "path", "service"],
                "properties": {
                  "description": {
                    "description": "Description of this test case.",
                    "type": "string"
                  },
                  "host": {
                    "description": "Host portion of the URL.",
                    "type": "string"
                  },
                  "path": {
                    "description": "Path portion of the URL.",
                    "type": "string"
                  },
                  "service": {
                    "description": "The backend service resource that should be matched by this test.\nFor the Global URL Map, it should be a reference to the backend\nservice or backend bucket.\nFor the Regional URL Map, it should be a reference to the backend\nservice.",
                    "type": "object",
                    "properties": {
                      "backendBucketRef": {
                        "type": "object",
                        "properties": {
                          "external": {
                            "description": "The selfLink of a ComputeBackendBucket.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          }
                        }
                      },
                      "backendServiceRef": {
                        "type": "object",
                        "properties": {
                          "external": {
                            "description": "The selfLink of a ComputeBackendService.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "fingerprint": {
              "description": "Fingerprint of this resource. This field is used internally during\nupdates of this resource.",
              "type": "string"
            },
            "mapId": {
              "description": "The unique identifier for the resource.",
              "type": "integer"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeURLMap",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeURLMapList": {
      "description": "ComputeURLMapList is a list of ComputeURLMap",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computeurlmaps. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeURLMap"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeURLMapList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeURLMapList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeVPNGateway": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeVPNGateway"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["networkRef", "region"],
          "properties": {
            "description": {
              "description": "Immutable. An optional description of this resource.",
              "type": "string"
            },
            "networkRef": {
              "description": "The network this VPN gateway is accepting traffic for.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "region": {
              "description": "Immutable. The region this gateway should sit in.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "vpnInterfaces": {
              "description": "Immutable. A list of interfaces on this VPN gateway.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "id": {
                    "description": "Immutable. The numeric ID of this VPN gateway interface.",
                    "type": "integer"
                  },
                  "interconnectAttachmentRef": {
                    "description": "Immutable. When this value is present, the VPN Gateway will be used\nfor IPsec-encrypted Cloud Interconnect; all Egress or Ingress\ntraffic for this VPN Gateway interface will go through the specified\ninterconnect attachment resource. Not currently available publicly.",
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The selfLink of a ComputeInterconnectAttachment.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  },
                  "ipAddress": {
                    "description": "The external IP address for this VPN gateway interface.",
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeVPNGateway",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeVPNGatewayList": {
      "description": "ComputeVPNGatewayList is a list of ComputeVPNGateway",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computevpngateways. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeVPNGateway"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeVPNGatewayList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeVPNGatewayList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeVPNTunnel": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeVPNTunnel"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["region", "sharedSecret"],
          "properties": {
            "description": {
              "description": "Immutable. An optional description of this resource.",
              "type": "string"
            },
            "ikeVersion": {
              "description": "Immutable. IKE protocol version to use when establishing the VPN tunnel with\npeer VPN gateway.\nAcceptable IKE versions are 1 or 2. Default version is 2.",
              "type": "integer"
            },
            "localTrafficSelector": {
              "description": "Immutable. Local traffic selector to use when establishing the VPN tunnel with\npeer VPN gateway. The value should be a CIDR formatted string,\nfor example '192.168.0.0/16'. The ranges should be disjoint.\nOnly IPv4 is supported.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "peerExternalGatewayInterface": {
              "description": "Immutable. The interface ID of the external VPN gateway to which this VPN tunnel is connected.",
              "type": "integer"
            },
            "peerExternalGatewayRef": {
              "description": "The peer side external VPN gateway to which this VPN tunnel\nis connected.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeExternalVPNGateway.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "peerGCPGatewayRef": {
              "description": "The peer side HA GCP VPN gateway to which this VPN tunnel is\nconnected. If provided, the VPN tunnel will automatically use the\nsame VPN gateway interface ID in the peer GCP VPN gateway.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeVPNGateway.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "peerIp": {
              "description": "Immutable. IP address of the peer VPN gateway. Only IPv4 is supported.",
              "type": "string"
            },
            "region": {
              "description": "Immutable. The region where the tunnel is located. If unset, is set to the region of 'target_vpn_gateway'.",
              "type": "string"
            },
            "remoteTrafficSelector": {
              "description": "Immutable. Remote traffic selector to use when establishing the VPN tunnel with\npeer VPN gateway. The value should be a CIDR formatted string,\nfor example '192.168.0.0/16'. The ranges should be disjoint.\nOnly IPv4 is supported.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "routerRef": {
              "description": "The router to be used for dynamic routing.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeRouter.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "sharedSecret": {
              "description": "Immutable. Shared secret used to set the secure session between the Cloud VPN\ngateway and the peer VPN gateway.",
              "type": "object",
              "properties": {
                "value": {
                  "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                  "type": "string"
                },
                "valueFrom": {
                  "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                  "type": "object",
                  "properties": {
                    "secretKeyRef": {
                      "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                      "type": "object",
                      "required": ["name", "key"],
                      "properties": {
                        "key": {
                          "description": "Key that identifies the value to be extracted.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the Secret to extract a value from.",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "targetVPNGatewayRef": {
              "description": "The ComputeTargetVPNGateway with which this VPN tunnel is\nassociated.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeTargetVPNGateway.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "vpnGatewayInterface": {
              "description": "Immutable. The interface ID of the VPN gateway with which this VPN tunnel is associated.",
              "type": "integer"
            },
            "vpnGatewayRef": {
              "description": "The ComputeVPNGateway with which this VPN tunnel is associated.\nThis must be used if a High Availability VPN gateway resource is\ncreated.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeVPNGateway.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTimestamp": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "detailedStatus": {
              "description": "Detailed status message for the VPN tunnel.",
              "type": "string"
            },
            "labelFingerprint": {
              "description": "The fingerprint used for optimistic locking of this resource.  Used\ninternally during updates.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            },
            "sharedSecretHash": {
              "description": "Hash of the shared secret.",
              "type": "string"
            },
            "tunnelId": {
              "description": "The unique identifier for the resource. This identifier is defined by the server.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeVPNTunnel",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.compute.v1beta1.ComputeVPNTunnelList": {
      "description": "ComputeVPNTunnelList is a list of ComputeVPNTunnel",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["compute.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of computevpntunnels. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.compute.v1beta1.ComputeVPNTunnel"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComputeVPNTunnelList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "compute.cnrm.cloud.google.com",
          "kind": "ComputeVPNTunnelList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.configcontroller.v1beta1.ConfigControllerInstance": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["configcontroller.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ConfigControllerInstance"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location", "managementConfig", "projectRef"],
          "properties": {
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "managementConfig": {
              "description": "Configuration of the cluster management",
              "type": "object",
              "required": ["standardManagementConfig"],
              "properties": {
                "standardManagementConfig": {
                  "description": "Configuration of the standard (GKE) cluster management",
                  "type": "object",
                  "required": ["masterIPv4CidrBlock"],
                  "properties": {
                    "clusterCidrBlock": {
                      "description": "The IP address range for the cluster pod IPs. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.",
                      "type": "string"
                    },
                    "clusterNamedRange": {
                      "description": "The name of the existing secondary range in the cluster's subnetwork to use for pod IP addresses. Alternatively, cluster_cidr_block can be used to automatically create a GKE-managed one.",
                      "type": "string"
                    },
                    "manBlock": {
                      "description": "Master Authorized Network. Allows access to the k8s master from this block.",
                      "type": "string"
                    },
                    "masterIPv4CidrBlock": {
                      "description": "The /28 network that the masters will use.",
                      "type": "string"
                    },
                    "networkRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "Existing VPC Network to put the GKE cluster and nodes in.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    },
                    "servicesCidrBlock": {
                      "description": "The IP address range for the cluster service IPs. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.",
                      "type": "string"
                    },
                    "servicesNamedRange": {
                      "description": "The name of the existing secondary range in the cluster's subnetwork to use for service ClusterIPs. Alternatively, services_cidr_block can be used to automatically create a GKE-managed one.",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "usePrivateEndpoint": {
              "description": "Only allow access to the master's private endpoint IP.",
              "type": "boolean"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "gkeResourceLink": {
              "description": "Output only. KrmApiHost GCP self link used for identifying the underlying endpoint (GKE cluster currently).",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "state": {
              "description": "Output only. The current state of the internal state machine for the KrmApiHost. Possible values: STATE_UNSPECIFIED, CREATING, RUNNING, DELETING, SUSPENDED, READ_ONLY",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "configcontroller.cnrm.cloud.google.com",
          "kind": "ConfigControllerInstance",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.configcontroller.v1beta1.ConfigControllerInstanceList": {
      "description": "ConfigControllerInstanceList is a list of ConfigControllerInstance",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["configcontroller.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of configcontrollerinstances. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.configcontroller.v1beta1.ConfigControllerInstance"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ConfigControllerInstanceList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "configcontroller.cnrm.cloud.google.com",
          "kind": "ConfigControllerInstanceList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.container.v1beta1.ContainerCluster": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["container.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ContainerCluster"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location"],
          "properties": {
            "addonsConfig": {
              "description": "The configuration for addons supported by GKE.",
              "type": "object",
              "properties": {
                "cloudrunConfig": {
                  "description": "The status of the CloudRun addon. It is disabled by default. Set disabled = false to enable.",
                  "type": "object",
                  "required": ["disabled"],
                  "properties": {
                    "disabled": {
                      "type": "boolean"
                    },
                    "loadBalancerType": {
                      "type": "string"
                    }
                  }
                },
                "configConnectorConfig": {
                  "description": "The of the Config Connector addon.",
                  "type": "object",
                  "required": ["enabled"],
                  "properties": {
                    "enabled": {
                      "type": "boolean"
                    }
                  }
                },
                "dnsCacheConfig": {
                  "description": "The status of the NodeLocal DNSCache addon. It is disabled by default. Set enabled = true to enable.",
                  "type": "object",
                  "required": ["enabled"],
                  "properties": {
                    "enabled": {
                      "type": "boolean"
                    }
                  }
                },
                "gcePersistentDiskCsiDriverConfig": {
                  "description": "Whether this cluster should enable the Google Compute Engine Persistent Disk Container Storage Interface (CSI) Driver. Defaults to disabled; set enabled = true to enable.",
                  "type": "object",
                  "required": ["enabled"],
                  "properties": {
                    "enabled": {
                      "type": "boolean"
                    }
                  }
                },
                "horizontalPodAutoscaling": {
                  "description": "The status of the Horizontal Pod Autoscaling addon, which increases or decreases the number of replica pods a replication controller has based on the resource usage of the existing pods. It ensures that a Heapster pod is running in the cluster, which is also used by the Cloud Monitoring service. It is enabled by default; set disabled = true to disable.",
                  "type": "object",
                  "required": ["disabled"],
                  "properties": {
                    "disabled": {
                      "type": "boolean"
                    }
                  }
                },
                "httpLoadBalancing": {
                  "description": "The status of the HTTP (L7) load balancing controller addon, which makes it easy to set up HTTP load balancers for services in a cluster. It is enabled by default; set disabled = true to disable.",
                  "type": "object",
                  "required": ["disabled"],
                  "properties": {
                    "disabled": {
                      "type": "boolean"
                    }
                  }
                },
                "istioConfig": {
                  "description": "The status of the Istio addon.",
                  "type": "object",
                  "required": ["disabled"],
                  "properties": {
                    "auth": {
                      "description": "The authentication type between services in Istio. Available options include AUTH_MUTUAL_TLS.",
                      "type": "string"
                    },
                    "disabled": {
                      "description": "The status of the Istio addon, which makes it easy to set up Istio for services in a cluster. It is disabled by default. Set disabled = false to enable.",
                      "type": "boolean"
                    }
                  }
                },
                "kalmConfig": {
                  "description": "Configuration for the KALM addon, which manages the lifecycle of k8s. It is disabled by default; Set enabled = true to enable.",
                  "type": "object",
                  "required": ["enabled"],
                  "properties": {
                    "enabled": {
                      "type": "boolean"
                    }
                  }
                },
                "networkPolicyConfig": {
                  "description": "Whether we should enable the network policy addon for the master. This must be enabled in order to enable network policy for the nodes. To enable this, you must also define a network_policy block, otherwise nothing will happen. It can only be disabled if the nodes already do not have network policies enabled. Defaults to disabled; set disabled = false to enable.",
                  "type": "object",
                  "required": ["disabled"],
                  "properties": {
                    "disabled": {
                      "type": "boolean"
                    }
                  }
                }
              }
            },
            "authenticatorGroupsConfig": {
              "description": "Immutable. Configuration for the Google Groups for GKE feature.",
              "type": "object",
              "required": ["securityGroup"],
              "properties": {
                "securityGroup": {
                  "description": "Immutable. The name of the RBAC security group for use with Google security groups in Kubernetes RBAC. Group name must be in format gke-security-groups@yourdomain.com.",
                  "type": "string"
                }
              }
            },
            "clusterAutoscaling": {
              "description": "Per-cluster configuration of Node Auto-Provisioning with Cluster Autoscaler to automatically adjust the size of the cluster and create/delete node pools based on the current needs of the cluster's workload. See the guide to using Node Auto-Provisioning for more details.",
              "type": "object",
              "required": ["enabled"],
              "properties": {
                "autoProvisioningDefaults": {
                  "description": "Contains defaults for a node pool created by NAP.",
                  "type": "object",
                  "properties": {
                    "minCpuPlatform": {
                      "description": "Minimum CPU platform to be used by this instance. The instance may be scheduled on the specified or newer CPU platform. Applicable values are the friendly names of CPU platforms, such as Intel Haswell.",
                      "type": "string"
                    },
                    "oauthScopes": {
                      "description": "Scopes that are used by NAP when creating node pools.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "serviceAccountRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "The email of an IAMServiceAccount.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "autoscalingProfile": {
                  "description": "Configuration options for the Autoscaling profile feature, which lets you choose whether the cluster autoscaler should optimize for resource utilization or resource availability when deciding to remove nodes from a cluster. Can be BALANCED or OPTIMIZE_UTILIZATION. Defaults to BALANCED.",
                  "type": "string"
                },
                "enabled": {
                  "description": "Whether node auto-provisioning is enabled. Resource limits for cpu and memory must be defined to enable node auto-provisioning.",
                  "type": "boolean"
                },
                "resourceLimits": {
                  "description": "Global constraints for machine resources in the cluster. Configuring the cpu and memory types is required if node auto-provisioning is enabled. These limits will apply to node pool autoscaling in addition to node auto-provisioning.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["resourceType"],
                    "properties": {
                      "maximum": {
                        "description": "Maximum amount of the resource in the cluster.",
                        "type": "integer"
                      },
                      "minimum": {
                        "description": "Minimum amount of the resource in the cluster.",
                        "type": "integer"
                      },
                      "resourceType": {
                        "description": "The type of the resource. For example, cpu and memory. See the guide to using Node Auto-Provisioning for a list of types.",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "clusterIpv4Cidr": {
              "description": "Immutable. The IP address range of the Kubernetes pods in this cluster in CIDR notation (e.g. 10.96.0.0/14). Leave blank to have one automatically chosen or specify a /14 block in 10.0.0.0/8. This field will only work for routes-based clusters, where ip_allocation_policy is not defined.",
              "type": "string"
            },
            "clusterTelemetry": {
              "description": "Telemetry integration for the cluster.",
              "type": "object",
              "required": ["type"],
              "properties": {
                "type": {
                  "description": "Type of the integration.",
                  "type": "string"
                }
              }
            },
            "confidentialNodes": {
              "description": "Immutable. Configuration for the confidential nodes feature, which makes nodes run on confidential VMs. Warning: This configuration can't be changed (or added/removed) after cluster creation without deleting and recreating the entire cluster.",
              "type": "object",
              "required": ["enabled"],
              "properties": {
                "enabled": {
                  "description": "Immutable. Whether Confidential Nodes feature is enabled for all nodes in this cluster.",
                  "type": "boolean"
                }
              }
            },
            "databaseEncryption": {
              "description": "Application-layer Secrets Encryption settings. The object format is {state = string, key_name = string}. Valid values of state are: \"ENCRYPTED\"; \"DECRYPTED\". key_name is the name of a CloudKMS key.",
              "type": "object",
              "required": ["state"],
              "properties": {
                "keyName": {
                  "description": "The key to use to encrypt/decrypt secrets.",
                  "type": "string"
                },
                "state": {
                  "description": "ENCRYPTED or DECRYPTED.",
                  "type": "string"
                }
              }
            },
            "datapathProvider": {
              "description": "The desired datapath provider for this cluster. By default, uses the IPTables-based kube-proxy implementation.",
              "type": "string"
            },
            "defaultMaxPodsPerNode": {
              "description": "Immutable. The default maximum number of pods per node in this cluster. This doesn't work on \"routes-based\" clusters, clusters that don't have IP Aliasing enabled.",
              "type": "integer"
            },
            "defaultSnatStatus": {
              "description": "Whether the cluster disables default in-node sNAT rules. In-node sNAT rules will be disabled when defaultSnatStatus is disabled.",
              "type": "object",
              "required": ["disabled"],
              "properties": {
                "disabled": {
                  "description": "When disabled is set to false, default IP masquerade rules will be applied to the nodes to prevent sNAT on cluster internal traffic.",
                  "type": "boolean"
                }
              }
            },
            "description": {
              "description": "Immutable.  Description of the cluster.",
              "type": "string"
            },
            "dnsConfig": {
              "description": "Immutable. Configuration for Cloud DNS for Kubernetes Engine.",
              "type": "object",
              "properties": {
                "clusterDns": {
                  "description": "Which in-cluster DNS provider should be used.",
                  "type": "string"
                },
                "clusterDnsDomain": {
                  "description": "The suffix used for all cluster service records.",
                  "type": "string"
                },
                "clusterDnsScope": {
                  "description": "The scope of access to cluster DNS records.",
                  "type": "string"
                }
              }
            },
            "enableAutopilot": {
              "description": "Immutable. Enable Autopilot for this cluster.",
              "type": "boolean"
            },
            "enableBinaryAuthorization": {
              "description": "Enable Binary Authorization for this cluster. If enabled, all container images will be validated by Google Binary Authorization.",
              "type": "boolean"
            },
            "enableIntranodeVisibility": {
              "description": "Whether Intra-node visibility is enabled for this cluster. This makes same node pod to pod traffic visible for VPC network.",
              "type": "boolean"
            },
            "enableKubernetesAlpha": {
              "description": "Immutable. Whether to enable Kubernetes Alpha features for this cluster. Note that when this option is enabled, the cluster cannot be upgraded and will be automatically deleted after 30 days.",
              "type": "boolean"
            },
            "enableL4IlbSubsetting": {
              "description": "Whether L4ILB Subsetting is enabled for this cluster.",
              "type": "boolean"
            },
            "enableLegacyAbac": {
              "description": "Whether the ABAC authorizer is enabled for this cluster. When enabled, identities in the system, including service accounts, nodes, and controllers, will have statically granted permissions beyond those provided by the RBAC configuration or IAM. Defaults to false.",
              "type": "boolean"
            },
            "enableShieldedNodes": {
              "description": "Enable Shielded Nodes features on all nodes in this cluster. Defaults to true.",
              "type": "boolean"
            },
            "enableTpu": {
              "description": "Immutable. Whether to enable Cloud TPU resources in this cluster.",
              "type": "boolean"
            },
            "identityServiceConfig": {
              "description": "Configuration for Identity Service which allows customers to use external identity providers with the K8S API.",
              "type": "object",
              "properties": {
                "enabled": {
                  "description": "Whether to enable the Identity Service component.",
                  "type": "boolean"
                }
              }
            },
            "initialNodeCount": {
              "description": "Immutable. The number of nodes to create in this cluster's default node pool. In regional or multi-zonal clusters, this is the number of nodes per zone. Must be set if node_pool is not set. If you're using google_container_node_pool objects with no default node pool, you'll need to set this to a value of at least 1, alongside setting remove_default_node_pool to true.",
              "type": "integer"
            },
            "ipAllocationPolicy": {
              "description": "Immutable. Configuration of cluster IP allocation for VPC-native clusters. Adding this block enables IP aliasing, making the cluster VPC-native instead of routes-based.",
              "type": "object",
              "properties": {
                "clusterIpv4CidrBlock": {
                  "description": "Immutable. The IP address range for the cluster pod IPs. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.",
                  "type": "string"
                },
                "clusterSecondaryRangeName": {
                  "description": "Immutable. The name of the existing secondary range in the cluster's subnetwork to use for pod IP addresses. Alternatively, cluster_ipv4_cidr_block can be used to automatically create a GKE-managed one.",
                  "type": "string"
                },
                "servicesIpv4CidrBlock": {
                  "description": "Immutable. The IP address range of the services IPs in this cluster. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.",
                  "type": "string"
                },
                "servicesSecondaryRangeName": {
                  "description": "Immutable. The name of the existing secondary range in the cluster's subnetwork to use for service ClusterIPs. Alternatively, services_ipv4_cidr_block can be used to automatically create a GKE-managed one.",
                  "type": "string"
                }
              }
            },
            "location": {
              "description": "Immutable. The location (region or zone) in which the cluster master will be created, as well as the default node location. If you specify a zone (such as us-central1-a), the cluster will be a zonal cluster with a single cluster master. If you specify a region (such as us-west1), the cluster will be a regional cluster with multiple masters spread across zones in the region, and with default node locations in those zones as well.",
              "type": "string"
            },
            "loggingConfig": {
              "description": "Logging configuration for the cluster.",
              "type": "object",
              "required": ["enableComponents"],
              "properties": {
                "enableComponents": {
                  "description": "GKE components exposing logs. Valid values include SYSTEM_COMPONENTS and WORKLOADS.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "loggingService": {
              "description": "The logging service that the cluster should write logs to. Available options include logging.googleapis.com(Legacy Stackdriver), logging.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Logging), and none. Defaults to logging.googleapis.com/kubernetes.",
              "type": "string"
            },
            "maintenancePolicy": {
              "description": "The maintenance policy to use for the cluster.",
              "type": "object",
              "properties": {
                "dailyMaintenanceWindow": {
                  "description": "Time window specified for daily maintenance operations. Specify start_time in RFC3339 format \"HH:MM\u201d, where HH : [00-23] and MM : [00-59] GMT.",
                  "type": "object",
                  "required": ["startTime"],
                  "properties": {
                    "duration": {
                      "type": "string"
                    },
                    "startTime": {
                      "type": "string"
                    }
                  }
                },
                "maintenanceExclusion": {
                  "description": "Exceptions to maintenance window. Non-emergency maintenance should not occur in these windows.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["endTime", "exclusionName", "startTime"],
                    "properties": {
                      "endTime": {
                        "type": "string"
                      },
                      "exclusionName": {
                        "type": "string"
                      },
                      "startTime": {
                        "type": "string"
                      }
                    }
                  }
                },
                "recurringWindow": {
                  "description": "Time window for recurring maintenance operations.",
                  "type": "object",
                  "required": ["endTime", "recurrence", "startTime"],
                  "properties": {
                    "endTime": {
                      "type": "string"
                    },
                    "recurrence": {
                      "type": "string"
                    },
                    "startTime": {
                      "type": "string"
                    }
                  }
                }
              }
            },
            "masterAuth": {
              "description": "DEPRECATED \u2014 Basic authentication was removed for GKE cluster versions >= 1.19. The authentication information for accessing the Kubernetes master. Some values in this block are only returned by the API if your service account has permission to get credentials for your GKE cluster. If you see an unexpected diff unsetting your client cert, ensure you have the container.clusters.getCredentials permission.",
              "type": "object",
              "properties": {
                "clientCertificate": {
                  "description": "Base64 encoded public certificate used by clients to authenticate to the cluster endpoint.",
                  "type": "string"
                },
                "clientCertificateConfig": {
                  "description": "Immutable. Whether client certificate authorization is enabled for this cluster.",
                  "type": "object",
                  "required": ["issueClientCertificate"],
                  "properties": {
                    "issueClientCertificate": {
                      "description": "Immutable. Whether client certificate authorization is enabled for this cluster.",
                      "type": "boolean"
                    }
                  }
                },
                "clientKey": {
                  "description": "Base64 encoded private key used by clients to authenticate to the cluster endpoint.",
                  "type": "string"
                },
                "clusterCaCertificate": {
                  "description": "Base64 encoded public certificate that is the root of trust for the cluster.",
                  "type": "string"
                },
                "password": {
                  "description": "The password to use for HTTP basic authentication when accessing the Kubernetes master endpoint.",
                  "type": "object",
                  "properties": {
                    "value": {
                      "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                      "type": "string"
                    },
                    "valueFrom": {
                      "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                      "type": "object",
                      "properties": {
                        "secretKeyRef": {
                          "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                          "type": "object",
                          "required": ["name", "key"],
                          "properties": {
                            "key": {
                              "description": "Key that identifies the value to be extracted.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the Secret to extract a value from.",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "username": {
                  "description": "The username to use for HTTP basic authentication when accessing the Kubernetes master endpoint. If not present basic auth will be disabled.",
                  "type": "string"
                }
              }
            },
            "masterAuthorizedNetworksConfig": {
              "description": "The desired configuration options for master authorized networks. Omit the nested cidr_blocks attribute to disallow external access (except the cluster node IPs, which GKE automatically whitelists).",
              "type": "object",
              "properties": {
                "cidrBlocks": {
                  "description": "External networks that can access the Kubernetes cluster master through HTTPS.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["cidrBlock"],
                    "properties": {
                      "cidrBlock": {
                        "description": "External network that can access Kubernetes master through HTTPS. Must be specified in CIDR notation.",
                        "type": "string"
                      },
                      "displayName": {
                        "description": "Field for users to identify CIDR blocks.",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "minMasterVersion": {
              "description": "The minimum version of the master. GKE will auto-update the master to new versions, so this does not guarantee the current master version--use the read-only master_version field to obtain that. If unset, the cluster's version will be set by GKE to the version of the most recent official release (which is not necessarily the latest version).",
              "type": "string"
            },
            "monitoringConfig": {
              "description": "Monitoring configuration for the cluster.",
              "type": "object",
              "required": ["enableComponents"],
              "properties": {
                "enableComponents": {
                  "description": "GKE components exposing metrics. Valid values include SYSTEM_COMPONENTS and WORKLOADS.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "monitoringService": {
              "description": "The monitoring service that the cluster should write metrics to. Automatically send metrics from pods in the cluster to the Google Cloud Monitoring API. VM metrics will be collected by Google Compute Engine regardless of this setting Available options include monitoring.googleapis.com(Legacy Stackdriver), monitoring.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Monitoring), and none. Defaults to monitoring.googleapis.com/kubernetes.",
              "type": "string"
            },
            "networkPolicy": {
              "description": "Configuration options for the NetworkPolicy feature.",
              "type": "object",
              "required": ["enabled"],
              "properties": {
                "enabled": {
                  "description": "Whether network policy is enabled on the cluster.",
                  "type": "boolean"
                },
                "provider": {
                  "description": "The selected network policy provider. Defaults to PROVIDER_UNSPECIFIED.",
                  "type": "string"
                }
              }
            },
            "networkRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "networkingMode": {
              "description": "Immutable. Determines whether alias IPs or routes will be used for pod IPs in the cluster.",
              "type": "string"
            },
            "nodeConfig": {
              "description": "Immutable. The configuration of the nodepool.",
              "type": "object",
              "properties": {
                "bootDiskKMSCryptoKeyRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a KMSCryptoKey.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "diskSizeGb": {
                  "description": "Immutable. Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB.",
                  "type": "integer"
                },
                "diskType": {
                  "description": "Immutable. Type of the disk attached to each node.",
                  "type": "string"
                },
                "ephemeralStorageConfig": {
                  "description": "Immutable. Parameters for the ephemeral storage filesystem.",
                  "type": "object",
                  "required": ["localSsdCount"],
                  "properties": {
                    "localSsdCount": {
                      "description": "Immutable. Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces. Each local SSD is 375 GB in size.",
                      "type": "integer"
                    }
                  }
                },
                "gcfsConfig": {
                  "description": "Immutable. GCFS configuration for this node.",
                  "type": "object",
                  "required": ["enabled"],
                  "properties": {
                    "enabled": {
                      "description": "Immutable. Whether or not GCFS is enabled.",
                      "type": "boolean"
                    }
                  }
                },
                "guestAccelerator": {
                  "description": "Immutable. List of the type and count of accelerator cards attached to the instance.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["count", "type"],
                    "properties": {
                      "count": {
                        "description": "Immutable. The number of the accelerator cards exposed to an instance.",
                        "type": "integer"
                      },
                      "gpuPartitionSize": {
                        "description": "Immutable. Size of partitions to create on the GPU. Valid values are described in the NVIDIA mig user guide (https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning).",
                        "type": "string"
                      },
                      "type": {
                        "description": "Immutable. The accelerator type resource name.",
                        "type": "string"
                      }
                    }
                  }
                },
                "imageType": {
                  "description": "The image type to use for this node. Note that for a given image type, the latest version of it will be used.",
                  "type": "string"
                },
                "kubeletConfig": {
                  "description": "Node kubelet configs.",
                  "type": "object",
                  "required": ["cpuManagerPolicy"],
                  "properties": {
                    "cpuCfsQuota": {
                      "description": "Enable CPU CFS quota enforcement for containers that specify CPU limits.",
                      "type": "boolean"
                    },
                    "cpuCfsQuotaPeriod": {
                      "description": "Set the CPU CFS quota period value 'cpu.cfs_period_us'.",
                      "type": "string"
                    },
                    "cpuManagerPolicy": {
                      "description": "Control the CPU management policy on the node.",
                      "type": "string"
                    }
                  }
                },
                "labels": {
                  "description": "Immutable. The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "linuxNodeConfig": {
                  "description": "Parameters that can be configured on Linux nodes.",
                  "type": "object",
                  "required": ["sysctls"],
                  "properties": {
                    "sysctls": {
                      "description": "The Linux kernel parameters to be applied to the nodes and all pods running on the nodes.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    }
                  }
                },
                "localSsdCount": {
                  "description": "Immutable. The number of local SSD disks to be attached to the node.",
                  "type": "integer"
                },
                "machineType": {
                  "description": "Immutable. The name of a Google Compute Engine machine type.",
                  "type": "string"
                },
                "metadata": {
                  "description": "Immutable. The metadata key/value pairs assigned to instances in the cluster.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "minCpuPlatform": {
                  "description": "Immutable. Minimum CPU platform to be used by this instance. The instance may be scheduled on the specified or newer CPU platform.",
                  "type": "string"
                },
                "nodeGroupRef": {
                  "description": "Immutable. Setting this field will assign instances\nof this pool to run on the specified node group. This is useful\nfor running workloads on sole tenant nodes.",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The name of a ComputeNodeGroup.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "oauthScopes": {
                  "description": "Immutable. The set of Google API scopes to be made available on all of the node VMs.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "preemptible": {
                  "description": "Immutable. Whether the nodes are created as preemptible VM instances.",
                  "type": "boolean"
                },
                "sandboxConfig": {
                  "description": "Immutable. Sandbox configuration for this node.",
                  "type": "object",
                  "required": ["sandboxType"],
                  "properties": {
                    "sandboxType": {
                      "description": "Type of the sandbox to use for the node (e.g. 'gvisor').",
                      "type": "string"
                    }
                  }
                },
                "serviceAccountRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The email of an IAMServiceAccount.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "shieldedInstanceConfig": {
                  "description": "Immutable. Shielded Instance options.",
                  "type": "object",
                  "properties": {
                    "enableIntegrityMonitoring": {
                      "description": "Immutable. Defines whether the instance has integrity monitoring enabled.",
                      "type": "boolean"
                    },
                    "enableSecureBoot": {
                      "description": "Immutable. Defines whether the instance has Secure Boot enabled.",
                      "type": "boolean"
                    }
                  }
                },
                "spot": {
                  "description": "Immutable. Whether the nodes are created as spot VM instances.",
                  "type": "boolean"
                },
                "tags": {
                  "description": "Immutable. The list of instance tags applied to all nodes.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "taint": {
                  "description": "Immutable. List of Kubernetes taints to be applied to each node.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["effect", "key", "value"],
                    "properties": {
                      "effect": {
                        "description": "Immutable. Effect for taint.",
                        "type": "string"
                      },
                      "key": {
                        "description": "Immutable. Key for taint.",
                        "type": "string"
                      },
                      "value": {
                        "description": "Immutable. Value for taint.",
                        "type": "string"
                      }
                    }
                  }
                },
                "workloadMetadataConfig": {
                  "description": "Immutable. The workload metadata configuration for this node.",
                  "type": "object",
                  "properties": {
                    "mode": {
                      "description": "Mode is the configuration for how to expose metadata to workloads running on the node.",
                      "type": "string"
                    },
                    "nodeMetadata": {
                      "description": "DEPRECATED \u2014 Deprecated in favor of mode. NodeMetadata is the configuration for how to expose metadata to the workloads running on the node.",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "nodeLocations": {
              "description": "The list of zones in which the cluster's nodes are located. Nodes must be in the region of their regional cluster or in the same region as their cluster's zone for zonal clusters. If this is specified for a zonal cluster, omit the cluster's zone.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "nodeVersion": {
              "type": "string"
            },
            "notificationConfig": {
              "description": "The notification config for sending cluster upgrade notifications.",
              "type": "object",
              "required": ["pubsub"],
              "properties": {
                "pubsub": {
                  "description": "Notification config for Cloud Pub/Sub.",
                  "type": "object",
                  "required": ["enabled"],
                  "properties": {
                    "enabled": {
                      "description": "Whether or not the notification config is enabled.",
                      "type": "boolean"
                    },
                    "topicRef": {
                      "description": "The PubSubTopic to send the notification to.",
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "A string of the format \"projects/{{project}}/topics/{{value}}\", where {{value}} is the name of a PubSubTopic.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "podSecurityPolicyConfig": {
              "description": "Configuration for the PodSecurityPolicy feature.",
              "type": "object",
              "required": ["enabled"],
              "properties": {
                "enabled": {
                  "description": "Enable the PodSecurityPolicy controller for this cluster. If enabled, pods must be valid under a PodSecurityPolicy to be created.",
                  "type": "boolean"
                }
              }
            },
            "privateClusterConfig": {
              "description": "Configuration for private clusters, clusters with private nodes.",
              "type": "object",
              "required": ["enablePrivateEndpoint"],
              "properties": {
                "enablePrivateEndpoint": {
                  "description": "Immutable. Enables the private cluster feature, creating a private endpoint on the cluster. In a private cluster, nodes only have RFC 1918 private addresses and communicate with the master's private endpoint via private networking.",
                  "type": "boolean"
                },
                "enablePrivateNodes": {
                  "description": "Immutable. When true, the cluster's private endpoint is used as the cluster endpoint and access through the public endpoint is disabled. When false, either endpoint can be used. This field only applies to private clusters, when enable_private_nodes is true.",
                  "type": "boolean"
                },
                "masterGlobalAccessConfig": {
                  "description": "Controls cluster master global access settings.",
                  "type": "object",
                  "required": ["enabled"],
                  "properties": {
                    "enabled": {
                      "description": "Whether the cluster master is accessible globally or not.",
                      "type": "boolean"
                    }
                  }
                },
                "masterIpv4CidrBlock": {
                  "description": "Immutable. The IP range in CIDR notation to use for the hosted master network. This range will be used for assigning private IP addresses to the cluster master(s) and the ILB VIP. This range must not overlap with any other ranges in use within the cluster's network, and it must be a /28 subnet. See Private Cluster Limitations for more details. This field only applies to private clusters, when enable_private_nodes is true.",
                  "type": "string"
                },
                "peeringName": {
                  "description": "The name of the peering between this cluster and the Google owned VPC.",
                  "type": "string"
                },
                "privateEndpoint": {
                  "description": "The internal IP address of this cluster's master endpoint.",
                  "type": "string"
                },
                "publicEndpoint": {
                  "description": "The external IP address of this cluster's master endpoint.",
                  "type": "string"
                }
              }
            },
            "privateIpv6GoogleAccess": {
              "description": "The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4).",
              "type": "string"
            },
            "releaseChannel": {
              "description": "Configuration options for the Release channel feature, which provide more control over automatic upgrades of your GKE clusters. Note that removing this field from your config will not unenroll it. Instead, use the \"UNSPECIFIED\" channel.",
              "type": "object",
              "required": ["channel"],
              "properties": {
                "channel": {
                  "description": "The selected release channel. Accepted values are:\n* UNSPECIFIED: Not set.\n* RAPID: Weekly upgrade cadence; Early testers and developers who requires new features.\n* REGULAR: Multiple per month upgrade cadence; Production users who need features not yet offered in the Stable channel.\n* STABLE: Every few months upgrade cadence; Production users who need stability above all else, and for whom frequent upgrades are too risky.",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "resourceUsageExportConfig": {
              "description": "Configuration for the ResourceUsageExportConfig feature.",
              "type": "object",
              "required": ["bigqueryDestination"],
              "properties": {
                "bigqueryDestination": {
                  "description": "Parameters for using BigQuery as the destination of resource usage export.",
                  "type": "object",
                  "required": ["datasetId"],
                  "properties": {
                    "datasetId": {
                      "description": "The ID of a BigQuery Dataset.",
                      "type": "string"
                    }
                  }
                },
                "enableNetworkEgressMetering": {
                  "description": "Whether to enable network egress metering for this cluster. If enabled, a daemonset will be created in the cluster to meter network egress traffic.",
                  "type": "boolean"
                },
                "enableResourceConsumptionMetering": {
                  "description": "Whether to enable resource consumption metering on this cluster. When enabled, a table will be created in the resource export BigQuery dataset to store resource consumption data. The resulting table can be joined with the resource usage table or with BigQuery billing export. Defaults to true.",
                  "type": "boolean"
                }
              }
            },
            "subnetworkRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeSubnetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "verticalPodAutoscaling": {
              "description": "Vertical Pod Autoscaling automatically adjusts the resources of pods controlled by it.",
              "type": "object",
              "required": ["enabled"],
              "properties": {
                "enabled": {
                  "description": "Enables vertical pod autoscaling.",
                  "type": "boolean"
                }
              }
            },
            "workloadIdentityConfig": {
              "description": "Configuration for the use of Kubernetes Service Accounts in GCP IAM policies.",
              "type": "object",
              "properties": {
                "identityNamespace": {
                  "description": "DEPRECATED \u2014 This field will be removed in a future major release as it has been deprecated in the API. Use `workloadPool` instead; `workloadPool` field will supersede this field.\nEnables workload identity.",
                  "type": "string"
                },
                "workloadPool": {
                  "description": "The workload pool to attach all Kubernetes service accounts to.",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "endpoint": {
              "description": "The IP address of this cluster's Kubernetes master.",
              "type": "string"
            },
            "labelFingerprint": {
              "description": "The fingerprint of the set of labels for this cluster.",
              "type": "string"
            },
            "masterVersion": {
              "description": "The current version of the master in the cluster. This may be different than the min_master_version set in the config if the master has been updated by GKE.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "operation": {
              "type": "string"
            },
            "selfLink": {
              "description": "Server-defined URL for the resource.",
              "type": "string"
            },
            "servicesIpv4Cidr": {
              "description": "The IP address range of the Kubernetes services in this cluster, in CIDR notation (e.g. 1.2.3.4/29). Service addresses are typically put in the last /16 from the container CIDR.",
              "type": "string"
            },
            "tpuIpv4CidrBlock": {
              "description": "The IP address range of the Cloud TPUs in this cluster, in CIDR notation (e.g. 1.2.3.4/29).",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "container.cnrm.cloud.google.com",
          "kind": "ContainerCluster",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.container.v1beta1.ContainerClusterList": {
      "description": "ContainerClusterList is a list of ContainerCluster",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["container.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of containerclusters. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.container.v1beta1.ContainerCluster"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ContainerClusterList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "container.cnrm.cloud.google.com",
          "kind": "ContainerClusterList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.container.v1beta1.ContainerNodePool": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["container.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ContainerNodePool"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["clusterRef", "location"],
          "properties": {
            "autoscaling": {
              "description": "Configuration required by cluster autoscaler to adjust the size of the node pool to the current cluster usage. To disable autoscaling, set minNodeCount and maxNodeCount to 0.",
              "type": "object",
              "required": ["maxNodeCount", "minNodeCount"],
              "properties": {
                "maxNodeCount": {
                  "description": "Maximum number of nodes in the NodePool. Must be >= min_node_count.",
                  "type": "integer"
                },
                "minNodeCount": {
                  "description": "Minimum number of nodes in the NodePool. Must be >=0 and <= max_node_count.",
                  "type": "integer"
                }
              }
            },
            "clusterRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a ContainerCluster.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "initialNodeCount": {
              "description": "Immutable. The initial number of nodes for the pool. In regional or multi-zonal clusters, this is the number of nodes per zone. Changing this will force recreation of the resource.",
              "type": "integer"
            },
            "location": {
              "description": "Immutable. The location (region or zone) of the cluster.",
              "type": "string"
            },
            "management": {
              "description": "Node management configuration, wherein auto-repair and auto-upgrade is configured.",
              "type": "object",
              "properties": {
                "autoRepair": {
                  "description": "Whether the nodes will be automatically repaired.",
                  "type": "boolean"
                },
                "autoUpgrade": {
                  "description": "Whether the nodes will be automatically upgraded.",
                  "type": "boolean"
                }
              }
            },
            "maxPodsPerNode": {
              "description": "Immutable. The maximum number of pods per node in this node pool. Note that this does not work on node pools which are \"route-based\" - that is, node pools belonging to clusters that do not have IP Aliasing enabled.",
              "type": "integer"
            },
            "namePrefix": {
              "description": "Immutable. Creates a unique name for the node pool beginning with the specified prefix. Conflicts with name.",
              "type": "string"
            },
            "networkConfig": {
              "description": "Networking configuration for this NodePool. If specified, it overrides the cluster-level defaults.",
              "type": "object",
              "required": ["podRange"],
              "properties": {
                "createPodRange": {
                  "description": "Immutable. Whether to create a new range for pod IPs in this node pool. Defaults are provided for pod_range and pod_ipv4_cidr_block if they are not specified.",
                  "type": "boolean"
                },
                "podIpv4CidrBlock": {
                  "description": "Immutable. The IP address range for pod IPs in this node pool. Only applicable if create_pod_range is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) to pick a specific range to use.",
                  "type": "string"
                },
                "podRange": {
                  "description": "Immutable. The ID of the secondary range for pod IPs. If create_pod_range is true, this ID is used for the new range. If create_pod_range is false, uses an existing secondary range with this ID.",
                  "type": "string"
                }
              }
            },
            "nodeConfig": {
              "description": "Immutable. The configuration of the nodepool.",
              "type": "object",
              "properties": {
                "bootDiskKMSCryptoKeyRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a KMSCryptoKey.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "diskSizeGb": {
                  "description": "Immutable. Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB.",
                  "type": "integer"
                },
                "diskType": {
                  "description": "Immutable. Type of the disk attached to each node.",
                  "type": "string"
                },
                "ephemeralStorageConfig": {
                  "description": "Immutable. Parameters for the ephemeral storage filesystem.",
                  "type": "object",
                  "required": ["localSsdCount"],
                  "properties": {
                    "localSsdCount": {
                      "description": "Immutable. Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces. Each local SSD is 375 GB in size.",
                      "type": "integer"
                    }
                  }
                },
                "gcfsConfig": {
                  "description": "Immutable. GCFS configuration for this node.",
                  "type": "object",
                  "required": ["enabled"],
                  "properties": {
                    "enabled": {
                      "description": "Immutable. Whether or not GCFS is enabled.",
                      "type": "boolean"
                    }
                  }
                },
                "guestAccelerator": {
                  "description": "Immutable. List of the type and count of accelerator cards attached to the instance.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["count", "type"],
                    "properties": {
                      "count": {
                        "description": "Immutable. The number of the accelerator cards exposed to an instance.",
                        "type": "integer"
                      },
                      "gpuPartitionSize": {
                        "description": "Immutable. Size of partitions to create on the GPU. Valid values are described in the NVIDIA mig user guide (https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning).",
                        "type": "string"
                      },
                      "type": {
                        "description": "Immutable. The accelerator type resource name.",
                        "type": "string"
                      }
                    }
                  }
                },
                "imageType": {
                  "description": "The image type to use for this node. Note that for a given image type, the latest version of it will be used.",
                  "type": "string"
                },
                "kubeletConfig": {
                  "description": "Node kubelet configs.",
                  "type": "object",
                  "required": ["cpuManagerPolicy"],
                  "properties": {
                    "cpuCfsQuota": {
                      "description": "Enable CPU CFS quota enforcement for containers that specify CPU limits.",
                      "type": "boolean"
                    },
                    "cpuCfsQuotaPeriod": {
                      "description": "Set the CPU CFS quota period value 'cpu.cfs_period_us'.",
                      "type": "string"
                    },
                    "cpuManagerPolicy": {
                      "description": "Control the CPU management policy on the node.",
                      "type": "string"
                    }
                  }
                },
                "labels": {
                  "description": "Immutable. The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "linuxNodeConfig": {
                  "description": "Parameters that can be configured on Linux nodes.",
                  "type": "object",
                  "required": ["sysctls"],
                  "properties": {
                    "sysctls": {
                      "description": "The Linux kernel parameters to be applied to the nodes and all pods running on the nodes.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    }
                  }
                },
                "localSsdCount": {
                  "description": "Immutable. The number of local SSD disks to be attached to the node.",
                  "type": "integer"
                },
                "machineType": {
                  "description": "Immutable. The name of a Google Compute Engine machine type.",
                  "type": "string"
                },
                "metadata": {
                  "description": "Immutable. The metadata key/value pairs assigned to instances in the cluster.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "minCpuPlatform": {
                  "description": "Immutable. Minimum CPU platform to be used by this instance. The instance may be scheduled on the specified or newer CPU platform.",
                  "type": "string"
                },
                "nodeGroupRef": {
                  "description": "Immutable. Setting this field will assign instances\nof this pool to run on the specified node group. This is useful\nfor running workloads on sole tenant nodes.",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The name of a ComputeNodeGroup.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "oauthScopes": {
                  "description": "Immutable. The set of Google API scopes to be made available on all of the node VMs.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "preemptible": {
                  "description": "Immutable. Whether the nodes are created as preemptible VM instances.",
                  "type": "boolean"
                },
                "sandboxConfig": {
                  "description": "Immutable. Sandbox configuration for this node.",
                  "type": "object",
                  "required": ["sandboxType"],
                  "properties": {
                    "sandboxType": {
                      "description": "Type of the sandbox to use for the node (e.g. 'gvisor').",
                      "type": "string"
                    }
                  }
                },
                "serviceAccountRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The email of an IAMServiceAccount.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "shieldedInstanceConfig": {
                  "description": "Immutable. Shielded Instance options.",
                  "type": "object",
                  "properties": {
                    "enableIntegrityMonitoring": {
                      "description": "Immutable. Defines whether the instance has integrity monitoring enabled.",
                      "type": "boolean"
                    },
                    "enableSecureBoot": {
                      "description": "Immutable. Defines whether the instance has Secure Boot enabled.",
                      "type": "boolean"
                    }
                  }
                },
                "spot": {
                  "description": "Immutable. Whether the nodes are created as spot VM instances.",
                  "type": "boolean"
                },
                "tags": {
                  "description": "Immutable. The list of instance tags applied to all nodes.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "taint": {
                  "description": "Immutable. List of Kubernetes taints to be applied to each node.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["effect", "key", "value"],
                    "properties": {
                      "effect": {
                        "description": "Immutable. Effect for taint.",
                        "type": "string"
                      },
                      "key": {
                        "description": "Immutable. Key for taint.",
                        "type": "string"
                      },
                      "value": {
                        "description": "Immutable. Value for taint.",
                        "type": "string"
                      }
                    }
                  }
                },
                "workloadMetadataConfig": {
                  "description": "The workload metadata configuration for this node.",
                  "type": "object",
                  "properties": {
                    "mode": {
                      "description": "Mode is the configuration for how to expose metadata to workloads running on the node.",
                      "type": "string"
                    },
                    "nodeMetadata": {
                      "description": "DEPRECATED \u2014 Deprecated in favor of mode. NodeMetadata is the configuration for how to expose metadata to the workloads running on the node.",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "nodeCount": {
              "description": "The number of nodes per instance group. This field can be used to update the number of nodes per instance group but should not be used alongside autoscaling.",
              "type": "integer"
            },
            "nodeLocations": {
              "description": "The list of zones in which the node pool's nodes should be located. Nodes must be in the region of their regional cluster or in the same region as their cluster's zone for zonal clusters. If unspecified, the cluster-level node_locations will be used.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "upgradeSettings": {
              "description": "Specify node upgrade settings to change how many nodes GKE attempts to upgrade at once. The number of nodes upgraded simultaneously is the sum of max_surge and max_unavailable. The maximum number of nodes upgraded simultaneously is limited to 20.",
              "type": "object",
              "required": ["maxSurge", "maxUnavailable"],
              "properties": {
                "maxSurge": {
                  "description": "The number of additional nodes that can be added to the node pool during an upgrade. Increasing max_surge raises the number of nodes that can be upgraded simultaneously. Can be set to 0 or greater.",
                  "type": "integer"
                },
                "maxUnavailable": {
                  "description": "The number of nodes that can be simultaneously unavailable during an upgrade. Increasing max_unavailable raises the number of nodes that can be upgraded in parallel. Can be set to 0 or greater.",
                  "type": "integer"
                }
              }
            },
            "version": {
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "instanceGroupUrls": {
              "description": "The resource URLs of the managed instance groups associated with this node pool.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "managedInstanceGroupUrls": {
              "description": "List of instance group URLs which have been assigned to this node pool.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "operation": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "container.cnrm.cloud.google.com",
          "kind": "ContainerNodePool",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.container.v1beta1.ContainerNodePoolList": {
      "description": "ContainerNodePoolList is a list of ContainerNodePool",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["container.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of containernodepools. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.container.v1beta1.ContainerNodePool"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ContainerNodePoolList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "container.cnrm.cloud.google.com",
          "kind": "ContainerNodePoolList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.containeranalysis.v1beta1.ContainerAnalysisNote": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["containeranalysis.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ContainerAnalysisNote"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "attestation": {
              "description": "A note describing an attestation role.",
              "type": "object",
              "properties": {
                "hint": {
                  "description": "Hint hints at the purpose of the attestation authority.",
                  "type": "object",
                  "required": ["humanReadableName"],
                  "properties": {
                    "humanReadableName": {
                      "description": "Required. The human readable name of this attestation authority, for example \"qa\".",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "build": {
              "description": "A note describing build provenance for a verifiable build.",
              "type": "object",
              "required": ["builderVersion"],
              "properties": {
                "builderVersion": {
                  "description": "Required. Immutable. Version of the builder which produced this build.",
                  "type": "string"
                }
              }
            },
            "deployment": {
              "description": "A note describing something that can be deployed.",
              "type": "object",
              "required": ["resourceUri"],
              "properties": {
                "resourceUri": {
                  "description": "Required. Resource URI for the artifact being deployed.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "discovery": {
              "description": "A note describing the initial analysis of a resource.",
              "type": "object",
              "required": ["analysisKind"],
              "properties": {
                "analysisKind": {
                  "description": "The kind of analysis that is handled by this discovery. Possible values: NOTE_KIND_UNSPECIFIED, VULNERABILITY, BUILD, IMAGE, PACKAGE, DEPLOYMENT, DISCOVERY, ATTESTATION, UPGRADE",
                  "type": "string"
                }
              }
            },
            "expirationTime": {
              "description": "Time of expiration for this note. Empty if note does not expire.",
              "type": "string",
              "format": "date-time"
            },
            "image": {
              "description": "A note describing a base image.",
              "type": "object",
              "required": ["fingerprint", "resourceUrl"],
              "properties": {
                "fingerprint": {
                  "description": "Required. Immutable. The fingerprint of the base image.",
                  "type": "object",
                  "required": ["v1Name", "v2Blob"],
                  "properties": {
                    "v1Name": {
                      "description": "Required. The layer ID of the final layer in the Docker image's v1 representation.",
                      "type": "string"
                    },
                    "v2Blob": {
                      "description": "Required. The ordered list of v2 blobs that represent a given image.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                },
                "resourceUrl": {
                  "description": "Required. Immutable. The resource_url for the resource representing the basis of associated occurrence images.",
                  "type": "string"
                }
              }
            },
            "longDescription": {
              "description": "A detailed description of this note.",
              "type": "string"
            },
            "package": {
              "description": "Required for non-Windows OS. The package this Upgrade is for.",
              "type": "object",
              "required": ["name"],
              "properties": {
                "distribution": {
                  "description": "The various channels by which a package is distributed.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["cpeUri"],
                    "properties": {
                      "architecture": {
                        "description": "The CPU architecture for which packages in this distribution channel were built Possible values: ARCHITECTURE_UNSPECIFIED, X86, X64",
                        "type": "string"
                      },
                      "cpeUri": {
                        "description": "The cpe_uri in [cpe format](https://cpe.mitre.org/specification/) denoting the package manager version distributing a package.",
                        "type": "string"
                      },
                      "description": {
                        "description": "The distribution channel-specific description of this package.",
                        "type": "string"
                      },
                      "latestVersion": {
                        "description": "The latest available version of this package in this distribution channel.",
                        "type": "object",
                        "required": ["kind"],
                        "properties": {
                          "epoch": {
                            "description": "Used to correct mistakes in the version numbering scheme.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "fullName": {
                            "description": "Human readable version string. This string is of the form :- and is only set when kind is NORMAL.",
                            "type": "string"
                          },
                          "kind": {
                            "description": "Distinguish between sentinel MIN/MAX versions and normal versions. If kind is not NORMAL, then the other fields are ignored. Possible values: NOTE_KIND_UNSPECIFIED, VULNERABILITY, BUILD, IMAGE, PACKAGE, DEPLOYMENT, DISCOVERY, ATTESTATION, UPGRADE",
                            "type": "string"
                          },
                          "name": {
                            "description": "The main part of the version name.",
                            "type": "string"
                          },
                          "revision": {
                            "description": "The iteration of the package build from the above version.",
                            "type": "string"
                          }
                        }
                      },
                      "maintainer": {
                        "description": "A freeform string denoting the maintainer of this package.",
                        "type": "string"
                      },
                      "url": {
                        "description": "The distribution channel-specific homepage for this package.",
                        "type": "string"
                      }
                    }
                  }
                },
                "name": {
                  "description": "The name of the package.",
                  "type": "string"
                }
              }
            },
            "relatedNoteNames": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "external": {
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "relatedUrl": {
              "description": "URLs associated with this note.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "label": {
                    "description": "Label to describe usage of the URL",
                    "type": "string"
                  },
                  "url": {
                    "description": "Specific URL to associate with the note",
                    "type": "string"
                  }
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "shortDescription": {
              "description": "A one sentence description of this note.",
              "type": "string"
            },
            "vulnerability": {
              "description": "A note describing a package vulnerability.",
              "type": "object",
              "properties": {
                "cvssScore": {
                  "description": "The CVSS score of this vulnerability. CVSS score is on a scale of 0 - 10 where 0 indicates low severity and 10 indicates high severity.",
                  "type": "number",
                  "format": "double"
                },
                "cvssV3": {
                  "description": "The full description of the CVSSv3 for this vulnerability.",
                  "type": "object",
                  "properties": {
                    "attackComplexity": {
                      "description": " Possible values: ATTACK_COMPLEXITY_UNSPECIFIED, ATTACK_COMPLEXITY_LOW, ATTACK_COMPLEXITY_HIGH",
                      "type": "string"
                    },
                    "attackVector": {
                      "description": "Base Metrics Represents the intrinsic characteristics of a vulnerability that are constant over time and across user environments. Possible values: ATTACK_VECTOR_UNSPECIFIED, ATTACK_VECTOR_NETWORK, ATTACK_VECTOR_ADJACENT, ATTACK_VECTOR_LOCAL, ATTACK_VECTOR_PHYSICAL",
                      "type": "string"
                    },
                    "availabilityImpact": {
                      "description": " Possible values: IMPACT_UNSPECIFIED, IMPACT_HIGH, IMPACT_LOW, IMPACT_NONE",
                      "type": "string"
                    },
                    "baseScore": {
                      "description": "The base score is a function of the base metric scores.",
                      "type": "number",
                      "format": "double"
                    },
                    "confidentialityImpact": {
                      "description": " Possible values: IMPACT_UNSPECIFIED, IMPACT_HIGH, IMPACT_LOW, IMPACT_NONE",
                      "type": "string"
                    },
                    "exploitabilityScore": {
                      "type": "number",
                      "format": "double"
                    },
                    "impactScore": {
                      "type": "number",
                      "format": "double"
                    },
                    "integrityImpact": {
                      "description": " Possible values: IMPACT_UNSPECIFIED, IMPACT_HIGH, IMPACT_LOW, IMPACT_NONE",
                      "type": "string"
                    },
                    "privilegesRequired": {
                      "description": " Possible values: PRIVILEGES_REQUIRED_UNSPECIFIED, PRIVILEGES_REQUIRED_NONE, PRIVILEGES_REQUIRED_LOW, PRIVILEGES_REQUIRED_HIGH",
                      "type": "string"
                    },
                    "scope": {
                      "description": " Possible values: SCOPE_UNSPECIFIED, SCOPE_UNCHANGED, SCOPE_CHANGED",
                      "type": "string"
                    },
                    "userInteraction": {
                      "description": " Possible values: USER_INTERACTION_UNSPECIFIED, USER_INTERACTION_NONE, USER_INTERACTION_REQUIRED",
                      "type": "string"
                    }
                  }
                },
                "details": {
                  "description": "Details of all known distros and packages affected by this vulnerability.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["affectedCpeUri", "affectedPackage"],
                    "properties": {
                      "affectedCpeUri": {
                        "description": "Required. The (https://cpe.mitre.org/specification/) this vulnerability affects.",
                        "type": "string"
                      },
                      "affectedPackage": {
                        "description": "Required. The package this vulnerability affects.",
                        "type": "string"
                      },
                      "affectedVersionEnd": {
                        "description": "The version number at the end of an interval in which this vulnerability exists. A vulnerability can affect a package between version numbers that are disjoint sets of intervals (example: ) each of which will be represented in its own Detail. If a specific affected version is provided by a vulnerability database, affected_version_start and affected_version_end will be the same in that Detail.",
                        "type": "object",
                        "required": ["kind"],
                        "properties": {
                          "epoch": {
                            "description": "Used to correct mistakes in the version numbering scheme.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "fullName": {
                            "description": "Human readable version string. This string is of the form :- and is only set when kind is NORMAL.",
                            "type": "string"
                          },
                          "kind": {
                            "description": "Required. Distinguishes between sentinel MIN/MAX versions and normal versions. Possible values: NOTE_KIND_UNSPECIFIED, VULNERABILITY, BUILD, IMAGE, PACKAGE, DEPLOYMENT, DISCOVERY, ATTESTATION, UPGRADE",
                            "type": "string"
                          },
                          "name": {
                            "description": "Required only when version kind is NORMAL. The main part of the version name.",
                            "type": "string"
                          },
                          "revision": {
                            "description": "The iteration of the package build from the above version.",
                            "type": "string"
                          }
                        }
                      },
                      "affectedVersionStart": {
                        "description": "The version number at the start of an interval in which this vulnerability exists. A vulnerability can affect a package between version numbers that are disjoint sets of intervals (example: ) each of which will be represented in its own Detail. If a specific affected version is provided by a vulnerability database, affected_version_start and affected_version_end will be the same in that Detail.",
                        "type": "object",
                        "required": ["kind"],
                        "properties": {
                          "epoch": {
                            "description": "Used to correct mistakes in the version numbering scheme.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "fullName": {
                            "description": "Human readable version string. This string is of the form :- and is only set when kind is NORMAL.",
                            "type": "string"
                          },
                          "kind": {
                            "description": "Required. Distinguishes between sentinel MIN/MAX versions and normal versions. Possible values: NOTE_KIND_UNSPECIFIED, VULNERABILITY, BUILD, IMAGE, PACKAGE, DEPLOYMENT, DISCOVERY, ATTESTATION, UPGRADE",
                            "type": "string"
                          },
                          "name": {
                            "description": "Required only when version kind is NORMAL. The main part of the version name.",
                            "type": "string"
                          },
                          "revision": {
                            "description": "The iteration of the package build from the above version.",
                            "type": "string"
                          }
                        }
                      },
                      "description": {
                        "description": "A vendor-specific description of this vulnerability.",
                        "type": "string"
                      },
                      "fixedCpeUri": {
                        "description": "The distro recommended (https://cpe.mitre.org/specification/) to update to that contains a fix for this vulnerability. It is possible for this to be different from the affected_cpe_uri.",
                        "type": "string"
                      },
                      "fixedPackage": {
                        "description": "The distro recommended package to update to that contains a fix for this vulnerability. It is possible for this to be different from the affected_package.",
                        "type": "string"
                      },
                      "fixedVersion": {
                        "description": "The distro recommended version to update to that contains a fix for this vulnerability. Setting this to VersionKind.MAXIMUM means no such version is yet available.",
                        "type": "object",
                        "required": ["kind"],
                        "properties": {
                          "epoch": {
                            "description": "Used to correct mistakes in the version numbering scheme.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "fullName": {
                            "description": "Human readable version string. This string is of the form :- and is only set when kind is NORMAL.",
                            "type": "string"
                          },
                          "kind": {
                            "description": "Required. Distinguishes between sentinel MIN/MAX versions and normal versions. Possible values: NOTE_KIND_UNSPECIFIED, VULNERABILITY, BUILD, IMAGE, PACKAGE, DEPLOYMENT, DISCOVERY, ATTESTATION, UPGRADE",
                            "type": "string"
                          },
                          "name": {
                            "description": "Required only when version kind is NORMAL. The main part of the version name.",
                            "type": "string"
                          },
                          "revision": {
                            "description": "The iteration of the package build from the above version.",
                            "type": "string"
                          }
                        }
                      },
                      "isObsolete": {
                        "description": "Whether this detail is obsolete. Occurrences are expected not to point to obsolete details.",
                        "type": "boolean"
                      },
                      "packageType": {
                        "description": "The type of package; whether native or non native (e.g., ruby gems, node.js packages, etc.).",
                        "type": "string"
                      },
                      "severityName": {
                        "description": "The distro assigned severity of this vulnerability.",
                        "type": "string"
                      },
                      "sourceUpdateTime": {
                        "description": "The time this information was last changed at the source. This is an upstream timestamp from the underlying information source - e.g. Ubuntu security tracker.",
                        "type": "string",
                        "format": "date-time"
                      }
                    }
                  }
                },
                "severity": {
                  "description": "The note provider assigned severity of this vulnerability. Possible values: SEVERITY_UNSPECIFIED, MINIMAL, LOW, MEDIUM, HIGH, CRITICAL",
                  "type": "string"
                },
                "sourceUpdateTime": {
                  "description": "The time this information was last changed at the source. This is an upstream timestamp from the underlying information source - e.g. Ubuntu security tracker.",
                  "type": "string",
                  "format": "date-time"
                },
                "windowsDetails": {
                  "description": "Windows details get their own format because the information format and model don't match a normal detail. Specifically Windows updates are done as patches, thus Windows vulnerabilities really are a missing package, rather than a package being at an incorrect version.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["cpeUri", "fixingKbs", "name"],
                    "properties": {
                      "cpeUri": {
                        "description": "Required. The (https://cpe.mitre.org/specification/) this vulnerability affects.",
                        "type": "string"
                      },
                      "description": {
                        "description": "The description of this vulnerability.",
                        "type": "string"
                      },
                      "fixingKbs": {
                        "description": "Required. The names of the KBs which have hotfixes to mitigate this vulnerability. Note that there may be multiple hotfixes (and thus multiple KBs) that mitigate a given vulnerability. Currently any listed KBs presence is considered a fix.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "name": {
                              "description": "The KB name (generally of the form KB+ (e.g., KB123456)).",
                              "type": "string"
                            },
                            "url": {
                              "description": "A link to the KB in the (https://www.catalog.update.microsoft.com/).",
                              "type": "string"
                            }
                          }
                        }
                      },
                      "name": {
                        "description": "Required. The name of this vulnerability.",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The time this note was created. This field can be used as a filter in list requests.",
              "type": "string",
              "format": "date-time"
            },
            "image": {
              "type": "object",
              "properties": {
                "fingerprint": {
                  "type": "object",
                  "properties": {
                    "v2Name": {
                      "description": "Output only. The name of the image's v2 blobs computed via: ) Only the name of the final blob is kept.",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Output only. The time this note was last updated. This field can be used as a filter in list requests.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "containeranalysis.cnrm.cloud.google.com",
          "kind": "ContainerAnalysisNote",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.containeranalysis.v1beta1.ContainerAnalysisNoteList": {
      "description": "ContainerAnalysisNoteList is a list of ContainerAnalysisNote",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["containeranalysis.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of containeranalysisnotes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.containeranalysis.v1beta1.ContainerAnalysisNote"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ContainerAnalysisNoteList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "containeranalysis.cnrm.cloud.google.com",
          "kind": "ContainerAnalysisNoteList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.core.v1beta1.ConfigConnector": {
      "description": "ConfigConnector is the Schema for the configconnectors API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["core.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ConfigConnector"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "ConfigConnectorSpec defines the desired state of ConfigConnector",
          "type": "object",
          "properties": {
            "credentialSecretName": {
              "description": "The Kubernetes secret that contains the Google Service Account Key's credentials to be used by ConfigConnector to authenticate with Google Cloud APIs. This field is used only when in cluster mode. It's recommended to use `googleServiceAccount` when running ConfigConnector in Google Kubernetes Engine (GKE) clusters with Workload Identity enabled. This field cannot be specified together with `googleServiceAccount`.",
              "type": "string"
            },
            "googleServiceAccount": {
              "description": "The Google Service Account to be used by Config Connector to authenticate with Google Cloud APIs. This field is used only when running in cluster mode with Workload Identity enabled. See Google Kubernetes Engine (GKE) workload-identity (https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity) for details. This field cannot be specified together with `credentialSecretName`. For namespaced mode, use `googleServiceAccount` in ConfigConnectorContext CRD to specify the Google Service Account to be used to authenticate with Google Cloud APIs per namespace.",
              "type": "string"
            },
            "mode": {
              "description": "The mode that Config Connector will run in. This can be either 'cluster' or 'namespaced'. The default is 'namespaced'. Cluster mode uses a single Google Service Account to create and manage resources, even if you are using Config Connector to manage multiple Projects. You must specify either `credentialSecretName` or `googleServiceAccount` when in cluster mode, but not both. Namespaced mode allows you to use different Google service accounts for different Projects. When in namespaced mode, you must create a ConfigConnectorContext object per namespace that you want to enable Config Connector in, and each must set `googleServiceAccount` to specify the Google Service Account to be used to authenticate with Google Cloud APIs for the namespace.",
              "type": "string",
              "enum": ["cluster", "namespaced"]
            }
          }
        },
        "status": {
          "description": "ConfigConnectorStatus defines the observed state of ConfigConnector",
          "type": "object",
          "required": ["healthy"],
          "properties": {
            "errors": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "healthy": {
              "type": "boolean"
            },
            "phase": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "core.cnrm.cloud.google.com",
          "kind": "ConfigConnector",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.core.v1beta1.ConfigConnectorContext": {
      "description": "ConfigConnectorContext is the Schema for the ConfigConnectorContexts API",
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["core.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ConfigConnectorContext"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "ConfigConnectorContextSpec defines the desired state of ConfigConnectorContext",
          "type": "object",
          "required": ["googleServiceAccount"],
          "properties": {
            "billingProject": {
              "description": "Specifies the project to use for preconditions, quota and billing. Should only be used when requestProjectPolicy is set to BILLING_PROJECT.",
              "type": "string"
            },
            "googleServiceAccount": {
              "description": "The Google Service Account to be used by Config Connector to authenticate with Google Cloud APIs in the associated namespace.",
              "type": "string"
            },
            "requestProjectPolicy": {
              "description": "Specifies which project to use for preconditions, quota, and billing for requests made to Google Cloud APIs for resources in the associated namespace. Must be one of 'SERVICE_ACCOUNT_PROJECT', 'RESOURCE_PROJECT', or 'BILLING_PROJECT. Defaults to 'SERVICE_ACCOUNT_PROJECT'. If set to 'SERVICE_ACCOUNT_PROJECT', uses the project that the Google Service Account belongs to. If set to 'RESOURCE_PROJECT', uses the project that the resource belongs to. If set to 'BILLING_PROJECT', uses the project specified by spec.billingProject.",
              "type": "string",
              "enum": [
                "SERVICE_ACCOUNT_PROJECT",
                "RESOURCE_PROJECT",
                "BILLING_PROJECT"
              ]
            }
          }
        },
        "status": {
          "description": "ConfigConnectorContextStatus defines the observed state of ConfigConnectorContext",
          "type": "object",
          "required": ["healthy"],
          "properties": {
            "errors": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "healthy": {
              "type": "boolean"
            },
            "phase": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "core.cnrm.cloud.google.com",
          "kind": "ConfigConnectorContext",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.core.v1beta1.ConfigConnectorContextList": {
      "description": "ConfigConnectorContextList is a list of ConfigConnectorContext",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["core.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of configconnectorcontexts. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.core.v1beta1.ConfigConnectorContext"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ConfigConnectorContextList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "core.cnrm.cloud.google.com",
          "kind": "ConfigConnectorContextList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.core.v1beta1.ConfigConnectorList": {
      "description": "ConfigConnectorList is a list of ConfigConnector",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["core.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of configconnectors. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.core.v1beta1.ConfigConnector"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ConfigConnectorList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "core.cnrm.cloud.google.com",
          "kind": "ConfigConnectorList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.dataflow.v1beta1.DataflowFlexTemplateJob": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["dataflow.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DataflowFlexTemplateJob"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["containerSpecGcsPath"],
          "properties": {
            "containerSpecGcsPath": {
              "type": "string"
            },
            "parameters": {
              "x-kubernetes-preserve-unknown-fields": true
            },
            "region": {
              "description": "Immutable. The region in which the created job should run.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "jobId": {
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "state": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "dataflow.cnrm.cloud.google.com",
          "kind": "DataflowFlexTemplateJob",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.dataflow.v1beta1.DataflowFlexTemplateJobList": {
      "description": "DataflowFlexTemplateJobList is a list of DataflowFlexTemplateJob",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["dataflow.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of dataflowflextemplatejobs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.dataflow.v1beta1.DataflowFlexTemplateJob"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DataflowFlexTemplateJobList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "dataflow.cnrm.cloud.google.com",
          "kind": "DataflowFlexTemplateJobList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.dataflow.v1beta1.DataflowJob": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["dataflow.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DataflowJob"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["tempGcsLocation", "templateGcsPath"],
          "properties": {
            "additionalExperiments": {
              "description": "List of experiments that should be used by the job. An example value is [\"enable_stackdriver_agent_metrics\"].",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "enableStreamingEngine": {
              "description": "Indicates if the job should use the streaming engine feature.",
              "type": "boolean"
            },
            "ipConfiguration": {
              "description": "The configuration for VM IPs. Options are \"WORKER_IP_PUBLIC\" or \"WORKER_IP_PRIVATE\".",
              "type": "string"
            },
            "kmsKeyRef": {
              "description": "The name for the Cloud KMS key for the job.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a KMSCryptoKey.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "machineType": {
              "description": "The machine type to use for the job.",
              "type": "string"
            },
            "maxWorkers": {
              "description": "Immutable. The number of workers permitted to work on the job. More workers may improve processing speed at additional cost.",
              "type": "integer"
            },
            "networkRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "parameters": {
              "description": "Key/Value pairs to be passed to the Dataflow job (as used in the template).",
              "x-kubernetes-preserve-unknown-fields": true
            },
            "region": {
              "description": "Immutable. The region in which the created job should run.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "serviceAccountRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The email of an IAMServiceAccount.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "subnetworkRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeSubnetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "tempGcsLocation": {
              "description": "A writeable location on Google Cloud Storage for the Dataflow job to dump its temporary data.",
              "type": "string"
            },
            "templateGcsPath": {
              "description": "The Google Cloud Storage path to the Dataflow job template.",
              "type": "string"
            },
            "transformNameMapping": {
              "description": "Only applicable when updating a pipeline. Map of transform name prefixes of the job to be replaced with the corresponding name prefixes of the new job.",
              "x-kubernetes-preserve-unknown-fields": true
            },
            "zone": {
              "description": "Immutable. The zone in which the created job should run. If it is not provided, the provider zone is used.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "jobId": {
              "description": "The unique ID of this job.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "state": {
              "description": "The current state of the resource, selected from the JobState enum.",
              "type": "string"
            },
            "type": {
              "description": "The type of this job, selected from the JobType enum.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "dataflow.cnrm.cloud.google.com",
          "kind": "DataflowJob",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.dataflow.v1beta1.DataflowJobList": {
      "description": "DataflowJobList is a list of DataflowJob",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["dataflow.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of dataflowjobs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.dataflow.v1beta1.DataflowJob"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DataflowJobList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "dataflow.cnrm.cloud.google.com",
          "kind": "DataflowJobList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.datafusion.v1beta1.DataFusionInstance": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["datafusion.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DataFusionInstance"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location", "type"],
          "properties": {
            "dataprocServiceAccountRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "User-managed service account to set on Dataproc when Cloud Data Fusion creates Dataproc to run data processing pipelines. This allows users to have fine-grained access control on Dataproc's accesses to cloud resources.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "description": {
              "description": "A description of this instance.",
              "type": "string"
            },
            "displayName": {
              "description": "Display name for an instance.",
              "type": "string"
            },
            "enableStackdriverLogging": {
              "description": "Option to enable Stackdriver Logging.",
              "type": "boolean"
            },
            "enableStackdriverMonitoring": {
              "description": "Option to enable Stackdriver Monitoring.",
              "type": "boolean"
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "networkConfig": {
              "description": "Network configuration options. These are required when a private Data Fusion instance is to be created.",
              "type": "object",
              "properties": {
                "ipAllocation": {
                  "description": "The IP range in CIDR notation to use for the managed Data Fusion instance nodes. This range must not overlap with any other ranges used in the customer network.",
                  "type": "string"
                },
                "networkRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "Name of the network in the customer project with which the Tenant Project will be peered for executing pipelines. In case of shared VPC where the network resides in another host project the network should specified in the form of projects/{host-project-id}/global/networks/{network}",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "options": {
              "description": "Map of additional options used to configure the behavior of Data Fusion instance.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "privateInstance": {
              "description": "Specifies whether the Data Fusion instance should be private. If set to true, all Data Fusion nodes will have private IP addresses and will not be able to access the public internet.",
              "type": "boolean"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "type": {
              "description": "Required. Instance type. Possible values: TYPE_UNSPECIFIED, BASIC, ENTERPRISE, DEVELOPER",
              "type": "string"
            },
            "version": {
              "description": "Current version of the Data Fusion.",
              "type": "string"
            },
            "zone": {
              "description": "Name of the zone in which the Data Fusion instance will be created. Only DEVELOPER instances use this field.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "apiEndpoint": {
              "description": "Output only. Endpoint on which the REST APIs is accessible.",
              "type": "string"
            },
            "availableVersion": {
              "description": "Available versions that the instance can be upgraded to.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "availableFeatures": {
                    "description": "Represents a list of available feature names for a given version.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "defaultVersion": {
                    "description": "Whether this is currently the default version for Cloud Data Fusion",
                    "type": "boolean"
                  },
                  "versionNumber": {
                    "description": "The version number of the Data Fusion instance, such as '6.0.1.0'.",
                    "type": "string"
                  }
                }
              }
            },
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The time the instance was created.",
              "type": "string",
              "format": "date-time"
            },
            "gcsBucket": {
              "description": "Output only. Cloud Storage bucket generated by Data Fusion in the customer project.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "p4ServiceAccount": {
              "description": "Output only. P4 service account for the customer project.",
              "type": "string"
            },
            "serviceEndpoint": {
              "description": "Output only. Endpoint on which the Data Fusion UI is accessible.",
              "type": "string"
            },
            "state": {
              "description": "Output only. The current state of this Data Fusion instance. Possible values: STATE_UNSPECIFIED, ENABLED, DISABLED, UNKNOWN",
              "type": "string"
            },
            "stateMessage": {
              "description": "Output only. Additional information about the current state of this Data Fusion instance if available.",
              "type": "string"
            },
            "tenantProjectId": {
              "description": "Output only. The name of the tenant project.",
              "type": "string"
            },
            "updateTime": {
              "description": "Output only. The time the instance was last updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "datafusion.cnrm.cloud.google.com",
          "kind": "DataFusionInstance",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.datafusion.v1beta1.DataFusionInstanceList": {
      "description": "DataFusionInstanceList is a list of DataFusionInstance",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["datafusion.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of datafusioninstances. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.datafusion.v1beta1.DataFusionInstance"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DataFusionInstanceList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "datafusion.cnrm.cloud.google.com",
          "kind": "DataFusionInstanceList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.dataproc.v1beta1.DataprocAutoscalingPolicy": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["dataproc.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DataprocAutoscalingPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["basicAlgorithm", "location", "workerConfig"],
          "properties": {
            "basicAlgorithm": {
              "type": "object",
              "required": ["yarnConfig"],
              "properties": {
                "cooldownPeriod": {
                  "description": "Optional. Duration between scaling events. A scaling period starts after the update operation from the previous event has completed. Bounds: . Default: 2m.",
                  "type": "string"
                },
                "yarnConfig": {
                  "description": "Required. YARN autoscaling configuration.",
                  "type": "object",
                  "required": [
                    "gracefulDecommissionTimeout",
                    "scaleDownFactor",
                    "scaleUpFactor"
                  ],
                  "properties": {
                    "gracefulDecommissionTimeout": {
                      "description": "Required. Timeout for YARN graceful decommissioning of Node Managers. Specifies the duration to wait for jobs to complete before forcefully removing workers (and potentially interrupting jobs). Only applicable to downscaling operations.",
                      "type": "string"
                    },
                    "scaleDownFactor": {
                      "description": "Required. Fraction of average YARN pending memory in the last cooldown period for which to remove workers. A scale-down factor of 1 will result in scaling down so that there is no available memory remaining after the update (more aggressive scaling). A scale-down factor of 0 disables removing workers, which can be beneficial for autoscaling a single job. See .",
                      "type": "number",
                      "format": "double"
                    },
                    "scaleDownMinWorkerFraction": {
                      "description": "Optional. Minimum scale-down threshold as a fraction of total cluster size before scaling occurs. For example, in a 20-worker cluster, a threshold of 0.1 means the autoscaler must recommend at least a 2 worker scale-down for the cluster to scale. A threshold of 0 means the autoscaler will scale down on any recommended change. Bounds: . Default: 0.0.",
                      "type": "number",
                      "format": "double"
                    },
                    "scaleUpFactor": {
                      "description": "Required. Fraction of average YARN pending memory in the last cooldown period for which to add workers. A scale-up factor of 1.0 will result in scaling up so that there is no pending memory remaining after the update (more aggressive scaling). A scale-up factor closer to 0 will result in a smaller magnitude of scaling up (less aggressive scaling). See .",
                      "type": "number",
                      "format": "double"
                    },
                    "scaleUpMinWorkerFraction": {
                      "description": "Optional. Minimum scale-up threshold as a fraction of total cluster size before scaling occurs. For example, in a 20-worker cluster, a threshold of 0.1 means the autoscaler must recommend at least a 2-worker scale-up for the cluster to scale. A threshold of 0 means the autoscaler will scale up on any recommended change. Bounds: . Default: 0.0.",
                      "type": "number",
                      "format": "double"
                    }
                  }
                }
              }
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "secondaryWorkerConfig": {
              "description": "Optional. Describes how the autoscaler will operate for secondary workers.",
              "type": "object",
              "properties": {
                "maxInstances": {
                  "description": "Optional. Maximum number of instances for this group. Note that by default, clusters will not use secondary workers. Required for secondary workers if the minimum secondary instances is set. Primary workers - Bounds: [min_instances, ). Secondary workers - Bounds: [min_instances, ). Default: 0.",
                  "type": "integer",
                  "format": "int64"
                },
                "minInstances": {
                  "description": "Optional. Minimum number of instances for this group. Primary workers - Bounds: . Default: 0.",
                  "type": "integer",
                  "format": "int64"
                },
                "weight": {
                  "description": "Optional. Weight for the instance group, which is used to determine the fraction of total workers in the cluster from this instance group. For example, if primary workers have weight 2, and secondary workers have weight 1, the cluster will have approximately 2 primary workers for each secondary worker. The cluster may not reach the specified balance if constrained by min/max bounds or other autoscaling settings. For example, if `max_instances` for secondary workers is 0, then only primary workers will be added. The cluster can also be out of balance when created. If weight is not set on any instance group, the cluster will default to equal weight for all groups: the cluster will attempt to maintain an equal number of workers in each group within the configured size bounds for each group. If weight is set for one group only, the cluster will default to zero weight on the unset group. For example if weight is set only on primary workers, the cluster will use primary workers only and no secondary workers.",
                  "type": "integer",
                  "format": "int64"
                }
              }
            },
            "workerConfig": {
              "description": "Required. Describes how the autoscaler will operate for primary workers.",
              "type": "object",
              "required": ["maxInstances"],
              "properties": {
                "maxInstances": {
                  "description": "Required. Maximum number of instances for this group. Required for primary workers. Note that by default, clusters will not use secondary workers. Required for secondary workers if the minimum secondary instances is set. Primary workers - Bounds: [min_instances, ). Secondary workers - Bounds: [min_instances, ). Default: 0.",
                  "type": "integer",
                  "format": "int64"
                },
                "minInstances": {
                  "description": "Optional. Minimum number of instances for this group. Primary workers - Bounds: . Default: 0.",
                  "type": "integer",
                  "format": "int64"
                },
                "weight": {
                  "description": "Optional. Weight for the instance group, which is used to determine the fraction of total workers in the cluster from this instance group. For example, if primary workers have weight 2, and secondary workers have weight 1, the cluster will have approximately 2 primary workers for each secondary worker. The cluster may not reach the specified balance if constrained by min/max bounds or other autoscaling settings. For example, if `max_instances` for secondary workers is 0, then only primary workers will be added. The cluster can also be out of balance when created. If weight is not set on any instance group, the cluster will default to equal weight for all groups: the cluster will attempt to maintain an equal number of workers in each group within the configured size bounds for each group. If weight is set for one group only, the cluster will default to zero weight on the unset group. For example if weight is set only on primary workers, the cluster will use primary workers only and no secondary workers.",
                  "type": "integer",
                  "format": "int64"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "dataproc.cnrm.cloud.google.com",
          "kind": "DataprocAutoscalingPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.dataproc.v1beta1.DataprocAutoscalingPolicyList": {
      "description": "DataprocAutoscalingPolicyList is a list of DataprocAutoscalingPolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["dataproc.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of dataprocautoscalingpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.dataproc.v1beta1.DataprocAutoscalingPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DataprocAutoscalingPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "dataproc.cnrm.cloud.google.com",
          "kind": "DataprocAutoscalingPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.dataproc.v1beta1.DataprocCluster": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["dataproc.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DataprocCluster"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location"],
          "properties": {
            "config": {
              "description": "Required. The cluster config. Note that Dataproc may set default values, and values may change when clusters are updated.",
              "type": "object",
              "properties": {
                "autoscalingConfig": {
                  "description": "Optional. Autoscaling config for the policy associated with the cluster. Cluster does not autoscale if this field is unset.",
                  "type": "object",
                  "properties": {
                    "policyRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "Optional. The autoscaling policy used by the cluster. Only resource names including projectid and location (region) are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[project_id]/locations/[dataproc_region]/autoscalingPolicies/[policy_id]` * `projects/[project_id]/locations/[dataproc_region]/autoscalingPolicies/[policy_id]` Note that the policy must be in the same project and Dataproc region.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "encryptionConfig": {
                  "description": "Optional. Encryption settings for the cluster.",
                  "type": "object",
                  "properties": {
                    "gcePdKmsKeyRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "Optional. The Cloud KMS key name to use for PD disk encryption for all instances in the cluster.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "endpointConfig": {
                  "description": "Optional. Port/endpoint configuration for this cluster",
                  "type": "object",
                  "properties": {
                    "enableHttpPortAccess": {
                      "description": "Optional. If true, enable http access to specific ports on the cluster from external sources. Defaults to false.",
                      "type": "boolean"
                    }
                  }
                },
                "gceClusterConfig": {
                  "description": "Optional. The shared Compute Engine config settings for all instances in a cluster.",
                  "type": "object",
                  "properties": {
                    "internalIPOnly": {
                      "description": "Optional. If true, all instances in the cluster will only have internal IP addresses. By default, clusters are not restricted to internal IP addresses, and will have ephemeral external IP addresses assigned to each instance. This `internal_ip_only` restriction can only be enabled for subnetwork enabled networks, and all off-cluster dependencies must be configured to be accessible without external IP addresses.",
                      "type": "boolean"
                    },
                    "metadata": {
                      "description": "The Compute Engine metadata entries to add to all instances (see [Project and instance metadata](https://cloud.google.com/compute/docs/storing-retrieving-metadata#project_and_instance_metadata)).",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "networkRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "Optional. The Compute Engine network to be used for machine communications. Cannot be specified with subnetwork_uri. If neither `network_uri` nor `subnetwork_uri` is specified, the \"default\" network of the project is used, if it exists. Cannot be a \"Custom Subnet Network\" (see [Using Subnetworks](https://cloud.google.com/compute/docs/subnetworks) for more information). A full URL, partial URI, or short name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[project_id]/regions/global/default` * `projects/[project_id]/regions/global/default` * `default`",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    },
                    "nodeGroupAffinity": {
                      "description": "Optional. Node Group Affinity for sole-tenant clusters.",
                      "type": "object",
                      "required": ["nodeGroupRef"],
                      "properties": {
                        "nodeGroupRef": {
                          "type": "object",
                          "properties": {
                            "external": {
                              "description": "Required. The URI of a sole-tenant [node group resource](https://cloud.google.com/compute/docs/reference/rest/v1/nodeGroups) that the cluster will be created on. A full URL, partial URI, or node group name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[project_id]/zones/us-central1-a/nodeGroups/node-group-1` * `projects/[project_id]/zones/us-central1-a/nodeGroups/node-group-1` * `node-group-1`",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                              "type": "string"
                            },
                            "namespace": {
                              "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "privateIPv6GoogleAccess": {
                      "description": "Optional. The type of IPv6 access for a cluster. Possible values: PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED, INHERIT_FROM_SUBNETWORK, OUTBOUND, BIDIRECTIONAL",
                      "type": "string"
                    },
                    "reservationAffinity": {
                      "description": "Optional. Reservation Affinity for consuming Zonal reservation.",
                      "type": "object",
                      "properties": {
                        "consumeReservationType": {
                          "description": "Optional. Type of reservation to consume Possible values: TYPE_UNSPECIFIED, NO_RESERVATION, ANY_RESERVATION, SPECIFIC_RESERVATION",
                          "type": "string"
                        },
                        "key": {
                          "description": "Optional. Corresponds to the label key of reservation resource.",
                          "type": "string"
                        },
                        "values": {
                          "description": "Optional. Corresponds to the label values of reservation resource.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      }
                    },
                    "serviceAccountRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "Optional. The [Dataproc service account](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/service-accounts#service_accounts_in_dataproc) (also see [VM Data Plane identity](https://cloud.google.com/dataproc/docs/concepts/iam/dataproc-principals#vm_service_account_data_plane_identity)) used by Dataproc cluster VM instances to access Google Cloud Platform services. If not specified, the [Compute Engine default service account](https://cloud.google.com/compute/docs/access/service-accounts#default_service_account) is used.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    },
                    "serviceAccountScopes": {
                      "description": "Optional. The URIs of service account scopes to be included in Compute Engine instances. The following base set of scopes is always included: * https://www.googleapis.com/auth/cloud.useraccounts.readonly * https://www.googleapis.com/auth/devstorage.read_write * https://www.googleapis.com/auth/logging.write If no scopes are specified, the following defaults are also provided: * https://www.googleapis.com/auth/bigquery * https://www.googleapis.com/auth/bigtable.admin.table * https://www.googleapis.com/auth/bigtable.data * https://www.googleapis.com/auth/devstorage.full_control",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "subnetworkRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "Optional. The Compute Engine subnetwork to be used for machine communications. Cannot be specified with network_uri. A full URL, partial URI, or short name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[project_id]/regions/us-east1/subnetworks/sub0` * `projects/[project_id]/regions/us-east1/subnetworks/sub0` * `sub0`",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    },
                    "tags": {
                      "description": "The Compute Engine tags to add to all instances (see [Tagging instances](https://cloud.google.com/compute/docs/label-or-tag-resources#tags)).",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "zone": {
                      "description": "Optional. The zone where the Compute Engine cluster will be located. On a create request, it is required in the \"global\" region. If omitted in a non-global Dataproc region, the service will pick a zone in the corresponding Compute Engine region. On a get request, zone will always be present. A full URL, partial URI, or short name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[project_id]/zones/[zone]` * `projects/[project_id]/zones/[zone]` * `us-central1-f`",
                      "type": "string"
                    }
                  }
                },
                "initializationActions": {
                  "description": "Optional. Commands to execute on each node after config is completed. By default, executables are run on master and all worker nodes. You can test a node's `role` metadata to run an executable on a master or worker node, as shown below using `curl` (you can also use `wget`): ROLE=$(curl -H Metadata-Flavor:Google http://metadata/computeMetadata/v1/instance/attributes/dataproc-role) if [[ \"${ROLE}\" == 'Master' ]]; then ... master specific actions ... else ... worker specific actions ... fi",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["executableFile"],
                    "properties": {
                      "executableFile": {
                        "description": "Required. Cloud Storage URI of executable file.",
                        "type": "string"
                      },
                      "executionTimeout": {
                        "description": "Optional. Amount of time executable has to complete. Default is 10 minutes (see JSON representation of [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)). Cluster creation fails with an explanatory error message (the name of the executable that caused the error and the exceeded timeout period) if the executable is not completed at end of the timeout period.",
                        "type": "string"
                      }
                    }
                  }
                },
                "lifecycleConfig": {
                  "description": "Optional. Lifecycle setting for the cluster.",
                  "type": "object",
                  "properties": {
                    "autoDeleteTime": {
                      "description": "Optional. The time when cluster will be auto-deleted (see JSON representation of [Timestamp](https://developers.google.com/protocol-buffers/docs/proto3#json)).",
                      "type": "string",
                      "format": "date-time"
                    },
                    "autoDeleteTtl": {
                      "description": "Optional. The lifetime duration of cluster. The cluster will be auto-deleted at the end of this period. Minimum value is 10 minutes; maximum value is 14 days (see JSON representation of [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).",
                      "type": "string"
                    },
                    "idleDeleteTtl": {
                      "description": "Optional. The duration to keep the cluster alive while idling (when no jobs are running). Passing this threshold will cause the cluster to be deleted. Minimum value is 5 minutes; maximum value is 14 days (see JSON representation of [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).",
                      "type": "string"
                    }
                  }
                },
                "masterConfig": {
                  "description": "Optional. The Compute Engine config settings for the master instance in a cluster.",
                  "type": "object",
                  "properties": {
                    "accelerators": {
                      "description": "Optional. The Compute Engine accelerator configuration for these instances.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "acceleratorCount": {
                            "description": "The number of the accelerator cards of this type exposed to this instance.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "acceleratorType": {
                            "description": "Full URL, partial URI, or short name of the accelerator type resource to expose to this instance. See [Compute Engine AcceleratorTypes](https://cloud.google.com/compute/docs/reference/beta/acceleratorTypes). Examples: * `https://www.googleapis.com/compute/beta/projects/[project_id]/zones/us-east1-a/acceleratorTypes/nvidia-tesla-k80` * `projects/[project_id]/zones/us-east1-a/acceleratorTypes/nvidia-tesla-k80` * `nvidia-tesla-k80` **Auto Zone Exception**: If you are using the Dataproc [Auto Zone Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the accelerator type resource, for example, `nvidia-tesla-k80`.",
                            "type": "string"
                          }
                        }
                      }
                    },
                    "diskConfig": {
                      "description": "Optional. Disk option config settings.",
                      "type": "object",
                      "properties": {
                        "bootDiskSizeGb": {
                          "description": "Optional. Size in GB of the boot disk (default is 500GB).",
                          "type": "integer",
                          "format": "int64"
                        },
                        "bootDiskType": {
                          "description": "Optional. Type of the boot disk (default is \"pd-standard\"). Valid values: \"pd-balanced\" (Persistent Disk Balanced Solid State Drive), \"pd-ssd\" (Persistent Disk Solid State Drive), or \"pd-standard\" (Persistent Disk Hard Disk Drive). See [Disk types](https://cloud.google.com/compute/docs/disks#disk-types).",
                          "type": "string"
                        },
                        "numLocalSsds": {
                          "description": "Optional. Number of attached SSDs, from 0 to 4 (default is 0). If SSDs are not attached, the boot disk is used to store runtime logs and [HDFS](https://hadoop.apache.org/docs/r1.2.1/hdfs_user_guide.html) data. If one or more SSDs are attached, this runtime bulk data is spread across them, and the boot disk contains only basic config and installed binaries.",
                          "type": "integer",
                          "format": "int64"
                        }
                      }
                    },
                    "imageRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "Optional. The Compute Engine image resource used for cluster instances. The URI can represent an image or image family. Image examples: * `https://www.googleapis.com/compute/beta/projects/[project_id]/global/images/[image-id]` * `projects/[project_id]/global/images/[image-id]` * `image-id` Image family examples. Dataproc will use the most recent image from the family: * `https://www.googleapis.com/compute/beta/projects/[project_id]/global/images/family/[custom-image-family-name]` * `projects/[project_id]/global/images/family/[custom-image-family-name]` If the URI is unspecified, it will be inferred from `SoftwareConfig.image_version` or the system default.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    },
                    "machineType": {
                      "description": "Optional. The Compute Engine machine type used for cluster instances. A full URL, partial URI, or short name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[project_id]/zones/us-east1-a/machineTypes/n1-standard-2` * `projects/[project_id]/zones/us-east1-a/machineTypes/n1-standard-2` * `n1-standard-2` **Auto Zone Exception**: If you are using the Dataproc [Auto Zone Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the machine type resource, for example, `n1-standard-2`.",
                      "type": "string"
                    },
                    "minCpuPlatform": {
                      "description": "Optional. Specifies the minimum cpu platform for the Instance Group. See [Dataproc -> Minimum CPU Platform](https://cloud.google.com/dataproc/docs/concepts/compute/dataproc-min-cpu).",
                      "type": "string"
                    },
                    "numInstances": {
                      "description": "Optional. The number of VM instances in the instance group. For [HA cluster](/dataproc/docs/concepts/configuring-clusters/high-availability) [master_config](#FIELDS.master_config) groups, **must be set to 3**. For standard cluster [master_config](#FIELDS.master_config) groups, **must be set to 1**.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "preemptibility": {
                      "description": "Optional. Specifies the preemptibility of the instance group. The default value for master and worker groups is `NON_PREEMPTIBLE`. This default cannot be changed. The default value for secondary instances is `PREEMPTIBLE`. Possible values: PREEMPTIBILITY_UNSPECIFIED, NON_PREEMPTIBLE, PREEMPTIBLE",
                      "type": "string"
                    }
                  }
                },
                "secondaryWorkerConfig": {
                  "description": "Optional. The Compute Engine config settings for the master instance in a cluster.",
                  "type": "object",
                  "properties": {
                    "accelerators": {
                      "description": "Optional. The Compute Engine accelerator configuration for these instances.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "acceleratorCount": {
                            "description": "The number of the accelerator cards of this type exposed to this instance.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "acceleratorType": {
                            "description": "Full URL, partial URI, or short name of the accelerator type resource to expose to this instance. See [Compute Engine AcceleratorTypes](https://cloud.google.com/compute/docs/reference/beta/acceleratorTypes). Examples: * `https://www.googleapis.com/compute/beta/projects/[project_id]/zones/us-east1-a/acceleratorTypes/nvidia-tesla-k80` * `projects/[project_id]/zones/us-east1-a/acceleratorTypes/nvidia-tesla-k80` * `nvidia-tesla-k80` **Auto Zone Exception**: If you are using the Dataproc [Auto Zone Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the accelerator type resource, for example, `nvidia-tesla-k80`.",
                            "type": "string"
                          }
                        }
                      }
                    },
                    "diskConfig": {
                      "description": "Optional. Disk option config settings.",
                      "type": "object",
                      "properties": {
                        "bootDiskSizeGb": {
                          "description": "Optional. Size in GB of the boot disk (default is 500GB).",
                          "type": "integer",
                          "format": "int64"
                        },
                        "bootDiskType": {
                          "description": "Optional. Type of the boot disk (default is \"pd-standard\"). Valid values: \"pd-balanced\" (Persistent Disk Balanced Solid State Drive), \"pd-ssd\" (Persistent Disk Solid State Drive), or \"pd-standard\" (Persistent Disk Hard Disk Drive). See [Disk types](https://cloud.google.com/compute/docs/disks#disk-types).",
                          "type": "string"
                        },
                        "numLocalSsds": {
                          "description": "Optional. Number of attached SSDs, from 0 to 4 (default is 0). If SSDs are not attached, the boot disk is used to store runtime logs and [HDFS](https://hadoop.apache.org/docs/r1.2.1/hdfs_user_guide.html) data. If one or more SSDs are attached, this runtime bulk data is spread across them, and the boot disk contains only basic config and installed binaries.",
                          "type": "integer",
                          "format": "int64"
                        }
                      }
                    },
                    "imageRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "Optional. The Compute Engine image resource used for cluster instances. The URI can represent an image or image family. Image examples: * `https://www.googleapis.com/compute/beta/projects/[project_id]/global/images/[image-id]` * `projects/[project_id]/global/images/[image-id]` * `image-id` Image family examples. Dataproc will use the most recent image from the family: * `https://www.googleapis.com/compute/beta/projects/[project_id]/global/images/family/[custom-image-family-name]` * `projects/[project_id]/global/images/family/[custom-image-family-name]` If the URI is unspecified, it will be inferred from `SoftwareConfig.image_version` or the system default.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    },
                    "machineType": {
                      "description": "Optional. The Compute Engine machine type used for cluster instances. A full URL, partial URI, or short name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[project_id]/zones/us-east1-a/machineTypes/n1-standard-2` * `projects/[project_id]/zones/us-east1-a/machineTypes/n1-standard-2` * `n1-standard-2` **Auto Zone Exception**: If you are using the Dataproc [Auto Zone Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the machine type resource, for example, `n1-standard-2`.",
                      "type": "string"
                    },
                    "minCpuPlatform": {
                      "description": "Optional. Specifies the minimum cpu platform for the Instance Group. See [Dataproc -> Minimum CPU Platform](https://cloud.google.com/dataproc/docs/concepts/compute/dataproc-min-cpu).",
                      "type": "string"
                    },
                    "numInstances": {
                      "description": "Optional. The number of VM instances in the instance group. For [HA cluster](/dataproc/docs/concepts/configuring-clusters/high-availability) [master_config](#FIELDS.master_config) groups, **must be set to 3**. For standard cluster [master_config](#FIELDS.master_config) groups, **must be set to 1**.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "preemptibility": {
                      "description": "Optional. Specifies the preemptibility of the instance group. The default value for master and worker groups is `NON_PREEMPTIBLE`. This default cannot be changed. The default value for secondary instances is `PREEMPTIBLE`. Possible values: PREEMPTIBILITY_UNSPECIFIED, NON_PREEMPTIBLE, PREEMPTIBLE",
                      "type": "string"
                    }
                  }
                },
                "securityConfig": {
                  "description": "Optional. Security settings for the cluster.",
                  "type": "object",
                  "properties": {
                    "kerberosConfig": {
                      "description": "Optional. Kerberos related configuration.",
                      "type": "object",
                      "properties": {
                        "crossRealmTrustAdminServer": {
                          "description": "Optional. The admin server (IP or hostname) for the remote trusted realm in a cross realm trust relationship.",
                          "type": "string"
                        },
                        "crossRealmTrustKdc": {
                          "description": "Optional. The KDC (IP or hostname) for the remote trusted realm in a cross realm trust relationship.",
                          "type": "string"
                        },
                        "crossRealmTrustRealm": {
                          "description": "Optional. The remote realm the Dataproc on-cluster KDC will trust, should the user enable cross realm trust.",
                          "type": "string"
                        },
                        "crossRealmTrustSharedPassword": {
                          "description": "Optional. The Cloud Storage URI of a KMS encrypted file containing the shared password between the on-cluster Kerberos realm and the remote trusted realm, in a cross realm trust relationship.",
                          "type": "string"
                        },
                        "enableKerberos": {
                          "description": "Optional. Flag to indicate whether to Kerberize the cluster (default: false). Set this field to true to enable Kerberos on a cluster.",
                          "type": "boolean"
                        },
                        "kdcDbKey": {
                          "description": "Optional. The Cloud Storage URI of a KMS encrypted file containing the master key of the KDC database.",
                          "type": "string"
                        },
                        "keyPassword": {
                          "description": "Optional. The Cloud Storage URI of a KMS encrypted file containing the password to the user provided key. For the self-signed certificate, this password is generated by Dataproc.",
                          "type": "string"
                        },
                        "keystore": {
                          "description": "Optional. The Cloud Storage URI of the keystore file used for SSL encryption. If not provided, Dataproc will provide a self-signed certificate.",
                          "type": "string"
                        },
                        "keystorePassword": {
                          "description": "Optional. The Cloud Storage URI of a KMS encrypted file containing the password to the user provided keystore. For the self-signed certificate, this password is generated by Dataproc.",
                          "type": "string"
                        },
                        "kmsKeyRef": {
                          "type": "object",
                          "properties": {
                            "external": {
                              "description": "Optional. The uri of the KMS key used to encrypt various sensitive files.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                              "type": "string"
                            },
                            "namespace": {
                              "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                              "type": "string"
                            }
                          }
                        },
                        "realm": {
                          "description": "Optional. The name of the on-cluster Kerberos realm. If not specified, the uppercased domain of hostnames will be the realm.",
                          "type": "string"
                        },
                        "rootPrincipalPassword": {
                          "description": "Optional. The Cloud Storage URI of a KMS encrypted file containing the root principal password.",
                          "type": "string"
                        },
                        "tgtLifetimeHours": {
                          "description": "Optional. The lifetime of the ticket granting ticket, in hours. If not specified, or user specifies 0, then default value 10 will be used.",
                          "type": "integer",
                          "format": "int64"
                        },
                        "truststore": {
                          "description": "Optional. The Cloud Storage URI of the truststore file used for SSL encryption. If not provided, Dataproc will provide a self-signed certificate.",
                          "type": "string"
                        },
                        "truststorePassword": {
                          "description": "Optional. The Cloud Storage URI of a KMS encrypted file containing the password to the user provided truststore. For the self-signed certificate, this password is generated by Dataproc.",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "softwareConfig": {
                  "description": "Optional. The config settings for software inside the cluster.",
                  "type": "object",
                  "properties": {
                    "imageVersion": {
                      "description": "Optional. The version of software inside the cluster. It must be one of the supported [Dataproc Versions](https://cloud.google.com/dataproc/docs/concepts/versioning/dataproc-versions#supported_dataproc_versions), such as \"1.2\" (including a subminor version, such as \"1.2.29\"), or the [\"preview\" version](https://cloud.google.com/dataproc/docs/concepts/versioning/dataproc-versions#other_versions). If unspecified, it defaults to the latest Debian version.",
                      "type": "string"
                    },
                    "optionalComponents": {
                      "description": "Optional. The set of components to activate on the cluster.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "properties": {
                      "description": "Optional. The properties to set on daemon config files. Property keys are specified in `prefix:property` format, for example `core:hadoop.tmp.dir`. The following are supported prefixes and their mappings: * capacity-scheduler: `capacity-scheduler.xml` * core: `core-site.xml` * distcp: `distcp-default.xml` * hdfs: `hdfs-site.xml` * hive: `hive-site.xml` * mapred: `mapred-site.xml` * pig: `pig.properties` * spark: `spark-defaults.conf` * yarn: `yarn-site.xml` For more information, see [Cluster properties](https://cloud.google.com/dataproc/docs/concepts/cluster-properties).",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    }
                  }
                },
                "stagingBucketRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "Optional. A Cloud Storage bucket used to stage job dependencies, config files, and job driver console output. If you do not specify a staging bucket, Cloud Dataproc will determine a Cloud Storage location (US, ASIA, or EU) for your cluster's staging bucket according to the Compute Engine zone where your cluster is deployed, and then create and manage this project-level, per-location bucket (see [Dataproc staging bucket](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/staging-bucket)). **This field requires a Cloud Storage bucket name, not a URI to a Cloud Storage bucket.**",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "tempBucketRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "Optional. A Cloud Storage bucket used to store ephemeral cluster and jobs data, such as Spark and MapReduce history files. If you do not specify a temp bucket, Dataproc will determine a Cloud Storage location (US, ASIA, or EU) for your cluster's temp bucket according to the Compute Engine zone where your cluster is deployed, and then create and manage this project-level, per-location bucket. The default bucket has a TTL of 90 days, but you can use any TTL (or none) if you specify a bucket. **This field requires a Cloud Storage bucket name, not a URI to a Cloud Storage bucket.**",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "workerConfig": {
                  "description": "Optional. The Compute Engine config settings for the master instance in a cluster.",
                  "type": "object",
                  "properties": {
                    "accelerators": {
                      "description": "Optional. The Compute Engine accelerator configuration for these instances.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "acceleratorCount": {
                            "description": "The number of the accelerator cards of this type exposed to this instance.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "acceleratorType": {
                            "description": "Full URL, partial URI, or short name of the accelerator type resource to expose to this instance. See [Compute Engine AcceleratorTypes](https://cloud.google.com/compute/docs/reference/beta/acceleratorTypes). Examples: * `https://www.googleapis.com/compute/beta/projects/[project_id]/zones/us-east1-a/acceleratorTypes/nvidia-tesla-k80` * `projects/[project_id]/zones/us-east1-a/acceleratorTypes/nvidia-tesla-k80` * `nvidia-tesla-k80` **Auto Zone Exception**: If you are using the Dataproc [Auto Zone Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the accelerator type resource, for example, `nvidia-tesla-k80`.",
                            "type": "string"
                          }
                        }
                      }
                    },
                    "diskConfig": {
                      "description": "Optional. Disk option config settings.",
                      "type": "object",
                      "properties": {
                        "bootDiskSizeGb": {
                          "description": "Optional. Size in GB of the boot disk (default is 500GB).",
                          "type": "integer",
                          "format": "int64"
                        },
                        "bootDiskType": {
                          "description": "Optional. Type of the boot disk (default is \"pd-standard\"). Valid values: \"pd-balanced\" (Persistent Disk Balanced Solid State Drive), \"pd-ssd\" (Persistent Disk Solid State Drive), or \"pd-standard\" (Persistent Disk Hard Disk Drive). See [Disk types](https://cloud.google.com/compute/docs/disks#disk-types).",
                          "type": "string"
                        },
                        "numLocalSsds": {
                          "description": "Optional. Number of attached SSDs, from 0 to 4 (default is 0). If SSDs are not attached, the boot disk is used to store runtime logs and [HDFS](https://hadoop.apache.org/docs/r1.2.1/hdfs_user_guide.html) data. If one or more SSDs are attached, this runtime bulk data is spread across them, and the boot disk contains only basic config and installed binaries.",
                          "type": "integer",
                          "format": "int64"
                        }
                      }
                    },
                    "imageRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "Optional. The Compute Engine image resource used for cluster instances. The URI can represent an image or image family. Image examples: * `https://www.googleapis.com/compute/beta/projects/[project_id]/global/images/[image-id]` * `projects/[project_id]/global/images/[image-id]` * `image-id` Image family examples. Dataproc will use the most recent image from the family: * `https://www.googleapis.com/compute/beta/projects/[project_id]/global/images/family/[custom-image-family-name]` * `projects/[project_id]/global/images/family/[custom-image-family-name]` If the URI is unspecified, it will be inferred from `SoftwareConfig.image_version` or the system default.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    },
                    "machineType": {
                      "description": "Optional. The Compute Engine machine type used for cluster instances. A full URL, partial URI, or short name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[project_id]/zones/us-east1-a/machineTypes/n1-standard-2` * `projects/[project_id]/zones/us-east1-a/machineTypes/n1-standard-2` * `n1-standard-2` **Auto Zone Exception**: If you are using the Dataproc [Auto Zone Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the machine type resource, for example, `n1-standard-2`.",
                      "type": "string"
                    },
                    "minCpuPlatform": {
                      "description": "Optional. Specifies the minimum cpu platform for the Instance Group. See [Dataproc -> Minimum CPU Platform](https://cloud.google.com/dataproc/docs/concepts/compute/dataproc-min-cpu).",
                      "type": "string"
                    },
                    "numInstances": {
                      "description": "Optional. The number of VM instances in the instance group. For [HA cluster](/dataproc/docs/concepts/configuring-clusters/high-availability) [master_config](#FIELDS.master_config) groups, **must be set to 3**. For standard cluster [master_config](#FIELDS.master_config) groups, **must be set to 1**.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "preemptibility": {
                      "description": "Optional. Specifies the preemptibility of the instance group. The default value for master and worker groups is `NON_PREEMPTIBLE`. This default cannot be changed. The default value for secondary instances is `PREEMPTIBLE`. Possible values: PREEMPTIBILITY_UNSPECIFIED, NON_PREEMPTIBLE, PREEMPTIBLE",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "location": {
              "description": "The location for the resource, usually a GCP region.",
              "type": "string"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "Required. The Google Cloud Platform project ID that the cluster belongs to.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "clusterUuid": {
              "description": "Output only. A cluster UUID (Unique Universal Identifier). Dataproc generates this value when it creates the cluster.",
              "type": "string"
            },
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "config": {
              "type": "object",
              "properties": {
                "endpointConfig": {
                  "type": "object",
                  "properties": {
                    "httpPorts": {
                      "description": "Output only. The map of port descriptions to URLs. Will only be populated if enable_http_port_access is true.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    }
                  }
                },
                "lifecycleConfig": {
                  "type": "object",
                  "properties": {
                    "idleStartTime": {
                      "description": "Output only. The time when cluster became idle (most recent job finished) and became eligible for deletion due to idleness (see JSON representation of [Timestamp](https://developers.google.com/protocol-buffers/docs/proto3#json)).",
                      "type": "string",
                      "format": "date-time"
                    }
                  }
                },
                "masterConfig": {
                  "type": "object",
                  "properties": {
                    "instanceNames": {
                      "description": "Output only. The list of instance names. Dataproc derives the names from `cluster_name`, `num_instances`, and the instance group.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "isPreemptible": {
                      "description": "Output only. Specifies that this instance group contains preemptible instances.",
                      "type": "boolean"
                    },
                    "managedGroupConfig": {
                      "description": "Output only. The config for Compute Engine Instance Group Manager that manages this group. This is only used for preemptible instance groups.",
                      "type": "object",
                      "properties": {
                        "instanceGroupManagerName": {
                          "description": "Output only. The name of the Instance Group Manager for this group.",
                          "type": "string"
                        },
                        "instanceTemplateName": {
                          "description": "Output only. The name of the Instance Template used for the Managed Instance Group.",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "secondaryWorkerConfig": {
                  "type": "object",
                  "properties": {
                    "instanceNames": {
                      "description": "Output only. The list of instance names. Dataproc derives the names from `cluster_name`, `num_instances`, and the instance group.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "isPreemptible": {
                      "description": "Output only. Specifies that this instance group contains preemptible instances.",
                      "type": "boolean"
                    },
                    "managedGroupConfig": {
                      "description": "Output only. The config for Compute Engine Instance Group Manager that manages this group. This is only used for preemptible instance groups.",
                      "type": "object",
                      "properties": {
                        "instanceGroupManagerName": {
                          "description": "Output only. The name of the Instance Group Manager for this group.",
                          "type": "string"
                        },
                        "instanceTemplateName": {
                          "description": "Output only. The name of the Instance Template used for the Managed Instance Group.",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "workerConfig": {
                  "type": "object",
                  "properties": {
                    "instanceNames": {
                      "description": "Output only. The list of instance names. Dataproc derives the names from `cluster_name`, `num_instances`, and the instance group.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "isPreemptible": {
                      "description": "Output only. Specifies that this instance group contains preemptible instances.",
                      "type": "boolean"
                    },
                    "managedGroupConfig": {
                      "description": "Output only. The config for Compute Engine Instance Group Manager that manages this group. This is only used for preemptible instance groups.",
                      "type": "object",
                      "properties": {
                        "instanceGroupManagerName": {
                          "description": "Output only. The name of the Instance Group Manager for this group.",
                          "type": "string"
                        },
                        "instanceTemplateName": {
                          "description": "Output only. The name of the Instance Template used for the Managed Instance Group.",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "metrics": {
              "description": "Output only. Contains cluster daemon metrics such as HDFS and YARN stats. **Beta Feature**: This report is available for testing purposes only. It may be changed before final release.",
              "type": "object",
              "properties": {
                "hdfsMetrics": {
                  "description": "The HDFS metrics.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "yarnMetrics": {
                  "description": "The YARN metrics.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "status": {
              "description": "Output only. Cluster status.",
              "type": "object",
              "properties": {
                "detail": {
                  "description": "Optional. Output only. Details of cluster's state.",
                  "type": "string"
                },
                "state": {
                  "description": "Output only. The cluster's state. Possible values: UNKNOWN, CREATING, RUNNING, ERROR, DELETING, UPDATING, STOPPING, STOPPED, STARTING",
                  "type": "string"
                },
                "stateStartTime": {
                  "description": "Output only. Time when this state was entered (see JSON representation of [Timestamp](https://developers.google.com/protocol-buffers/docs/proto3#json)).",
                  "type": "string",
                  "format": "date-time"
                },
                "substate": {
                  "description": "Output only. Additional state information that includes status reported by the agent. Possible values: UNSPECIFIED, UNHEALTHY, STALE_STATUS",
                  "type": "string"
                }
              }
            },
            "statusHistory": {
              "description": "Output only. The previous cluster status.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "detail": {
                    "description": "Optional. Output only. Details of cluster's state.",
                    "type": "string"
                  },
                  "state": {
                    "description": "Output only. The cluster's state. Possible values: UNKNOWN, CREATING, RUNNING, ERROR, DELETING, UPDATING, STOPPING, STOPPED, STARTING",
                    "type": "string"
                  },
                  "stateStartTime": {
                    "description": "Output only. Time when this state was entered (see JSON representation of [Timestamp](https://developers.google.com/protocol-buffers/docs/proto3#json)).",
                    "type": "string",
                    "format": "date-time"
                  },
                  "substate": {
                    "description": "Output only. Additional state information that includes status reported by the agent. Possible values: UNSPECIFIED, UNHEALTHY, STALE_STATUS",
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "dataproc.cnrm.cloud.google.com",
          "kind": "DataprocCluster",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.dataproc.v1beta1.DataprocClusterList": {
      "description": "DataprocClusterList is a list of DataprocCluster",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["dataproc.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of dataprocclusters. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.dataproc.v1beta1.DataprocCluster"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DataprocClusterList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "dataproc.cnrm.cloud.google.com",
          "kind": "DataprocClusterList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.dataproc.v1beta1.DataprocWorkflowTemplate": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["dataproc.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DataprocWorkflowTemplate"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["jobs", "location", "placement"],
          "properties": {
            "dagTimeout": {
              "description": "Optional. Timeout duration for the DAG of jobs, expressed in seconds (see [JSON representation of duration](https://developers.google.com/protocol-buffers/docs/proto3#json)). The timeout duration must be from 10 minutes (\"600s\") to 24 hours (\"86400s\"). The timer begins when the first job is submitted. If the workflow is running at the end of the timeout period, any remaining jobs are cancelled, the workflow is ended, and if the workflow was running on a [managed cluster](/dataproc/docs/concepts/workflows/using-workflows#configuring_or_selecting_a_cluster), the cluster is deleted.",
              "type": "string"
            },
            "jobs": {
              "description": "Required. The Directed Acyclic Graph of Jobs to submit.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["stepId"],
                "properties": {
                  "hadoopJob": {
                    "description": "Optional. Job is a Hadoop job.",
                    "type": "object",
                    "properties": {
                      "archiveUris": {
                        "description": "Optional. HCFS URIs of archives to be extracted in the working directory of Hadoop drivers and tasks. Supported file types: .jar, .tar, .tar.gz, .tgz, or .zip.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "args": {
                        "description": "Optional. The arguments to pass to the driver. Do not include arguments, such as `-libjars` or `-Dfoo=bar`, that can be set as job properties, since a collision may occur that causes an incorrect job submission.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "fileUris": {
                        "description": "Optional. HCFS (Hadoop Compatible Filesystem) URIs of files to be copied to the working directory of Hadoop drivers and distributed tasks. Useful for naively parallel tasks.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "jarFileUris": {
                        "description": "Optional. Jar file URIs to add to the CLASSPATHs of the Hadoop driver and tasks.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "loggingConfig": {
                        "description": "Optional. The runtime log config for job execution.",
                        "type": "object",
                        "properties": {
                          "driverLogLevels": {
                            "description": "The per-package log levels for the driver. This may include \"root\" package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "mainClass": {
                        "description": "The name of the driver's main class. The jar file containing the class must be in the default CLASSPATH or specified in `jar_file_uris`.",
                        "type": "string"
                      },
                      "mainJarFileUri": {
                        "description": "The HCFS URI of the jar file containing the main class. Examples: 'gs://foo-bucket/analytics-binaries/extract-useful-metrics-mr.jar' 'hdfs:/tmp/test-samples/custom-wordcount.jar' 'file:///home/usr/lib/hadoop-mapreduce/hadoop-mapreduce-examples.jar'",
                        "type": "string"
                      },
                      "properties": {
                        "description": "Optional. A mapping of property names to values, used to configure Hadoop. Properties that conflict with values set by the Dataproc API may be overwritten. Can include properties set in /etc/hadoop/conf/*-site and classes in user code.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "hiveJob": {
                    "description": "Optional. Job is a Hive job.",
                    "type": "object",
                    "properties": {
                      "continueOnFailure": {
                        "description": "Optional. Whether to continue executing queries if a query fails. The default value is `false`. Setting to `true` can be useful when executing independent parallel queries.",
                        "type": "boolean"
                      },
                      "jarFileUris": {
                        "description": "Optional. HCFS URIs of jar files to add to the CLASSPATH of the Hive server and Hadoop MapReduce (MR) tasks. Can contain Hive SerDes and UDFs.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "properties": {
                        "description": "Optional. A mapping of property names and values, used to configure Hive. Properties that conflict with values set by the Dataproc API may be overwritten. Can include properties set in /etc/hadoop/conf/*-site.xml, /etc/hive/conf/hive-site.xml, and classes in user code.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      },
                      "queryFileUri": {
                        "description": "The HCFS URI of the script that contains Hive queries.",
                        "type": "string"
                      },
                      "queryList": {
                        "description": "A list of queries.",
                        "type": "object",
                        "required": ["queries"],
                        "properties": {
                          "queries": {
                            "description": "Required. The queries to execute. You do not need to end a query expression with a semicolon. Multiple queries can be specified in one string by separating each with a semicolon. Here is an example of a Dataproc API snippet that uses a QueryList to specify a HiveJob: \"hiveJob\": { \"queryList\": { \"queries\": [ \"query1\", \"query2\", \"query3;query4\", ] } }",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "scriptVariables": {
                        "description": "Optional. Mapping of query variable names to values (equivalent to the Hive command: `SET name=\"value\";`).",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "labels": {
                    "description": "Optional. The labels to associate with this job. Label keys must be between 1 and 63 characters long, and must conform to the following regular expression: p{Ll}p{Lo}{0,62} Label values must be between 1 and 63 characters long, and must conform to the following regular expression: [p{Ll}p{Lo}p{N}_-]{0,63} No more than 32 labels can be associated with a given job.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "pigJob": {
                    "description": "Optional. Job is a Pig job.",
                    "type": "object",
                    "properties": {
                      "continueOnFailure": {
                        "description": "Optional. Whether to continue executing queries if a query fails. The default value is `false`. Setting to `true` can be useful when executing independent parallel queries.",
                        "type": "boolean"
                      },
                      "jarFileUris": {
                        "description": "Optional. HCFS URIs of jar files to add to the CLASSPATH of the Pig Client and Hadoop MapReduce (MR) tasks. Can contain Pig UDFs.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "loggingConfig": {
                        "description": "Optional. The runtime log config for job execution.",
                        "type": "object",
                        "properties": {
                          "driverLogLevels": {
                            "description": "The per-package log levels for the driver. This may include \"root\" package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "properties": {
                        "description": "Optional. A mapping of property names to values, used to configure Pig. Properties that conflict with values set by the Dataproc API may be overwritten. Can include properties set in /etc/hadoop/conf/*-site.xml, /etc/pig/conf/pig.properties, and classes in user code.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      },
                      "queryFileUri": {
                        "description": "The HCFS URI of the script that contains the Pig queries.",
                        "type": "string"
                      },
                      "queryList": {
                        "description": "A list of queries.",
                        "type": "object",
                        "required": ["queries"],
                        "properties": {
                          "queries": {
                            "description": "Required. The queries to execute. You do not need to end a query expression with a semicolon. Multiple queries can be specified in one string by separating each with a semicolon. Here is an example of a Dataproc API snippet that uses a QueryList to specify a HiveJob: \"hiveJob\": { \"queryList\": { \"queries\": [ \"query1\", \"query2\", \"query3;query4\", ] } }",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "scriptVariables": {
                        "description": "Optional. Mapping of query variable names to values (equivalent to the Pig command: `name=[value]`).",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "prerequisiteStepIds": {
                    "description": "Optional. The optional list of prerequisite job step_ids. If not specified, the job will start at the beginning of workflow.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "prestoJob": {
                    "description": "Optional. Job is a Presto job.",
                    "type": "object",
                    "properties": {
                      "clientTags": {
                        "description": "Optional. Presto client tags to attach to this query",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "continueOnFailure": {
                        "description": "Optional. Whether to continue executing queries if a query fails. The default value is `false`. Setting to `true` can be useful when executing independent parallel queries.",
                        "type": "boolean"
                      },
                      "loggingConfig": {
                        "description": "Optional. The runtime log config for job execution.",
                        "type": "object",
                        "properties": {
                          "driverLogLevels": {
                            "description": "The per-package log levels for the driver. This may include \"root\" package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "outputFormat": {
                        "description": "Optional. The format in which query output will be displayed. See the Presto documentation for supported output formats",
                        "type": "string"
                      },
                      "properties": {
                        "description": "Optional. A mapping of property names to values. Used to set Presto [session properties](https://prestodb.io/docs/current/sql/set-session.html) Equivalent to using the --session flag in the Presto CLI",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      },
                      "queryFileUri": {
                        "description": "The HCFS URI of the script that contains SQL queries.",
                        "type": "string"
                      },
                      "queryList": {
                        "description": "A list of queries.",
                        "type": "object",
                        "required": ["queries"],
                        "properties": {
                          "queries": {
                            "description": "Required. The queries to execute. You do not need to end a query expression with a semicolon. Multiple queries can be specified in one string by separating each with a semicolon. Here is an example of a Dataproc API snippet that uses a QueryList to specify a HiveJob: \"hiveJob\": { \"queryList\": { \"queries\": [ \"query1\", \"query2\", \"query3;query4\", ] } }",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  },
                  "pysparkJob": {
                    "description": "Optional. Job is a PySpark job.",
                    "type": "object",
                    "required": ["mainPythonFileUri"],
                    "properties": {
                      "archiveUris": {
                        "description": "Optional. HCFS URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "args": {
                        "description": "Optional. The arguments to pass to the driver. Do not include arguments, such as `--conf`, that can be set as job properties, since a collision may occur that causes an incorrect job submission.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "fileUris": {
                        "description": "Optional. HCFS URIs of files to be placed in the working directory of each executor. Useful for naively parallel tasks.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "jarFileUris": {
                        "description": "Optional. HCFS URIs of jar files to add to the CLASSPATHs of the Python driver and tasks.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "loggingConfig": {
                        "description": "Optional. The runtime log config for job execution.",
                        "type": "object",
                        "properties": {
                          "driverLogLevels": {
                            "description": "The per-package log levels for the driver. This may include \"root\" package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "mainPythonFileUri": {
                        "description": "Required. The HCFS URI of the main Python file to use as the driver. Must be a .py file.",
                        "type": "string"
                      },
                      "properties": {
                        "description": "Optional. A mapping of property names to values, used to configure PySpark. Properties that conflict with values set by the Dataproc API may be overwritten. Can include properties set in /etc/spark/conf/spark-defaults.conf and classes in user code.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      },
                      "pythonFileUris": {
                        "description": "Optional. HCFS file URIs of Python files to pass to the PySpark framework. Supported file types: .py, .egg, and .zip.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "scheduling": {
                    "description": "Optional. Job scheduling configuration.",
                    "type": "object",
                    "properties": {
                      "maxFailuresPerHour": {
                        "description": "Optional. Maximum number of times per hour a driver may be restarted as a result of driver exiting with non-zero code before job is reported failed. A job may be reported as thrashing if driver exits with non-zero code 4 times within 10 minute window. Maximum value is 10.",
                        "type": "integer",
                        "format": "int64"
                      },
                      "maxFailuresTotal": {
                        "description": "Optional. Maximum number of times in total a driver may be restarted as a result of driver exiting with non-zero code before job is reported failed. Maximum value is 240.",
                        "type": "integer",
                        "format": "int64"
                      }
                    }
                  },
                  "sparkJob": {
                    "description": "Optional. Job is a Spark job.",
                    "type": "object",
                    "properties": {
                      "archiveUris": {
                        "description": "Optional. HCFS URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "args": {
                        "description": "Optional. The arguments to pass to the driver. Do not include arguments, such as `--conf`, that can be set as job properties, since a collision may occur that causes an incorrect job submission.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "fileUris": {
                        "description": "Optional. HCFS URIs of files to be placed in the working directory of each executor. Useful for naively parallel tasks.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "jarFileUris": {
                        "description": "Optional. HCFS URIs of jar files to add to the CLASSPATHs of the Spark driver and tasks.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "loggingConfig": {
                        "description": "Optional. The runtime log config for job execution.",
                        "type": "object",
                        "properties": {
                          "driverLogLevels": {
                            "description": "The per-package log levels for the driver. This may include \"root\" package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "mainClass": {
                        "description": "The name of the driver's main class. The jar file that contains the class must be in the default CLASSPATH or specified in `jar_file_uris`.",
                        "type": "string"
                      },
                      "mainJarFileUri": {
                        "description": "The HCFS URI of the jar file that contains the main class.",
                        "type": "string"
                      },
                      "properties": {
                        "description": "Optional. A mapping of property names to values, used to configure Spark. Properties that conflict with values set by the Dataproc API may be overwritten. Can include properties set in /etc/spark/conf/spark-defaults.conf and classes in user code.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "sparkRJob": {
                    "description": "Optional. Job is a SparkR job.",
                    "type": "object",
                    "required": ["mainRFileUri"],
                    "properties": {
                      "archiveUris": {
                        "description": "Optional. HCFS URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "args": {
                        "description": "Optional. The arguments to pass to the driver. Do not include arguments, such as `--conf`, that can be set as job properties, since a collision may occur that causes an incorrect job submission.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "fileUris": {
                        "description": "Optional. HCFS URIs of files to be placed in the working directory of each executor. Useful for naively parallel tasks.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "loggingConfig": {
                        "description": "Optional. The runtime log config for job execution.",
                        "type": "object",
                        "properties": {
                          "driverLogLevels": {
                            "description": "The per-package log levels for the driver. This may include \"root\" package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "mainRFileUri": {
                        "description": "Required. The HCFS URI of the main R file to use as the driver. Must be a .R file.",
                        "type": "string"
                      },
                      "properties": {
                        "description": "Optional. A mapping of property names to values, used to configure SparkR. Properties that conflict with values set by the Dataproc API may be overwritten. Can include properties set in /etc/spark/conf/spark-defaults.conf and classes in user code.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "sparkSqlJob": {
                    "description": "Optional. Job is a SparkSql job.",
                    "type": "object",
                    "properties": {
                      "jarFileUris": {
                        "description": "Optional. HCFS URIs of jar files to be added to the Spark CLASSPATH.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "loggingConfig": {
                        "description": "Optional. The runtime log config for job execution.",
                        "type": "object",
                        "properties": {
                          "driverLogLevels": {
                            "description": "The per-package log levels for the driver. This may include \"root\" package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "properties": {
                        "description": "Optional. A mapping of property names to values, used to configure Spark SQL's SparkConf. Properties that conflict with values set by the Dataproc API may be overwritten.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      },
                      "queryFileUri": {
                        "description": "The HCFS URI of the script that contains SQL queries.",
                        "type": "string"
                      },
                      "queryList": {
                        "description": "A list of queries.",
                        "type": "object",
                        "required": ["queries"],
                        "properties": {
                          "queries": {
                            "description": "Required. The queries to execute. You do not need to end a query expression with a semicolon. Multiple queries can be specified in one string by separating each with a semicolon. Here is an example of a Dataproc API snippet that uses a QueryList to specify a HiveJob: \"hiveJob\": { \"queryList\": { \"queries\": [ \"query1\", \"query2\", \"query3;query4\", ] } }",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "scriptVariables": {
                        "description": "Optional. Mapping of query variable names to values (equivalent to the Spark SQL command: SET `name=\"value\";`).",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "stepId": {
                    "description": "Required. The step id. The id must be unique among all jobs within the template. The step id is used as prefix for job id, as job `goog-dataproc-workflow-step-id` label, and in prerequisiteStepIds field from other steps. The id must contain only letters (a-z, A-Z), numbers (0-9), underscores (_), and hyphens (-). Cannot begin or end with underscore or hyphen. Must consist of between 3 and 50 characters.",
                    "type": "string"
                  }
                }
              }
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "parameters": {
              "description": "Optional. Template parameters whose values are substituted into the template. Values for parameters must be provided when the template is instantiated.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["fields", "name"],
                "properties": {
                  "description": {
                    "description": "Optional. Brief description of the parameter. Must not exceed 1024 characters.",
                    "type": "string"
                  },
                  "fields": {
                    "description": "Required. Paths to all fields that the parameter replaces. A field is allowed to appear in at most one parameter's list of field paths. A field path is similar in syntax to a google.protobuf.FieldMask. For example, a field path that references the zone field of a workflow template's cluster selector would be specified as `placement.clusterSelector.zone`. Also, field paths can reference fields using the following syntax: * Values in maps can be referenced by key: * labels['key'] * placement.clusterSelector.clusterLabels['key'] * placement.managedCluster.labels['key'] * placement.clusterSelector.clusterLabels['key'] * jobs['step-id'].labels['key'] * Jobs in the jobs list can be referenced by step-id: * jobs['step-id'].hadoopJob.mainJarFileUri * jobs['step-id'].hiveJob.queryFileUri * jobs['step-id'].pySparkJob.mainPythonFileUri * jobs['step-id'].hadoopJob.jarFileUris[0] * jobs['step-id'].hadoopJob.archiveUris[0] * jobs['step-id'].hadoopJob.fileUris[0] * jobs['step-id'].pySparkJob.pythonFileUris[0] * Items in repeated fields can be referenced by a zero-based index: * jobs['step-id'].sparkJob.args[0] * Other examples: * jobs['step-id'].hadoopJob.properties['key'] * jobs['step-id'].hadoopJob.args[0] * jobs['step-id'].hiveJob.scriptVariables['key'] * jobs['step-id'].hadoopJob.mainJarFileUri * placement.clusterSelector.zone It may not be possible to parameterize maps and repeated fields in their entirety since only individual map values and individual items in repeated fields can be referenced. For example, the following field paths are invalid: - placement.clusterSelector.clusterLabels - jobs['step-id'].sparkJob.args",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "name": {
                    "description": "Required. Parameter name. The parameter name is used as the key, and paired with the parameter value, which are passed to the template when the template is instantiated. The name must contain only capital letters (A-Z), numbers (0-9), and underscores (_), and must not start with a number. The maximum length is 40 characters.",
                    "type": "string"
                  },
                  "validation": {
                    "description": "Optional. Validation rules to be applied to this parameter's value.",
                    "type": "object",
                    "properties": {
                      "regex": {
                        "description": "Validation based on regular expressions.",
                        "type": "object",
                        "required": ["regexes"],
                        "properties": {
                          "regexes": {
                            "description": "Required. RE2 regular expressions used to validate the parameter's value. The value must match the regex in its entirety (substring matches are not sufficient).",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "values": {
                        "description": "Validation based on a list of allowed values.",
                        "type": "object",
                        "required": ["values"],
                        "properties": {
                          "values": {
                            "description": "Required. List of allowed values for the parameter.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "placement": {
              "description": "Required. WorkflowTemplate scheduling information.",
              "type": "object",
              "properties": {
                "clusterSelector": {
                  "description": "Optional. A selector that chooses target cluster for jobs based on metadata. The selector is evaluated at the time each job is submitted.",
                  "type": "object",
                  "required": ["clusterLabels"],
                  "properties": {
                    "clusterLabels": {
                      "description": "Required. The cluster labels. Cluster must have all labels to match.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "zone": {
                      "description": "Optional. The zone where workflow process executes. This parameter does not affect the selection of the cluster. If unspecified, the zone of the first cluster matching the selector is used.",
                      "type": "string"
                    }
                  }
                },
                "managedCluster": {
                  "description": "A cluster that is managed by the workflow.",
                  "type": "object",
                  "required": ["clusterName", "config"],
                  "properties": {
                    "clusterName": {
                      "description": "Required. The cluster name prefix. A unique cluster name will be formed by appending a random suffix. The name must contain only lower-case letters (a-z), numbers (0-9), and hyphens (-). Must begin with a letter. Cannot begin or end with hyphen. Must consist of between 2 and 35 characters.",
                      "type": "string"
                    },
                    "config": {
                      "description": "Required. The cluster configuration.",
                      "type": "object",
                      "properties": {
                        "autoscalingConfig": {
                          "description": "Optional. Autoscaling config for the policy associated with the cluster. Cluster does not autoscale if this field is unset.",
                          "type": "object",
                          "properties": {
                            "policyRef": {
                              "type": "object",
                              "properties": {
                                "external": {
                                  "description": "Optional. The autoscaling policy used by the cluster. Only resource names including projectid and location (region) are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[project_id]/locations/[dataproc_region]/autoscalingPolicies/[policy_id]` * `projects/[project_id]/locations/[dataproc_region]/autoscalingPolicies/[policy_id]` Note that the policy must be in the same project and Dataproc region.",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                  "type": "string"
                                },
                                "namespace": {
                                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                  "type": "string"
                                }
                              }
                            }
                          }
                        },
                        "encryptionConfig": {
                          "description": "Optional. Encryption settings for the cluster.",
                          "type": "object",
                          "properties": {
                            "gcePdKmsKeyRef": {
                              "type": "object",
                              "properties": {
                                "external": {
                                  "description": "Optional. The Cloud KMS key name to use for PD disk encryption for all instances in the cluster.",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                  "type": "string"
                                },
                                "namespace": {
                                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                  "type": "string"
                                }
                              }
                            }
                          }
                        },
                        "endpointConfig": {
                          "description": "Optional. Port/endpoint configuration for this cluster",
                          "type": "object",
                          "properties": {
                            "enableHttpPortAccess": {
                              "description": "Optional. If true, enable http access to specific ports on the cluster from external sources. Defaults to false.",
                              "type": "boolean"
                            }
                          }
                        },
                        "gceClusterConfig": {
                          "description": "Optional. The shared Compute Engine config settings for all instances in a cluster.",
                          "type": "object",
                          "properties": {
                            "internalIPOnly": {
                              "description": "Optional. If true, all instances in the cluster will only have internal IP addresses. By default, clusters are not restricted to internal IP addresses, and will have ephemeral external IP addresses assigned to each instance. This `internal_ip_only` restriction can only be enabled for subnetwork enabled networks, and all off-cluster dependencies must be configured to be accessible without external IP addresses.",
                              "type": "boolean"
                            },
                            "metadata": {
                              "description": "The Compute Engine metadata entries to add to all instances (see [Project and instance metadata](https://cloud.google.com/compute/docs/storing-retrieving-metadata#project_and_instance_metadata)).",
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            },
                            "networkRef": {
                              "type": "object",
                              "properties": {
                                "external": {
                                  "description": "Optional. The Compute Engine network to be used for machine communications. Cannot be specified with subnetwork_uri. If neither `network_uri` nor `subnetwork_uri` is specified, the \"default\" network of the project is used, if it exists. Cannot be a \"Custom Subnet Network\" (see [Using Subnetworks](https://cloud.google.com/compute/docs/subnetworks) for more information). A full URL, partial URI, or short name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[project_id]/regions/global/default` * `projects/[project_id]/regions/global/default` * `default`",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                  "type": "string"
                                },
                                "namespace": {
                                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                  "type": "string"
                                }
                              }
                            },
                            "nodeGroupAffinity": {
                              "description": "Optional. Node Group Affinity for sole-tenant clusters.",
                              "type": "object",
                              "required": ["nodeGroupRef"],
                              "properties": {
                                "nodeGroupRef": {
                                  "type": "object",
                                  "properties": {
                                    "external": {
                                      "description": "Required. The URI of a sole-tenant [node group resource](https://cloud.google.com/compute/docs/reference/rest/v1/nodeGroups) that the cluster will be created on. A full URL, partial URI, or node group name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[project_id]/zones/us-central1-a/nodeGroups/node-group-1` * `projects/[project_id]/zones/us-central1-a/nodeGroups/node-group-1` * `node-group-1`",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "privateIPv6GoogleAccess": {
                              "description": "Optional. The type of IPv6 access for a cluster. Possible values: PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED, INHERIT_FROM_SUBNETWORK, OUTBOUND, BIDIRECTIONAL",
                              "type": "string"
                            },
                            "reservationAffinity": {
                              "description": "Optional. Reservation Affinity for consuming Zonal reservation.",
                              "type": "object",
                              "properties": {
                                "consumeReservationType": {
                                  "description": "Optional. Type of reservation to consume Possible values: TYPE_UNSPECIFIED, NO_RESERVATION, ANY_RESERVATION, SPECIFIC_RESERVATION",
                                  "type": "string"
                                },
                                "key": {
                                  "description": "Optional. Corresponds to the label key of reservation resource.",
                                  "type": "string"
                                },
                                "values": {
                                  "description": "Optional. Corresponds to the label values of reservation resource.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "serviceAccountRef": {
                              "type": "object",
                              "properties": {
                                "external": {
                                  "description": "Optional. The [Dataproc service account](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/service-accounts#service_accounts_in_dataproc) (also see [VM Data Plane identity](https://cloud.google.com/dataproc/docs/concepts/iam/dataproc-principals#vm_service_account_data_plane_identity)) used by Dataproc cluster VM instances to access Google Cloud Platform services. If not specified, the [Compute Engine default service account](https://cloud.google.com/compute/docs/access/service-accounts#default_service_account) is used.",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                  "type": "string"
                                },
                                "namespace": {
                                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                  "type": "string"
                                }
                              }
                            },
                            "serviceAccountScopes": {
                              "description": "Optional. The URIs of service account scopes to be included in Compute Engine instances. The following base set of scopes is always included: * https://www.googleapis.com/auth/cloud.useraccounts.readonly * https://www.googleapis.com/auth/devstorage.read_write * https://www.googleapis.com/auth/logging.write If no scopes are specified, the following defaults are also provided: * https://www.googleapis.com/auth/bigquery * https://www.googleapis.com/auth/bigtable.admin.table * https://www.googleapis.com/auth/bigtable.data * https://www.googleapis.com/auth/devstorage.full_control",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "subnetworkRef": {
                              "type": "object",
                              "properties": {
                                "external": {
                                  "description": "Optional. The Compute Engine subnetwork to be used for machine communications. Cannot be specified with network_uri. A full URL, partial URI, or short name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[project_id]/regions/us-east1/subnetworks/sub0` * `projects/[project_id]/regions/us-east1/subnetworks/sub0` * `sub0`",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                  "type": "string"
                                },
                                "namespace": {
                                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                  "type": "string"
                                }
                              }
                            },
                            "tags": {
                              "description": "The Compute Engine tags to add to all instances (see [Tagging instances](https://cloud.google.com/compute/docs/label-or-tag-resources#tags)).",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "zone": {
                              "description": "Optional. The zone where the Compute Engine cluster will be located. On a create request, it is required in the \"global\" region. If omitted in a non-global Dataproc region, the service will pick a zone in the corresponding Compute Engine region. On a get request, zone will always be present. A full URL, partial URI, or short name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[project_id]/zones/[zone]` * `projects/[project_id]/zones/[zone]` * `us-central1-f`",
                              "type": "string"
                            }
                          }
                        },
                        "initializationActions": {
                          "description": "Optional. Commands to execute on each node after config is completed. By default, executables are run on master and all worker nodes. You can test a node's `role` metadata to run an executable on a master or worker node, as shown below using `curl` (you can also use `wget`): ROLE=$(curl -H Metadata-Flavor:Google http://metadata/computeMetadata/v1/instance/attributes/dataproc-role) if [[ \"${ROLE}\" == 'Master' ]]; then ... master specific actions ... else ... worker specific actions ... fi",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "executableFile": {
                                "description": "Required. Cloud Storage URI of executable file.",
                                "type": "string"
                              },
                              "executionTimeout": {
                                "description": "Optional. Amount of time executable has to complete. Default is 10 minutes (see JSON representation of [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)). Cluster creation fails with an explanatory error message (the name of the executable that caused the error and the exceeded timeout period) if the executable is not completed at end of the timeout period.",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "lifecycleConfig": {
                          "description": "Optional. Lifecycle setting for the cluster.",
                          "type": "object",
                          "properties": {
                            "autoDeleteTime": {
                              "description": "Optional. The time when cluster will be auto-deleted (see JSON representation of [Timestamp](https://developers.google.com/protocol-buffers/docs/proto3#json)).",
                              "type": "string",
                              "format": "date-time"
                            },
                            "autoDeleteTtl": {
                              "description": "Optional. The lifetime duration of cluster. The cluster will be auto-deleted at the end of this period. Minimum value is 10 minutes; maximum value is 14 days (see JSON representation of [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).",
                              "type": "string"
                            },
                            "idleDeleteTtl": {
                              "description": "Optional. The duration to keep the cluster alive while idling (when no jobs are running). Passing this threshold will cause the cluster to be deleted. Minimum value is 5 minutes; maximum value is 14 days (see JSON representation of [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).",
                              "type": "string"
                            }
                          }
                        },
                        "masterConfig": {
                          "description": "Optional. The Compute Engine config settings for worker instances in a cluster.",
                          "type": "object",
                          "properties": {
                            "accelerators": {
                              "description": "Optional. The Compute Engine accelerator configuration for these instances.",
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "acceleratorCount": {
                                    "description": "The number of the accelerator cards of this type exposed to this instance.",
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "acceleratorType": {
                                    "description": "Full URL, partial URI, or short name of the accelerator type resource to expose to this instance. See [Compute Engine AcceleratorTypes](https://cloud.google.com/compute/docs/reference/beta/acceleratorTypes). Examples: * `https://www.googleapis.com/compute/beta/projects/[project_id]/zones/us-east1-a/acceleratorTypes/nvidia-tesla-k80` * `projects/[project_id]/zones/us-east1-a/acceleratorTypes/nvidia-tesla-k80` * `nvidia-tesla-k80` **Auto Zone Exception**: If you are using the Dataproc [Auto Zone Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the accelerator type resource, for example, `nvidia-tesla-k80`.",
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "diskConfig": {
                              "description": "Optional. Disk option config settings.",
                              "type": "object",
                              "properties": {
                                "bootDiskSizeGb": {
                                  "description": "Optional. Size in GB of the boot disk (default is 500GB).",
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "bootDiskType": {
                                  "description": "Optional. Type of the boot disk (default is \"pd-standard\"). Valid values: \"pd-balanced\" (Persistent Disk Balanced Solid State Drive), \"pd-ssd\" (Persistent Disk Solid State Drive), or \"pd-standard\" (Persistent Disk Hard Disk Drive). See [Disk types](https://cloud.google.com/compute/docs/disks#disk-types).",
                                  "type": "string"
                                },
                                "numLocalSsds": {
                                  "description": "Optional. Number of attached SSDs, from 0 to 4 (default is 0). If SSDs are not attached, the boot disk is used to store runtime logs and [HDFS](https://hadoop.apache.org/docs/r1.2.1/hdfs_user_guide.html) data. If one or more SSDs are attached, this runtime bulk data is spread across them, and the boot disk contains only basic config and installed binaries.",
                                  "type": "integer",
                                  "format": "int64"
                                }
                              }
                            },
                            "imageRef": {
                              "type": "object",
                              "properties": {
                                "external": {
                                  "description": "Optional. The Compute Engine image resource used for cluster instances. The URI can represent an image or image family. Image examples: * `https://www.googleapis.com/compute/beta/projects/[project_id]/global/images/[image-id]` * `projects/[project_id]/global/images/[image-id]` * `image-id` Image family examples. Dataproc will use the most recent image from the family: * `https://www.googleapis.com/compute/beta/projects/[project_id]/global/images/family/[custom-image-family-name]` * `projects/[project_id]/global/images/family/[custom-image-family-name]` If the URI is unspecified, it will be inferred from `SoftwareConfig.image_version` or the system default.",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                  "type": "string"
                                },
                                "namespace": {
                                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                  "type": "string"
                                }
                              }
                            },
                            "machineType": {
                              "description": "Optional. The Compute Engine machine type used for cluster instances. A full URL, partial URI, or short name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[project_id]/zones/us-east1-a/machineTypes/n1-standard-2` * `projects/[project_id]/zones/us-east1-a/machineTypes/n1-standard-2` * `n1-standard-2` **Auto Zone Exception**: If you are using the Dataproc [Auto Zone Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the machine type resource, for example, `n1-standard-2`.",
                              "type": "string"
                            },
                            "minCpuPlatform": {
                              "description": "Optional. Specifies the minimum cpu platform for the Instance Group. See [Dataproc -> Minimum CPU Platform](https://cloud.google.com/dataproc/docs/concepts/compute/dataproc-min-cpu).",
                              "type": "string"
                            },
                            "numInstances": {
                              "description": "Optional. The number of VM instances in the instance group. For [HA cluster](/dataproc/docs/concepts/configuring-clusters/high-availability) [master_config](#FIELDS.master_config) groups, **must be set to 3**. For standard cluster [master_config](#FIELDS.master_config) groups, **must be set to 1**.",
                              "type": "integer",
                              "format": "int64"
                            },
                            "preemptibility": {
                              "description": "Optional. Specifies the preemptibility of the instance group. The default value for master and worker groups is `NON_PREEMPTIBLE`. This default cannot be changed. The default value for secondary instances is `PREEMPTIBLE`. Possible values: PREEMPTIBILITY_UNSPECIFIED, NON_PREEMPTIBLE, PREEMPTIBLE",
                              "type": "string"
                            }
                          }
                        },
                        "secondaryWorkerConfig": {
                          "description": "Optional. The Compute Engine config settings for worker instances in a cluster.",
                          "type": "object",
                          "properties": {
                            "accelerators": {
                              "description": "Optional. The Compute Engine accelerator configuration for these instances.",
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "acceleratorCount": {
                                    "description": "The number of the accelerator cards of this type exposed to this instance.",
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "acceleratorType": {
                                    "description": "Full URL, partial URI, or short name of the accelerator type resource to expose to this instance. See [Compute Engine AcceleratorTypes](https://cloud.google.com/compute/docs/reference/beta/acceleratorTypes). Examples: * `https://www.googleapis.com/compute/beta/projects/[project_id]/zones/us-east1-a/acceleratorTypes/nvidia-tesla-k80` * `projects/[project_id]/zones/us-east1-a/acceleratorTypes/nvidia-tesla-k80` * `nvidia-tesla-k80` **Auto Zone Exception**: If you are using the Dataproc [Auto Zone Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the accelerator type resource, for example, `nvidia-tesla-k80`.",
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "diskConfig": {
                              "description": "Optional. Disk option config settings.",
                              "type": "object",
                              "properties": {
                                "bootDiskSizeGb": {
                                  "description": "Optional. Size in GB of the boot disk (default is 500GB).",
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "bootDiskType": {
                                  "description": "Optional. Type of the boot disk (default is \"pd-standard\"). Valid values: \"pd-balanced\" (Persistent Disk Balanced Solid State Drive), \"pd-ssd\" (Persistent Disk Solid State Drive), or \"pd-standard\" (Persistent Disk Hard Disk Drive). See [Disk types](https://cloud.google.com/compute/docs/disks#disk-types).",
                                  "type": "string"
                                },
                                "numLocalSsds": {
                                  "description": "Optional. Number of attached SSDs, from 0 to 4 (default is 0). If SSDs are not attached, the boot disk is used to store runtime logs and [HDFS](https://hadoop.apache.org/docs/r1.2.1/hdfs_user_guide.html) data. If one or more SSDs are attached, this runtime bulk data is spread across them, and the boot disk contains only basic config and installed binaries.",
                                  "type": "integer",
                                  "format": "int64"
                                }
                              }
                            },
                            "imageRef": {
                              "type": "object",
                              "properties": {
                                "external": {
                                  "description": "Optional. The Compute Engine image resource used for cluster instances. The URI can represent an image or image family. Image examples: * `https://www.googleapis.com/compute/beta/projects/[project_id]/global/images/[image-id]` * `projects/[project_id]/global/images/[image-id]` * `image-id` Image family examples. Dataproc will use the most recent image from the family: * `https://www.googleapis.com/compute/beta/projects/[project_id]/global/images/family/[custom-image-family-name]` * `projects/[project_id]/global/images/family/[custom-image-family-name]` If the URI is unspecified, it will be inferred from `SoftwareConfig.image_version` or the system default.",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                  "type": "string"
                                },
                                "namespace": {
                                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                  "type": "string"
                                }
                              }
                            },
                            "machineType": {
                              "description": "Optional. The Compute Engine machine type used for cluster instances. A full URL, partial URI, or short name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[project_id]/zones/us-east1-a/machineTypes/n1-standard-2` * `projects/[project_id]/zones/us-east1-a/machineTypes/n1-standard-2` * `n1-standard-2` **Auto Zone Exception**: If you are using the Dataproc [Auto Zone Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the machine type resource, for example, `n1-standard-2`.",
                              "type": "string"
                            },
                            "minCpuPlatform": {
                              "description": "Optional. Specifies the minimum cpu platform for the Instance Group. See [Dataproc -> Minimum CPU Platform](https://cloud.google.com/dataproc/docs/concepts/compute/dataproc-min-cpu).",
                              "type": "string"
                            },
                            "numInstances": {
                              "description": "Optional. The number of VM instances in the instance group. For [HA cluster](/dataproc/docs/concepts/configuring-clusters/high-availability) [master_config](#FIELDS.master_config) groups, **must be set to 3**. For standard cluster [master_config](#FIELDS.master_config) groups, **must be set to 1**.",
                              "type": "integer",
                              "format": "int64"
                            },
                            "preemptibility": {
                              "description": "Optional. Specifies the preemptibility of the instance group. The default value for master and worker groups is `NON_PREEMPTIBLE`. This default cannot be changed. The default value for secondary instances is `PREEMPTIBLE`. Possible values: PREEMPTIBILITY_UNSPECIFIED, NON_PREEMPTIBLE, PREEMPTIBLE",
                              "type": "string"
                            }
                          }
                        },
                        "securityConfig": {
                          "description": "Optional. Security settings for the cluster.",
                          "type": "object",
                          "properties": {
                            "kerberosConfig": {
                              "description": "Optional. Kerberos related configuration.",
                              "type": "object",
                              "properties": {
                                "crossRealmTrustAdminServer": {
                                  "description": "Optional. The admin server (IP or hostname) for the remote trusted realm in a cross realm trust relationship.",
                                  "type": "string"
                                },
                                "crossRealmTrustKdc": {
                                  "description": "Optional. The KDC (IP or hostname) for the remote trusted realm in a cross realm trust relationship.",
                                  "type": "string"
                                },
                                "crossRealmTrustRealm": {
                                  "description": "Optional. The remote realm the Dataproc on-cluster KDC will trust, should the user enable cross realm trust.",
                                  "type": "string"
                                },
                                "crossRealmTrustSharedPassword": {
                                  "description": "Optional. The Cloud Storage URI of a KMS encrypted file containing the shared password between the on-cluster Kerberos realm and the remote trusted realm, in a cross realm trust relationship.",
                                  "type": "string"
                                },
                                "enableKerberos": {
                                  "description": "Optional. Flag to indicate whether to Kerberize the cluster (default: false). Set this field to true to enable Kerberos on a cluster.",
                                  "type": "boolean"
                                },
                                "kdcDbKey": {
                                  "description": "Optional. The Cloud Storage URI of a KMS encrypted file containing the master key of the KDC database.",
                                  "type": "string"
                                },
                                "keyPassword": {
                                  "description": "Optional. The Cloud Storage URI of a KMS encrypted file containing the password to the user provided key. For the self-signed certificate, this password is generated by Dataproc.",
                                  "type": "string"
                                },
                                "keystore": {
                                  "description": "Optional. The Cloud Storage URI of the keystore file used for SSL encryption. If not provided, Dataproc will provide a self-signed certificate.",
                                  "type": "string"
                                },
                                "keystorePassword": {
                                  "description": "Optional. The Cloud Storage URI of a KMS encrypted file containing the password to the user provided keystore. For the self-signed certificate, this password is generated by Dataproc.",
                                  "type": "string"
                                },
                                "kmsKeyRef": {
                                  "type": "object",
                                  "properties": {
                                    "external": {
                                      "description": "Optional. The uri of the KMS key used to encrypt various sensitive files.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                      "type": "string"
                                    }
                                  }
                                },
                                "realm": {
                                  "description": "Optional. The name of the on-cluster Kerberos realm. If not specified, the uppercased domain of hostnames will be the realm.",
                                  "type": "string"
                                },
                                "rootPrincipalPassword": {
                                  "description": "Optional. The Cloud Storage URI of a KMS encrypted file containing the root principal password.",
                                  "type": "string"
                                },
                                "tgtLifetimeHours": {
                                  "description": "Optional. The lifetime of the ticket granting ticket, in hours. If not specified, or user specifies 0, then default value 10 will be used.",
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "truststore": {
                                  "description": "Optional. The Cloud Storage URI of the truststore file used for SSL encryption. If not provided, Dataproc will provide a self-signed certificate.",
                                  "type": "string"
                                },
                                "truststorePassword": {
                                  "description": "Optional. The Cloud Storage URI of a KMS encrypted file containing the password to the user provided truststore. For the self-signed certificate, this password is generated by Dataproc.",
                                  "type": "string"
                                }
                              }
                            }
                          }
                        },
                        "softwareConfig": {
                          "description": "Optional. The config settings for software inside the cluster.",
                          "type": "object",
                          "properties": {
                            "imageVersion": {
                              "description": "Optional. The version of software inside the cluster. It must be one of the supported [Dataproc Versions](https://cloud.google.com/dataproc/docs/concepts/versioning/dataproc-versions#supported_dataproc_versions), such as \"1.2\" (including a subminor version, such as \"1.2.29\"), or the [\"preview\" version](https://cloud.google.com/dataproc/docs/concepts/versioning/dataproc-versions#other_versions). If unspecified, it defaults to the latest Debian version.",
                              "type": "string"
                            },
                            "optionalComponents": {
                              "description": "Optional. The set of components to activate on the cluster.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "properties": {
                              "description": "Optional. The properties to set on daemon config files. Property keys are specified in `prefix:property` format, for example `core:hadoop.tmp.dir`. The following are supported prefixes and their mappings: * capacity-scheduler: `capacity-scheduler.xml` * core: `core-site.xml` * distcp: `distcp-default.xml` * hdfs: `hdfs-site.xml` * hive: `hive-site.xml` * mapred: `mapred-site.xml` * pig: `pig.properties` * spark: `spark-defaults.conf` * yarn: `yarn-site.xml` For more information, see [Cluster properties](https://cloud.google.com/dataproc/docs/concepts/cluster-properties).",
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            }
                          }
                        },
                        "stagingBucketRef": {
                          "type": "object",
                          "properties": {
                            "external": {
                              "description": "Optional. A Cloud Storage bucket used to stage job dependencies, config files, and job driver console output. If you do not specify a staging bucket, Cloud Dataproc will determine a Cloud Storage location (US, ASIA, or EU) for your cluster's staging bucket according to the Compute Engine zone where your cluster is deployed, and then create and manage this project-level, per-location bucket (see [Dataproc staging bucket](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/staging-bucket)). **This field requires a Cloud Storage bucket name, not a URI to a Cloud Storage bucket.**",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                              "type": "string"
                            },
                            "namespace": {
                              "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                              "type": "string"
                            }
                          }
                        },
                        "tempBucketRef": {
                          "type": "object",
                          "properties": {
                            "external": {
                              "description": "Optional. A Cloud Storage bucket used to store ephemeral cluster and jobs data, such as Spark and MapReduce history files. If you do not specify a temp bucket, Dataproc will determine a Cloud Storage location (US, ASIA, or EU) for your cluster's temp bucket according to the Compute Engine zone where your cluster is deployed, and then create and manage this project-level, per-location bucket. The default bucket has a TTL of 90 days, but you can use any TTL (or none) if you specify a bucket. **This field requires a Cloud Storage bucket name, not a URI to a Cloud Storage bucket.**",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                              "type": "string"
                            },
                            "namespace": {
                              "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                              "type": "string"
                            }
                          }
                        },
                        "workerConfig": {
                          "description": "Optional. The Compute Engine config settings for worker instances in a cluster.",
                          "type": "object",
                          "properties": {
                            "accelerators": {
                              "description": "Optional. The Compute Engine accelerator configuration for these instances.",
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "acceleratorCount": {
                                    "description": "The number of the accelerator cards of this type exposed to this instance.",
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "acceleratorType": {
                                    "description": "Full URL, partial URI, or short name of the accelerator type resource to expose to this instance. See [Compute Engine AcceleratorTypes](https://cloud.google.com/compute/docs/reference/beta/acceleratorTypes). Examples: * `https://www.googleapis.com/compute/beta/projects/[project_id]/zones/us-east1-a/acceleratorTypes/nvidia-tesla-k80` * `projects/[project_id]/zones/us-east1-a/acceleratorTypes/nvidia-tesla-k80` * `nvidia-tesla-k80` **Auto Zone Exception**: If you are using the Dataproc [Auto Zone Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the accelerator type resource, for example, `nvidia-tesla-k80`.",
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "diskConfig": {
                              "description": "Optional. Disk option config settings.",
                              "type": "object",
                              "properties": {
                                "bootDiskSizeGb": {
                                  "description": "Optional. Size in GB of the boot disk (default is 500GB).",
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "bootDiskType": {
                                  "description": "Optional. Type of the boot disk (default is \"pd-standard\"). Valid values: \"pd-balanced\" (Persistent Disk Balanced Solid State Drive), \"pd-ssd\" (Persistent Disk Solid State Drive), or \"pd-standard\" (Persistent Disk Hard Disk Drive). See [Disk types](https://cloud.google.com/compute/docs/disks#disk-types).",
                                  "type": "string"
                                },
                                "numLocalSsds": {
                                  "description": "Optional. Number of attached SSDs, from 0 to 4 (default is 0). If SSDs are not attached, the boot disk is used to store runtime logs and [HDFS](https://hadoop.apache.org/docs/r1.2.1/hdfs_user_guide.html) data. If one or more SSDs are attached, this runtime bulk data is spread across them, and the boot disk contains only basic config and installed binaries.",
                                  "type": "integer",
                                  "format": "int64"
                                }
                              }
                            },
                            "imageRef": {
                              "type": "object",
                              "properties": {
                                "external": {
                                  "description": "Optional. The Compute Engine image resource used for cluster instances. The URI can represent an image or image family. Image examples: * `https://www.googleapis.com/compute/beta/projects/[project_id]/global/images/[image-id]` * `projects/[project_id]/global/images/[image-id]` * `image-id` Image family examples. Dataproc will use the most recent image from the family: * `https://www.googleapis.com/compute/beta/projects/[project_id]/global/images/family/[custom-image-family-name]` * `projects/[project_id]/global/images/family/[custom-image-family-name]` If the URI is unspecified, it will be inferred from `SoftwareConfig.image_version` or the system default.",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                  "type": "string"
                                },
                                "namespace": {
                                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                  "type": "string"
                                }
                              }
                            },
                            "machineType": {
                              "description": "Optional. The Compute Engine machine type used for cluster instances. A full URL, partial URI, or short name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[project_id]/zones/us-east1-a/machineTypes/n1-standard-2` * `projects/[project_id]/zones/us-east1-a/machineTypes/n1-standard-2` * `n1-standard-2` **Auto Zone Exception**: If you are using the Dataproc [Auto Zone Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the machine type resource, for example, `n1-standard-2`.",
                              "type": "string"
                            },
                            "minCpuPlatform": {
                              "description": "Optional. Specifies the minimum cpu platform for the Instance Group. See [Dataproc -> Minimum CPU Platform](https://cloud.google.com/dataproc/docs/concepts/compute/dataproc-min-cpu).",
                              "type": "string"
                            },
                            "numInstances": {
                              "description": "Optional. The number of VM instances in the instance group. For [HA cluster](/dataproc/docs/concepts/configuring-clusters/high-availability) [master_config](#FIELDS.master_config) groups, **must be set to 3**. For standard cluster [master_config](#FIELDS.master_config) groups, **must be set to 1**.",
                              "type": "integer",
                              "format": "int64"
                            },
                            "preemptibility": {
                              "description": "Optional. Specifies the preemptibility of the instance group. The default value for master and worker groups is `NON_PREEMPTIBLE`. This default cannot be changed. The default value for secondary instances is `PREEMPTIBLE`. Possible values: PREEMPTIBILITY_UNSPECIFIED, NON_PREEMPTIBLE, PREEMPTIBLE",
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "labels": {
                      "description": "Optional. The labels to associate with this cluster. Label keys must be between 1 and 63 characters long, and must conform to the following PCRE regular expression: p{Ll}p{Lo}{0,62} Label values must be between 1 and 63 characters long, and must conform to the following PCRE regular expression: [p{Ll}p{Lo}p{N}_-]{0,63} No more than 32 labels can be associated with a given cluster.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The time template was created.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "placement": {
              "type": "object",
              "properties": {
                "managedCluster": {
                  "type": "object",
                  "properties": {
                    "config": {
                      "type": "object",
                      "properties": {
                        "endpointConfig": {
                          "type": "object",
                          "properties": {
                            "httpPorts": {
                              "description": "Output only. The map of port descriptions to URLs. Will only be populated if enable_http_port_access is true.",
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            }
                          }
                        },
                        "lifecycleConfig": {
                          "type": "object",
                          "properties": {
                            "idleStartTime": {
                              "description": "Output only. The time when cluster became idle (most recent job finished) and became eligible for deletion due to idleness (see JSON representation of [Timestamp](https://developers.google.com/protocol-buffers/docs/proto3#json)).",
                              "type": "string",
                              "format": "date-time"
                            }
                          }
                        },
                        "masterConfig": {
                          "type": "object",
                          "properties": {
                            "instanceNames": {
                              "description": "Output only. The list of instance names. Dataproc derives the names from `cluster_name`, `num_instances`, and the instance group.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "isPreemptible": {
                              "description": "Output only. Specifies that this instance group contains preemptible instances.",
                              "type": "boolean"
                            },
                            "managedGroupConfig": {
                              "description": "Output only. The config for Compute Engine Instance Group Manager that manages this group. This is only used for preemptible instance groups.",
                              "type": "object",
                              "properties": {
                                "instanceGroupManagerName": {
                                  "description": "Output only. The name of the Instance Group Manager for this group.",
                                  "type": "string"
                                },
                                "instanceTemplateName": {
                                  "description": "Output only. The name of the Instance Template used for the Managed Instance Group.",
                                  "type": "string"
                                }
                              }
                            }
                          }
                        },
                        "secondaryWorkerConfig": {
                          "type": "object",
                          "properties": {
                            "instanceNames": {
                              "description": "Output only. The list of instance names. Dataproc derives the names from `cluster_name`, `num_instances`, and the instance group.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "isPreemptible": {
                              "description": "Output only. Specifies that this instance group contains preemptible instances.",
                              "type": "boolean"
                            },
                            "managedGroupConfig": {
                              "description": "Output only. The config for Compute Engine Instance Group Manager that manages this group. This is only used for preemptible instance groups.",
                              "type": "object",
                              "properties": {
                                "instanceGroupManagerName": {
                                  "description": "Output only. The name of the Instance Group Manager for this group.",
                                  "type": "string"
                                },
                                "instanceTemplateName": {
                                  "description": "Output only. The name of the Instance Template used for the Managed Instance Group.",
                                  "type": "string"
                                }
                              }
                            }
                          }
                        },
                        "workerConfig": {
                          "type": "object",
                          "properties": {
                            "instanceNames": {
                              "description": "Output only. The list of instance names. Dataproc derives the names from `cluster_name`, `num_instances`, and the instance group.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "isPreemptible": {
                              "description": "Output only. Specifies that this instance group contains preemptible instances.",
                              "type": "boolean"
                            },
                            "managedGroupConfig": {
                              "description": "Output only. The config for Compute Engine Instance Group Manager that manages this group. This is only used for preemptible instance groups.",
                              "type": "object",
                              "properties": {
                                "instanceGroupManagerName": {
                                  "description": "Output only. The name of the Instance Group Manager for this group.",
                                  "type": "string"
                                },
                                "instanceTemplateName": {
                                  "description": "Output only. The name of the Instance Template used for the Managed Instance Group.",
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "updateTime": {
              "description": "Output only. The time template was last updated.",
              "type": "string",
              "format": "date-time"
            },
            "version": {
              "description": "Output only. The current version of this workflow template.",
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "dataproc.cnrm.cloud.google.com",
          "kind": "DataprocWorkflowTemplate",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.dataproc.v1beta1.DataprocWorkflowTemplateList": {
      "description": "DataprocWorkflowTemplateList is a list of DataprocWorkflowTemplate",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["dataproc.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of dataprocworkflowtemplates. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.dataproc.v1beta1.DataprocWorkflowTemplate"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DataprocWorkflowTemplateList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "dataproc.cnrm.cloud.google.com",
          "kind": "DataprocWorkflowTemplateList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.dns.v1beta1.DNSManagedZone": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["dns.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DNSManagedZone"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["dnsName"],
          "properties": {
            "description": {
              "description": "A textual description field. Defaults to 'Managed by Config Connector'.",
              "type": "string"
            },
            "dnsName": {
              "description": "Immutable. The DNS name of this managed zone, for instance \"example.com.\".",
              "type": "string"
            },
            "dnssecConfig": {
              "description": "DNSSEC configuration.",
              "type": "object",
              "properties": {
                "defaultKeySpecs": {
                  "description": "Specifies parameters that will be used for generating initial DnsKeys\nfor this ManagedZone. If you provide a spec for keySigning or zoneSigning,\nyou must also provide one for the other.\ndefault_key_specs can only be updated when the state is 'off'.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "algorithm": {
                        "description": "String mnemonic specifying the DNSSEC algorithm of this key Possible values: [\"ecdsap256sha256\", \"ecdsap384sha384\", \"rsasha1\", \"rsasha256\", \"rsasha512\"].",
                        "type": "string"
                      },
                      "keyLength": {
                        "description": "Length of the keys in bits.",
                        "type": "integer"
                      },
                      "keyType": {
                        "description": "Specifies whether this is a key signing key (KSK) or a zone\nsigning key (ZSK). Key signing keys have the Secure Entry\nPoint flag set and, when active, will only be used to sign\nresource record sets of type DNSKEY. Zone signing keys do\nnot have the Secure Entry Point flag set and will be used\nto sign all other types of resource record sets. Possible values: [\"keySigning\", \"zoneSigning\"].",
                        "type": "string"
                      },
                      "kind": {
                        "description": "Identifies what kind of resource this is.",
                        "type": "string"
                      }
                    }
                  }
                },
                "kind": {
                  "description": "Identifies what kind of resource this is.",
                  "type": "string"
                },
                "nonExistence": {
                  "description": "Specifies the mechanism used to provide authenticated denial-of-existence responses.\nnon_existence can only be updated when the state is 'off'. Possible values: [\"nsec\", \"nsec3\"].",
                  "type": "string"
                },
                "state": {
                  "description": "Specifies whether DNSSEC is enabled, and what mode it is in Possible values: [\"off\", \"on\", \"transfer\"].",
                  "type": "string"
                }
              }
            },
            "forwardingConfig": {
              "description": "The presence for this field indicates that outbound forwarding is enabled\nfor this zone. The value of this field contains the set of destinations\nto forward to.",
              "type": "object",
              "required": ["targetNameServers"],
              "properties": {
                "targetNameServers": {
                  "description": "List of target name servers to forward to. Cloud DNS will\nselect the best available name server if more than\none target is given.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["ipv4Address"],
                    "properties": {
                      "forwardingPath": {
                        "description": "Forwarding path for this TargetNameServer. If unset or 'default' Cloud DNS will make forwarding\ndecision based on address ranges, i.e. RFC1918 addresses go to the VPC, Non-RFC1918 addresses go\nto the Internet. When set to 'private', Cloud DNS will always send queries through VPC for this target Possible values: [\"default\", \"private\"].",
                        "type": "string"
                      },
                      "ipv4Address": {
                        "description": "IPv4 address of a target name server.",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "peeringConfig": {
              "description": "The presence of this field indicates that DNS Peering is enabled for this\nzone. The value of this field contains the network to peer with.",
              "type": "object",
              "required": ["targetNetwork"],
              "properties": {
                "targetNetwork": {
                  "description": "The network with which to peer.",
                  "type": "object",
                  "required": ["networkRef"],
                  "properties": {
                    "networkRef": {
                      "description": "VPC network to forward queries to.",
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "The selfLink of a ComputeNetwork.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "privateVisibilityConfig": {
              "description": "For privately visible zones, the set of Virtual Private Cloud\nresources that the zone is visible from.",
              "type": "object",
              "required": ["networks"],
              "properties": {
                "networks": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["networkRef"],
                    "properties": {
                      "networkRef": {
                        "description": "VPC network to bind to.",
                        "type": "object",
                        "properties": {
                          "external": {
                            "description": "The selfLink of a ComputeNetwork.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "reverseLookup": {
              "description": "Immutable. Specifies if this is a managed reverse lookup zone. If true, Cloud DNS will resolve reverse\nlookup queries using automatically configured records for VPC resources. This only applies\nto networks listed under 'private_visibility_config'.",
              "type": "boolean"
            },
            "serviceDirectoryConfig": {
              "description": "Immutable. The presence of this field indicates that this zone is backed by Service Directory. The value of this field contains information related to the namespace associated with the zone.",
              "type": "object",
              "required": ["namespace"],
              "properties": {
                "namespace": {
                  "description": "The namespace associated with the zone.",
                  "type": "object",
                  "required": ["namespaceUrl"],
                  "properties": {
                    "namespaceUrl": {
                      "description": "The fully qualified or partial URL of the service directory namespace that should be\nassociated with the zone. This should be formatted like\n'https://servicedirectory.googleapis.com/v1/projects/{project}/locations/{location}/namespaces/{namespace_id}'\nor simply 'projects/{project}/locations/{location}/namespaces/{namespace_id}'\nIgnored for 'public' visibility zones.",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "visibility": {
              "description": "Immutable. The zone's visibility: public zones are exposed to the Internet,\nwhile private zones are visible only to Virtual Private Cloud resources. Default value: \"public\" Possible values: [\"private\", \"public\"].",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "nameServers": {
              "description": "Delegate your managed_zone to these virtual name servers;\ndefined by the server.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "dns.cnrm.cloud.google.com",
          "kind": "DNSManagedZone",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.dns.v1beta1.DNSManagedZoneList": {
      "description": "DNSManagedZoneList is a list of DNSManagedZone",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["dns.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of dnsmanagedzones. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.dns.v1beta1.DNSManagedZone"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DNSManagedZoneList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "dns.cnrm.cloud.google.com",
          "kind": "DNSManagedZoneList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.dns.v1beta1.DNSPolicy": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["dns.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DNSPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "alternativeNameServerConfig": {
              "description": "Sets an alternative name server for the associated networks.\nWhen specified, all DNS queries are forwarded to a name server that you choose.\nNames such as .internal are not available when an alternative name server is specified.",
              "type": "object",
              "required": ["targetNameServers"],
              "properties": {
                "targetNameServers": {
                  "description": "Sets an alternative name server for the associated networks. When specified,\nall DNS queries are forwarded to a name server that you choose. Names such as .internal\nare not available when an alternative name server is specified.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["ipv4Address"],
                    "properties": {
                      "forwardingPath": {
                        "description": "Forwarding path for this TargetNameServer. If unset or 'default' Cloud DNS will make forwarding\ndecision based on address ranges, i.e. RFC1918 addresses go to the VPC, Non-RFC1918 addresses go\nto the Internet. When set to 'private', Cloud DNS will always send queries through VPC for this target Possible values: [\"default\", \"private\"].",
                        "type": "string"
                      },
                      "ipv4Address": {
                        "description": "IPv4 address to forward to.",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "description": {
              "description": "A textual description field. Defaults to 'Managed by Config Connector'.",
              "type": "string"
            },
            "enableInboundForwarding": {
              "description": "Allows networks bound to this policy to receive DNS queries sent\nby VMs or applications over VPN connections. When enabled, a\nvirtual IP address will be allocated from each of the sub-networks\nthat are bound to this policy.",
              "type": "boolean"
            },
            "enableLogging": {
              "description": "Controls whether logging is enabled for the networks bound to this policy.\nDefaults to no logging if not set.",
              "type": "boolean"
            },
            "networks": {
              "description": "List of network names specifying networks to which this policy is applied.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["networkRef"],
                "properties": {
                  "networkRef": {
                    "description": "VPC network to bind to.",
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The selfLink of a ComputeNetwork.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "dns.cnrm.cloud.google.com",
          "kind": "DNSPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.dns.v1beta1.DNSPolicyList": {
      "description": "DNSPolicyList is a list of DNSPolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["dns.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of dnspolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.dns.v1beta1.DNSPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DNSPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "dns.cnrm.cloud.google.com",
          "kind": "DNSPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.dns.v1beta1.DNSRecordSet": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["dns.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DNSRecordSet"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["managedZoneRef", "name", "rrdatas", "type"],
          "properties": {
            "managedZoneRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a DNSManagedZone.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "name": {
              "description": "Immutable. The DNS name this record set will apply to.",
              "type": "string"
            },
            "rrdatas": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "ttl": {
              "description": "The time-to-live of this record set (seconds).",
              "type": "integer"
            },
            "type": {
              "description": "The DNS record set type.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "dns.cnrm.cloud.google.com",
          "kind": "DNSRecordSet",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.dns.v1beta1.DNSRecordSetList": {
      "description": "DNSRecordSetList is a list of DNSRecordSet",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["dns.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of dnsrecordsets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.dns.v1beta1.DNSRecordSet"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DNSRecordSetList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "dns.cnrm.cloud.google.com",
          "kind": "DNSRecordSetList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.filestore.v1beta1.FilestoreBackup": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["filestore.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["FilestoreBackup"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": [
            "location",
            "projectRef",
            "sourceFileShare",
            "sourceInstanceRef"
          ],
          "properties": {
            "description": {
              "description": "A description of the backup with 2048 characters or less. Requests with longer descriptions will be rejected.",
              "type": "string"
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "sourceFileShare": {
              "description": "Name of the file share in the source Cloud Filestore instance that the backup is created from.",
              "type": "string"
            },
            "sourceInstanceRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The resource name of the source Cloud Filestore instance, in the format projects/{project_number}/locations/{location_id}/instances/{instance_id}, used to create this backup.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "capacityGb": {
              "description": "Output only. Capacity of the source file share when the backup was created.",
              "type": "integer",
              "format": "int64"
            },
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The time when the backup was created.",
              "type": "string",
              "format": "date-time"
            },
            "downloadBytes": {
              "description": "Output only. Amount of bytes that will be downloaded if the backup is restored. This may be different than storage bytes, since sequential backups of the same disk will share storage.",
              "type": "integer",
              "format": "int64"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "sourceInstanceTier": {
              "description": "Output only. The service tier of the source Cloud Filestore instance that this backup is created from. Possible values: TIER_UNSPECIFIED, STANDARD, PREMIUM, BASIC_HDD, BASIC_SSD, HIGH_SCALE_SSD",
              "type": "string"
            },
            "state": {
              "description": "Output only. The backup state. Possible values: STATE_UNSPECIFIED, CREATING, READY, REPAIRING, DELETING, ERROR, RESTORING",
              "type": "string"
            },
            "storageBytes": {
              "description": "Output only. The size of the storage used by the backup. As backups share storage, this number is expected to change with backup creation/deletion.",
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "filestore.cnrm.cloud.google.com",
          "kind": "FilestoreBackup",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.filestore.v1beta1.FilestoreBackupList": {
      "description": "FilestoreBackupList is a list of FilestoreBackup",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["filestore.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of filestorebackups. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.filestore.v1beta1.FilestoreBackup"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["FilestoreBackupList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "filestore.cnrm.cloud.google.com",
          "kind": "FilestoreBackupList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.filestore.v1beta1.FilestoreInstance": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["filestore.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["FilestoreInstance"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location", "projectRef"],
          "properties": {
            "description": {
              "description": "The description of the instance (2048 characters or less).",
              "type": "string"
            },
            "fileShares": {
              "description": "File system shares on the instance. For this version, only a single file share is supported.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "capacityGb": {
                    "description": "File share capacity in gigabytes (GB). Cloud Filestore defines 1 GB as 1024^3 bytes.",
                    "type": "integer",
                    "format": "int64"
                  },
                  "name": {
                    "description": "The name of the file share (must be 16 characters or less).",
                    "type": "string"
                  },
                  "nfsExportOptions": {
                    "description": "Nfs Export Options. There is a limit of 10 export options per file share.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "accessMode": {
                          "description": "Either READ_ONLY, for allowing only read requests on the exported directory, or READ_WRITE, for allowing both read and write requests. The default is READ_WRITE. Possible values: ACCESS_MODE_UNSPECIFIED, READ_ONLY, READ_WRITE",
                          "type": "string"
                        },
                        "anonGid": {
                          "description": "An integer representing the anonymous group id with a default value of 65534. Anon_gid may only be set with squash_mode of ROOT_SQUASH. An error will be returned if this field is specified for other squash_mode settings.",
                          "type": "integer",
                          "format": "int64"
                        },
                        "anonUid": {
                          "description": "An integer representing the anonymous user id with a default value of 65534. Anon_uid may only be set with squash_mode of ROOT_SQUASH. An error will be returned if this field is specified for other squash_mode settings.",
                          "type": "integer",
                          "format": "int64"
                        },
                        "ipRanges": {
                          "description": "List of either an IPv4 addresses in the format `{octet1}.{octet2}.{octet3}.{octet4}` or CIDR ranges in the format `{octet1}.{octet2}.{octet3}.{octet4}/{mask size}` which may mount the file share. Overlapping IP ranges are not allowed, both within and across NfsExportOptions. An error will be returned. The limit is 64 IP ranges/addresses for each FileShareConfig among all NfsExportOptions.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "squashMode": {
                          "description": "Either NO_ROOT_SQUASH, for allowing root access on the exported directory, or ROOT_SQUASH, for not allowing root access. The default is NO_ROOT_SQUASH. Possible values: SQUASH_MODE_UNSPECIFIED, NO_ROOT_SQUASH, ROOT_SQUASH",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "sourceBackupRef": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The resource name of the backup, in the format `projects/{project_number}/locations/{location_id}/backups/{backup_id}`, that this file share has been restored from.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "networks": {
              "description": "VPC networks to which the instance is connected. For this version, only a single network is supported.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "ipAddresses": {
                    "description": "Output only. IPv4 addresses in the format `{octet1}.{octet2}.{octet3}.{octet4}` or IPv6 addresses in the format `{block1}:{block2}:{block3}:{block4}:{block5}:{block6}:{block7}:{block8}`.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "modes": {
                    "description": "Internet protocol versions for which the instance has IP addresses assigned. For this version, only MODE_IPV4 is supported.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "networkRef": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The name of the Google Compute Engine [VPC network](https://cloud.google.com/vpc/docs/vpc) to which the instance is connected.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  },
                  "reservedIPRange": {
                    "description": "A /29 CIDR block in one of the [internal IP address ranges](https://www.arin.net/reference/research/statistics/address_filters/) that identifies the range of IP addresses reserved for this instance. For example, 10.0.0.0/29 or 192.168.0.0/29. The range you specify can't overlap with either existing subnets or assigned IP address ranges for other Cloud Filestore instances in the selected VPC network.",
                    "type": "string"
                  }
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "tier": {
              "description": "The service tier of the instance. Possible values: TIER_UNSPECIFIED, STANDARD, PREMIUM, BASIC_HDD, BASIC_SSD, HIGH_SCALE_SSD",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The time when the instance was created.",
              "type": "string",
              "format": "date-time"
            },
            "etag": {
              "description": "Server-specified ETag for the instance resource to prevent simultaneous updates from overwriting each other.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "state": {
              "description": "Output only. The instance state. Possible values: STATE_UNSPECIFIED, CREATING, READY, REPAIRING, DELETING, ERROR",
              "type": "string"
            },
            "statusMessage": {
              "description": "Output only. Additional information about the instance state, if available.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "filestore.cnrm.cloud.google.com",
          "kind": "FilestoreInstance",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.filestore.v1beta1.FilestoreInstanceList": {
      "description": "FilestoreInstanceList is a list of FilestoreInstance",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["filestore.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of filestoreinstances. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.filestore.v1beta1.FilestoreInstance"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["FilestoreInstanceList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "filestore.cnrm.cloud.google.com",
          "kind": "FilestoreInstanceList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.firestore.v1beta1.FirestoreIndex": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["firestore.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["FirestoreIndex"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["collection", "fields"],
          "properties": {
            "collection": {
              "description": "Immutable. The collection being indexed.",
              "type": "string"
            },
            "database": {
              "description": "Immutable. The Firestore database id. Defaults to '\"(default)\"'.",
              "type": "string"
            },
            "fields": {
              "description": "Immutable. The fields supported by this index. The last field entry is always for\nthe field path '__name__'. If, on creation, '__name__' was not\nspecified as the last field, it will be added automatically with the\nsame direction as that of the last field defined. If the final field\nin a composite index is not directional, the '__name__' will be\nordered '\"ASCENDING\"' (unless explicitly specified otherwise).",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "arrayConfig": {
                    "description": "Immutable. Indicates that this field supports operations on arrayValues. Only one of 'order' and 'arrayConfig' can\nbe specified. Possible values: [\"CONTAINS\"].",
                    "type": "string"
                  },
                  "fieldPath": {
                    "description": "Immutable. Name of the field.",
                    "type": "string"
                  },
                  "order": {
                    "description": "Immutable. Indicates that this field supports ordering by the specified order or comparing using =, <, <=, >, >=.\nOnly one of 'order' and 'arrayConfig' can be specified. Possible values: [\"ASCENDING\", \"DESCENDING\"].",
                    "type": "string"
                  }
                }
              }
            },
            "queryScope": {
              "description": "Immutable. The scope at which a query is run. Default value: \"COLLECTION\" Possible values: [\"COLLECTION\", \"COLLECTION_GROUP\"].",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "name": {
              "description": "A server defined name for this index. Format:\n'projects/{{project}}/databases/{{database}}/collectionGroups/{{collection}}/indexes/{{server_generated_id}}'.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "firestore.cnrm.cloud.google.com",
          "kind": "FirestoreIndex",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.firestore.v1beta1.FirestoreIndexList": {
      "description": "FirestoreIndexList is a list of FirestoreIndex",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["firestore.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of firestoreindexes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.firestore.v1beta1.FirestoreIndex"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["FirestoreIndexList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "firestore.cnrm.cloud.google.com",
          "kind": "FirestoreIndexList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.gameservices.v1beta1.GameServicesRealm": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["gameservices.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["GameServicesRealm"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location", "timeZone"],
          "properties": {
            "description": {
              "description": "Human readable description of the realm.",
              "type": "string"
            },
            "location": {
              "description": "The location for this realm.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "timeZone": {
              "description": "Required. Time zone where all policies targeting this realm are evaluated. The value of this field must be from the IANA time zone database: https://www.iana.org/time-zones.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The creation time.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Output only. The last-modified time.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "gameservices.cnrm.cloud.google.com",
          "kind": "GameServicesRealm",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.gameservices.v1beta1.GameServicesRealmList": {
      "description": "GameServicesRealmList is a list of GameServicesRealm",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["gameservices.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of gameservicesrealms. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.gameservices.v1beta1.GameServicesRealm"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["GameServicesRealmList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "gameservices.cnrm.cloud.google.com",
          "kind": "GameServicesRealmList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.gkehub.v1beta1.GKEHubFeature": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["gkehub.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["GKEHubFeature"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location", "projectRef"],
          "properties": {
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "spec": {
              "description": "Optional. Hub-wide Feature configuration. If this Feature does not support any Hub-wide configuration, this field may be unused.",
              "type": "object",
              "properties": {
                "multiclusteringress": {
                  "description": "Multicluster Ingress-specific spec.",
                  "type": "object",
                  "required": ["configMembershipRef"],
                  "properties": {
                    "configMembershipRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "Fully-qualified Membership name which hosts the MultiClusterIngress CRD. Example: `projects/foo-proj/locations/global/memberships/bar`",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. When the Feature resource was created.",
              "type": "string",
              "format": "date-time"
            },
            "deleteTime": {
              "description": "Output only. When the Feature resource was deleted.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "resourceState": {
              "description": "State of the Feature resource itself.",
              "type": "object",
              "properties": {
                "hasResources": {
                  "description": "Whether this Feature has outstanding resources that need to be cleaned up before it can be disabled.",
                  "type": "boolean"
                },
                "state": {
                  "description": "The current state of the Feature resource in the Hub API. Possible values: STATE_UNSPECIFIED, ENABLING, ACTIVE, DISABLING, UPDATING, SERVICE_UPDATING",
                  "type": "string"
                }
              }
            },
            "state": {
              "description": "Output only. The Hub-wide Feature state",
              "type": "object",
              "properties": {
                "state": {
                  "description": "Output only. The \"running state\" of the Feature in this Hub.",
                  "type": "object",
                  "properties": {
                    "code": {
                      "description": "The high-level, machine-readable status of this Feature. Possible values: CODE_UNSPECIFIED, OK, WARNING, ERROR",
                      "type": "string"
                    },
                    "description": {
                      "description": "A human-readable description of the current status.",
                      "type": "string"
                    },
                    "updateTime": {
                      "description": "The time this status and any related Feature-specific details were updated. A timestamp in RFC3339 UTC \"Zulu\" format, with nanosecond resolution and up to nine fractional digits. Examples: \"2014-10-02T15:01:23Z\" and \"2014-10-02T15:01:23.045123456Z\"",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "updateTime": {
              "description": "Output only. When the Feature resource was last updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "gkehub.cnrm.cloud.google.com",
          "kind": "GKEHubFeature",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.gkehub.v1beta1.GKEHubFeatureList": {
      "description": "GKEHubFeatureList is a list of GKEHubFeature",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["gkehub.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of gkehubfeatures. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.gkehub.v1beta1.GKEHubFeature"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["GKEHubFeatureList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "gkehub.cnrm.cloud.google.com",
          "kind": "GKEHubFeatureList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.gkehub.v1beta1.GKEHubFeatureMembership": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["gkehub.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["GKEHubFeatureMembership"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": [
            "configmanagement",
            "featureRef",
            "location",
            "membershipRef",
            "projectRef"
          ],
          "properties": {
            "configmanagement": {
              "description": "Config Management-specific spec.",
              "type": "object",
              "properties": {
                "binauthz": {
                  "description": "Binauthz configuration for the cluster.",
                  "type": "object",
                  "properties": {
                    "enabled": {
                      "description": "Whether binauthz is enabled in this cluster.",
                      "type": "boolean"
                    }
                  }
                },
                "configSync": {
                  "description": "Config Sync configuration for the cluster.",
                  "type": "object",
                  "properties": {
                    "git": {
                      "type": "object",
                      "properties": {
                        "gcpServiceAccountRef": {
                          "type": "object",
                          "properties": {
                            "external": {
                              "description": "The GCP Service Account Email used for auth when secretType is gcpServiceAccount.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                              "type": "string"
                            },
                            "namespace": {
                              "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                              "type": "string"
                            }
                          }
                        },
                        "httpsProxy": {
                          "description": "URL for the HTTPS proxy to be used when communicating with the Git repo.",
                          "type": "string"
                        },
                        "policyDir": {
                          "description": "The path within the Git repository that represents the top level of the repo to sync. Default: the root directory of the repository.",
                          "type": "string"
                        },
                        "secretType": {
                          "description": "Type of secret configured for access to the Git repo.",
                          "type": "string"
                        },
                        "syncBranch": {
                          "description": "The branch of the repository to sync from. Default: master.",
                          "type": "string"
                        },
                        "syncRepo": {
                          "description": "The URL of the Git repository to use as the source of truth.",
                          "type": "string"
                        },
                        "syncRev": {
                          "description": "Git revision (tag or hash) to check out. Default HEAD.",
                          "type": "string"
                        },
                        "syncWaitSecs": {
                          "description": "Period in seconds between consecutive syncs. Default: 15.",
                          "type": "string"
                        }
                      }
                    },
                    "sourceFormat": {
                      "description": "Specifies whether the Config Sync Repo is in \"hierarchical\" or \"unstructured\" mode.",
                      "type": "string"
                    }
                  }
                },
                "hierarchyController": {
                  "description": "Hierarchy Controller configuration for the cluster.",
                  "type": "object",
                  "properties": {
                    "enableHierarchicalResourceQuota": {
                      "description": "Whether hierarchical resource quota is enabled in this cluster.",
                      "type": "boolean"
                    },
                    "enablePodTreeLabels": {
                      "description": "Whether pod tree labels are enabled in this cluster.",
                      "type": "boolean"
                    },
                    "enabled": {
                      "description": "Whether Hierarchy Controller is enabled in this cluster.",
                      "type": "boolean"
                    }
                  }
                },
                "policyController": {
                  "description": "Policy Controller configuration for the cluster.",
                  "type": "object",
                  "properties": {
                    "auditIntervalSeconds": {
                      "description": "Sets the interval for Policy Controller Audit Scans (in seconds). When set to 0, this disables audit functionality altogether.",
                      "type": "string"
                    },
                    "enabled": {
                      "description": "Enables the installation of Policy Controller. If false, the rest of PolicyController fields take no effect.",
                      "type": "boolean"
                    },
                    "exemptableNamespaces": {
                      "description": "The set of namespaces that are excluded from Policy Controller checks. Namespaces do not need to currently exist on the cluster.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "logDeniesEnabled": {
                      "description": "Logs all denies and dry run failures.",
                      "type": "boolean"
                    },
                    "referentialRulesEnabled": {
                      "description": "Enables the ability to use Constraint Templates that reference to objects other than the object currently being evaluated.",
                      "type": "boolean"
                    },
                    "templateLibraryInstalled": {
                      "description": "Installs the default template library along with Policy Controller.",
                      "type": "boolean"
                    }
                  }
                },
                "version": {
                  "description": "Version of ACM installed.",
                  "type": "string"
                }
              }
            },
            "featureRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of the feature",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "location": {
              "description": "The location of the feature",
              "type": "string"
            },
            "membershipRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of the membership",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project of the feature",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "gkehub.cnrm.cloud.google.com",
          "kind": "GKEHubFeatureMembership",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.gkehub.v1beta1.GKEHubFeatureMembershipList": {
      "description": "GKEHubFeatureMembershipList is a list of GKEHubFeatureMembership",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["gkehub.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of gkehubfeaturememberships. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.gkehub.v1beta1.GKEHubFeatureMembership"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["GKEHubFeatureMembershipList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "gkehub.cnrm.cloud.google.com",
          "kind": "GKEHubFeatureMembershipList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.gkehub.v1beta1.GKEHubMembership": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["gkehub.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["GKEHubMembership"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location"],
          "properties": {
            "authority": {
              "description": "Optional. How to identify workloads from this Membership. See the documentation on Workload Identity for more details: https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity",
              "type": "object",
              "properties": {
                "issuer": {
                  "description": "Optional. A JSON Web Token (JWT) issuer URI. `issuer` must start with `https://` and be a valid URL with length <2000 characters. If set, then Google will allow valid OIDC tokens from this issuer to authenticate within the workload_identity_pool. OIDC discovery will be performed on this URI to validate tokens from the issuer. Clearing `issuer` disables Workload Identity. `issuer` cannot be directly modified; it must be cleared (and Workload Identity disabled) before using a new issuer (and re-enabling Workload Identity).",
                  "type": "string"
                }
              }
            },
            "description": {
              "description": "Description of this membership, limited to 63 characters. Must match the regex: `*` This field is present for legacy purposes.",
              "type": "string"
            },
            "endpoint": {
              "description": "Optional. Endpoint information to reach this member.",
              "type": "object",
              "properties": {
                "gkeCluster": {
                  "description": "Optional. GKE-specific information. Only present if this Membership is a GKE cluster.",
                  "type": "object",
                  "properties": {
                    "resourceRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "Immutable. Self-link of the GCP resource for the GKE cluster. For example: //container.googleapis.com/projects/my-project/locations/us-west1-a/clusters/my-cluster Zonal clusters are also supported.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "kubernetesResource": {
                  "description": "Optional. The in-cluster Kubernetes Resources that should be applied for a correctly registered cluster, in the steady state. These resources: * Ensure that the cluster is exclusively registered to one and only one Hub Membership. * Propagate Workload Pool Information available in the Membership Authority field. * Ensure proper initial configuration of default Hub Features.",
                  "type": "object",
                  "properties": {
                    "membershipCrManifest": {
                      "description": "Input only. The YAML representation of the Membership CR. This field is ignored for GKE clusters where Hub can read the CR directly. Callers should provide the CR that is currently present in the cluster during CreateMembership or UpdateMembership, or leave this field empty if none exists. The CR manifest is used to validate the cluster has not been registered with another Membership.",
                      "type": "string"
                    },
                    "resourceOptions": {
                      "description": "Optional. Options for Kubernetes resource generation.",
                      "type": "object",
                      "properties": {
                        "connectVersion": {
                          "description": "Optional. The Connect agent version to use for connect_resources. Defaults to the latest GKE Connect version. The version must be a currently supported version, obsolete versions will be rejected.",
                          "type": "string"
                        },
                        "v1beta1Crd": {
                          "description": "Optional. Use `apiextensions/v1beta1` instead of `apiextensions/v1` for CustomResourceDefinition resources. This option should be set for clusters with Kubernetes apiserver versions <1.16.",
                          "type": "boolean"
                        }
                      }
                    }
                  }
                }
              }
            },
            "externalId": {
              "description": "Optional. An externally-generated and managed ID for this Membership. This ID may be modified after creation, but this is not recommended. The ID must match the regex: `*` If this Membership represents a Kubernetes cluster, this value should be set to the UID of the `kube-system` namespace object.",
              "type": "string"
            },
            "infrastructureType": {
              "description": "Optional. The infrastructure type this Membership is running on. Possible values: INFRASTRUCTURE_TYPE_UNSPECIFIED, ON_PREM, MULTI_CLOUD",
              "type": "string"
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "authority": {
              "type": "object",
              "properties": {
                "identityProvider": {
                  "description": "Output only. An identity provider that reflects the `issuer` in the workload identity pool.",
                  "type": "string"
                },
                "workloadIdentityPool": {
                  "description": "Output only. The name of the workload identity pool in which `issuer` will be recognized. There is a single Workload Identity Pool per Hub that is shared between all Memberships that belong to that Hub. For a Hub hosted in: {PROJECT_ID}, the workload pool format is `{PROJECT_ID}.hub.id.goog`, although this is subject to change in newer versions of this API.",
                  "type": "string"
                }
              }
            },
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. When the Membership was created.",
              "type": "string",
              "format": "date-time"
            },
            "deleteTime": {
              "description": "Output only. When the Membership was deleted.",
              "type": "string",
              "format": "date-time"
            },
            "endpoint": {
              "type": "object",
              "properties": {
                "kubernetesMetadata": {
                  "description": "Output only. Useful Kubernetes-specific metadata.",
                  "type": "object",
                  "properties": {
                    "kubernetesApiServerVersion": {
                      "description": "Output only. Kubernetes API server version string as reported by `/version`.",
                      "type": "string"
                    },
                    "memoryMb": {
                      "description": "Output only. The total memory capacity as reported by the sum of all Kubernetes nodes resources, defined in MB.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "nodeCount": {
                      "description": "Output only. Node count as reported by Kubernetes nodes resources.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "nodeProviderId": {
                      "description": "Output only. Node providerID as reported by the first node in the list of nodes on the Kubernetes endpoint. On Kubernetes platforms that support zero-node clusters (like GKE-on-GCP), the node_count will be zero and the node_provider_id will be empty.",
                      "type": "string"
                    },
                    "updateTime": {
                      "description": "Output only. The time at which these details were last updated. This update_time is different from the Membership-level update_time since EndpointDetails are updated internally for API consumers.",
                      "type": "string",
                      "format": "date-time"
                    },
                    "vcpuCount": {
                      "description": "Output only. vCPU count as reported by Kubernetes nodes resources.",
                      "type": "integer",
                      "format": "int64"
                    }
                  }
                },
                "kubernetesResource": {
                  "type": "object",
                  "properties": {
                    "connectResources": {
                      "description": "Output only. The Kubernetes resources for installing the GKE Connect agent This field is only populated in the Membership returned from a successful long-running operation from CreateMembership or UpdateMembership. It is not populated during normal GetMembership or ListMemberships requests. To get the resource manifest after the initial registration, the caller should make a UpdateMembership call with an empty field mask.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "clusterScoped": {
                            "description": "Whether the resource provided in the manifest is `cluster_scoped`. If unset, the manifest is assumed to be namespace scoped. This field is used for REST mapping when applying the resource in a cluster.",
                            "type": "boolean"
                          },
                          "manifest": {
                            "description": "YAML manifest of the resource.",
                            "type": "string"
                          }
                        }
                      }
                    },
                    "membershipResources": {
                      "description": "Output only. Additional Kubernetes resources that need to be applied to the cluster after Membership creation, and after every update. This field is only populated in the Membership returned from a successful long-running operation from CreateMembership or UpdateMembership. It is not populated during normal GetMembership or ListMemberships requests. To get the resource manifest after the initial registration, the caller should make a UpdateMembership call with an empty field mask.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "clusterScoped": {
                            "description": "Whether the resource provided in the manifest is `cluster_scoped`. If unset, the manifest is assumed to be namespace scoped. This field is used for REST mapping when applying the resource in a cluster.",
                            "type": "boolean"
                          },
                          "manifest": {
                            "description": "YAML manifest of the resource.",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "lastConnectionTime": {
              "description": "Output only. For clusters using Connect, the timestamp of the most recent connection established with Google Cloud. This time is updated every several minutes, not continuously. For clusters that do not use GKE Connect, or that have never connected successfully, this field will be unset.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "state": {
              "description": "Output only. State of the Membership resource.",
              "type": "object",
              "properties": {
                "code": {
                  "description": "Output only. The current state of the Membership resource. Possible values: CODE_UNSPECIFIED, CREATING, READY, DELETING, UPDATING, SERVICE_UPDATING",
                  "type": "string"
                }
              }
            },
            "uniqueId": {
              "description": "Output only. Google-generated UUID for this resource. This is unique across all Membership resources. If a Membership resource is deleted and another resource with the same name is created, it gets a different unique_id.",
              "type": "string"
            },
            "updateTime": {
              "description": "Output only. When the Membership was last updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "gkehub.cnrm.cloud.google.com",
          "kind": "GKEHubMembership",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.gkehub.v1beta1.GKEHubMembershipList": {
      "description": "GKEHubMembershipList is a list of GKEHubMembership",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["gkehub.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of gkehubmemberships. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.gkehub.v1beta1.GKEHubMembership"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["GKEHubMembershipList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "gkehub.cnrm.cloud.google.com",
          "kind": "GKEHubMembershipList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMAuditConfig": {
      "description": "IAMAuditConfig is the schema for the IAM audit logging API.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMAuditConfig"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "IAMAuditConfigSpec defines the desired state of IAMAuditConfig.",
          "type": "object",
          "required": ["auditLogConfigs", "resourceRef", "service"],
          "properties": {
            "auditLogConfigs": {
              "description": "Required. The configuration for logging of each type of permission.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["logType"],
                "properties": {
                  "exemptedMembers": {
                    "description": "Identities that do not cause logging for this type of permission. The format is the same as that for 'members' in IAMPolicy/IAMPolicyMember.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "logType": {
                    "description": "Permission type for which logging is to be configured. Must be one of 'DATA_READ', 'DATA_WRITE', or 'ADMIN_READ'.",
                    "type": "string",
                    "pattern": "^(DATA_READ|DATA_WRITE|ADMIN_READ)$"
                  }
                }
              }
            },
            "resourceRef": {
              "description": "Immutable. Required. The GCP resource to set the IAMAuditConfig on (e.g. project).",
              "type": "object",
              "required": ["kind"],
              "properties": {
                "apiVersion": {
                  "type": "string"
                },
                "external": {
                  "type": "string"
                },
                "kind": {
                  "type": "string"
                },
                "name": {
                  "type": "string"
                },
                "namespace": {
                  "type": "string"
                }
              }
            },
            "service": {
              "description": "Immutable. Required. The service for which to enable Data Access audit logs. The special value 'allServices' covers all services. Note that if there are audit configs covering both 'allServices' and a specific service, then the union of the two audit configs is used for that service: the 'logTypes' specified in each 'auditLogConfig' are enabled, and the 'exemptedMembers' in each 'auditLogConfg' are exempted.",
              "type": "string"
            }
          }
        },
        "status": {
          "description": "IAMAuditConfigStatus defines the observed state of IAMAuditConfig.",
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observations of the IAMAuditConfig's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMAuditConfig",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMAuditConfigList": {
      "description": "IAMAuditConfigList is a list of IAMAuditConfig",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of iamauditconfigs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.iam.v1beta1.IAMAuditConfig"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMAuditConfigList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMAuditConfigList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMCustomRole": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMCustomRole"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["permissions", "title"],
          "properties": {
            "description": {
              "description": "A human-readable description for the role.",
              "type": "string"
            },
            "permissions": {
              "description": "The names of the permissions this role grants when bound in an IAM policy. At least one permission must be specified.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The roleId of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "stage": {
              "description": "The current launch stage of the role. Defaults to GA.",
              "type": "string"
            },
            "title": {
              "description": "A human-readable title for the role.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "deleted": {
              "description": "The current deleted state of the role.",
              "type": "boolean"
            },
            "name": {
              "description": "The full name of the role.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMCustomRole",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMCustomRoleList": {
      "description": "IAMCustomRoleList is a list of IAMCustomRole",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of iamcustomroles. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.iam.v1beta1.IAMCustomRole"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMCustomRoleList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMCustomRoleList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMPartialPolicy": {
      "description": "IAMPartialPolicy is the Schema for the iampartialpolicy API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMPartialPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "IAMPartialPolicySpec defines the desired state of IAMPartialPolicy",
          "type": "object",
          "required": ["resourceRef"],
          "properties": {
            "bindings": {
              "description": "Optional. The list of IAM bindings managed by Config Connector.",
              "type": "array",
              "items": {
                "description": "Specifies the members to bind to an IAM role.",
                "type": "object",
                "required": ["role"],
                "properties": {
                  "condition": {
                    "description": "Optional. The condition under which the binding applies.",
                    "type": "object",
                    "required": ["expression", "title"],
                    "properties": {
                      "description": {
                        "type": "string"
                      },
                      "expression": {
                        "type": "string"
                      },
                      "title": {
                        "type": "string"
                      }
                    }
                  },
                  "members": {
                    "description": "Optional. The list of IAM users to be bound to the role.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "member": {
                          "description": "The IAM identity to be bound to the role. Exactly one of 'member' or 'memberFrom' must be used.",
                          "type": "string"
                        },
                        "memberFrom": {
                          "description": "The IAM identity to be bound to the role. Exactly one of 'member' or 'memberFrom' must be used, and only one subfield within 'memberFrom' can be used.",
                          "type": "object",
                          "properties": {
                            "logSinkRef": {
                              "description": "The LoggingLogSink whose writer identity (i.e. its 'status.writerIdentity') is to be bound to the role.",
                              "type": "object",
                              "required": ["name"],
                              "properties": {
                                "name": {
                                  "type": "string"
                                },
                                "namespace": {
                                  "type": "string"
                                }
                              }
                            },
                            "serviceAccountRef": {
                              "description": "The IAMServiceAccount to be bound to the role.",
                              "type": "object",
                              "required": ["name"],
                              "properties": {
                                "name": {
                                  "type": "string"
                                },
                                "namespace": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "role": {
                    "description": "Required. The role to bind the users to.",
                    "type": "string",
                    "pattern": "^((projects|organizations)/[^/]+/)?roles/[\\w_\\.]+$"
                  }
                }
              }
            },
            "resourceRef": {
              "description": "Immutable. Required. The GCP resource to set the IAM policy on.",
              "type": "object",
              "required": ["kind"],
              "properties": {
                "apiVersion": {
                  "type": "string"
                },
                "external": {
                  "type": "string"
                },
                "kind": {
                  "type": "string"
                },
                "name": {
                  "type": "string"
                },
                "namespace": {
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "description": "IAMPartialPolicyStatus defines the observed state of IAMPartialPolicy",
          "type": "object",
          "properties": {
            "allBindings": {
              "description": "AllBindings surfaces all IAM bindings for the referenced resource.",
              "type": "array",
              "items": {
                "description": "Specifies the members to bind to an IAM role.",
                "type": "object",
                "required": ["role"],
                "properties": {
                  "condition": {
                    "description": "Optional. The condition under which the binding applies.",
                    "type": "object",
                    "required": ["expression", "title"],
                    "properties": {
                      "description": {
                        "type": "string"
                      },
                      "expression": {
                        "type": "string"
                      },
                      "title": {
                        "type": "string"
                      }
                    }
                  },
                  "members": {
                    "description": "Optional. The list of IAM users to be bound to the role.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "role": {
                    "description": "Required. The role to bind the users to.",
                    "type": "string"
                  }
                }
              }
            },
            "conditions": {
              "description": "Conditions represent the latest available observations of the IAM policy's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "lastAppliedBindings": {
              "description": "LastAppliedBindings is the list of IAM bindings that were most recently applied by Config Connector.",
              "type": "array",
              "items": {
                "description": "Specifies the members to bind to an IAM role.",
                "type": "object",
                "required": ["role"],
                "properties": {
                  "condition": {
                    "description": "Optional. The condition under which the binding applies.",
                    "type": "object",
                    "required": ["expression", "title"],
                    "properties": {
                      "description": {
                        "type": "string"
                      },
                      "expression": {
                        "type": "string"
                      },
                      "title": {
                        "type": "string"
                      }
                    }
                  },
                  "members": {
                    "description": "Optional. The list of IAM users to be bound to the role.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "role": {
                    "description": "Required. The role to bind the users to.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMPartialPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMPartialPolicyList": {
      "description": "IAMPartialPolicyList is a list of IAMPartialPolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of iampartialpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.iam.v1beta1.IAMPartialPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMPartialPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMPartialPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMPolicy": {
      "description": "IAMPolicy is the Schema for the iampolicies API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "IAMPolicySpec defines the desired state of IAMPolicy",
          "type": "object",
          "required": ["resourceRef"],
          "properties": {
            "auditConfigs": {
              "description": "Optional. The list of IAM audit configs.",
              "type": "array",
              "items": {
                "description": "Specifies the Cloud Audit Logs configuration for the IAM policy.",
                "type": "object",
                "required": ["auditLogConfigs", "service"],
                "properties": {
                  "auditLogConfigs": {
                    "description": "Required. The configuration for logging of each type of permission.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": ["logType"],
                      "properties": {
                        "exemptedMembers": {
                          "description": "Identities that do not cause logging for this type of permission. The format is the same as that for 'members' in IAMPolicy/IAMPolicyMember.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "logType": {
                          "description": "Permission type for which logging is to be configured. Must be one of 'DATA_READ', 'DATA_WRITE', or 'ADMIN_READ'.",
                          "type": "string",
                          "pattern": "^(DATA_READ|DATA_WRITE|ADMIN_READ)$"
                        }
                      }
                    }
                  },
                  "service": {
                    "description": "Required. The service for which to enable Data Access audit logs. The special value 'allServices' covers all services. Note that if there are audit configs covering both 'allServices' and a specific service, then the union of the two audit configs is used for that service: the 'logTypes' specified in each 'auditLogConfig' are enabled, and the 'exemptedMembers' in each 'auditLogConfg' are exempted.",
                    "type": "string"
                  }
                }
              }
            },
            "bindings": {
              "description": "Optional. The list of IAM bindings.",
              "type": "array",
              "items": {
                "description": "Specifies the members to bind to an IAM role.",
                "type": "object",
                "required": ["role"],
                "properties": {
                  "condition": {
                    "description": "Optional. The condition under which the binding applies.",
                    "type": "object",
                    "required": ["expression", "title"],
                    "properties": {
                      "description": {
                        "type": "string"
                      },
                      "expression": {
                        "type": "string"
                      },
                      "title": {
                        "type": "string"
                      }
                    }
                  },
                  "members": {
                    "description": "Optional. The list of IAM users to be bound to the role.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "role": {
                    "description": "Required. The role to bind the users to.",
                    "type": "string",
                    "pattern": "^((projects|organizations)/[^/]+/)?roles/[\\w_\\.]+$"
                  }
                }
              }
            },
            "resourceRef": {
              "description": "Immutable. Required. The GCP resource to set the IAM policy on.",
              "type": "object",
              "required": ["kind"],
              "properties": {
                "apiVersion": {
                  "type": "string"
                },
                "external": {
                  "type": "string"
                },
                "kind": {
                  "type": "string"
                },
                "name": {
                  "type": "string"
                },
                "namespace": {
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "description": "IAMPolicyStatus defines the observed state of IAMPolicy",
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observations of the IAM policy's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMPolicyList": {
      "description": "IAMPolicyList is a list of IAMPolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of iampolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.iam.v1beta1.IAMPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMPolicyMember": {
      "description": "IAMPolicyMember is the Schema for the iampolicies API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMPolicyMember"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "IAMPolicyMemberSpec defines the desired state of IAMPolicyMember",
          "type": "object",
          "required": ["resourceRef", "role"],
          "properties": {
            "condition": {
              "description": "Immutable. Optional. The condition under which the binding applies.",
              "type": "object",
              "required": ["expression", "title"],
              "properties": {
                "description": {
                  "type": "string"
                },
                "expression": {
                  "type": "string"
                },
                "title": {
                  "type": "string"
                }
              }
            },
            "member": {
              "description": "Immutable. The IAM identity to be bound to the role. Exactly one of 'member' or 'memberFrom' must be used.",
              "type": "string"
            },
            "memberFrom": {
              "description": "Immutable. The IAM identity to be bound to the role. Exactly one of 'member' or 'memberFrom' must be used, and only one subfield within 'memberFrom' can be used.",
              "type": "object",
              "properties": {
                "logSinkRef": {
                  "description": "The LoggingLogSink whose writer identity (i.e. its 'status.writerIdentity') is to be bound to the role.",
                  "type": "object",
                  "required": ["name"],
                  "properties": {
                    "name": {
                      "type": "string"
                    },
                    "namespace": {
                      "type": "string"
                    }
                  }
                },
                "serviceAccountRef": {
                  "description": "The IAMServiceAccount to be bound to the role.",
                  "type": "object",
                  "required": ["name"],
                  "properties": {
                    "name": {
                      "type": "string"
                    },
                    "namespace": {
                      "type": "string"
                    }
                  }
                }
              }
            },
            "resourceRef": {
              "description": "Immutable. Required. The GCP resource to set the IAM policy on.",
              "type": "object",
              "required": ["kind"],
              "properties": {
                "apiVersion": {
                  "type": "string"
                },
                "external": {
                  "type": "string"
                },
                "kind": {
                  "type": "string"
                },
                "name": {
                  "type": "string"
                },
                "namespace": {
                  "type": "string"
                }
              }
            },
            "role": {
              "description": "Immutable. Required. The role for which the Member will be bound.",
              "type": "string",
              "pattern": "^((projects|organizations)/[^/]+/)?roles/[\\w_\\.]+$"
            }
          }
        },
        "status": {
          "description": "IAMPolicyMemberStatus defines the observed state of IAMPolicyMember",
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observations of the IAM policy's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMPolicyMember",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMPolicyMemberList": {
      "description": "IAMPolicyMemberList is a list of IAMPolicyMember",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of iampolicymembers. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.iam.v1beta1.IAMPolicyMember"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMPolicyMemberList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMPolicyMemberList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMServiceAccount": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMServiceAccount"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "description": {
              "description": "A text description of the service account. Must be less than or equal to 256 UTF-8 bytes.",
              "type": "string"
            },
            "disabled": {
              "description": "Whether the service account is disabled. Defaults to false.",
              "type": "boolean"
            },
            "displayName": {
              "description": "The display name for the service account. Can be updated without creating a new resource.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The accountId of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "email": {
              "description": "The e-mail address of the service account. This value should be referenced from any google_iam_policy data sources that would grant the service account privileges.",
              "type": "string"
            },
            "name": {
              "description": "The fully-qualified name of the service account.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "uniqueId": {
              "description": "The unique id of the service account.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMServiceAccount",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMServiceAccountKey": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMServiceAccountKey"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["serviceAccountRef"],
          "properties": {
            "keyAlgorithm": {
              "description": "Immutable. The algorithm used to generate the key, used only on create. KEY_ALG_RSA_2048 is the default algorithm. Valid values are: \"KEY_ALG_RSA_1024\", \"KEY_ALG_RSA_2048\".",
              "type": "string"
            },
            "privateKeyType": {
              "description": "Immutable.",
              "type": "string"
            },
            "publicKeyData": {
              "description": "Immutable. A field that allows clients to upload their own public key. If set, use this public key data to create a service account key for given service account. Please note, the expected format for this field is a base64 encoded X509_PEM.",
              "type": "string"
            },
            "publicKeyType": {
              "description": "Immutable.",
              "type": "string"
            },
            "serviceAccountRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The email of an IAMServiceAccount.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "name": {
              "description": "Immutable. The name used for this key pair.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "privateKey": {
              "description": "The private key in JSON format, base64 encoded. This is what you normally get as a file when creating service account keys through the CLI or web console. This is only populated when creating a new key.",
              "type": "string"
            },
            "publicKey": {
              "description": "Immutable. The public key, base64 encoded.",
              "type": "string"
            },
            "validAfter": {
              "description": "The key can be used after this timestamp. A timestamp in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds. Example: \"2014-10-02T15:01:23.045123456Z\".",
              "type": "string"
            },
            "validBefore": {
              "description": "The key can be used before this timestamp. A timestamp in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds. Example: \"2014-10-02T15:01:23.045123456Z\".",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMServiceAccountKey",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMServiceAccountKeyList": {
      "description": "IAMServiceAccountKeyList is a list of IAMServiceAccountKey",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of iamserviceaccountkeys. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.iam.v1beta1.IAMServiceAccountKey"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMServiceAccountKeyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMServiceAccountKeyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMServiceAccountList": {
      "description": "IAMServiceAccountList is a list of IAMServiceAccount",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of iamserviceaccounts. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.iam.v1beta1.IAMServiceAccount"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMServiceAccountList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMServiceAccountList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMWorkloadIdentityPool": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMWorkloadIdentityPool"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location", "projectRef"],
          "properties": {
            "description": {
              "description": "A description of the pool. Cannot exceed 256 characters.",
              "type": "string"
            },
            "disabled": {
              "description": "Whether the pool is disabled. You cannot use a disabled pool to exchange tokens, or use existing tokens to access resources. If the pool is re-enabled, existing tokens grant access again.",
              "type": "boolean"
            },
            "displayName": {
              "description": "A display name for the pool. Cannot exceed 32 characters.",
              "type": "string"
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "state": {
              "description": "Output only. The state of the pool. Possible values: STATE_UNSPECIFIED, ACTIVE, DELETED",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMWorkloadIdentityPool",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMWorkloadIdentityPoolList": {
      "description": "IAMWorkloadIdentityPoolList is a list of IAMWorkloadIdentityPool",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of iamworkloadidentitypools. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.iam.v1beta1.IAMWorkloadIdentityPool"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMWorkloadIdentityPoolList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMWorkloadIdentityPoolList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMWorkloadIdentityPoolProvider": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMWorkloadIdentityPoolProvider"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location", "projectRef", "workloadIdentityPoolRef"],
          "properties": {
            "attributeCondition": {
              "description": "[A Common Expression Language](https://opensource.google/projects/cel) expression, in plain text, to restrict what otherwise valid authentication credentials issued by the provider should not be accepted. The expression must output a boolean representing whether to allow the federation. The following keywords may be referenced in the expressions: * `assertion`: JSON representing the authentication credential issued by the provider. * `google`: The Google attributes mapped from the assertion in the `attribute_mappings`. * `attribute`: The custom attributes mapped from the assertion in the `attribute_mappings`. The maximum length of the attribute condition expression is 4096 characters. If unspecified, all valid authentication credential are accepted. The following example shows how to only allow credentials with a mapped `google.groups` value of `admins`: ``` \"'admins' in google.groups\" ```",
              "type": "string"
            },
            "attributeMapping": {
              "description": "Maps attributes from authentication credentials issued by an external identity provider to Google Cloud attributes, such as `subject` and `segment`. Each key must be a string specifying the Google Cloud IAM attribute to map to. The following keys are supported: * `google.subject`: The principal IAM is authenticating. You can reference this value in IAM bindings. This is also the subject that appears in Cloud Logging logs. Cannot exceed 127 characters. * `google.groups`: Groups the external identity belongs to. You can grant groups access to resources using an IAM `principalSet` binding; access applies to all members of the group. You can also provide custom attributes by specifying `attribute.{custom_attribute}`, where `{custom_attribute}` is the name of the custom attribute to be mapped. You can define a maximum of 50 custom attributes. The maximum length of a mapped attribute key is 100 characters, and the key may only contain the characters [a-z0-9_]. You can reference these attributes in IAM policies to define fine-grained access for a workload to Google Cloud resources. For example: * `google.subject`: `principal://iam.googleapis.com/projects/{project}/locations/{location}/workloadIdentityPools/{pool}/subject/{value}` * `google.groups`: `principalSet://iam.googleapis.com/projects/{project}/locations/{location}/workloadIdentityPools/{pool}/group/{value}` * `attribute.{custom_attribute}`: `principalSet://iam.googleapis.com/projects/{project}/locations/{location}/workloadIdentityPools/{pool}/attribute.{custom_attribute}/{value}` Each value must be a [Common Expression Language] (https://opensource.google/projects/cel) function that maps an identity provider credential to the normalized attribute specified by the corresponding map key. You can use the `assertion` keyword in the expression to access a JSON representation of the authentication credential issued by the provider. The maximum length of an attribute mapping expression is 2048 characters. When evaluated, the total size of all mapped attributes must not exceed 8KB. For AWS providers, if no attribute mapping is defined, the following default mapping applies: ``` { \"google.subject\":\"assertion.arn\", \"attribute.aws_role\": \"assertion.arn.contains('assumed-role')\" \" ? assertion.arn.extract('{account_arn}assumed-role/')\" \" + 'assumed-role/'\" \" + assertion.arn.extract('assumed-role/{role_name}/')\" \" : assertion.arn\", } ``` If any custom attribute mappings are defined, they must include a mapping to the `google.subject` attribute. For OIDC providers, you must supply a custom mapping, which must include the `google.subject` attribute. For example, the following maps the `sub` claim of the incoming credential to the `subject` attribute on a Google token: ``` {\"google.subject\": \"assertion.sub\"} ```",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "aws": {
              "description": "An Amazon Web Services identity provider.",
              "type": "object",
              "required": ["accountId"],
              "properties": {
                "accountId": {
                  "description": "Required. The AWS account ID.",
                  "type": "string"
                },
                "stsUri": {
                  "description": "A list of AWS STS URIs that can be used when exchanging credentials. If not provided, any valid AWS STS URI is allowed. URIs must use the form `https://sts.amazonaws.com` or `https://sts.{region}.amazonaws.com`, where {region} is a valid AWS region. You can specify a maximum of 25 URIs.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "description": {
              "description": "A description for the provider. Cannot exceed 256 characters.",
              "type": "string"
            },
            "disabled": {
              "description": "Whether the provider is disabled. You cannot use a disabled provider to exchange tokens. However, existing tokens still grant access.",
              "type": "boolean"
            },
            "displayName": {
              "description": "A display name for the provider. Cannot exceed 32 characters.",
              "type": "string"
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "oidc": {
              "description": "An OpenId Connect 1.0 identity provider.",
              "type": "object",
              "required": ["issuerUri"],
              "properties": {
                "allowedAudiences": {
                  "description": "Acceptable values for the `aud` field (audience) in the OIDC token. Token exchange requests are rejected if the token audience does not match one of the configured values. Each audience may be at most 256 characters. A maximum of 10 audiences may be configured. If this list is empty, the OIDC token audience must be equal to the full canonical resource name of the WorkloadIdentityPoolProvider, with or without the HTTPS prefix. For example: ``` //iam.googleapis.com/projects//locations//workloadIdentityPools//providers/ https://iam.googleapis.com/projects//locations//workloadIdentityPools//providers/ ```",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "issuerUri": {
                  "description": "Required. The OIDC issuer URL. Must be an HTTPS endpoint.",
                  "type": "string"
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "workloadIdentityPoolRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The workloadIdentityPool for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "state": {
              "description": "Output only. The state of the provider. Possible values: STATE_UNSPECIFIED, ACTIVE, DELETED",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMWorkloadIdentityPoolProvider",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iam.v1beta1.IAMWorkloadIdentityPoolProviderList": {
      "description": "IAMWorkloadIdentityPoolProviderList is a list of IAMWorkloadIdentityPoolProvider",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iam.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of iamworkloadidentitypoolproviders. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.iam.v1beta1.IAMWorkloadIdentityPoolProvider"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAMWorkloadIdentityPoolProviderList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iam.cnrm.cloud.google.com",
          "kind": "IAMWorkloadIdentityPoolProviderList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iap.v1beta1.IAPBrand": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iap.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAPBrand"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "applicationTitle": {
              "description": "Application name displayed on OAuth consent screen.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            },
            "supportEmail": {
              "description": "Support email displayed on the OAuth consent screen.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "orgInternalOnly": {
              "description": "Output only. Whether the brand is only intended for usage inside the G Suite organization only.",
              "type": "boolean"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iap.cnrm.cloud.google.com",
          "kind": "IAPBrand",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iap.v1beta1.IAPBrandList": {
      "description": "IAPBrandList is a list of IAPBrand",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iap.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of iapbrands. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.iap.v1beta1.IAPBrand"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAPBrandList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iap.cnrm.cloud.google.com",
          "kind": "IAPBrandList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iap.v1beta1.IAPIdentityAwareProxyClient": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iap.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAPIdentityAwareProxyClient"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["brandRef"],
          "properties": {
            "brandRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The brand for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "displayName": {
              "description": "Human-friendly name given to the OAuth client.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "secret": {
              "description": "Output only. Client secret of the OAuth client.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iap.cnrm.cloud.google.com",
          "kind": "IAPIdentityAwareProxyClient",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.iap.v1beta1.IAPIdentityAwareProxyClientList": {
      "description": "IAPIdentityAwareProxyClientList is a list of IAPIdentityAwareProxyClient",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["iap.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of iapidentityawareproxyclients. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.iap.v1beta1.IAPIdentityAwareProxyClient"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IAPIdentityAwareProxyClientList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "iap.cnrm.cloud.google.com",
          "kind": "IAPIdentityAwareProxyClientList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.identityplatform.v1beta1.IdentityPlatformOAuthIDPConfig": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["identityplatform.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IdentityPlatformOAuthIDPConfig"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "clientId": {
              "description": "The client id of an OAuth client.",
              "type": "string"
            },
            "clientSecret": {
              "description": "The client secret of the OAuth client, to enable OIDC code flow.",
              "type": "object",
              "properties": {
                "value": {
                  "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                  "type": "string"
                },
                "valueFrom": {
                  "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                  "type": "object",
                  "properties": {
                    "secretKeyRef": {
                      "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                      "type": "object",
                      "required": ["name", "key"],
                      "properties": {
                        "key": {
                          "description": "Key that identifies the value to be extracted.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the Secret to extract a value from.",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "displayName": {
              "description": "The config's display name set by developers.",
              "type": "string"
            },
            "enabled": {
              "description": "True if allows the user to sign in with the provider.",
              "type": "boolean"
            },
            "issuer": {
              "description": "For OIDC Idps, the issuer identifier.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "responseType": {
              "description": "The multiple response type to request for in the OAuth authorization flow. This can possibly be a combination of set bits (e.g.: {id\\_token, token}).",
              "type": "object",
              "properties": {
                "code": {
                  "description": "If true, authorization code is returned from IdP's authorization endpoint.",
                  "type": "boolean"
                },
                "idToken": {
                  "description": "If true, ID token is returned from IdP's authorization endpoint.",
                  "type": "boolean"
                },
                "token": {
                  "description": "If true, access token is returned from IdP's authorization endpoint.",
                  "type": "boolean"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "identityplatform.cnrm.cloud.google.com",
          "kind": "IdentityPlatformOAuthIDPConfig",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.identityplatform.v1beta1.IdentityPlatformOAuthIDPConfigList": {
      "description": "IdentityPlatformOAuthIDPConfigList is a list of IdentityPlatformOAuthIDPConfig",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["identityplatform.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of identityplatformoauthidpconfigs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.identityplatform.v1beta1.IdentityPlatformOAuthIDPConfig"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IdentityPlatformOAuthIDPConfigList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "identityplatform.cnrm.cloud.google.com",
          "kind": "IdentityPlatformOAuthIDPConfigList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.identityplatform.v1beta1.IdentityPlatformTenant": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["identityplatform.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IdentityPlatformTenant"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "allowPasswordSignup": {
              "description": "Whether to allow email/password user authentication.",
              "type": "boolean"
            },
            "disableAuth": {
              "description": "Whether authentication is disabled for the tenant. If true, the users under the disabled tenant are not allowed to sign-in. Admins of the disabled tenant are not able to manage its users.",
              "type": "boolean"
            },
            "displayName": {
              "description": "Display name of the tenant.",
              "type": "string"
            },
            "enableAnonymousUser": {
              "description": "Whether to enable anonymous user authentication.",
              "type": "boolean"
            },
            "enableEmailLinkSignin": {
              "description": "Whether to enable email link user authentication.",
              "type": "boolean"
            },
            "mfaConfig": {
              "description": "The tenant-level configuration of MFA options.",
              "type": "object",
              "properties": {
                "enabledProviders": {
                  "description": "A list of usable second factors for this project.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "state": {
                  "description": "Whether MultiFactor Authentication has been enabled for this project. Possible values: STATE_UNSPECIFIED, DISABLED, ENABLED, MANDATORY",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            },
            "testPhoneNumbers": {
              "description": "A map of <test phone number, fake code> pairs that can be used for MFA. The phone number should be in E.164 format (https://www.itu.int/rec/T-REC-E.164/) and a maximum of 10 pairs can be added (error will be thrown once exceeded).",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "identityplatform.cnrm.cloud.google.com",
          "kind": "IdentityPlatformTenant",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.identityplatform.v1beta1.IdentityPlatformTenantList": {
      "description": "IdentityPlatformTenantList is a list of IdentityPlatformTenant",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["identityplatform.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of identityplatformtenants. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.identityplatform.v1beta1.IdentityPlatformTenant"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IdentityPlatformTenantList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "identityplatform.cnrm.cloud.google.com",
          "kind": "IdentityPlatformTenantList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.identityplatform.v1beta1.IdentityPlatformTenantOAuthIDPConfig": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["identityplatform.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IdentityPlatformTenantOAuthIDPConfig"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["tenantRef"],
          "properties": {
            "clientId": {
              "description": "The client id of an OAuth client.",
              "type": "string"
            },
            "clientSecret": {
              "description": "The client secret of the OAuth client, to enable OIDC code flow.",
              "type": "object",
              "properties": {
                "value": {
                  "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                  "type": "string"
                },
                "valueFrom": {
                  "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                  "type": "object",
                  "properties": {
                    "secretKeyRef": {
                      "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                      "type": "object",
                      "required": ["name", "key"],
                      "properties": {
                        "key": {
                          "description": "Key that identifies the value to be extracted.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the Secret to extract a value from.",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "displayName": {
              "description": "The config's display name set by developers.",
              "type": "string"
            },
            "enabled": {
              "description": "True if allows the user to sign in with the provider.",
              "type": "boolean"
            },
            "issuer": {
              "description": "For OIDC Idps, the issuer identifier.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "responseType": {
              "description": "The multiple response type to request for in the OAuth authorization flow. This can possibly be a combination of set bits (e.g.: {id\\_token, token}).",
              "type": "object",
              "properties": {
                "code": {
                  "description": "If true, authorization code is returned from IdP's authorization endpoint.",
                  "type": "boolean"
                },
                "idToken": {
                  "description": "If true, ID token is returned from IdP's authorization endpoint.",
                  "type": "boolean"
                },
                "token": {
                  "description": "If true, access token is returned from IdP's authorization endpoint.",
                  "type": "boolean"
                }
              }
            },
            "tenantRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The tenant for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "identityplatform.cnrm.cloud.google.com",
          "kind": "IdentityPlatformTenantOAuthIDPConfig",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.identityplatform.v1beta1.IdentityPlatformTenantOAuthIDPConfigList": {
      "description": "IdentityPlatformTenantOAuthIDPConfigList is a list of IdentityPlatformTenantOAuthIDPConfig",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["identityplatform.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of identityplatformtenantoauthidpconfigs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.identityplatform.v1beta1.IdentityPlatformTenantOAuthIDPConfig"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IdentityPlatformTenantOAuthIDPConfigList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "identityplatform.cnrm.cloud.google.com",
          "kind": "IdentityPlatformTenantOAuthIDPConfigList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.kms.v1beta1.KMSCryptoKey": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["kms.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["KMSCryptoKey"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["keyRingRef"],
          "properties": {
            "destroyScheduledDuration": {
              "description": "Immutable. The period of time that versions of this key spend in the DESTROY_SCHEDULED state before transitioning to DESTROYED.\nIf not specified at creation time, the default duration is 24 hours.",
              "type": "string"
            },
            "importOnly": {
              "description": "Immutable. Whether this key may contain imported versions only.",
              "type": "boolean"
            },
            "keyRingRef": {
              "description": "The KMSKeyRing that this key belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a KMSKeyRing.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "purpose": {
              "description": "Immutable. The immutable purpose of this CryptoKey. See the\n[purpose reference](https://cloud.google.com/kms/docs/reference/rest/v1/projects.locations.keyRings.cryptoKeys#CryptoKeyPurpose)\nfor possible inputs. Default value: \"ENCRYPT_DECRYPT\" Possible values: [\"ENCRYPT_DECRYPT\", \"ASYMMETRIC_SIGN\", \"ASYMMETRIC_DECRYPT\"].",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "rotationPeriod": {
              "description": "Every time this period passes, generate a new CryptoKeyVersion and set it as the primary.\nThe first rotation will take place after the specified period. The rotation period has\nthe format of a decimal number with up to 9 fractional digits, followed by the\nletter 's' (seconds). It must be greater than a day (ie, 86400).",
              "type": "string"
            },
            "skipInitialVersionCreation": {
              "description": "Immutable. If set to true, the request will create a CryptoKey without any CryptoKeyVersions. \nYou must use the 'google_kms_key_ring_import_job' resource to import the CryptoKeyVersion.",
              "type": "boolean"
            },
            "versionTemplate": {
              "description": "A template describing settings for new crypto key versions.",
              "type": "object",
              "required": ["algorithm"],
              "properties": {
                "algorithm": {
                  "description": "The algorithm to use when creating a version based on this template.\nSee the [algorithm reference](https://cloud.google.com/kms/docs/reference/rest/v1/CryptoKeyVersionAlgorithm) for possible inputs.",
                  "type": "string"
                },
                "protectionLevel": {
                  "description": "Immutable. The protection level to use when creating a version based on this template. Possible values include \"SOFTWARE\", \"HSM\", \"EXTERNAL\". Defaults to \"SOFTWARE\".",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "description": "The self link of the created KeyRing in the format projects/{project}/locations/{location}/keyRings/{name}.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "kms.cnrm.cloud.google.com",
          "kind": "KMSCryptoKey",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.kms.v1beta1.KMSCryptoKeyList": {
      "description": "KMSCryptoKeyList is a list of KMSCryptoKey",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["kms.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of kmscryptokeys. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.kms.v1beta1.KMSCryptoKey"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["KMSCryptoKeyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "kms.cnrm.cloud.google.com",
          "kind": "KMSCryptoKeyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.kms.v1beta1.KMSKeyRing": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["kms.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["KMSKeyRing"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location"],
          "properties": {
            "location": {
              "description": "Immutable. The location for the KeyRing.\nA full list of valid locations can be found by running 'gcloud kms locations list'.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "description": "The self link of the created KeyRing in the format projects/{project}/locations/{location}/keyRings/{name}.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "kms.cnrm.cloud.google.com",
          "kind": "KMSKeyRing",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.kms.v1beta1.KMSKeyRingList": {
      "description": "KMSKeyRingList is a list of KMSKeyRing",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["kms.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of kmskeyrings. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.kms.v1beta1.KMSKeyRing"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["KMSKeyRingList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "kms.cnrm.cloud.google.com",
          "kind": "KMSKeyRingList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.logging.v1beta1.LoggingLogExclusion": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["logging.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["LoggingLogExclusion"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["filter"],
          "properties": {
            "billingAccountRef": {
              "description": "The BillingAccount that this resource belongs to. Only one of [projectRef, folderRef, organizationRef, billingAccountRef] may be specified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The ID of a BillingAccount in format billingAccounts/{billingaccount_id}.",
                  "type": "string"
                },
                "name": {
                  "description": "[WARNING] BillingAccount not yet supported in Config Connector, use 'external' field to reference existing resources.\nName of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "description": {
              "description": "Optional. A description of this exclusion.",
              "type": "string"
            },
            "disabled": {
              "description": "Optional. If set to True, then this exclusion is disabled and it does not exclude any log entries. You can update an exclusion to change the value of this field.",
              "type": "boolean"
            },
            "filter": {
              "description": "Required. An (https://cloud.google.com/logging/docs/view/advanced-queries#sample), you can exclude less than 100% of the matching log entries. For example, the following query matches 99% of low-severity log entries from Google Cloud Storage buckets: `\"resource.type=gcs_bucket severity",
              "type": "string"
            },
            "folderRef": {
              "description": "The Folder that this resource belongs to. Only one of [projectRef, folderRef, organizationRef, billingAccountRef] may be specified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The ID of a Folder in format folders/{folder_id}.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "organizationRef": {
              "description": "The Organization that this resource belongs to. Only one of [projectRef, folderRef, organizationRef, billingAccountRef] may be specified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The ID of an Organization in format organizations/{organization_id}.",
                  "type": "string"
                },
                "name": {
                  "description": "[WARNING] Organization not yet supported in Config Connector, use 'external' field to reference existing resources.\nName of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to. Only one of [projectRef, folderRef, organizationRef, billingAccountRef] may be specified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The ID of a Project in format projects/{project_id}.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The creation timestamp of the exclusion. This field may not be present for older exclusions.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Output only. The last update timestamp of the exclusion. This field may not be present for older exclusions.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "logging.cnrm.cloud.google.com",
          "kind": "LoggingLogExclusion",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.logging.v1beta1.LoggingLogExclusionList": {
      "description": "LoggingLogExclusionList is a list of LoggingLogExclusion",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["logging.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of logginglogexclusions. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.logging.v1beta1.LoggingLogExclusion"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["LoggingLogExclusionList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "logging.cnrm.cloud.google.com",
          "kind": "LoggingLogExclusionList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.logging.v1beta1.LoggingLogMetric": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["logging.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["LoggingLogMetric"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["filter", "projectRef"],
          "properties": {
            "bucketOptions": {
              "description": "Optional. The `bucket_options` are required when the logs-based metric is using a DISTRIBUTION value type and it describes the bucket boundaries used to create a histogram of the extracted values.",
              "type": "object",
              "properties": {
                "explicitBuckets": {
                  "description": "The explicit buckets.",
                  "type": "object",
                  "properties": {
                    "bounds": {
                      "description": "The values must be monotonically increasing.",
                      "type": "array",
                      "items": {
                        "type": "number",
                        "format": "double"
                      }
                    }
                  }
                },
                "exponentialBuckets": {
                  "description": "The exponential buckets.",
                  "type": "object",
                  "properties": {
                    "growthFactor": {
                      "description": "Must be greater than 1.",
                      "type": "number",
                      "format": "double"
                    },
                    "numFiniteBuckets": {
                      "description": "Must be greater than 0.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "scale": {
                      "description": "Must be greater than 0.",
                      "type": "number",
                      "format": "double"
                    }
                  }
                },
                "linearBuckets": {
                  "description": "The linear bucket.",
                  "type": "object",
                  "properties": {
                    "numFiniteBuckets": {
                      "description": "Must be greater than 0.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "offset": {
                      "description": "Lower bound of the first bucket.",
                      "type": "number",
                      "format": "double"
                    },
                    "width": {
                      "description": "Must be greater than 0.",
                      "type": "number",
                      "format": "double"
                    }
                  }
                }
              }
            },
            "description": {
              "description": "Optional. A description of this metric, which is used in documentation. The maximum length of the description is 8000 characters.",
              "type": "string"
            },
            "disabled": {
              "description": "Optional. If set to True, then this metric is disabled and it does not generate any points.",
              "type": "boolean"
            },
            "filter": {
              "description": "Required. An [advanced logs filter](https://cloud.google.com/logging/docs/view/advanced_filters) which is used to match log entries. Example: \"resource.type=gae_app AND severity>=ERROR\" The maximum length of the filter is 20000 characters.",
              "type": "string"
            },
            "labelExtractors": {
              "description": "Optional. A map from a label key string to an extractor expression which is used to extract data from a log entry field and assign as the label value. Each label key specified in the LabelDescriptor must have an associated extractor expression in this map. The syntax of the extractor expression is the same as for the `value_extractor` field. The extracted value is converted to the type defined in the label descriptor. If the either the extraction or the type conversion fails, the label will have a default value. The default value for a string label is an empty string, for an integer label its 0, and for a boolean label its `false`. Note that there are upper bounds on the maximum number of labels and the number of active time series that are allowed in a project.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "metricDescriptor": {
              "description": "Optional. The metric descriptor associated with the logs-based metric. If unspecified, it uses a default metric descriptor with a DELTA metric kind, INT64 value type, with no labels and a unit of \"1\". Such a metric counts the number of log entries matching the `filter` expression. The `name`, `type`, and `description` fields in the `metric_descriptor` are output only, and is constructed using the `name` and `description` field in the LogMetric. To create a logs-based metric that records a distribution of log values, a DELTA metric kind with a DISTRIBUTION value type must be used along with a `value_extractor` expression in the LogMetric. Each label in the metric descriptor must have a matching label name as the key and an extractor expression as the value in the `label_extractors` map. The `metric_kind` and `value_type` fields in the `metric_descriptor` cannot be updated once initially configured. New labels can be added in the `metric_descriptor`, but existing labels cannot be modified except for their description.",
              "type": "object",
              "properties": {
                "displayName": {
                  "description": "A concise name for the metric, which can be displayed in user interfaces. Use sentence case without an ending period, for example \"Request count\". This field is optional but it is recommended to be set for any metrics associated with user-visible concepts, such as Quota.",
                  "type": "string"
                },
                "labels": {
                  "description": "The set of labels that can be used to describe a specific instance of this metric type. For example, the `appengine.googleapis.com/http/server/response_latencies` metric type has a label for the HTTP response code, `response_code`, so you can look at latencies for successful responses or just for responses that failed.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "description": {
                        "description": "A human-readable description for the label.",
                        "type": "string"
                      },
                      "key": {
                        "description": "The label key.",
                        "type": "string"
                      },
                      "valueType": {
                        "description": "The type of data that can be assigned to the label. Possible values: STRING, BOOL, INT64, DOUBLE, DISTRIBUTION, MONEY",
                        "type": "string"
                      }
                    }
                  }
                },
                "launchStage": {
                  "description": "Optional. The launch stage of the metric definition. Possible values: UNIMPLEMENTED, PRELAUNCH, EARLY_ACCESS, ALPHA, BETA, GA, DEPRECATED",
                  "type": "string"
                },
                "metadata": {
                  "description": "Optional. Metadata which can be used to guide usage of the metric.",
                  "type": "object",
                  "properties": {
                    "ingestDelay": {
                      "description": "The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.",
                      "type": "string"
                    },
                    "samplePeriod": {
                      "description": "The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.",
                      "type": "string"
                    }
                  }
                },
                "metricKind": {
                  "description": "Whether the metric records instantaneous values, changes to a value, etc. Some combinations of `metric_kind` and `value_type` might not be supported. Possible values: GAUGE, DELTA, CUMULATIVE",
                  "type": "string"
                },
                "unit": {
                  "description": "The units in which the metric value is reported. It is only applicable if the `value_type` is `INT64`, `DOUBLE`, or `DISTRIBUTION`. The `unit` defines the representation of the stored metric values. Different systems might scale the values to be more easily displayed (so a value of `0.02kBy` _might_ be displayed as `20By`, and a value of `3523kBy` _might_ be displayed as `3.5MBy`). However, if the `unit` is `kBy`, then the value of the metric is always in thousands of bytes, no matter how it might be displayed. If you want a custom metric to record the exact number of CPU-seconds used by a job, you can create an `INT64 CUMULATIVE` metric whose `unit` is `s{CPU}` (or equivalently `1s{CPU}` or just `s`). If the job uses 12,005 CPU-seconds, then the value is written as `12005`. Alternatively, if you want a custom metric to record data in a more granular way, you can create a `DOUBLE CUMULATIVE` metric whose `unit` is `ks{CPU}`, and then write the value `12.005` (which is `12005/1000`), or use `Kis{CPU}` and write `11.723` (which is `12005/1024`). The supported units are a subset of [The Unified Code for Units of Measure](https://unitsofmeasure.org/ucum.html) standard: **Basic units (UNIT)** * `bit` bit * `By` byte * `s` second * `min` minute * `h` hour * `d` day * `1` dimensionless **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `E` exa (10^18) * `Z` zetta (10^21) * `Y` yotta (10^24) * `m` milli (10^-3) * `u` micro (10^-6) * `n` nano (10^-9) * `p` pico (10^-12) * `f` femto (10^-15) * `a` atto (10^-18) * `z` zepto (10^-21) * `y` yocto (10^-24) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For examples, `kBy/{email}` or `MiBy/10ms` (although you should almost never have `/s` in a metric `unit`; rates should always be computed at query time from the underlying cumulative or delta value). * `.` multiplication or composition (as an infix operator). For examples, `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: Expression = Component: { \".\" Component } { \"/\" Component } ; Component = ( [ PREFIX ] UNIT | \"%\" ) [ Annotation ] | Annotation | \"1\" ; Annotation = \"{\" NAME \"}\" ; Notes: * `Annotation` is just a comment if it follows a `UNIT`. If the annotation is used alone, then the unit is equivalent to `1`. For examples, `{request}/s == 1/s`, `By{transmitted}/s == By/s`. * `NAME` is a sequence of non-blank printable ASCII characters not containing `{` or `}`. * `1` represents a unitary [dimensionless unit](https://en.wikipedia.org/wiki/Dimensionless_quantity) of 1, such as in `1/s`. It is typically used when none of the basic units are appropriate. For example, \"new users per day\" can be represented as `1/d` or `{new-users}/d` (and a metric value `5` would mean \"5 new users). Alternatively, \"thousands of page views per day\" would be represented as `1000/d` or `k1/d` or `k{page_views}/d` (and a metric value of `5.3` would mean \"5300 page views per day\"). * `%` represents dimensionless value of 1/100, and annotates values giving a percentage (so the metric values are typically in the range of 0..100, and a metric value `3` means \"3 percent\"). * `10^2.%` indicates a metric contains a ratio, typically in the range 0..1, that will be multiplied by 100 and displayed as a percentage (so a metric value `0.03` means \"3 percent\").",
                  "type": "string"
                },
                "valueType": {
                  "description": "Whether the measurement is an integer, a floating-point number, etc. Some combinations of `metric_kind` and `value_type` might not be supported. Possible values: STRING, BOOL, INT64, DOUBLE, DISTRIBUTION, MONEY",
                  "type": "string"
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The resource name of the project in which to create the metric.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "valueExtractor": {
              "description": "Optional. A `value_extractor` is required when using a distribution logs-based metric to extract the values to record from a log entry. Two functions are supported for value extraction: `EXTRACT(field)` or `REGEXP_EXTRACT(field, regex)`. The argument are: 1. field: The name of the log entry field from which the value is to be extracted. 2. regex: A regular expression using the Google RE2 syntax (https://github.com/google/re2/wiki/Syntax) with a single capture group to extract data from the specified log entry field. The value of the field is converted to a string before applying the regex. It is an error to specify a regex that does not include exactly one capture group. The result of the extraction must be convertible to a double type, as the distribution always records double values. If either the extraction or the conversion to double fails, then those values are not recorded in the distribution. Example: `REGEXP_EXTRACT(jsonPayload.request, \".*quantity=(d+).*\")`",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The creation timestamp of the metric. This field may not be present for older metrics.",
              "type": "string",
              "format": "date-time"
            },
            "metricDescriptor": {
              "type": "object",
              "properties": {
                "description": {
                  "description": "A detailed description of the metric, which can be used in documentation.",
                  "type": "string"
                },
                "monitoredResourceTypes": {
                  "description": "Read-only. If present, then a time series, which is identified partially by a metric type and a MonitoredResourceDescriptor, that is associated with this metric type can only be associated with one of the monitored resource types listed here.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "name": {
                  "description": "The resource name of the metric descriptor.",
                  "type": "string"
                },
                "type": {
                  "description": "The metric type, including its DNS name prefix. The type is not URL-encoded. All user-defined metric types have the DNS name `custom.googleapis.com` or `external.googleapis.com`. Metric types should use a natural hierarchical grouping. For example: \"custom.googleapis.com/invoice/paid/amount\" \"external.googleapis.com/prometheus/up\" \"appengine.googleapis.com/http/server/response_latencies\"",
                  "type": "string"
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Output only. The last update timestamp of the metric. This field may not be present for older metrics.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "logging.cnrm.cloud.google.com",
          "kind": "LoggingLogMetric",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.logging.v1beta1.LoggingLogMetricList": {
      "description": "LoggingLogMetricList is a list of LoggingLogMetric",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["logging.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of logginglogmetrics. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.logging.v1beta1.LoggingLogMetric"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["LoggingLogMetricList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "logging.cnrm.cloud.google.com",
          "kind": "LoggingLogMetricList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.logging.v1beta1.LoggingLogSink": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["logging.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["LoggingLogSink"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["destination"],
          "properties": {
            "bigqueryOptions": {
              "description": "Options that affect sinks exporting data to BigQuery.",
              "type": "object",
              "required": ["usePartitionedTables"],
              "properties": {
                "usePartitionedTables": {
                  "description": "Whether to use BigQuery's partition tables. By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned tables the date suffix is no longer present and special query syntax has to be used instead. In both cases, tables are sharded based on UTC timezone.",
                  "type": "boolean"
                }
              }
            },
            "description": {
              "description": "A description of this sink. The maximum length of the description is 8000 characters.",
              "type": "string"
            },
            "destination": {
              "type": "object",
              "properties": {
                "bigQueryDatasetRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "A string of the format \"bigquery.googleapis.com/projects/{{project}}/datasets/{{value}}\", where {{value}} is the name of a BigQueryDataset.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "pubSubTopicRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "A string of the format \"pubsub.googleapis.com/projects/{{project}}/topics/{{value}}\", where {{value}} is the name of a PubSubTopic.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "storageBucketRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "A string of the format \"storage.googleapis.com/{{value}}\", where {{value}} is the name of a StorageBucket.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "disabled": {
              "description": "If set to True, then this sink is disabled and it does not export any log entries.",
              "type": "boolean"
            },
            "exclusions": {
              "description": "Log entries that match any of the exclusion filters will not be exported. If a log entry is matched by both filter and one of exclusion_filters it will not be exported.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["filter", "name"],
                "properties": {
                  "description": {
                    "description": "A description of this exclusion.",
                    "type": "string"
                  },
                  "disabled": {
                    "description": "If set to True, then this exclusion is disabled and it does not exclude any log entries.",
                    "type": "boolean"
                  },
                  "filter": {
                    "description": "An advanced logs filter that matches the log entries to be excluded. By using the sample function, you can exclude less than 100% of the matching log entries.",
                    "type": "string"
                  },
                  "name": {
                    "description": "A client-assigned identifier, such as \"load-balancer-exclusion\". Identifiers are limited to 100 characters and can include only letters, digits, underscores, hyphens, and periods. First character has to be alphanumeric.",
                    "type": "string"
                  }
                }
              }
            },
            "filter": {
              "description": "The filter to apply when exporting logs. Only log entries that match the filter are exported.",
              "type": "string"
            },
            "folderRef": {
              "description": "The folder in which to create the sink. Only one of projectRef,\nfolderRef, or organizationRef may be specified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The folderId of a Folder.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "includeChildren": {
              "description": "Immutable. Whether or not to include children organizations in the sink export. If true, logs associated with child projects are also exported; otherwise only logs relating to the provided organization are included.",
              "type": "boolean"
            },
            "organizationRef": {
              "description": "The organization in which to create the sink. Only one of projectRef,\nfolderRef, or organizationRef may be specified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of an Organization.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "projectRef": {
              "description": "The project in which to create the sink. Only one of projectRef,\nfolderRef, or organizationRef may be specified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a Project.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "uniqueWriterIdentity": {
              "description": "Immutable. Whether or not to create a unique identity associated with this sink. If false (the default), then the writer_identity used is serviceAccount:cloud-logs@system.gserviceaccount.com. If true, then a unique service account is created and used for this sink. If you wish to publish logs across projects, you must set unique_writer_identity to true.",
              "type": "boolean"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "writerIdentity": {
              "description": "The identity associated with this sink. This identity must be granted write access to the configured destination.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "logging.cnrm.cloud.google.com",
          "kind": "LoggingLogSink",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.logging.v1beta1.LoggingLogSinkList": {
      "description": "LoggingLogSinkList is a list of LoggingLogSink",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["logging.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of logginglogsinks. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.logging.v1beta1.LoggingLogSink"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["LoggingLogSinkList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "logging.cnrm.cloud.google.com",
          "kind": "LoggingLogSinkList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.memcache.v1beta1.MemcacheInstance": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["memcache.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MemcacheInstance"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["nodeConfig", "nodeCount", "region"],
          "properties": {
            "displayName": {
              "description": "A user-visible name for the instance.",
              "type": "string"
            },
            "memcacheParameters": {
              "description": "Immutable. User-specified parameters for this memcache instance.",
              "type": "object",
              "properties": {
                "id": {
                  "description": "This is a unique ID associated with this set of parameters.",
                  "type": "string"
                },
                "params": {
                  "description": "User-defined set of parameters to use in the memcache process.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            "memcacheVersion": {
              "description": "The major version of Memcached software. If not provided, latest supported version will be used.\nCurrently the latest supported major version is MEMCACHE_1_5. The minor version will be automatically\ndetermined by our system based on the latest supported minor version. Default value: \"MEMCACHE_1_5\" Possible values: [\"MEMCACHE_1_5\"].",
              "type": "string"
            },
            "networkRef": {
              "description": "The full name of the network to connect the instance to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "A string of the format \"projects/{{project}}/global/networks/{{value}}\", where {{value}} is the name of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "nodeConfig": {
              "description": "Immutable. Configuration for memcache nodes.",
              "type": "object",
              "required": ["cpuCount", "memorySizeMb"],
              "properties": {
                "cpuCount": {
                  "description": "Number of CPUs per node.",
                  "type": "integer"
                },
                "memorySizeMb": {
                  "description": "Memory size in Mebibytes for each memcache node.",
                  "type": "integer"
                }
              }
            },
            "nodeCount": {
              "description": "Number of nodes in the memcache instance.",
              "type": "integer"
            },
            "region": {
              "description": "Immutable. The region of the Memcache instance. If it is not provided, the provider region is used.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "zones": {
              "description": "Immutable. Zones where memcache nodes should be provisioned.  If not\nprovided, all zones will be used.",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Creation timestamp in RFC3339 text format.",
              "type": "string"
            },
            "discoveryEndpoint": {
              "description": "Endpoint for Discovery API.",
              "type": "string"
            },
            "memcacheFullVersion": {
              "description": "The full version of memcached server running on this instance.",
              "type": "string"
            },
            "memcacheNodes": {
              "description": "Additional information about the instance state, if available.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "host": {
                    "description": "Hostname or IP address of the Memcached node used by the clients to connect to the Memcached server on this node.",
                    "type": "string"
                  },
                  "nodeId": {
                    "description": "Identifier of the Memcached node. The node id does not include project or location like the Memcached instance name.",
                    "type": "string"
                  },
                  "port": {
                    "description": "The port number of the Memcached server on this node.",
                    "type": "integer"
                  },
                  "state": {
                    "description": "Current state of the Memcached node.",
                    "type": "string"
                  },
                  "zone": {
                    "description": "Location (GCP Zone) for the Memcached node.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "memcache.cnrm.cloud.google.com",
          "kind": "MemcacheInstance",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.memcache.v1beta1.MemcacheInstanceList": {
      "description": "MemcacheInstanceList is a list of MemcacheInstance",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["memcache.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of memcacheinstances. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.memcache.v1beta1.MemcacheInstance"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MemcacheInstanceList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "memcache.cnrm.cloud.google.com",
          "kind": "MemcacheInstanceList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.monitoring.v1beta1.MonitoringAlertPolicy": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["monitoring.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MonitoringAlertPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["combiner", "conditions", "displayName"],
          "properties": {
            "combiner": {
              "description": "How to combine the results of multiple conditions to\ndetermine if an incident should be opened. Possible values: [\"AND\", \"OR\", \"AND_WITH_MATCHING_RESOURCE\"].",
              "type": "string"
            },
            "conditions": {
              "description": "A list of conditions for the policy. The conditions are combined by\nAND or OR according to the combiner field. If the combined conditions\nevaluate to true, then an incident is created. A policy can have from\none to six conditions.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["displayName"],
                "properties": {
                  "conditionAbsent": {
                    "description": "A condition that checks that a time series\ncontinues to receive new data points.",
                    "type": "object",
                    "required": ["duration"],
                    "properties": {
                      "aggregations": {
                        "description": "Specifies the alignment of data points in\nindividual time series as well as how to\ncombine the retrieved time series together\n(such as when aggregating multiple streams\non each resource to a single stream for each\nresource or when aggregating streams across\nall members of a group of resources).\nMultiple aggregations are applied in the\norder specified.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "alignmentPeriod": {
                              "description": "The alignment period for per-time\nseries alignment. If present,\nalignmentPeriod must be at least\n60 seconds. After per-time series\nalignment, each time series will\ncontain data points only on the\nperiod boundaries. If\nperSeriesAligner is not specified\nor equals ALIGN_NONE, then this\nfield is ignored. If\nperSeriesAligner is specified and\ndoes not equal ALIGN_NONE, then\nthis field must be defined;\notherwise an error is returned.",
                              "type": "string"
                            },
                            "crossSeriesReducer": {
                              "description": "The approach to be used to combine\ntime series. Not all reducer\nfunctions may be applied to all\ntime series, depending on the\nmetric type and the value type of\nthe original time series.\nReduction may change the metric\ntype of value type of the time\nseries.Time series data must be\naligned in order to perform cross-\ntime series reduction. If\ncrossSeriesReducer is specified,\nthen perSeriesAligner must be\nspecified and not equal ALIGN_NONE\nand alignmentPeriod must be\nspecified; otherwise, an error is\nreturned. Possible values: [\"REDUCE_NONE\", \"REDUCE_MEAN\", \"REDUCE_MIN\", \"REDUCE_MAX\", \"REDUCE_SUM\", \"REDUCE_STDDEV\", \"REDUCE_COUNT\", \"REDUCE_COUNT_TRUE\", \"REDUCE_COUNT_FALSE\", \"REDUCE_FRACTION_TRUE\", \"REDUCE_PERCENTILE_99\", \"REDUCE_PERCENTILE_95\", \"REDUCE_PERCENTILE_50\", \"REDUCE_PERCENTILE_05\"].",
                              "type": "string"
                            },
                            "groupByFields": {
                              "description": "The set of fields to preserve when\ncrossSeriesReducer is specified.\nThe groupByFields determine how\nthe time series are partitioned\ninto subsets prior to applying the\naggregation function. Each subset\ncontains time series that have the\nsame value for each of the\ngrouping fields. Each individual\ntime series is a member of exactly\none subset. The crossSeriesReducer\nis applied to each subset of time\nseries. It is not possible to\nreduce across different resource\ntypes, so this field implicitly\ncontains resource.type. Fields not\nspecified in groupByFields are\naggregated away. If groupByFields\nis not specified and all the time\nseries have the same resource\ntype, then the time series are\naggregated into a single output\ntime series. If crossSeriesReducer\nis not defined, this field is\nignored.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "perSeriesAligner": {
                              "description": "The approach to be used to align\nindividual time series. Not all\nalignment functions may be applied\nto all time series, depending on\nthe metric type and value type of\nthe original time series.\nAlignment may change the metric\ntype or the value type of the time\nseries.Time series data must be\naligned in order to perform cross-\ntime series reduction. If\ncrossSeriesReducer is specified,\nthen perSeriesAligner must be\nspecified and not equal ALIGN_NONE\nand alignmentPeriod must be\nspecified; otherwise, an error is\nreturned. Possible values: [\"ALIGN_NONE\", \"ALIGN_DELTA\", \"ALIGN_RATE\", \"ALIGN_INTERPOLATE\", \"ALIGN_NEXT_OLDER\", \"ALIGN_MIN\", \"ALIGN_MAX\", \"ALIGN_MEAN\", \"ALIGN_COUNT\", \"ALIGN_SUM\", \"ALIGN_STDDEV\", \"ALIGN_COUNT_TRUE\", \"ALIGN_COUNT_FALSE\", \"ALIGN_FRACTION_TRUE\", \"ALIGN_PERCENTILE_99\", \"ALIGN_PERCENTILE_95\", \"ALIGN_PERCENTILE_50\", \"ALIGN_PERCENTILE_05\", \"ALIGN_PERCENT_CHANGE\"].",
                              "type": "string"
                            }
                          }
                        }
                      },
                      "duration": {
                        "description": "The amount of time that a time series must\nfail to report new data to be considered\nfailing. Currently, only values that are a\nmultiple of a minute--e.g. 60s, 120s, or 300s\n--are supported.",
                        "type": "string"
                      },
                      "filter": {
                        "description": "A filter that identifies which time series\nshould be compared with the threshold.The\nfilter is similar to the one that is\nspecified in the\nMetricService.ListTimeSeries request (that\ncall is useful to verify the time series\nthat will be retrieved / processed) and must\nspecify the metric type and optionally may\ncontain restrictions on resource type,\nresource labels, and metric labels. This\nfield may not exceed 2048 Unicode characters\nin length.",
                        "type": "string"
                      },
                      "trigger": {
                        "description": "The number/percent of time series for which\nthe comparison must hold in order for the\ncondition to trigger. If unspecified, then\nthe condition will trigger if the comparison\nis true for any of the time series that have\nbeen identified by filter and aggregations.",
                        "type": "object",
                        "properties": {
                          "count": {
                            "description": "The absolute number of time series\nthat must fail the predicate for the\ncondition to be triggered.",
                            "type": "integer"
                          },
                          "percent": {
                            "description": "The percentage of time series that\nmust fail the predicate for the\ncondition to be triggered.",
                            "type": "number"
                          }
                        }
                      }
                    }
                  },
                  "conditionMonitoringQueryLanguage": {
                    "description": "A Monitoring Query Language query that outputs a boolean stream.",
                    "type": "object",
                    "required": ["duration", "query"],
                    "properties": {
                      "duration": {
                        "description": "The amount of time that a time series must\nviolate the threshold to be considered\nfailing. Currently, only values that are a\nmultiple of a minute--e.g., 0, 60, 120, or\n300 seconds--are supported. If an invalid\nvalue is given, an error will be returned.\nWhen choosing a duration, it is useful to\nkeep in mind the frequency of the underlying\ntime series data (which may also be affected\nby any alignments specified in the\naggregations field); a good duration is long\nenough so that a single outlier does not\ngenerate spurious alerts, but short enough\nthat unhealthy states are detected and\nalerted on quickly.",
                        "type": "string"
                      },
                      "query": {
                        "description": "Monitoring Query Language query that outputs a boolean stream.",
                        "type": "string"
                      },
                      "trigger": {
                        "description": "The number/percent of time series for which\nthe comparison must hold in order for the\ncondition to trigger. If unspecified, then\nthe condition will trigger if the comparison\nis true for any of the time series that have\nbeen identified by filter and aggregations,\nor by the ratio, if denominator_filter and\ndenominator_aggregations are specified.",
                        "type": "object",
                        "properties": {
                          "count": {
                            "description": "The absolute number of time series\nthat must fail the predicate for the\ncondition to be triggered.",
                            "type": "integer"
                          },
                          "percent": {
                            "description": "The percentage of time series that\nmust fail the predicate for the\ncondition to be triggered.",
                            "type": "number"
                          }
                        }
                      }
                    }
                  },
                  "conditionThreshold": {
                    "description": "A condition that compares a time series against a\nthreshold.",
                    "type": "object",
                    "required": ["comparison", "duration"],
                    "properties": {
                      "aggregations": {
                        "description": "Specifies the alignment of data points in\nindividual time series as well as how to\ncombine the retrieved time series together\n(such as when aggregating multiple streams\non each resource to a single stream for each\nresource or when aggregating streams across\nall members of a group of resources).\nMultiple aggregations are applied in the\norder specified.This field is similar to the\none in the MetricService.ListTimeSeries\nrequest. It is advisable to use the\nListTimeSeries method when debugging this\nfield.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "alignmentPeriod": {
                              "description": "The alignment period for per-time\nseries alignment. If present,\nalignmentPeriod must be at least\n60 seconds. After per-time series\nalignment, each time series will\ncontain data points only on the\nperiod boundaries. If\nperSeriesAligner is not specified\nor equals ALIGN_NONE, then this\nfield is ignored. If\nperSeriesAligner is specified and\ndoes not equal ALIGN_NONE, then\nthis field must be defined;\notherwise an error is returned.",
                              "type": "string"
                            },
                            "crossSeriesReducer": {
                              "description": "The approach to be used to combine\ntime series. Not all reducer\nfunctions may be applied to all\ntime series, depending on the\nmetric type and the value type of\nthe original time series.\nReduction may change the metric\ntype of value type of the time\nseries.Time series data must be\naligned in order to perform cross-\ntime series reduction. If\ncrossSeriesReducer is specified,\nthen perSeriesAligner must be\nspecified and not equal ALIGN_NONE\nand alignmentPeriod must be\nspecified; otherwise, an error is\nreturned. Possible values: [\"REDUCE_NONE\", \"REDUCE_MEAN\", \"REDUCE_MIN\", \"REDUCE_MAX\", \"REDUCE_SUM\", \"REDUCE_STDDEV\", \"REDUCE_COUNT\", \"REDUCE_COUNT_TRUE\", \"REDUCE_COUNT_FALSE\", \"REDUCE_FRACTION_TRUE\", \"REDUCE_PERCENTILE_99\", \"REDUCE_PERCENTILE_95\", \"REDUCE_PERCENTILE_50\", \"REDUCE_PERCENTILE_05\"].",
                              "type": "string"
                            },
                            "groupByFields": {
                              "description": "The set of fields to preserve when\ncrossSeriesReducer is specified.\nThe groupByFields determine how\nthe time series are partitioned\ninto subsets prior to applying the\naggregation function. Each subset\ncontains time series that have the\nsame value for each of the\ngrouping fields. Each individual\ntime series is a member of exactly\none subset. The crossSeriesReducer\nis applied to each subset of time\nseries. It is not possible to\nreduce across different resource\ntypes, so this field implicitly\ncontains resource.type. Fields not\nspecified in groupByFields are\naggregated away. If groupByFields\nis not specified and all the time\nseries have the same resource\ntype, then the time series are\naggregated into a single output\ntime series. If crossSeriesReducer\nis not defined, this field is\nignored.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "perSeriesAligner": {
                              "description": "The approach to be used to align\nindividual time series. Not all\nalignment functions may be applied\nto all time series, depending on\nthe metric type and value type of\nthe original time series.\nAlignment may change the metric\ntype or the value type of the time\nseries.Time series data must be\naligned in order to perform cross-\ntime series reduction. If\ncrossSeriesReducer is specified,\nthen perSeriesAligner must be\nspecified and not equal ALIGN_NONE\nand alignmentPeriod must be\nspecified; otherwise, an error is\nreturned. Possible values: [\"ALIGN_NONE\", \"ALIGN_DELTA\", \"ALIGN_RATE\", \"ALIGN_INTERPOLATE\", \"ALIGN_NEXT_OLDER\", \"ALIGN_MIN\", \"ALIGN_MAX\", \"ALIGN_MEAN\", \"ALIGN_COUNT\", \"ALIGN_SUM\", \"ALIGN_STDDEV\", \"ALIGN_COUNT_TRUE\", \"ALIGN_COUNT_FALSE\", \"ALIGN_FRACTION_TRUE\", \"ALIGN_PERCENTILE_99\", \"ALIGN_PERCENTILE_95\", \"ALIGN_PERCENTILE_50\", \"ALIGN_PERCENTILE_05\", \"ALIGN_PERCENT_CHANGE\"].",
                              "type": "string"
                            }
                          }
                        }
                      },
                      "comparison": {
                        "description": "The comparison to apply between the time\nseries (indicated by filter and aggregation)\nand the threshold (indicated by\nthreshold_value). The comparison is applied\non each time series, with the time series on\nthe left-hand side and the threshold on the\nright-hand side. Only COMPARISON_LT and\nCOMPARISON_GT are supported currently. Possible values: [\"COMPARISON_GT\", \"COMPARISON_GE\", \"COMPARISON_LT\", \"COMPARISON_LE\", \"COMPARISON_EQ\", \"COMPARISON_NE\"].",
                        "type": "string"
                      },
                      "denominatorAggregations": {
                        "description": "Specifies the alignment of data points in\nindividual time series selected by\ndenominatorFilter as well as how to combine\nthe retrieved time series together (such as\nwhen aggregating multiple streams on each\nresource to a single stream for each\nresource or when aggregating streams across\nall members of a group of resources).When\ncomputing ratios, the aggregations and\ndenominator_aggregations fields must use the\nsame alignment period and produce time\nseries that have the same periodicity and\nlabels.This field is similar to the one in\nthe MetricService.ListTimeSeries request. It\nis advisable to use the ListTimeSeries\nmethod when debugging this field.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "alignmentPeriod": {
                              "description": "The alignment period for per-time\nseries alignment. If present,\nalignmentPeriod must be at least\n60 seconds. After per-time series\nalignment, each time series will\ncontain data points only on the\nperiod boundaries. If\nperSeriesAligner is not specified\nor equals ALIGN_NONE, then this\nfield is ignored. If\nperSeriesAligner is specified and\ndoes not equal ALIGN_NONE, then\nthis field must be defined;\notherwise an error is returned.",
                              "type": "string"
                            },
                            "crossSeriesReducer": {
                              "description": "The approach to be used to combine\ntime series. Not all reducer\nfunctions may be applied to all\ntime series, depending on the\nmetric type and the value type of\nthe original time series.\nReduction may change the metric\ntype of value type of the time\nseries.Time series data must be\naligned in order to perform cross-\ntime series reduction. If\ncrossSeriesReducer is specified,\nthen perSeriesAligner must be\nspecified and not equal ALIGN_NONE\nand alignmentPeriod must be\nspecified; otherwise, an error is\nreturned. Possible values: [\"REDUCE_NONE\", \"REDUCE_MEAN\", \"REDUCE_MIN\", \"REDUCE_MAX\", \"REDUCE_SUM\", \"REDUCE_STDDEV\", \"REDUCE_COUNT\", \"REDUCE_COUNT_TRUE\", \"REDUCE_COUNT_FALSE\", \"REDUCE_FRACTION_TRUE\", \"REDUCE_PERCENTILE_99\", \"REDUCE_PERCENTILE_95\", \"REDUCE_PERCENTILE_50\", \"REDUCE_PERCENTILE_05\"].",
                              "type": "string"
                            },
                            "groupByFields": {
                              "description": "The set of fields to preserve when\ncrossSeriesReducer is specified.\nThe groupByFields determine how\nthe time series are partitioned\ninto subsets prior to applying the\naggregation function. Each subset\ncontains time series that have the\nsame value for each of the\ngrouping fields. Each individual\ntime series is a member of exactly\none subset. The crossSeriesReducer\nis applied to each subset of time\nseries. It is not possible to\nreduce across different resource\ntypes, so this field implicitly\ncontains resource.type. Fields not\nspecified in groupByFields are\naggregated away. If groupByFields\nis not specified and all the time\nseries have the same resource\ntype, then the time series are\naggregated into a single output\ntime series. If crossSeriesReducer\nis not defined, this field is\nignored.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "perSeriesAligner": {
                              "description": "The approach to be used to align\nindividual time series. Not all\nalignment functions may be applied\nto all time series, depending on\nthe metric type and value type of\nthe original time series.\nAlignment may change the metric\ntype or the value type of the time\nseries.Time series data must be\naligned in order to perform cross-\ntime series reduction. If\ncrossSeriesReducer is specified,\nthen perSeriesAligner must be\nspecified and not equal ALIGN_NONE\nand alignmentPeriod must be\nspecified; otherwise, an error is\nreturned. Possible values: [\"ALIGN_NONE\", \"ALIGN_DELTA\", \"ALIGN_RATE\", \"ALIGN_INTERPOLATE\", \"ALIGN_NEXT_OLDER\", \"ALIGN_MIN\", \"ALIGN_MAX\", \"ALIGN_MEAN\", \"ALIGN_COUNT\", \"ALIGN_SUM\", \"ALIGN_STDDEV\", \"ALIGN_COUNT_TRUE\", \"ALIGN_COUNT_FALSE\", \"ALIGN_FRACTION_TRUE\", \"ALIGN_PERCENTILE_99\", \"ALIGN_PERCENTILE_95\", \"ALIGN_PERCENTILE_50\", \"ALIGN_PERCENTILE_05\", \"ALIGN_PERCENT_CHANGE\"].",
                              "type": "string"
                            }
                          }
                        }
                      },
                      "denominatorFilter": {
                        "description": "A filter that identifies a time series that\nshould be used as the denominator of a ratio\nthat will be compared with the threshold. If\na denominator_filter is specified, the time\nseries specified by the filter field will be\nused as the numerator.The filter is similar\nto the one that is specified in the\nMetricService.ListTimeSeries request (that\ncall is useful to verify the time series\nthat will be retrieved / processed) and must\nspecify the metric type and optionally may\ncontain restrictions on resource type,\nresource labels, and metric labels. This\nfield may not exceed 2048 Unicode characters\nin length.",
                        "type": "string"
                      },
                      "duration": {
                        "description": "The amount of time that a time series must\nviolate the threshold to be considered\nfailing. Currently, only values that are a\nmultiple of a minute--e.g., 0, 60, 120, or\n300 seconds--are supported. If an invalid\nvalue is given, an error will be returned.\nWhen choosing a duration, it is useful to\nkeep in mind the frequency of the underlying\ntime series data (which may also be affected\nby any alignments specified in the\naggregations field); a good duration is long\nenough so that a single outlier does not\ngenerate spurious alerts, but short enough\nthat unhealthy states are detected and\nalerted on quickly.",
                        "type": "string"
                      },
                      "filter": {
                        "description": "A filter that identifies which time series\nshould be compared with the threshold.The\nfilter is similar to the one that is\nspecified in the\nMetricService.ListTimeSeries request (that\ncall is useful to verify the time series\nthat will be retrieved / processed) and must\nspecify the metric type and optionally may\ncontain restrictions on resource type,\nresource labels, and metric labels. This\nfield may not exceed 2048 Unicode characters\nin length.",
                        "type": "string"
                      },
                      "thresholdValue": {
                        "description": "A value against which to compare the time\nseries.",
                        "type": "number"
                      },
                      "trigger": {
                        "description": "The number/percent of time series for which\nthe comparison must hold in order for the\ncondition to trigger. If unspecified, then\nthe condition will trigger if the comparison\nis true for any of the time series that have\nbeen identified by filter and aggregations,\nor by the ratio, if denominator_filter and\ndenominator_aggregations are specified.",
                        "type": "object",
                        "properties": {
                          "count": {
                            "description": "The absolute number of time series\nthat must fail the predicate for the\ncondition to be triggered.",
                            "type": "integer"
                          },
                          "percent": {
                            "description": "The percentage of time series that\nmust fail the predicate for the\ncondition to be triggered.",
                            "type": "number"
                          }
                        }
                      }
                    }
                  },
                  "displayName": {
                    "description": "A short name or phrase used to identify the\ncondition in dashboards, notifications, and\nincidents. To avoid confusion, don't use the same\ndisplay name for multiple conditions in the same\npolicy.",
                    "type": "string"
                  },
                  "name": {
                    "description": "The unique resource name for this condition.\nIts syntax is:\nprojects/[PROJECT_ID]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]\n[CONDITION_ID] is assigned by Stackdriver Monitoring when\nthe condition is created as part of a new or updated alerting\npolicy.",
                    "type": "string"
                  }
                }
              }
            },
            "displayName": {
              "description": "A short name or phrase used to identify the policy in\ndashboards, notifications, and incidents. To avoid confusion, don't use\nthe same display name for multiple policies in the same project. The\nname is limited to 512 Unicode characters.",
              "type": "string"
            },
            "documentation": {
              "description": "Documentation that is included with notifications and incidents related\nto this policy. Best practice is for the documentation to include information\nto help responders understand, mitigate, escalate, and correct the underlying\nproblems detected by the alerting policy. Notification channels that have\nlimited capacity might not show this documentation.",
              "type": "object",
              "properties": {
                "content": {
                  "description": "The text of the documentation, interpreted according to mimeType.\nThe content may not exceed 8,192 Unicode characters and may not\nexceed more than 10,240 bytes when encoded in UTF-8 format,\nwhichever is smaller.",
                  "type": "string"
                },
                "mimeType": {
                  "description": "The format of the content field. Presently, only the value\n\"text/markdown\" is supported.",
                  "type": "string"
                }
              }
            },
            "enabled": {
              "description": "Whether or not the policy is enabled. The default is true.",
              "type": "boolean"
            },
            "notificationChannels": {
              "type": "array",
              "items": {
                "description": "Identifies the notification channels to which notifications should be sent when incidents are opened or closed or when new violations occur on an already opened incident.",
                "type": "object",
                "properties": {
                  "external": {
                    "description": "The name of a MonitoringNotificationChannel.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationRecord": {
              "description": "A read-only record of the creation of the alerting policy.\nIf provided in a call to create or update, this field will\nbe ignored.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "mutateTime": {
                    "description": "When the change occurred.",
                    "type": "string"
                  },
                  "mutatedBy": {
                    "description": "The email address of the user making the change.",
                    "type": "string"
                  }
                }
              }
            },
            "name": {
              "description": "The unique resource name for this policy.\nIts syntax is: projects/[PROJECT_ID]/alertPolicies/[ALERT_POLICY_ID].",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "monitoring.cnrm.cloud.google.com",
          "kind": "MonitoringAlertPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.monitoring.v1beta1.MonitoringAlertPolicyList": {
      "description": "MonitoringAlertPolicyList is a list of MonitoringAlertPolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["monitoring.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of monitoringalertpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.monitoring.v1beta1.MonitoringAlertPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MonitoringAlertPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "monitoring.cnrm.cloud.google.com",
          "kind": "MonitoringAlertPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.monitoring.v1beta1.MonitoringDashboard": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["monitoring.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MonitoringDashboard"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["displayName", "projectRef"],
          "properties": {
            "columnLayout": {
              "description": "The content is divided into equally spaced columns and the widgets are arranged vertically.",
              "type": "object",
              "properties": {
                "columns": {
                  "description": "The columns of content to display.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "weight": {
                        "description": "The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.",
                        "type": "integer",
                        "format": "int64"
                      },
                      "widgets": {
                        "description": "The display widgets arranged vertically in this column.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "blank": {
                              "description": "A blank space.",
                              "x-kubernetes-preserve-unknown-fields": true
                            },
                            "scorecard": {
                              "description": "A scorecard summarizing time series data.",
                              "type": "object",
                              "required": ["timeSeriesQuery"],
                              "properties": {
                                "gaugeView": {
                                  "description": "Will cause the scorecard to show a gauge chart.",
                                  "type": "object",
                                  "properties": {
                                    "lowerBound": {
                                      "description": "The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.",
                                      "type": "number",
                                      "format": "double"
                                    },
                                    "upperBound": {
                                      "description": "The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.",
                                      "type": "number",
                                      "format": "double"
                                    }
                                  }
                                },
                                "sparkChartView": {
                                  "description": "Will cause the scorecard to show a spark chart.",
                                  "type": "object",
                                  "required": ["sparkChartType"],
                                  "properties": {
                                    "minAlignmentPeriod": {
                                      "description": "The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.",
                                      "type": "string"
                                    },
                                    "sparkChartType": {
                                      "description": "Required. The type of sparkchart to show in this chartView. Possible values: SPARK_CHART_TYPE_UNSPECIFIED, SPARK_LINE, SPARK_BAR",
                                      "type": "string"
                                    }
                                  }
                                },
                                "thresholds": {
                                  "description": "The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.",
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "color": {
                                        "description": "The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED",
                                        "type": "string"
                                      },
                                      "direction": {
                                        "description": "The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW",
                                        "type": "string"
                                      },
                                      "label": {
                                        "description": "A label for the threshold.",
                                        "type": "string"
                                      },
                                      "value": {
                                        "description": "The value of the threshold. The value should be defined in the native scale of the metric.",
                                        "type": "number",
                                        "format": "double"
                                      }
                                    }
                                  }
                                },
                                "timeSeriesQuery": {
                                  "description": "Required. Fields for querying time series data from the Stackdriver metrics API.",
                                  "type": "object",
                                  "properties": {
                                    "timeSeriesFilter": {
                                      "description": "Filter parameters to fetch time series.",
                                      "type": "object",
                                      "required": ["filter"],
                                      "properties": {
                                        "aggregation": {
                                          "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                          "type": "object",
                                          "properties": {
                                            "alignmentPeriod": {
                                              "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                              "type": "string"
                                            },
                                            "crossSeriesReducer": {
                                              "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                              "type": "string"
                                            },
                                            "groupByFields": {
                                              "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "perSeriesAligner": {
                                              "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "filter": {
                                          "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                          "type": "string"
                                        },
                                        "pickTimeSeriesFilter": {
                                          "description": "Ranking based time series filter.",
                                          "type": "object",
                                          "properties": {
                                            "direction": {
                                              "description": "How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM",
                                              "type": "string"
                                            },
                                            "numTimeSeries": {
                                              "description": "How many time series to allow to pass through the filter.",
                                              "type": "integer",
                                              "format": "int64"
                                            },
                                            "rankingMethod": {
                                              "description": "`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "secondaryAggregation": {
                                          "description": "Apply a second aggregation after `aggregation` is applied.",
                                          "type": "object",
                                          "properties": {
                                            "alignmentPeriod": {
                                              "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                              "type": "string"
                                            },
                                            "crossSeriesReducer": {
                                              "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                              "type": "string"
                                            },
                                            "groupByFields": {
                                              "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "perSeriesAligner": {
                                              "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "timeSeriesFilterRatio": {
                                      "description": "Parameters to fetch a ratio between two time series filters.",
                                      "type": "object",
                                      "properties": {
                                        "denominator": {
                                          "description": "The denominator of the ratio.",
                                          "type": "object",
                                          "required": ["filter"],
                                          "properties": {
                                            "aggregation": {
                                              "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                              "type": "object",
                                              "properties": {
                                                "alignmentPeriod": {
                                                  "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                  "type": "string"
                                                },
                                                "crossSeriesReducer": {
                                                  "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                  "type": "string"
                                                },
                                                "groupByFields": {
                                                  "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  }
                                                },
                                                "perSeriesAligner": {
                                                  "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "filter": {
                                              "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "numerator": {
                                          "description": "The numerator of the ratio.",
                                          "type": "object",
                                          "required": ["filter"],
                                          "properties": {
                                            "aggregation": {
                                              "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                              "type": "object",
                                              "properties": {
                                                "alignmentPeriod": {
                                                  "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                  "type": "string"
                                                },
                                                "crossSeriesReducer": {
                                                  "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                  "type": "string"
                                                },
                                                "groupByFields": {
                                                  "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  }
                                                },
                                                "perSeriesAligner": {
                                                  "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "filter": {
                                              "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "pickTimeSeriesFilter": {
                                          "description": "Ranking based time series filter.",
                                          "type": "object",
                                          "properties": {
                                            "direction": {
                                              "description": "How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM",
                                              "type": "string"
                                            },
                                            "numTimeSeries": {
                                              "description": "How many time series to allow to pass through the filter.",
                                              "type": "integer",
                                              "format": "int64"
                                            },
                                            "rankingMethod": {
                                              "description": "`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "secondaryAggregation": {
                                          "description": "Apply a second aggregation after the ratio is computed.",
                                          "type": "object",
                                          "properties": {
                                            "alignmentPeriod": {
                                              "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                              "type": "string"
                                            },
                                            "crossSeriesReducer": {
                                              "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                              "type": "string"
                                            },
                                            "groupByFields": {
                                              "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "perSeriesAligner": {
                                              "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "timeSeriesQueryLanguage": {
                                      "description": "A query used to fetch time series.",
                                      "type": "string"
                                    },
                                    "unitOverride": {
                                      "description": "The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "text": {
                              "description": "A raw string or markdown displaying textual content.",
                              "type": "object",
                              "properties": {
                                "content": {
                                  "description": "The text content to be displayed.",
                                  "type": "string"
                                },
                                "format": {
                                  "description": "How the text content is formatted. Possible values: FORMAT_UNSPECIFIED, MARKDOWN, RAW",
                                  "type": "string"
                                }
                              }
                            },
                            "title": {
                              "description": "Optional. The title of the widget.",
                              "type": "string"
                            },
                            "xyChart": {
                              "description": "A chart of time series data.",
                              "type": "object",
                              "required": ["dataSets"],
                              "properties": {
                                "chartOptions": {
                                  "description": "Display options for the chart.",
                                  "type": "object",
                                  "properties": {
                                    "mode": {
                                      "description": "The chart mode. Possible values: MODE_UNSPECIFIED, COLOR, X_RAY, STATS",
                                      "type": "string"
                                    }
                                  }
                                },
                                "dataSets": {
                                  "description": "Required. The data displayed in this chart.",
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "required": ["timeSeriesQuery"],
                                    "properties": {
                                      "legendTemplate": {
                                        "description": "A template string for naming `TimeSeries` in the resulting data set. This should be a string with interpolations of the form `${label_name}`, which will resolve to the label's value. ",
                                        "type": "string"
                                      },
                                      "minAlignmentPeriod": {
                                        "description": "Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the `min_alignment_period` should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.",
                                        "type": "string"
                                      },
                                      "plotType": {
                                        "description": "How this data should be plotted on the chart. Possible values: PLOT_TYPE_UNSPECIFIED, LINE, STACKED_AREA, STACKED_BAR, HEATMAP",
                                        "type": "string"
                                      },
                                      "timeSeriesQuery": {
                                        "description": "Required. Fields for querying time series data from the Stackdriver metrics API.",
                                        "type": "object",
                                        "properties": {
                                          "timeSeriesFilter": {
                                            "description": "Filter parameters to fetch time series.",
                                            "type": "object",
                                            "required": ["filter"],
                                            "properties": {
                                              "aggregation": {
                                                "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                                "type": "object",
                                                "properties": {
                                                  "alignmentPeriod": {
                                                    "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                    "type": "string"
                                                  },
                                                  "crossSeriesReducer": {
                                                    "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                    "type": "string"
                                                  },
                                                  "groupByFields": {
                                                    "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                    "type": "array",
                                                    "items": {
                                                      "type": "string"
                                                    }
                                                  },
                                                  "perSeriesAligner": {
                                                    "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                    "type": "string"
                                                  }
                                                }
                                              },
                                              "filter": {
                                                "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                                "type": "string"
                                              },
                                              "pickTimeSeriesFilter": {
                                                "description": "Ranking based time series filter.",
                                                "type": "object",
                                                "properties": {
                                                  "direction": {
                                                    "description": "How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM",
                                                    "type": "string"
                                                  },
                                                  "numTimeSeries": {
                                                    "description": "How many time series to allow to pass through the filter.",
                                                    "type": "integer",
                                                    "format": "int64"
                                                  },
                                                  "rankingMethod": {
                                                    "description": "`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST",
                                                    "type": "string"
                                                  }
                                                }
                                              },
                                              "secondaryAggregation": {
                                                "description": "Apply a second aggregation after `aggregation` is applied.",
                                                "type": "object",
                                                "properties": {
                                                  "alignmentPeriod": {
                                                    "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                    "type": "string"
                                                  },
                                                  "crossSeriesReducer": {
                                                    "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                    "type": "string"
                                                  },
                                                  "groupByFields": {
                                                    "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                    "type": "array",
                                                    "items": {
                                                      "type": "string"
                                                    }
                                                  },
                                                  "perSeriesAligner": {
                                                    "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                    "type": "string"
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          "timeSeriesFilterRatio": {
                                            "description": "Parameters to fetch a ratio between two time series filters.",
                                            "type": "object",
                                            "properties": {
                                              "denominator": {
                                                "description": "The denominator of the ratio.",
                                                "type": "object",
                                                "required": ["filter"],
                                                "properties": {
                                                  "aggregation": {
                                                    "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                                    "type": "object",
                                                    "properties": {
                                                      "alignmentPeriod": {
                                                        "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                        "type": "string"
                                                      },
                                                      "crossSeriesReducer": {
                                                        "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                        "type": "string"
                                                      },
                                                      "groupByFields": {
                                                        "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                        "type": "array",
                                                        "items": {
                                                          "type": "string"
                                                        }
                                                      },
                                                      "perSeriesAligner": {
                                                        "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "filter": {
                                                    "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                                    "type": "string"
                                                  }
                                                }
                                              },
                                              "numerator": {
                                                "description": "The numerator of the ratio.",
                                                "type": "object",
                                                "required": ["filter"],
                                                "properties": {
                                                  "aggregation": {
                                                    "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                                    "type": "object",
                                                    "properties": {
                                                      "alignmentPeriod": {
                                                        "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                        "type": "string"
                                                      },
                                                      "crossSeriesReducer": {
                                                        "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                        "type": "string"
                                                      },
                                                      "groupByFields": {
                                                        "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                        "type": "array",
                                                        "items": {
                                                          "type": "string"
                                                        }
                                                      },
                                                      "perSeriesAligner": {
                                                        "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "filter": {
                                                    "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                                    "type": "string"
                                                  }
                                                }
                                              },
                                              "pickTimeSeriesFilter": {
                                                "description": "Ranking based time series filter.",
                                                "type": "object",
                                                "properties": {
                                                  "direction": {
                                                    "description": "How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM",
                                                    "type": "string"
                                                  },
                                                  "numTimeSeries": {
                                                    "description": "How many time series to allow to pass through the filter.",
                                                    "type": "integer",
                                                    "format": "int64"
                                                  },
                                                  "rankingMethod": {
                                                    "description": "`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST",
                                                    "type": "string"
                                                  }
                                                }
                                              },
                                              "secondaryAggregation": {
                                                "description": "Apply a second aggregation after the ratio is computed.",
                                                "type": "object",
                                                "properties": {
                                                  "alignmentPeriod": {
                                                    "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                    "type": "string"
                                                  },
                                                  "crossSeriesReducer": {
                                                    "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                    "type": "string"
                                                  },
                                                  "groupByFields": {
                                                    "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                    "type": "array",
                                                    "items": {
                                                      "type": "string"
                                                    }
                                                  },
                                                  "perSeriesAligner": {
                                                    "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                    "type": "string"
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          "timeSeriesQueryLanguage": {
                                            "description": "A query used to fetch time series.",
                                            "type": "string"
                                          },
                                          "unitOverride": {
                                            "description": "The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "thresholds": {
                                  "description": "Threshold lines drawn horizontally across the chart.",
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "color": {
                                        "description": "The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED",
                                        "type": "string"
                                      },
                                      "direction": {
                                        "description": "The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW",
                                        "type": "string"
                                      },
                                      "label": {
                                        "description": "A label for the threshold.",
                                        "type": "string"
                                      },
                                      "value": {
                                        "description": "The value of the threshold. The value should be defined in the native scale of the metric.",
                                        "type": "number",
                                        "format": "double"
                                      }
                                    }
                                  }
                                },
                                "timeshiftDuration": {
                                  "description": "The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.",
                                  "type": "string"
                                },
                                "xAxis": {
                                  "description": "The properties applied to the X axis.",
                                  "type": "object",
                                  "properties": {
                                    "label": {
                                      "description": "The label of the axis.",
                                      "type": "string"
                                    },
                                    "scale": {
                                      "description": "The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10",
                                      "type": "string"
                                    }
                                  }
                                },
                                "yAxis": {
                                  "description": "The properties applied to the Y axis.",
                                  "type": "object",
                                  "properties": {
                                    "label": {
                                      "description": "The label of the axis.",
                                      "type": "string"
                                    },
                                    "scale": {
                                      "description": "The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "displayName": {
              "description": "Required. The mutable, human-readable name.",
              "type": "string"
            },
            "gridLayout": {
              "description": "Content is arranged with a basic layout that re-flows a simple list of informational elements like widgets or tiles.",
              "type": "object",
              "properties": {
                "columns": {
                  "description": "The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.",
                  "type": "integer",
                  "format": "int64"
                },
                "widgets": {
                  "description": "The informational elements that are arranged into the columns row-first.",
                  "type": "array",
                  "items": {
                    "description": "The informational widget contained in the tile.",
                    "type": "object",
                    "properties": {
                      "blank": {
                        "description": "A blank space.",
                        "x-kubernetes-preserve-unknown-fields": true
                      },
                      "scorecard": {
                        "description": "A scorecard summarizing time series data.",
                        "type": "object",
                        "required": ["timeSeriesQuery"],
                        "properties": {
                          "gaugeView": {
                            "description": "Will cause the scorecard to show a gauge chart.",
                            "type": "object",
                            "properties": {
                              "lowerBound": {
                                "description": "The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.",
                                "type": "number",
                                "format": "double"
                              },
                              "upperBound": {
                                "description": "The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.",
                                "type": "number",
                                "format": "double"
                              }
                            }
                          },
                          "sparkChartView": {
                            "description": "Will cause the scorecard to show a spark chart.",
                            "type": "object",
                            "required": ["sparkChartType"],
                            "properties": {
                              "minAlignmentPeriod": {
                                "description": "The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.",
                                "type": "string"
                              },
                              "sparkChartType": {
                                "description": "Required. The type of sparkchart to show in this chartView. Possible values: SPARK_CHART_TYPE_UNSPECIFIED, SPARK_LINE, SPARK_BAR",
                                "type": "string"
                              }
                            }
                          },
                          "thresholds": {
                            "description": "The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.",
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "color": {
                                  "description": "The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED",
                                  "type": "string"
                                },
                                "direction": {
                                  "description": "The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW",
                                  "type": "string"
                                },
                                "label": {
                                  "description": "A label for the threshold.",
                                  "type": "string"
                                },
                                "value": {
                                  "description": "The value of the threshold. The value should be defined in the native scale of the metric.",
                                  "type": "number",
                                  "format": "double"
                                }
                              }
                            }
                          },
                          "timeSeriesQuery": {
                            "description": "Required. Fields for querying time series data from the Stackdriver metrics API.",
                            "type": "object",
                            "properties": {
                              "timeSeriesFilter": {
                                "description": "Filter parameters to fetch time series.",
                                "type": "object",
                                "required": ["filter"],
                                "properties": {
                                  "aggregation": {
                                    "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                    "type": "object",
                                    "properties": {
                                      "alignmentPeriod": {
                                        "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                        "type": "string"
                                      },
                                      "crossSeriesReducer": {
                                        "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                        "type": "string"
                                      },
                                      "groupByFields": {
                                        "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "perSeriesAligner": {
                                        "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "filter": {
                                    "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                    "type": "string"
                                  },
                                  "pickTimeSeriesFilter": {
                                    "description": "Ranking based time series filter.",
                                    "type": "object",
                                    "properties": {
                                      "direction": {
                                        "description": "How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM",
                                        "type": "string"
                                      },
                                      "numTimeSeries": {
                                        "description": "How many time series to allow to pass through the filter.",
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "rankingMethod": {
                                        "description": "`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "secondaryAggregation": {
                                    "description": "Apply a second aggregation after `aggregation` is applied.",
                                    "type": "object",
                                    "properties": {
                                      "alignmentPeriod": {
                                        "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                        "type": "string"
                                      },
                                      "crossSeriesReducer": {
                                        "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                        "type": "string"
                                      },
                                      "groupByFields": {
                                        "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "perSeriesAligner": {
                                        "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              },
                              "timeSeriesFilterRatio": {
                                "description": "Parameters to fetch a ratio between two time series filters.",
                                "type": "object",
                                "properties": {
                                  "denominator": {
                                    "description": "The denominator of the ratio.",
                                    "type": "object",
                                    "required": ["filter"],
                                    "properties": {
                                      "aggregation": {
                                        "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                        "type": "object",
                                        "properties": {
                                          "alignmentPeriod": {
                                            "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                            "type": "string"
                                          },
                                          "crossSeriesReducer": {
                                            "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                            "type": "string"
                                          },
                                          "groupByFields": {
                                            "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          },
                                          "perSeriesAligner": {
                                            "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "filter": {
                                        "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "numerator": {
                                    "description": "The numerator of the ratio.",
                                    "type": "object",
                                    "required": ["filter"],
                                    "properties": {
                                      "aggregation": {
                                        "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                        "type": "object",
                                        "properties": {
                                          "alignmentPeriod": {
                                            "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                            "type": "string"
                                          },
                                          "crossSeriesReducer": {
                                            "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                            "type": "string"
                                          },
                                          "groupByFields": {
                                            "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          },
                                          "perSeriesAligner": {
                                            "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "filter": {
                                        "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "pickTimeSeriesFilter": {
                                    "description": "Ranking based time series filter.",
                                    "type": "object",
                                    "properties": {
                                      "direction": {
                                        "description": "How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM",
                                        "type": "string"
                                      },
                                      "numTimeSeries": {
                                        "description": "How many time series to allow to pass through the filter.",
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "rankingMethod": {
                                        "description": "`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "secondaryAggregation": {
                                    "description": "Apply a second aggregation after the ratio is computed.",
                                    "type": "object",
                                    "properties": {
                                      "alignmentPeriod": {
                                        "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                        "type": "string"
                                      },
                                      "crossSeriesReducer": {
                                        "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                        "type": "string"
                                      },
                                      "groupByFields": {
                                        "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "perSeriesAligner": {
                                        "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              },
                              "timeSeriesQueryLanguage": {
                                "description": "A query used to fetch time series.",
                                "type": "string"
                              },
                              "unitOverride": {
                                "description": "The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.",
                                "type": "string"
                              }
                            }
                          }
                        }
                      },
                      "text": {
                        "description": "A raw string or markdown displaying textual content.",
                        "type": "object",
                        "properties": {
                          "content": {
                            "description": "The text content to be displayed.",
                            "type": "string"
                          },
                          "format": {
                            "description": "How the text content is formatted. Possible values: FORMAT_UNSPECIFIED, MARKDOWN, RAW",
                            "type": "string"
                          }
                        }
                      },
                      "title": {
                        "description": "Optional. The title of the widget.",
                        "type": "string"
                      },
                      "xyChart": {
                        "description": "A chart of time series data.",
                        "type": "object",
                        "required": ["dataSets"],
                        "properties": {
                          "chartOptions": {
                            "description": "Display options for the chart.",
                            "type": "object",
                            "properties": {
                              "mode": {
                                "description": "The chart mode. Possible values: MODE_UNSPECIFIED, COLOR, X_RAY, STATS",
                                "type": "string"
                              }
                            }
                          },
                          "dataSets": {
                            "description": "Required. The data displayed in this chart.",
                            "type": "array",
                            "items": {
                              "type": "object",
                              "required": ["timeSeriesQuery"],
                              "properties": {
                                "legendTemplate": {
                                  "description": "A template string for naming `TimeSeries` in the resulting data set. This should be a string with interpolations of the form `${label_name}`, which will resolve to the label's value. ",
                                  "type": "string"
                                },
                                "minAlignmentPeriod": {
                                  "description": "Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the `min_alignment_period` should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.",
                                  "type": "string"
                                },
                                "plotType": {
                                  "description": "How this data should be plotted on the chart. Possible values: PLOT_TYPE_UNSPECIFIED, LINE, STACKED_AREA, STACKED_BAR, HEATMAP",
                                  "type": "string"
                                },
                                "timeSeriesQuery": {
                                  "description": "Required. Fields for querying time series data from the Stackdriver metrics API.",
                                  "type": "object",
                                  "properties": {
                                    "timeSeriesFilter": {
                                      "description": "Filter parameters to fetch time series.",
                                      "type": "object",
                                      "required": ["filter"],
                                      "properties": {
                                        "aggregation": {
                                          "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                          "type": "object",
                                          "properties": {
                                            "alignmentPeriod": {
                                              "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                              "type": "string"
                                            },
                                            "crossSeriesReducer": {
                                              "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                              "type": "string"
                                            },
                                            "groupByFields": {
                                              "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "perSeriesAligner": {
                                              "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "filter": {
                                          "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                          "type": "string"
                                        },
                                        "pickTimeSeriesFilter": {
                                          "description": "Ranking based time series filter.",
                                          "type": "object",
                                          "properties": {
                                            "direction": {
                                              "description": "How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM",
                                              "type": "string"
                                            },
                                            "numTimeSeries": {
                                              "description": "How many time series to allow to pass through the filter.",
                                              "type": "integer",
                                              "format": "int64"
                                            },
                                            "rankingMethod": {
                                              "description": "`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "secondaryAggregation": {
                                          "description": "Apply a second aggregation after `aggregation` is applied.",
                                          "type": "object",
                                          "properties": {
                                            "alignmentPeriod": {
                                              "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                              "type": "string"
                                            },
                                            "crossSeriesReducer": {
                                              "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                              "type": "string"
                                            },
                                            "groupByFields": {
                                              "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "perSeriesAligner": {
                                              "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "timeSeriesFilterRatio": {
                                      "description": "Parameters to fetch a ratio between two time series filters.",
                                      "type": "object",
                                      "properties": {
                                        "denominator": {
                                          "description": "The denominator of the ratio.",
                                          "type": "object",
                                          "required": ["filter"],
                                          "properties": {
                                            "aggregation": {
                                              "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                              "type": "object",
                                              "properties": {
                                                "alignmentPeriod": {
                                                  "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                  "type": "string"
                                                },
                                                "crossSeriesReducer": {
                                                  "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                  "type": "string"
                                                },
                                                "groupByFields": {
                                                  "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  }
                                                },
                                                "perSeriesAligner": {
                                                  "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "filter": {
                                              "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "numerator": {
                                          "description": "The numerator of the ratio.",
                                          "type": "object",
                                          "required": ["filter"],
                                          "properties": {
                                            "aggregation": {
                                              "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                              "type": "object",
                                              "properties": {
                                                "alignmentPeriod": {
                                                  "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                  "type": "string"
                                                },
                                                "crossSeriesReducer": {
                                                  "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                  "type": "string"
                                                },
                                                "groupByFields": {
                                                  "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  }
                                                },
                                                "perSeriesAligner": {
                                                  "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "filter": {
                                              "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "pickTimeSeriesFilter": {
                                          "description": "Ranking based time series filter.",
                                          "type": "object",
                                          "properties": {
                                            "direction": {
                                              "description": "How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM",
                                              "type": "string"
                                            },
                                            "numTimeSeries": {
                                              "description": "How many time series to allow to pass through the filter.",
                                              "type": "integer",
                                              "format": "int64"
                                            },
                                            "rankingMethod": {
                                              "description": "`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "secondaryAggregation": {
                                          "description": "Apply a second aggregation after the ratio is computed.",
                                          "type": "object",
                                          "properties": {
                                            "alignmentPeriod": {
                                              "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                              "type": "string"
                                            },
                                            "crossSeriesReducer": {
                                              "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                              "type": "string"
                                            },
                                            "groupByFields": {
                                              "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "perSeriesAligner": {
                                              "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "timeSeriesQueryLanguage": {
                                      "description": "A query used to fetch time series.",
                                      "type": "string"
                                    },
                                    "unitOverride": {
                                      "description": "The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "thresholds": {
                            "description": "Threshold lines drawn horizontally across the chart.",
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "color": {
                                  "description": "The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED",
                                  "type": "string"
                                },
                                "direction": {
                                  "description": "The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW",
                                  "type": "string"
                                },
                                "label": {
                                  "description": "A label for the threshold.",
                                  "type": "string"
                                },
                                "value": {
                                  "description": "The value of the threshold. The value should be defined in the native scale of the metric.",
                                  "type": "number",
                                  "format": "double"
                                }
                              }
                            }
                          },
                          "timeshiftDuration": {
                            "description": "The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.",
                            "type": "string"
                          },
                          "xAxis": {
                            "description": "The properties applied to the X axis.",
                            "type": "object",
                            "properties": {
                              "label": {
                                "description": "The label of the axis.",
                                "type": "string"
                              },
                              "scale": {
                                "description": "The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10",
                                "type": "string"
                              }
                            }
                          },
                          "yAxis": {
                            "description": "The properties applied to the Y axis.",
                            "type": "object",
                            "properties": {
                              "label": {
                                "description": "The label of the axis.",
                                "type": "string"
                              },
                              "scale": {
                                "description": "The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10",
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "mosaicLayout": {
              "description": "The content is arranged as a grid of tiles, with each content widget occupying one or more tiles.",
              "type": "object",
              "properties": {
                "columns": {
                  "description": "The number of columns in the mosaic grid.",
                  "type": "integer",
                  "format": "int64"
                },
                "tiles": {
                  "description": "The tiles to display.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "height": {
                        "description": "The height of the tile, measured in grid squares.",
                        "type": "integer",
                        "format": "int64"
                      },
                      "widget": {
                        "description": "The informational widget contained in the tile.",
                        "type": "object",
                        "properties": {
                          "blank": {
                            "description": "A blank space.",
                            "x-kubernetes-preserve-unknown-fields": true
                          },
                          "scorecard": {
                            "description": "A scorecard summarizing time series data.",
                            "type": "object",
                            "required": ["timeSeriesQuery"],
                            "properties": {
                              "gaugeView": {
                                "description": "Will cause the scorecard to show a gauge chart.",
                                "type": "object",
                                "properties": {
                                  "lowerBound": {
                                    "description": "The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.",
                                    "type": "number",
                                    "format": "double"
                                  },
                                  "upperBound": {
                                    "description": "The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.",
                                    "type": "number",
                                    "format": "double"
                                  }
                                }
                              },
                              "sparkChartView": {
                                "description": "Will cause the scorecard to show a spark chart.",
                                "type": "object",
                                "required": ["sparkChartType"],
                                "properties": {
                                  "minAlignmentPeriod": {
                                    "description": "The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.",
                                    "type": "string"
                                  },
                                  "sparkChartType": {
                                    "description": "Required. The type of sparkchart to show in this chartView. Possible values: SPARK_CHART_TYPE_UNSPECIFIED, SPARK_LINE, SPARK_BAR",
                                    "type": "string"
                                  }
                                }
                              },
                              "thresholds": {
                                "description": "The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "color": {
                                      "description": "The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED",
                                      "type": "string"
                                    },
                                    "direction": {
                                      "description": "The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW",
                                      "type": "string"
                                    },
                                    "label": {
                                      "description": "A label for the threshold.",
                                      "type": "string"
                                    },
                                    "value": {
                                      "description": "The value of the threshold. The value should be defined in the native scale of the metric.",
                                      "type": "number",
                                      "format": "double"
                                    }
                                  }
                                }
                              },
                              "timeSeriesQuery": {
                                "description": "Required. Fields for querying time series data from the Stackdriver metrics API.",
                                "type": "object",
                                "properties": {
                                  "timeSeriesFilter": {
                                    "description": "Filter parameters to fetch time series.",
                                    "type": "object",
                                    "required": ["filter"],
                                    "properties": {
                                      "aggregation": {
                                        "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                        "type": "object",
                                        "properties": {
                                          "alignmentPeriod": {
                                            "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                            "type": "string"
                                          },
                                          "crossSeriesReducer": {
                                            "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                            "type": "string"
                                          },
                                          "groupByFields": {
                                            "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          },
                                          "perSeriesAligner": {
                                            "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "filter": {
                                        "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                        "type": "string"
                                      },
                                      "pickTimeSeriesFilter": {
                                        "description": "Ranking based time series filter.",
                                        "type": "object",
                                        "properties": {
                                          "direction": {
                                            "description": "How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM",
                                            "type": "string"
                                          },
                                          "numTimeSeries": {
                                            "description": "How many time series to allow to pass through the filter.",
                                            "type": "integer",
                                            "format": "int64"
                                          },
                                          "rankingMethod": {
                                            "description": "`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "secondaryAggregation": {
                                        "description": "Apply a second aggregation after `aggregation` is applied.",
                                        "type": "object",
                                        "properties": {
                                          "alignmentPeriod": {
                                            "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                            "type": "string"
                                          },
                                          "crossSeriesReducer": {
                                            "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                            "type": "string"
                                          },
                                          "groupByFields": {
                                            "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          },
                                          "perSeriesAligner": {
                                            "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "timeSeriesFilterRatio": {
                                    "description": "Parameters to fetch a ratio between two time series filters.",
                                    "type": "object",
                                    "properties": {
                                      "denominator": {
                                        "description": "The denominator of the ratio.",
                                        "type": "object",
                                        "required": ["filter"],
                                        "properties": {
                                          "aggregation": {
                                            "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                            "type": "object",
                                            "properties": {
                                              "alignmentPeriod": {
                                                "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                "type": "string"
                                              },
                                              "crossSeriesReducer": {
                                                "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                "type": "string"
                                              },
                                              "groupByFields": {
                                                "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                "type": "array",
                                                "items": {
                                                  "type": "string"
                                                }
                                              },
                                              "perSeriesAligner": {
                                                "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "filter": {
                                            "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "numerator": {
                                        "description": "The numerator of the ratio.",
                                        "type": "object",
                                        "required": ["filter"],
                                        "properties": {
                                          "aggregation": {
                                            "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                            "type": "object",
                                            "properties": {
                                              "alignmentPeriod": {
                                                "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                "type": "string"
                                              },
                                              "crossSeriesReducer": {
                                                "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                "type": "string"
                                              },
                                              "groupByFields": {
                                                "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                "type": "array",
                                                "items": {
                                                  "type": "string"
                                                }
                                              },
                                              "perSeriesAligner": {
                                                "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "filter": {
                                            "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "pickTimeSeriesFilter": {
                                        "description": "Ranking based time series filter.",
                                        "type": "object",
                                        "properties": {
                                          "direction": {
                                            "description": "How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM",
                                            "type": "string"
                                          },
                                          "numTimeSeries": {
                                            "description": "How many time series to allow to pass through the filter.",
                                            "type": "integer",
                                            "format": "int64"
                                          },
                                          "rankingMethod": {
                                            "description": "`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "secondaryAggregation": {
                                        "description": "Apply a second aggregation after the ratio is computed.",
                                        "type": "object",
                                        "properties": {
                                          "alignmentPeriod": {
                                            "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                            "type": "string"
                                          },
                                          "crossSeriesReducer": {
                                            "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                            "type": "string"
                                          },
                                          "groupByFields": {
                                            "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          },
                                          "perSeriesAligner": {
                                            "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "timeSeriesQueryLanguage": {
                                    "description": "A query used to fetch time series.",
                                    "type": "string"
                                  },
                                  "unitOverride": {
                                    "description": "The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.",
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "text": {
                            "description": "A raw string or markdown displaying textual content.",
                            "type": "object",
                            "properties": {
                              "content": {
                                "description": "The text content to be displayed.",
                                "type": "string"
                              },
                              "format": {
                                "description": "How the text content is formatted. Possible values: FORMAT_UNSPECIFIED, MARKDOWN, RAW",
                                "type": "string"
                              }
                            }
                          },
                          "title": {
                            "description": "Optional. The title of the widget.",
                            "type": "string"
                          },
                          "xyChart": {
                            "description": "A chart of time series data.",
                            "type": "object",
                            "required": ["dataSets"],
                            "properties": {
                              "chartOptions": {
                                "description": "Display options for the chart.",
                                "type": "object",
                                "properties": {
                                  "mode": {
                                    "description": "The chart mode. Possible values: MODE_UNSPECIFIED, COLOR, X_RAY, STATS",
                                    "type": "string"
                                  }
                                }
                              },
                              "dataSets": {
                                "description": "Required. The data displayed in this chart.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "required": ["timeSeriesQuery"],
                                  "properties": {
                                    "legendTemplate": {
                                      "description": "A template string for naming `TimeSeries` in the resulting data set. This should be a string with interpolations of the form `${label_name}`, which will resolve to the label's value. ",
                                      "type": "string"
                                    },
                                    "minAlignmentPeriod": {
                                      "description": "Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the `min_alignment_period` should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.",
                                      "type": "string"
                                    },
                                    "plotType": {
                                      "description": "How this data should be plotted on the chart. Possible values: PLOT_TYPE_UNSPECIFIED, LINE, STACKED_AREA, STACKED_BAR, HEATMAP",
                                      "type": "string"
                                    },
                                    "timeSeriesQuery": {
                                      "description": "Required. Fields for querying time series data from the Stackdriver metrics API.",
                                      "type": "object",
                                      "properties": {
                                        "timeSeriesFilter": {
                                          "description": "Filter parameters to fetch time series.",
                                          "type": "object",
                                          "required": ["filter"],
                                          "properties": {
                                            "aggregation": {
                                              "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                              "type": "object",
                                              "properties": {
                                                "alignmentPeriod": {
                                                  "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                  "type": "string"
                                                },
                                                "crossSeriesReducer": {
                                                  "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                  "type": "string"
                                                },
                                                "groupByFields": {
                                                  "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  }
                                                },
                                                "perSeriesAligner": {
                                                  "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "filter": {
                                              "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                              "type": "string"
                                            },
                                            "pickTimeSeriesFilter": {
                                              "description": "Ranking based time series filter.",
                                              "type": "object",
                                              "properties": {
                                                "direction": {
                                                  "description": "How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM",
                                                  "type": "string"
                                                },
                                                "numTimeSeries": {
                                                  "description": "How many time series to allow to pass through the filter.",
                                                  "type": "integer",
                                                  "format": "int64"
                                                },
                                                "rankingMethod": {
                                                  "description": "`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST",
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "secondaryAggregation": {
                                              "description": "Apply a second aggregation after `aggregation` is applied.",
                                              "type": "object",
                                              "properties": {
                                                "alignmentPeriod": {
                                                  "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                  "type": "string"
                                                },
                                                "crossSeriesReducer": {
                                                  "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                  "type": "string"
                                                },
                                                "groupByFields": {
                                                  "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  }
                                                },
                                                "perSeriesAligner": {
                                                  "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                  "type": "string"
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "timeSeriesFilterRatio": {
                                          "description": "Parameters to fetch a ratio between two time series filters.",
                                          "type": "object",
                                          "properties": {
                                            "denominator": {
                                              "description": "The denominator of the ratio.",
                                              "type": "object",
                                              "required": ["filter"],
                                              "properties": {
                                                "aggregation": {
                                                  "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                                  "type": "object",
                                                  "properties": {
                                                    "alignmentPeriod": {
                                                      "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                      "type": "string"
                                                    },
                                                    "crossSeriesReducer": {
                                                      "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                      "type": "string"
                                                    },
                                                    "groupByFields": {
                                                      "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                      "type": "array",
                                                      "items": {
                                                        "type": "string"
                                                      }
                                                    },
                                                    "perSeriesAligner": {
                                                      "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                      "type": "string"
                                                    }
                                                  }
                                                },
                                                "filter": {
                                                  "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "numerator": {
                                              "description": "The numerator of the ratio.",
                                              "type": "object",
                                              "required": ["filter"],
                                              "properties": {
                                                "aggregation": {
                                                  "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                                  "type": "object",
                                                  "properties": {
                                                    "alignmentPeriod": {
                                                      "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                      "type": "string"
                                                    },
                                                    "crossSeriesReducer": {
                                                      "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                      "type": "string"
                                                    },
                                                    "groupByFields": {
                                                      "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                      "type": "array",
                                                      "items": {
                                                        "type": "string"
                                                      }
                                                    },
                                                    "perSeriesAligner": {
                                                      "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                      "type": "string"
                                                    }
                                                  }
                                                },
                                                "filter": {
                                                  "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "pickTimeSeriesFilter": {
                                              "description": "Ranking based time series filter.",
                                              "type": "object",
                                              "properties": {
                                                "direction": {
                                                  "description": "How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM",
                                                  "type": "string"
                                                },
                                                "numTimeSeries": {
                                                  "description": "How many time series to allow to pass through the filter.",
                                                  "type": "integer",
                                                  "format": "int64"
                                                },
                                                "rankingMethod": {
                                                  "description": "`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST",
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "secondaryAggregation": {
                                              "description": "Apply a second aggregation after the ratio is computed.",
                                              "type": "object",
                                              "properties": {
                                                "alignmentPeriod": {
                                                  "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                  "type": "string"
                                                },
                                                "crossSeriesReducer": {
                                                  "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                  "type": "string"
                                                },
                                                "groupByFields": {
                                                  "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  }
                                                },
                                                "perSeriesAligner": {
                                                  "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                  "type": "string"
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "timeSeriesQueryLanguage": {
                                          "description": "A query used to fetch time series.",
                                          "type": "string"
                                        },
                                        "unitOverride": {
                                          "description": "The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.",
                                          "type": "string"
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "thresholds": {
                                "description": "Threshold lines drawn horizontally across the chart.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "color": {
                                      "description": "The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED",
                                      "type": "string"
                                    },
                                    "direction": {
                                      "description": "The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW",
                                      "type": "string"
                                    },
                                    "label": {
                                      "description": "A label for the threshold.",
                                      "type": "string"
                                    },
                                    "value": {
                                      "description": "The value of the threshold. The value should be defined in the native scale of the metric.",
                                      "type": "number",
                                      "format": "double"
                                    }
                                  }
                                }
                              },
                              "timeshiftDuration": {
                                "description": "The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.",
                                "type": "string"
                              },
                              "xAxis": {
                                "description": "The properties applied to the X axis.",
                                "type": "object",
                                "properties": {
                                  "label": {
                                    "description": "The label of the axis.",
                                    "type": "string"
                                  },
                                  "scale": {
                                    "description": "The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10",
                                    "type": "string"
                                  }
                                }
                              },
                              "yAxis": {
                                "description": "The properties applied to the Y axis.",
                                "type": "object",
                                "properties": {
                                  "label": {
                                    "description": "The label of the axis.",
                                    "type": "string"
                                  },
                                  "scale": {
                                    "description": "The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10",
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "width": {
                        "description": "The width of the tile, measured in grid squares.",
                        "type": "integer",
                        "format": "int64"
                      },
                      "xPos": {
                        "description": "The zero-indexed position of the tile in grid squares relative to the left edge of the grid.",
                        "type": "integer",
                        "format": "int64"
                      },
                      "yPos": {
                        "description": "The zero-indexed position of the tile in grid squares relative to the top edge of the grid.",
                        "type": "integer",
                        "format": "int64"
                      }
                    }
                  }
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project id of the resource.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "rowLayout": {
              "description": "The content is divided into equally spaced rows and the widgets are arranged horizontally.",
              "type": "object",
              "properties": {
                "rows": {
                  "description": "The rows of content to display.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "weight": {
                        "description": "The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.",
                        "type": "integer",
                        "format": "int64"
                      },
                      "widgets": {
                        "description": "The display widgets arranged horizontally in this row.",
                        "type": "array",
                        "items": {
                          "description": "The informational widget contained in the tile.",
                          "type": "object",
                          "properties": {
                            "blank": {
                              "description": "A blank space.",
                              "x-kubernetes-preserve-unknown-fields": true
                            },
                            "scorecard": {
                              "description": "A scorecard summarizing time series data.",
                              "type": "object",
                              "required": ["timeSeriesQuery"],
                              "properties": {
                                "gaugeView": {
                                  "description": "Will cause the scorecard to show a gauge chart.",
                                  "type": "object",
                                  "properties": {
                                    "lowerBound": {
                                      "description": "The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.",
                                      "type": "number",
                                      "format": "double"
                                    },
                                    "upperBound": {
                                      "description": "The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.",
                                      "type": "number",
                                      "format": "double"
                                    }
                                  }
                                },
                                "sparkChartView": {
                                  "description": "Will cause the scorecard to show a spark chart.",
                                  "type": "object",
                                  "required": ["sparkChartType"],
                                  "properties": {
                                    "minAlignmentPeriod": {
                                      "description": "The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.",
                                      "type": "string"
                                    },
                                    "sparkChartType": {
                                      "description": "Required. The type of sparkchart to show in this chartView. Possible values: SPARK_CHART_TYPE_UNSPECIFIED, SPARK_LINE, SPARK_BAR",
                                      "type": "string"
                                    }
                                  }
                                },
                                "thresholds": {
                                  "description": "The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.",
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "color": {
                                        "description": "The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED",
                                        "type": "string"
                                      },
                                      "direction": {
                                        "description": "The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW",
                                        "type": "string"
                                      },
                                      "label": {
                                        "description": "A label for the threshold.",
                                        "type": "string"
                                      },
                                      "value": {
                                        "description": "The value of the threshold. The value should be defined in the native scale of the metric.",
                                        "type": "number",
                                        "format": "double"
                                      }
                                    }
                                  }
                                },
                                "timeSeriesQuery": {
                                  "description": "Required. Fields for querying time series data from the Stackdriver metrics API.",
                                  "type": "object",
                                  "properties": {
                                    "timeSeriesFilter": {
                                      "description": "Filter parameters to fetch time series.",
                                      "type": "object",
                                      "required": ["filter"],
                                      "properties": {
                                        "aggregation": {
                                          "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                          "type": "object",
                                          "properties": {
                                            "alignmentPeriod": {
                                              "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                              "type": "string"
                                            },
                                            "crossSeriesReducer": {
                                              "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                              "type": "string"
                                            },
                                            "groupByFields": {
                                              "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "perSeriesAligner": {
                                              "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "filter": {
                                          "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                          "type": "string"
                                        },
                                        "pickTimeSeriesFilter": {
                                          "description": "Ranking based time series filter.",
                                          "type": "object",
                                          "properties": {
                                            "direction": {
                                              "description": "How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM",
                                              "type": "string"
                                            },
                                            "numTimeSeries": {
                                              "description": "How many time series to allow to pass through the filter.",
                                              "type": "integer",
                                              "format": "int64"
                                            },
                                            "rankingMethod": {
                                              "description": "`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "secondaryAggregation": {
                                          "description": "Apply a second aggregation after `aggregation` is applied.",
                                          "type": "object",
                                          "properties": {
                                            "alignmentPeriod": {
                                              "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                              "type": "string"
                                            },
                                            "crossSeriesReducer": {
                                              "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                              "type": "string"
                                            },
                                            "groupByFields": {
                                              "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "perSeriesAligner": {
                                              "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "timeSeriesFilterRatio": {
                                      "description": "Parameters to fetch a ratio between two time series filters.",
                                      "type": "object",
                                      "properties": {
                                        "denominator": {
                                          "description": "The denominator of the ratio.",
                                          "type": "object",
                                          "required": ["filter"],
                                          "properties": {
                                            "aggregation": {
                                              "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                              "type": "object",
                                              "properties": {
                                                "alignmentPeriod": {
                                                  "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                  "type": "string"
                                                },
                                                "crossSeriesReducer": {
                                                  "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                  "type": "string"
                                                },
                                                "groupByFields": {
                                                  "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  }
                                                },
                                                "perSeriesAligner": {
                                                  "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "filter": {
                                              "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "numerator": {
                                          "description": "The numerator of the ratio.",
                                          "type": "object",
                                          "required": ["filter"],
                                          "properties": {
                                            "aggregation": {
                                              "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                              "type": "object",
                                              "properties": {
                                                "alignmentPeriod": {
                                                  "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                  "type": "string"
                                                },
                                                "crossSeriesReducer": {
                                                  "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                  "type": "string"
                                                },
                                                "groupByFields": {
                                                  "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  }
                                                },
                                                "perSeriesAligner": {
                                                  "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "filter": {
                                              "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "pickTimeSeriesFilter": {
                                          "description": "Ranking based time series filter.",
                                          "type": "object",
                                          "properties": {
                                            "direction": {
                                              "description": "How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM",
                                              "type": "string"
                                            },
                                            "numTimeSeries": {
                                              "description": "How many time series to allow to pass through the filter.",
                                              "type": "integer",
                                              "format": "int64"
                                            },
                                            "rankingMethod": {
                                              "description": "`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "secondaryAggregation": {
                                          "description": "Apply a second aggregation after the ratio is computed.",
                                          "type": "object",
                                          "properties": {
                                            "alignmentPeriod": {
                                              "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                              "type": "string"
                                            },
                                            "crossSeriesReducer": {
                                              "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                              "type": "string"
                                            },
                                            "groupByFields": {
                                              "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            },
                                            "perSeriesAligner": {
                                              "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "timeSeriesQueryLanguage": {
                                      "description": "A query used to fetch time series.",
                                      "type": "string"
                                    },
                                    "unitOverride": {
                                      "description": "The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "text": {
                              "description": "A raw string or markdown displaying textual content.",
                              "type": "object",
                              "properties": {
                                "content": {
                                  "description": "The text content to be displayed.",
                                  "type": "string"
                                },
                                "format": {
                                  "description": "How the text content is formatted. Possible values: FORMAT_UNSPECIFIED, MARKDOWN, RAW",
                                  "type": "string"
                                }
                              }
                            },
                            "title": {
                              "description": "Optional. The title of the widget.",
                              "type": "string"
                            },
                            "xyChart": {
                              "description": "A chart of time series data.",
                              "type": "object",
                              "required": ["dataSets"],
                              "properties": {
                                "chartOptions": {
                                  "description": "Display options for the chart.",
                                  "type": "object",
                                  "properties": {
                                    "mode": {
                                      "description": "The chart mode. Possible values: MODE_UNSPECIFIED, COLOR, X_RAY, STATS",
                                      "type": "string"
                                    }
                                  }
                                },
                                "dataSets": {
                                  "description": "Required. The data displayed in this chart.",
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "required": ["timeSeriesQuery"],
                                    "properties": {
                                      "legendTemplate": {
                                        "description": "A template string for naming `TimeSeries` in the resulting data set. This should be a string with interpolations of the form `${label_name}`, which will resolve to the label's value. ",
                                        "type": "string"
                                      },
                                      "minAlignmentPeriod": {
                                        "description": "Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the `min_alignment_period` should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.",
                                        "type": "string"
                                      },
                                      "plotType": {
                                        "description": "How this data should be plotted on the chart. Possible values: PLOT_TYPE_UNSPECIFIED, LINE, STACKED_AREA, STACKED_BAR, HEATMAP",
                                        "type": "string"
                                      },
                                      "timeSeriesQuery": {
                                        "description": "Required. Fields for querying time series data from the Stackdriver metrics API.",
                                        "type": "object",
                                        "properties": {
                                          "timeSeriesFilter": {
                                            "description": "Filter parameters to fetch time series.",
                                            "type": "object",
                                            "required": ["filter"],
                                            "properties": {
                                              "aggregation": {
                                                "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                                "type": "object",
                                                "properties": {
                                                  "alignmentPeriod": {
                                                    "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                    "type": "string"
                                                  },
                                                  "crossSeriesReducer": {
                                                    "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                    "type": "string"
                                                  },
                                                  "groupByFields": {
                                                    "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                    "type": "array",
                                                    "items": {
                                                      "type": "string"
                                                    }
                                                  },
                                                  "perSeriesAligner": {
                                                    "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                    "type": "string"
                                                  }
                                                }
                                              },
                                              "filter": {
                                                "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                                "type": "string"
                                              },
                                              "pickTimeSeriesFilter": {
                                                "description": "Ranking based time series filter.",
                                                "type": "object",
                                                "properties": {
                                                  "direction": {
                                                    "description": "How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM",
                                                    "type": "string"
                                                  },
                                                  "numTimeSeries": {
                                                    "description": "How many time series to allow to pass through the filter.",
                                                    "type": "integer",
                                                    "format": "int64"
                                                  },
                                                  "rankingMethod": {
                                                    "description": "`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST",
                                                    "type": "string"
                                                  }
                                                }
                                              },
                                              "secondaryAggregation": {
                                                "description": "Apply a second aggregation after `aggregation` is applied.",
                                                "type": "object",
                                                "properties": {
                                                  "alignmentPeriod": {
                                                    "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                    "type": "string"
                                                  },
                                                  "crossSeriesReducer": {
                                                    "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                    "type": "string"
                                                  },
                                                  "groupByFields": {
                                                    "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                    "type": "array",
                                                    "items": {
                                                      "type": "string"
                                                    }
                                                  },
                                                  "perSeriesAligner": {
                                                    "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                    "type": "string"
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          "timeSeriesFilterRatio": {
                                            "description": "Parameters to fetch a ratio between two time series filters.",
                                            "type": "object",
                                            "properties": {
                                              "denominator": {
                                                "description": "The denominator of the ratio.",
                                                "type": "object",
                                                "required": ["filter"],
                                                "properties": {
                                                  "aggregation": {
                                                    "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                                    "type": "object",
                                                    "properties": {
                                                      "alignmentPeriod": {
                                                        "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                        "type": "string"
                                                      },
                                                      "crossSeriesReducer": {
                                                        "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                        "type": "string"
                                                      },
                                                      "groupByFields": {
                                                        "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                        "type": "array",
                                                        "items": {
                                                          "type": "string"
                                                        }
                                                      },
                                                      "perSeriesAligner": {
                                                        "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "filter": {
                                                    "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                                    "type": "string"
                                                  }
                                                }
                                              },
                                              "numerator": {
                                                "description": "The numerator of the ratio.",
                                                "type": "object",
                                                "required": ["filter"],
                                                "properties": {
                                                  "aggregation": {
                                                    "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
                                                    "type": "object",
                                                    "properties": {
                                                      "alignmentPeriod": {
                                                        "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                        "type": "string"
                                                      },
                                                      "crossSeriesReducer": {
                                                        "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                        "type": "string"
                                                      },
                                                      "groupByFields": {
                                                        "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                        "type": "array",
                                                        "items": {
                                                          "type": "string"
                                                        }
                                                      },
                                                      "perSeriesAligner": {
                                                        "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                        "type": "string"
                                                      }
                                                    }
                                                  },
                                                  "filter": {
                                                    "description": "Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.",
                                                    "type": "string"
                                                  }
                                                }
                                              },
                                              "pickTimeSeriesFilter": {
                                                "description": "Ranking based time series filter.",
                                                "type": "object",
                                                "properties": {
                                                  "direction": {
                                                    "description": "How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM",
                                                    "type": "string"
                                                  },
                                                  "numTimeSeries": {
                                                    "description": "How many time series to allow to pass through the filter.",
                                                    "type": "integer",
                                                    "format": "int64"
                                                  },
                                                  "rankingMethod": {
                                                    "description": "`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST",
                                                    "type": "string"
                                                  }
                                                }
                                              },
                                              "secondaryAggregation": {
                                                "description": "Apply a second aggregation after the ratio is computed.",
                                                "type": "object",
                                                "properties": {
                                                  "alignmentPeriod": {
                                                    "description": "The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.",
                                                    "type": "string"
                                                  },
                                                  "crossSeriesReducer": {
                                                    "description": "The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION",
                                                    "type": "string"
                                                  },
                                                  "groupByFields": {
                                                    "description": "The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.",
                                                    "type": "array",
                                                    "items": {
                                                      "type": "string"
                                                    }
                                                  },
                                                  "perSeriesAligner": {
                                                    "description": "An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.",
                                                    "type": "string"
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          "timeSeriesQueryLanguage": {
                                            "description": "A query used to fetch time series.",
                                            "type": "string"
                                          },
                                          "unitOverride": {
                                            "description": "The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "thresholds": {
                                  "description": "Threshold lines drawn horizontally across the chart.",
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "color": {
                                        "description": "The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED",
                                        "type": "string"
                                      },
                                      "direction": {
                                        "description": "The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW",
                                        "type": "string"
                                      },
                                      "label": {
                                        "description": "A label for the threshold.",
                                        "type": "string"
                                      },
                                      "value": {
                                        "description": "The value of the threshold. The value should be defined in the native scale of the metric.",
                                        "type": "number",
                                        "format": "double"
                                      }
                                    }
                                  }
                                },
                                "timeshiftDuration": {
                                  "description": "The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.",
                                  "type": "string"
                                },
                                "xAxis": {
                                  "description": "The properties applied to the X axis.",
                                  "type": "object",
                                  "properties": {
                                    "label": {
                                      "description": "The label of the axis.",
                                      "type": "string"
                                    },
                                    "scale": {
                                      "description": "The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10",
                                      "type": "string"
                                    }
                                  }
                                },
                                "yAxis": {
                                  "description": "The properties applied to the Y axis.",
                                  "type": "object",
                                  "properties": {
                                    "label": {
                                      "description": "The label of the axis.",
                                      "type": "string"
                                    },
                                    "scale": {
                                      "description": "The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "etag": {
              "description": "\\`etag\\` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. An \\`etag\\` is returned in the response to \\`GetDashboard\\`, and users are expected to put that etag in the request to \\`UpdateDashboard\\` to ensure that their change will be applied to the same version of the Dashboard configuration. The field should not be passed during dashboard creation.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "monitoring.cnrm.cloud.google.com",
          "kind": "MonitoringDashboard",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.monitoring.v1beta1.MonitoringDashboardList": {
      "description": "MonitoringDashboardList is a list of MonitoringDashboard",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["monitoring.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of monitoringdashboards. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.monitoring.v1beta1.MonitoringDashboard"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MonitoringDashboardList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "monitoring.cnrm.cloud.google.com",
          "kind": "MonitoringDashboardList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.monitoring.v1beta1.MonitoringGroup": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["monitoring.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MonitoringGroup"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["displayName", "filter"],
          "properties": {
            "displayName": {
              "description": "A user-assigned name for this group, used only for display purposes.",
              "type": "string"
            },
            "filter": {
              "description": "The filter used to determine which monitored resources belong to this group.",
              "type": "string"
            },
            "isCluster": {
              "description": "If true, the members of this group are considered to be a cluster. The system can perform additional analysis on groups that are clusters.",
              "type": "boolean"
            },
            "parentRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of the group's parent, if it has one. The format is: projects/ For groups with no parent, `parent_name` is the empty string, ``.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project of the group",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "monitoring.cnrm.cloud.google.com",
          "kind": "MonitoringGroup",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.monitoring.v1beta1.MonitoringGroupList": {
      "description": "MonitoringGroupList is a list of MonitoringGroup",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["monitoring.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of monitoringgroups. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.monitoring.v1beta1.MonitoringGroup"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MonitoringGroupList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "monitoring.cnrm.cloud.google.com",
          "kind": "MonitoringGroupList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.monitoring.v1beta1.MonitoringMetricDescriptor": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["monitoring.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MonitoringMetricDescriptor"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["metricKind", "projectRef", "type", "valueType"],
          "properties": {
            "description": {
              "description": "A detailed description of the metric, which can be used in documentation.",
              "type": "string"
            },
            "displayName": {
              "description": "A concise name for the metric, which can be displayed in user interfaces. Use sentence case without an ending period, for example \"Request count\". This field is optional but it is recommended to be set for any metrics associated with user-visible concepts, such as Quota.",
              "type": "string"
            },
            "labels": {
              "description": "The set of labels that can be used to describe a specific instance of this metric type. For example, the `appengine.googleapis.com/http/server/response_latencies` metric type has a label for the HTTP response code, `response_code`, so you can look at latencies for successful responses or just for responses that failed.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "description": {
                    "description": "A human-readable description for the label.",
                    "type": "string"
                  },
                  "key": {
                    "description": "The key for this label. The key must meet the following criteria: * Does not exceed 100 characters. * Matches the following regular expression: `a-zA-Z*` * The first character must be an upper- or lower-case letter. * The remaining characters must be letters, digits, or underscores.",
                    "type": "string"
                  },
                  "valueType": {
                    "description": "The type of data that can be assigned to the label. Possible values: STRING, BOOL, INT64",
                    "type": "string"
                  }
                }
              }
            },
            "launchStage": {
              "description": "Optional. The launch stage of the metric definition. Possible values: LAUNCH_STAGE_UNSPECIFIED, UNIMPLEMENTED, PRELAUNCH, EARLY_ACCESS, ALPHA, BETA, GA, DEPRECATED",
              "type": "string"
            },
            "metadata": {
              "description": "Optional. Metadata which can be used to guide usage of the metric.",
              "type": "object",
              "properties": {
                "ingestDelay": {
                  "description": "The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.",
                  "type": "string"
                },
                "launchStage": {
                  "description": "Deprecated. Must use the MetricDescriptor.launch_stage instead. Possible values: LAUNCH_STAGE_UNSPECIFIED, UNIMPLEMENTED, PRELAUNCH, EARLY_ACCESS, ALPHA, BETA, GA, DEPRECATED",
                  "type": "string"
                },
                "samplePeriod": {
                  "description": "The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.",
                  "type": "string"
                }
              }
            },
            "metricKind": {
              "description": "Whether the metric records instantaneous values, changes to a value, etc. Some combinations of `metric_kind` and `value_type` might not be supported. Possible values: METRIC_KIND_UNSPECIFIED, GAUGE, DELTA, CUMULATIVE",
              "type": "string"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "type": {
              "description": "The metric type, including its DNS name prefix. The type is not URL-encoded. All user-defined metric types have the DNS name `custom.googleapis.com` or `external.googleapis.com`. Metric types should use a natural hierarchical grouping. For example: \"custom.googleapis.com/invoice/paid/amount\" \"external.googleapis.com/prometheus/up\" \"appengine.googleapis.com/http/server/response_latencies\"",
              "type": "string"
            },
            "unit": {
              "description": "The units in which the metric value is reported. It is only applicable if the `value_type` is `INT64`, `DOUBLE`, or `DISTRIBUTION`. The `unit` defines the representation of the stored metric values. Different systems might scale the values to be more easily displayed (so a value of `0.02kBy` _might_ be displayed as `20By`, and a value of `3523kBy` _might_ be displayed as `3.5MBy`). However, if the `unit` is `kBy`, then the value of the metric is always in thousands of bytes, no matter how it might be displayed. If you want a custom metric to record the exact number of CPU-seconds used by a job, you can create an `INT64 CUMULATIVE` metric whose `unit` is `s{CPU}` (or equivalently `1s{CPU}` or just `s`). If the job uses 12,005 CPU-seconds, then the value is written as `12005`. Alternatively, if you want a custom metric to record data in a more granular way, you can create a `DOUBLE CUMULATIVE` metric whose `unit` is `ks{CPU}`, and then write the value `12.005` (which is `12005/1000`), or use `Kis{CPU}` and write `11.723` (which is `12005/1024`). The supported units are a subset of [The Unified Code for Units of Measure](https://unitsofmeasure.org/ucum.html) standard: **Basic units (UNIT)** * `bit` bit * `By` byte * `s` second * `min` minute * `h` hour * `d` day * `1` dimensionless **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `E` exa (10^18) * `Z` zetta (10^21) * `Y` yotta (10^24) * `m` milli (10^-3) * `u` micro (10^-6) * `n` nano (10^-9) * `p` pico (10^-12) * `f` femto (10^-15) * `a` atto (10^-18) * `z` zepto (10^-21) * `y` yocto (10^-24) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For examples, `kBy/{email}` or `MiBy/10ms` (although you should almost never have `/s` in a metric `unit`; rates should always be computed at query time from the underlying cumulative or delta value). * `.` multiplication or composition (as an infix operator). For examples, `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: Expression = Component: { \".\" Component } { \"/\" Component } ; Component = ( [ PREFIX ] UNIT | \"%\" ) [ Annotation ] | Annotation | \"1\" ; Annotation = \"{\" NAME \"}\" ; Notes: * `Annotation` is just a comment if it follows a `UNIT`. If the annotation is used alone, then the unit is equivalent to `1`. For examples, `{request}/s == 1/s`, `By{transmitted}/s == By/s`. * `NAME` is a sequence of non-blank printable ASCII characters not containing `{` or `}`. * `1` represents a unitary [dimensionless unit](https://en.wikipedia.org/wiki/Dimensionless_quantity) of 1, such as in `1/s`. It is typically used when none of the basic units are appropriate. For example, \"new users per day\" can be represented as `1/d` or `{new-users}/d` (and a metric value `5` would mean \"5 new users). Alternatively, \"thousands of page views per day\" would be represented as `1000/d` or `k1/d` or `k{page_views}/d` (and a metric value of `5.3` would mean \"5300 page views per day\"). * `%` represents dimensionless value of 1/100, and annotates values giving a percentage (so the metric values are typically in the range of 0..100, and a metric value `3` means \"3 percent\"). * `10^2.%` indicates a metric contains a ratio, typically in the range 0..1, that will be multiplied by 100 and displayed as a percentage (so a metric value `0.03` means \"3 percent\").",
              "type": "string"
            },
            "valueType": {
              "description": "Whether the measurement is an integer, a floating-point number, etc. Some combinations of `metric_kind` and `value_type` might not be supported. Possible values: STRING, BOOL, INT64",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "monitoredResourceTypes": {
              "description": "Read-only. If present, then a time series, which is identified partially by a metric type and a MonitoredResourceDescriptor, that is associated with this metric type can only be associated with one of the monitored resource types listed here.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "description": "The resource name of the metric descriptor.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "monitoring.cnrm.cloud.google.com",
          "kind": "MonitoringMetricDescriptor",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.monitoring.v1beta1.MonitoringMetricDescriptorList": {
      "description": "MonitoringMetricDescriptorList is a list of MonitoringMetricDescriptor",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["monitoring.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of monitoringmetricdescriptors. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.monitoring.v1beta1.MonitoringMetricDescriptor"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MonitoringMetricDescriptorList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "monitoring.cnrm.cloud.google.com",
          "kind": "MonitoringMetricDescriptorList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.monitoring.v1beta1.MonitoringNotificationChannel": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["monitoring.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MonitoringNotificationChannel"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["type"],
          "properties": {
            "description": {
              "description": "An optional human-readable description of this notification channel. This description may provide additional details, beyond the display name, for the channel. This may not exceed 1024 Unicode characters.",
              "type": "string"
            },
            "enabled": {
              "description": "Whether notifications are forwarded to the described channel. This makes it possible to disable delivery of notifications to a particular channel without removing the channel from all alerting policies that reference the channel. This is a more convenient approach when the change is temporary and you want to receive notifications from the same set of alerting policies on the channel at some point in the future.",
              "type": "boolean"
            },
            "labels": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            },
            "sensitiveLabels": {
              "description": "Different notification type behaviors are configured primarily using the the 'labels' field on this\nresource. This block contains the labels which contain secrets or passwords so that they can be marked\nsensitive and hidden from plan output. The name of the field, eg: password, will be the key\nin the 'labels' map in the api request.\n\nCredentials may not be specified in both locations and will cause an error. Changing from one location\nto a different credential configuration in the config will require an apply to update state.",
              "type": "object",
              "properties": {
                "authToken": {
                  "description": "An authorization token for a notification channel. Channel types that support this field include: slack.",
                  "type": "object",
                  "properties": {
                    "value": {
                      "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                      "type": "string"
                    },
                    "valueFrom": {
                      "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                      "type": "object",
                      "properties": {
                        "secretKeyRef": {
                          "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                          "type": "object",
                          "required": ["name", "key"],
                          "properties": {
                            "key": {
                              "description": "Key that identifies the value to be extracted.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the Secret to extract a value from.",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "password": {
                  "description": "An password for a notification channel. Channel types that support this field include: webhook_basicauth.",
                  "type": "object",
                  "properties": {
                    "value": {
                      "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                      "type": "string"
                    },
                    "valueFrom": {
                      "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                      "type": "object",
                      "properties": {
                        "secretKeyRef": {
                          "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                          "type": "object",
                          "required": ["name", "key"],
                          "properties": {
                            "key": {
                              "description": "Key that identifies the value to be extracted.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the Secret to extract a value from.",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "serviceKey": {
                  "description": "An servicekey token for a notification channel. Channel types that support this field include: pagerduty.",
                  "type": "object",
                  "properties": {
                    "value": {
                      "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                      "type": "string"
                    },
                    "valueFrom": {
                      "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                      "type": "object",
                      "properties": {
                        "secretKeyRef": {
                          "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                          "type": "object",
                          "required": ["name", "key"],
                          "properties": {
                            "key": {
                              "description": "Key that identifies the value to be extracted.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the Secret to extract a value from.",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "type": {
              "description": "The type of the notification channel. This field matches the value of the NotificationChannelDescriptor.type field. See https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.notificationChannelDescriptors/list to get the list of valid values such as \"email\", \"slack\", etc...",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "name": {
              "description": "The full REST resource name for this channel. The syntax is:\nprojects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID]\nThe [CHANNEL_ID] is automatically assigned by the server on creation.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "verificationStatus": {
              "description": "Indicates whether this channel has been verified or not. On a ListNotificationChannels or GetNotificationChannel operation, this field is expected to be populated.If the value is UNVERIFIED, then it indicates that the channel is non-functioning (it both requires verification and lacks verification); otherwise, it is assumed that the channel works.If the channel is neither VERIFIED nor UNVERIFIED, it implies that the channel is of a type that does not require verification or that this specific channel has been exempted from verification because it was created prior to verification being required for channels of this type.This field cannot be modified using a standard UpdateNotificationChannel operation. To change the value of this field, you must call VerifyNotificationChannel.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "monitoring.cnrm.cloud.google.com",
          "kind": "MonitoringNotificationChannel",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.monitoring.v1beta1.MonitoringNotificationChannelList": {
      "description": "MonitoringNotificationChannelList is a list of MonitoringNotificationChannel",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["monitoring.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of monitoringnotificationchannels. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.monitoring.v1beta1.MonitoringNotificationChannel"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MonitoringNotificationChannelList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "monitoring.cnrm.cloud.google.com",
          "kind": "MonitoringNotificationChannelList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.monitoring.v1beta1.MonitoringService": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["monitoring.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MonitoringService"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["projectRef"],
          "properties": {
            "displayName": {
              "description": "Name used for UI elements listing this Service.",
              "type": "string"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "telemetry": {
              "description": "Configuration for how to query telemetry on a Service.",
              "type": "object",
              "properties": {
                "resourceName": {
                  "description": "The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "monitoring.cnrm.cloud.google.com",
          "kind": "MonitoringService",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.monitoring.v1beta1.MonitoringServiceLevelObjective": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["monitoring.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MonitoringServiceLevelObjective"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["goal", "projectRef", "serviceRef"],
          "properties": {
            "calendarPeriod": {
              "description": "A calendar period, semantically \"since the start of the current ``\". At this time, only `DAY`, `WEEK`, `FORTNIGHT`, and `MONTH` are supported. Possible values: CALENDAR_PERIOD_UNSPECIFIED, DAY, WEEK, FORTNIGHT, MONTH, QUARTER, HALF, YEAR",
              "type": "string"
            },
            "displayName": {
              "description": "Name used for UI elements listing this SLO.",
              "type": "string"
            },
            "goal": {
              "description": "The fraction of service that must be good in order for this objective to be met. `0 < goal <= 0.999`.",
              "type": "number",
              "format": "double"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "rollingPeriod": {
              "description": "A rolling time period, semantically \"in the past ``\". Must be an integer multiple of 1 day no larger than 30 days.",
              "type": "string"
            },
            "serviceLevelIndicator": {
              "description": "The definition of good service, used to measure and calculate the quality of the `Service`'s performance with respect to a single aspect of service quality.",
              "type": "object",
              "properties": {
                "basicSli": {
                  "description": "Basic SLI on a well-known service type.",
                  "type": "object",
                  "properties": {
                    "availability": {
                      "description": "Good service is defined to be the count of requests made to this service that return successfully.",
                      "x-kubernetes-preserve-unknown-fields": true
                    },
                    "latency": {
                      "description": "Good service is defined to be the count of requests made to this service that are fast enough with respect to `latency.threshold`.",
                      "type": "object",
                      "properties": {
                        "experience": {
                          "description": "A description of the experience associated with failing requests. Possible values: LATENCY_EXPERIENCE_UNSPECIFIED, DELIGHTING, SATISFYING, ANNOYING",
                          "type": "string"
                        },
                        "threshold": {
                          "description": "Good service is defined to be the count of requests made to this service that return in no more than `threshold`.",
                          "type": "string"
                        }
                      }
                    },
                    "location": {
                      "description": "OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "method": {
                      "description": "OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "operationAvailability": {
                      "description": "Good service is defined to be the count of operations performed by this service that return successfully",
                      "x-kubernetes-preserve-unknown-fields": true
                    },
                    "operationLatency": {
                      "description": "Good service is defined to be the count of operations performed by this service that are fast enough with respect to `operation_latency.threshold`.",
                      "type": "object",
                      "properties": {
                        "experience": {
                          "description": "A description of the experience associated with failing requests. Possible values: LATENCY_EXPERIENCE_UNSPECIFIED, DELIGHTING, SATISFYING, ANNOYING",
                          "type": "string"
                        },
                        "threshold": {
                          "description": "Good service is defined to be the count of operations that are completed in no more than `threshold`.",
                          "type": "string"
                        }
                      }
                    },
                    "version": {
                      "description": "OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                },
                "requestBased": {
                  "description": "Request-based SLIs",
                  "type": "object",
                  "properties": {
                    "distributionCut": {
                      "description": "`distribution_cut` is used when `good_service` is a count of values aggregated in a `Distribution` that fall into a good range. The `total_service` is the total count of all values aggregated in the `Distribution`.",
                      "type": "object",
                      "properties": {
                        "distributionFilter": {
                          "description": "A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` aggregating values. Must have `ValueType = DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.",
                          "type": "string"
                        },
                        "range": {
                          "description": "Range of values considered \"good.\" For a one-sided range, set one bound to an infinite value.",
                          "type": "object",
                          "properties": {
                            "max": {
                              "description": "Range maximum.",
                              "type": "number",
                              "format": "double"
                            },
                            "min": {
                              "description": "Range minimum.",
                              "type": "number",
                              "format": "double"
                            }
                          }
                        }
                      }
                    },
                    "goodTotalRatio": {
                      "description": "`good_total_ratio` is used when the ratio of `good_service` to `total_service` is computed from two `TimeSeries`.",
                      "type": "object",
                      "properties": {
                        "badServiceFilter": {
                          "description": "A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.",
                          "type": "string"
                        },
                        "goodServiceFilter": {
                          "description": "A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` quantifying good service provided. Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.",
                          "type": "string"
                        },
                        "totalServiceFilter": {
                          "description": "A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` quantifying total demanded service. Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "windowsBased": {
                  "description": "Windows-based SLIs",
                  "type": "object",
                  "properties": {
                    "goodBadMetricFilter": {
                      "description": "A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` with `ValueType = BOOL`. The window is good if any `true` values appear in the window.",
                      "type": "string"
                    },
                    "goodTotalRatioThreshold": {
                      "description": "A window is good if its `performance` is high enough.",
                      "type": "object",
                      "properties": {
                        "basicSliPerformance": {
                          "description": "`BasicSli` to evaluate to judge window quality.",
                          "type": "object",
                          "properties": {
                            "availability": {
                              "description": "Good service is defined to be the count of requests made to this service that return successfully.",
                              "x-kubernetes-preserve-unknown-fields": true
                            },
                            "latency": {
                              "description": "Good service is defined to be the count of requests made to this service that are fast enough with respect to `latency.threshold`.",
                              "type": "object",
                              "properties": {
                                "experience": {
                                  "description": "A description of the experience associated with failing requests. Possible values: LATENCY_EXPERIENCE_UNSPECIFIED, DELIGHTING, SATISFYING, ANNOYING",
                                  "type": "string"
                                },
                                "threshold": {
                                  "description": "Good service is defined to be the count of requests made to this service that return in no more than `threshold`.",
                                  "type": "string"
                                }
                              }
                            },
                            "location": {
                              "description": "OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "method": {
                              "description": "OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "operationAvailability": {
                              "description": "Good service is defined to be the count of operations performed by this service that return successfully",
                              "x-kubernetes-preserve-unknown-fields": true
                            },
                            "operationLatency": {
                              "description": "Good service is defined to be the count of operations performed by this service that are fast enough with respect to `operation_latency.threshold`.",
                              "type": "object",
                              "properties": {
                                "experience": {
                                  "description": "A description of the experience associated with failing requests. Possible values: LATENCY_EXPERIENCE_UNSPECIFIED, DELIGHTING, SATISFYING, ANNOYING",
                                  "type": "string"
                                },
                                "threshold": {
                                  "description": "Good service is defined to be the count of operations that are completed in no more than `threshold`.",
                                  "type": "string"
                                }
                              }
                            },
                            "version": {
                              "description": "OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        },
                        "performance": {
                          "description": "`RequestBasedSli` to evaluate to judge window quality.",
                          "type": "object",
                          "properties": {
                            "distributionCut": {
                              "description": "`distribution_cut` is used when `good_service` is a count of values aggregated in a `Distribution` that fall into a good range. The `total_service` is the total count of all values aggregated in the `Distribution`.",
                              "type": "object",
                              "properties": {
                                "distributionFilter": {
                                  "description": "A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` aggregating values. Must have `ValueType = DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.",
                                  "type": "string"
                                },
                                "range": {
                                  "description": "Range of values considered \"good.\" For a one-sided range, set one bound to an infinite value.",
                                  "type": "object",
                                  "properties": {
                                    "max": {
                                      "description": "Range maximum.",
                                      "type": "number",
                                      "format": "double"
                                    },
                                    "min": {
                                      "description": "Range minimum.",
                                      "type": "number",
                                      "format": "double"
                                    }
                                  }
                                }
                              }
                            },
                            "goodTotalRatio": {
                              "description": "`good_total_ratio` is used when the ratio of `good_service` to `total_service` is computed from two `TimeSeries`.",
                              "type": "object",
                              "properties": {
                                "badServiceFilter": {
                                  "description": "A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.",
                                  "type": "string"
                                },
                                "goodServiceFilter": {
                                  "description": "A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` quantifying good service provided. Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.",
                                  "type": "string"
                                },
                                "totalServiceFilter": {
                                  "description": "A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` quantifying total demanded service. Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.",
                                  "type": "string"
                                }
                              }
                            }
                          }
                        },
                        "threshold": {
                          "description": "If window `performance >= threshold`, the window is counted as good.",
                          "type": "number",
                          "format": "double"
                        }
                      }
                    },
                    "metricMeanInRange": {
                      "description": "A window is good if the metric's value is in a good range, averaged across returned streams.",
                      "type": "object",
                      "properties": {
                        "range": {
                          "description": "Range of values considered \"good.\" For a one-sided range, set one bound to an infinite value.",
                          "type": "object",
                          "properties": {
                            "max": {
                              "description": "Range maximum.",
                              "type": "number",
                              "format": "double"
                            },
                            "min": {
                              "description": "Range minimum.",
                              "type": "number",
                              "format": "double"
                            }
                          }
                        },
                        "timeSeries": {
                          "description": "A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying the `TimeSeries` to use for evaluating window quality.",
                          "type": "string"
                        }
                      }
                    },
                    "metricSumInRange": {
                      "description": "A window is good if the metric's value is in a good range, summed across returned streams.",
                      "type": "object",
                      "properties": {
                        "range": {
                          "description": "Range of values considered \"good.\" For a one-sided range, set one bound to an infinite value.",
                          "type": "object",
                          "properties": {
                            "max": {
                              "description": "Range maximum.",
                              "type": "number",
                              "format": "double"
                            },
                            "min": {
                              "description": "Range minimum.",
                              "type": "number",
                              "format": "double"
                            }
                          }
                        },
                        "timeSeries": {
                          "description": "A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying the `TimeSeries` to use for evaluating window quality.",
                          "type": "string"
                        }
                      }
                    },
                    "windowPeriod": {
                      "description": "Duration over which window quality is evaluated. Must be an integer fraction of a day and at least `60s`.",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "serviceRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The service for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Time stamp of the `Create` or most recent `Update` command on this `Slo`.",
              "type": "string",
              "format": "date-time"
            },
            "deleteTime": {
              "description": "Time stamp of the `Update` or `Delete` command that made this no longer a current `Slo`. This field is not populated in `ServiceLevelObjective`s returned from calls to `GetServiceLevelObjective` and `ListServiceLevelObjectives`, because it is always empty in the current version. It is populated in `ServiceLevelObjective`s representing previous versions in the output of `ListServiceLevelObjectiveVersions`. Because all old configuration versions are stored, `Update` operations mark the obsoleted version as deleted.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "serviceManagementOwned": {
              "description": "Output only. If set, this SLO is managed at the [Service Management](https://cloud.google.com/service-management/overview) level. Therefore the service yaml file is the source of truth for this SLO, and API `Update` and `Delete` operations are forbidden.",
              "type": "boolean"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "monitoring.cnrm.cloud.google.com",
          "kind": "MonitoringServiceLevelObjective",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.monitoring.v1beta1.MonitoringServiceLevelObjectiveList": {
      "description": "MonitoringServiceLevelObjectiveList is a list of MonitoringServiceLevelObjective",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["monitoring.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of monitoringservicelevelobjectives. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.monitoring.v1beta1.MonitoringServiceLevelObjective"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MonitoringServiceLevelObjectiveList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "monitoring.cnrm.cloud.google.com",
          "kind": "MonitoringServiceLevelObjectiveList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.monitoring.v1beta1.MonitoringServiceList": {
      "description": "MonitoringServiceList is a list of MonitoringService",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["monitoring.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of monitoringservices. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.monitoring.v1beta1.MonitoringService"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MonitoringServiceList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "monitoring.cnrm.cloud.google.com",
          "kind": "MonitoringServiceList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.monitoring.v1beta1.MonitoringUptimeCheckConfig": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["monitoring.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MonitoringUptimeCheckConfig"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["displayName", "projectRef", "timeout"],
          "properties": {
            "contentMatchers": {
              "description": "The content that is expected to appear in the data returned by the target server against which the check is run.  Currently, only the first entry in the `content_matchers` list is supported, and additional entries will be ignored. This field is optional and should only be specified if a content match is required as part of the/ Uptime check.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["content"],
                "properties": {
                  "content": {
                    "type": "string"
                  },
                  "matcher": {
                    "description": " Possible values: CONTENT_MATCHER_OPTION_UNSPECIFIED, CONTAINS_STRING, NOT_CONTAINS_STRING, MATCHES_REGEX, NOT_MATCHES_REGEX",
                    "type": "string"
                  }
                }
              }
            },
            "displayName": {
              "description": "A human-friendly name for the Uptime check configuration. The display name should be unique within a Stackdriver Workspace in order to make it easier to identify; however, uniqueness is not enforced. Required.",
              "type": "string"
            },
            "httpCheck": {
              "description": "Contains information needed to make an HTTP or HTTPS check.",
              "type": "object",
              "properties": {
                "authInfo": {
                  "description": "The authentication information. Optional when creating an HTTP check; defaults to empty.",
                  "type": "object",
                  "required": ["password", "username"],
                  "properties": {
                    "password": {
                      "type": "object",
                      "properties": {
                        "value": {
                          "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                          "type": "string"
                        },
                        "valueFrom": {
                          "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                          "type": "object",
                          "properties": {
                            "secretKeyRef": {
                              "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                              "type": "object",
                              "required": ["name", "key"],
                              "properties": {
                                "key": {
                                  "description": "Key that identifies the value to be extracted.",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the Secret to extract a value from.",
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "username": {
                      "type": "string"
                    }
                  }
                },
                "body": {
                  "description": "The request body associated with the HTTP POST request. If `content_type` is `URL_ENCODED`, the body passed in must be URL-encoded. Users can provide a `Content-Length` header via the `headers` field or the API will do so. If the `request_method` is `GET` and `body` is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note: As with all `bytes` fields JSON representations are base64 encoded. e.g.: \"foo=bar\" in URL-encoded form is \"foo%3Dbar\" and in base64 encoding is \"Zm9vJTI1M0RiYXI=\".",
                  "type": "string"
                },
                "contentType": {
                  "description": "The content type to use for the check.  Possible values: TYPE_UNSPECIFIED, URL_ENCODED",
                  "type": "string"
                },
                "headers": {
                  "description": "The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "maskHeaders": {
                  "description": "Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if `mask_headers` is set to `true` then the headers will be obscured with `******.`",
                  "type": "boolean"
                },
                "path": {
                  "description": "Optional (defaults to \"/\"). The path to the page against which to run the check. Will be combined with the `host` (specified within the `monitored_resource`) and `port` to construct the full URL. If the provided path does not begin with \"/\", a \"/\" will be prepended automatically.",
                  "type": "string"
                },
                "port": {
                  "description": "Optional (defaults to 80 when `use_ssl` is `false`, and 443 when `use_ssl` is `true`). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the `monitored_resource`) and `path` to construct the full URL.",
                  "type": "integer",
                  "format": "int64"
                },
                "requestMethod": {
                  "description": "The HTTP request method to use for the check. If set to `METHOD_UNSPECIFIED` then `request_method` defaults to `GET`.",
                  "type": "string"
                },
                "useSsl": {
                  "description": "If `true`, use HTTPS instead of HTTP to run the check.",
                  "type": "boolean"
                },
                "validateSsl": {
                  "description": "Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where `monitored_resource` is set to `uptime_url`. If `use_ssl` is `false`, setting `validate_ssl` to `true` has no effect.",
                  "type": "boolean"
                }
              }
            },
            "monitoredResource": {
              "description": "The [monitored resource](https://cloud.google.com/monitoring/api/resources) associated with the configuration. The following monitored resource types are supported for Uptime checks:   `uptime_url`,   `gce_instance`,   `gae_app`,   `aws_ec2_instance`,   `aws_elb_load_balancer`",
              "type": "object",
              "required": ["filterLabels", "type"],
              "properties": {
                "filterLabels": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "type": {
                  "type": "string"
                }
              }
            },
            "period": {
              "description": "How often, in seconds, the Uptime check is performed. Currently, the only supported values are `60s` (1 minute), `300s` (5 minutes), `600s` (10 minutes), and `900s` (15 minutes). Optional, defaults to `60s`.",
              "type": "string"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for this uptime check config.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceGroup": {
              "description": "The group resource associated with the configuration.",
              "type": "object",
              "properties": {
                "groupRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The group of resources being monitored. Should be only the `[GROUP_ID]`, and not the full-path `projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]`.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "resourceType": {
                  "description": "The resource type of the group members. Possible values: RESOURCE_TYPE_UNSPECIFIED, INSTANCE, AWS_ELB_LOAD_BALANCER",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            },
            "selectedRegions": {
              "description": "The list of regions from which the check will be run. Some regions contain one location, and others contain more than one. If this field is specified, enough regions must be provided to include a minimum of 3 locations.  Not specifying this field will result in Uptime checks running from all available regions.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "tcpCheck": {
              "description": "Contains information needed to make a TCP check.",
              "type": "object",
              "required": ["port"],
              "properties": {
                "port": {
                  "description": "The TCP port on the server against which to run the check. Will be combined with host (specified within the `monitored_resource`) to construct the full URL. Required.",
                  "type": "integer",
                  "format": "int64"
                }
              }
            },
            "timeout": {
              "description": "The maximum amount of time to wait for the request to complete (must be between 1 and 60 seconds). Required.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "monitoring.cnrm.cloud.google.com",
          "kind": "MonitoringUptimeCheckConfig",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.monitoring.v1beta1.MonitoringUptimeCheckConfigList": {
      "description": "MonitoringUptimeCheckConfigList is a list of MonitoringUptimeCheckConfig",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["monitoring.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of monitoringuptimecheckconfigs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.monitoring.v1beta1.MonitoringUptimeCheckConfig"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MonitoringUptimeCheckConfigList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "monitoring.cnrm.cloud.google.com",
          "kind": "MonitoringUptimeCheckConfigList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networkconnectivity.v1beta1.NetworkConnectivityHub": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networkconnectivity.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkConnectivityHub"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["projectRef"],
          "properties": {
            "description": {
              "description": "An optional description of the hub.",
              "type": "string"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The time the hub was created.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "routingVpcs": {
              "description": "The VPC network associated with this hub's spokes. All of the VPN tunnels, VLAN attachments, and router appliance instances referenced by this hub's spokes must belong to this VPC network. This field is read-only. Network Connectivity Center automatically populates it based on the set of spokes attached to the hub.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "uri": {
                    "description": "The URI of the VPC network.",
                    "type": "string"
                  }
                }
              }
            },
            "state": {
              "description": "Output only. The current lifecycle state of this hub. Possible values: STATE_UNSPECIFIED, CREATING, ACTIVE, DELETING",
              "type": "string"
            },
            "uniqueId": {
              "description": "Output only. The Google-generated UUID for the hub. This value is unique across all hub resources. If a hub is deleted and another with the same name is created, the new hub is assigned a different unique_id.",
              "type": "string"
            },
            "updateTime": {
              "description": "Output only. The time the hub was last updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networkconnectivity.cnrm.cloud.google.com",
          "kind": "NetworkConnectivityHub",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networkconnectivity.v1beta1.NetworkConnectivityHubList": {
      "description": "NetworkConnectivityHubList is a list of NetworkConnectivityHub",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networkconnectivity.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of networkconnectivityhubs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.networkconnectivity.v1beta1.NetworkConnectivityHub"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkConnectivityHubList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networkconnectivity.cnrm.cloud.google.com",
          "kind": "NetworkConnectivityHubList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networkconnectivity.v1beta1.NetworkConnectivitySpoke": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networkconnectivity.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkConnectivitySpoke"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["hubRef", "location", "projectRef"],
          "properties": {
            "description": {
              "description": "An optional description of the spoke.",
              "type": "string"
            },
            "hubRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "Immutable. The URI of the hub that this spoke is attached to.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "linkedInterconnectAttachments": {
              "description": "A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.",
              "type": "object",
              "required": ["siteToSiteDataTransfer", "uris"],
              "properties": {
                "siteToSiteDataTransfer": {
                  "description": "A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.",
                  "type": "boolean"
                },
                "uris": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "linkedRouterApplianceInstances": {
              "description": "The URIs of linked Router appliance resources",
              "type": "object",
              "required": ["instances", "siteToSiteDataTransfer"],
              "properties": {
                "instances": {
                  "description": "The list of router appliance instances",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "ipAddress": {
                        "description": "The IP address on the VM to use for peering.",
                        "type": "string"
                      },
                      "virtualMachineRef": {
                        "type": "object",
                        "properties": {
                          "external": {
                            "description": "The URI of the virtual machine resource",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                },
                "siteToSiteDataTransfer": {
                  "description": "A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.",
                  "type": "boolean"
                }
              }
            },
            "linkedVpnTunnels": {
              "description": "The URIs of linked VPN tunnel resources",
              "type": "object",
              "required": ["siteToSiteDataTransfer", "uris"],
              "properties": {
                "siteToSiteDataTransfer": {
                  "description": "A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.",
                  "type": "boolean"
                },
                "uris": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The time the spoke was created.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "state": {
              "description": "Output only. The current lifecycle state of this spoke. Possible values: STATE_UNSPECIFIED, CREATING, ACTIVE, DELETING",
              "type": "string"
            },
            "uniqueId": {
              "description": "Output only. The Google-generated UUID for the spoke. This value is unique across all spoke resources. If a spoke is deleted and another with the same name is created, the new spoke is assigned a different unique_id.",
              "type": "string"
            },
            "updateTime": {
              "description": "Output only. The time the spoke was last updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networkconnectivity.cnrm.cloud.google.com",
          "kind": "NetworkConnectivitySpoke",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networkconnectivity.v1beta1.NetworkConnectivitySpokeList": {
      "description": "NetworkConnectivitySpokeList is a list of NetworkConnectivitySpoke",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networkconnectivity.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of networkconnectivityspokes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.networkconnectivity.v1beta1.NetworkConnectivitySpoke"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkConnectivitySpokeList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networkconnectivity.cnrm.cloud.google.com",
          "kind": "NetworkConnectivitySpokeList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networksecurity.v1beta1.NetworkSecurityAuthorizationPolicy": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networksecurity.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkSecurityAuthorizationPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["action", "location", "projectRef"],
          "properties": {
            "action": {
              "description": "Required. The action to take when a rule match is found. Possible values are \"ALLOW\" or \"DENY\". Possible values: ACTION_UNSPECIFIED, ALLOW, DENY",
              "type": "string"
            },
            "description": {
              "description": "Optional. Free-text description of the resource.",
              "type": "string"
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "rules": {
              "description": "Optional. List of rules to match. If not set, the action specified in the \u2018action\u2019 field will be applied without any additional rule checks.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "destinations": {
                    "description": "Optional. List of attributes for the traffic destination. If not set, the action specified in the \u2018action\u2019 field will be applied without any rule checks for the destination.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": ["hosts", "ports"],
                      "properties": {
                        "hosts": {
                          "description": "Required. List of host names to match. Matched against HOST header in http requests. Each host can be an exact match, or a prefix match (example, \u201cmydomain.*\u201d) or a suffix match (example, *.myorg.com\u201d) or a presence(any) match \u201c*\u201d.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "httpHeaderMatch": {
                          "description": "Optional. Match against key:value pair in http header. Provides a flexible match based on HTTP headers, for potentially advanced use cases.",
                          "type": "object",
                          "required": ["headerName", "regexMatch"],
                          "properties": {
                            "headerName": {
                              "description": "Required. The name of the HTTP header to match. For matching against the HTTP request's authority, use a headerMatch with the header name \":authority\". For matching a request's method, use the headerName \":method\".",
                              "type": "string"
                            },
                            "regexMatch": {
                              "description": "Required. The value of the header must match the regular expression specified in regexMatch. For regular expression grammar, please see: en.cppreference.com/w/cpp/regex/ecmascript For matching against a port specified in the HTTP request, use a headerMatch with headerName set to Host and a regular expression that satisfies the RFC2616 Host header's port specifier.",
                              "type": "string"
                            }
                          }
                        },
                        "methods": {
                          "description": "Optional. A list of HTTP methods to match. Should not be set for gRPC services.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "ports": {
                          "description": "Required. List of destination ports to match.",
                          "type": "array",
                          "items": {
                            "type": "integer",
                            "format": "int64"
                          }
                        }
                      }
                    }
                  },
                  "sources": {
                    "description": "Optional. List of attributes for the traffic source. If not set, the action specified in the \u2018action\u2019 field will be applied without any rule checks for the source.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "ipBlocks": {
                          "description": "Optional. List of CIDR ranges to match based on source IP address. Single IP (e.g., \"1.2.3.4\") and CIDR (e.g., \"1.2.3.0/24\") are supported.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "principals": {
                          "description": "Optional. List of peer identities to match for authorization. Each peer can be an exact match, or a prefix match (example, \u201cnamespace/*\u201d) or a suffix match (example, */service-account\u201d) or a presence match \u201c*\u201d.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The timestamp when the resource was created.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Output only. The timestamp when the resource was updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networksecurity.cnrm.cloud.google.com",
          "kind": "NetworkSecurityAuthorizationPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networksecurity.v1beta1.NetworkSecurityAuthorizationPolicyList": {
      "description": "NetworkSecurityAuthorizationPolicyList is a list of NetworkSecurityAuthorizationPolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networksecurity.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of networksecurityauthorizationpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.networksecurity.v1beta1.NetworkSecurityAuthorizationPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkSecurityAuthorizationPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networksecurity.cnrm.cloud.google.com",
          "kind": "NetworkSecurityAuthorizationPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networksecurity.v1beta1.NetworkSecurityClientTLSPolicy": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networksecurity.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkSecurityClientTLSPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location"],
          "properties": {
            "clientCertificate": {
              "description": "Optional. Defines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.",
              "type": "object",
              "properties": {
                "certificateProviderInstance": {
                  "description": "The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.",
                  "type": "object",
                  "required": ["pluginInstance"],
                  "properties": {
                    "pluginInstance": {
                      "description": "Required. Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to \"google_cloud_private_spiffe\" to use Certificate Authority Service certificate provider instance.",
                      "type": "string"
                    }
                  }
                },
                "grpcEndpoint": {
                  "description": "gRPC specific configuration to access the gRPC server to obtain the cert and private key.",
                  "type": "object",
                  "required": ["targetUri"],
                  "properties": {
                    "targetUri": {
                      "description": "Required. The target URI of the gRPC endpoint. Only UDS path is supported, and should start with \u201cunix:\u201d.",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "description": {
              "description": "Optional. Free-text description of the resource.",
              "type": "string"
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "serverValidationCa": {
              "description": "Required. Defines the mechanism to obtain the Certificate Authority certificate to validate the server certificate.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "certificateProviderInstance": {
                    "description": "The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.",
                    "type": "object",
                    "required": ["pluginInstance"],
                    "properties": {
                      "pluginInstance": {
                        "description": "Required. Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to \"google_cloud_private_spiffe\" to use Certificate Authority Service certificate provider instance.",
                        "type": "string"
                      }
                    }
                  },
                  "grpcEndpoint": {
                    "description": "gRPC specific configuration to access the gRPC server to obtain the CA certificate.",
                    "type": "object",
                    "required": ["targetUri"],
                    "properties": {
                      "targetUri": {
                        "description": "Required. The target URI of the gRPC endpoint. Only UDS path is supported, and should start with \u201cunix:\u201d.",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "sni": {
              "description": "Optional. Server Name Indication string to present to the server during TLS handshake. E.g: \"secure.example.com\".",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The timestamp when the resource was created.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Output only. The timestamp when the resource was updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networksecurity.cnrm.cloud.google.com",
          "kind": "NetworkSecurityClientTLSPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networksecurity.v1beta1.NetworkSecurityClientTLSPolicyList": {
      "description": "NetworkSecurityClientTLSPolicyList is a list of NetworkSecurityClientTLSPolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networksecurity.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of networksecurityclienttlspolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.networksecurity.v1beta1.NetworkSecurityClientTLSPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkSecurityClientTLSPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networksecurity.cnrm.cloud.google.com",
          "kind": "NetworkSecurityClientTLSPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networksecurity.v1beta1.NetworkSecurityServerTLSPolicy": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networksecurity.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkSecurityServerTLSPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location"],
          "properties": {
            "allowOpen": {
              "description": "Optional. Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if allow_open and mtls_policy are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility.",
              "type": "boolean"
            },
            "description": {
              "description": "Optional. Free-text description of the resource.",
              "type": "string"
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "mtlsPolicy": {
              "description": "Optional. Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If allow_open and mtls_policy are set, server allows both plain text and mTLS connections.",
              "type": "object",
              "required": ["clientValidationCa"],
              "properties": {
                "clientValidationCa": {
                  "description": "Required. Defines the mechanism to obtain the Certificate Authority certificate to validate the client certificate.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "certificateProviderInstance": {
                        "description": "The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.",
                        "type": "object",
                        "required": ["pluginInstance"],
                        "properties": {
                          "pluginInstance": {
                            "description": "Required. Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to \"google_cloud_private_spiffe\" to use Certificate Authority Service certificate provider instance.",
                            "type": "string"
                          }
                        }
                      },
                      "grpcEndpoint": {
                        "description": "gRPC specific configuration to access the gRPC server to obtain the CA certificate.",
                        "type": "object",
                        "required": ["targetUri"],
                        "properties": {
                          "targetUri": {
                            "description": "Required. The target URI of the gRPC endpoint. Only UDS path is supported, and should start with \u201cunix:\u201d.",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "serverCertificate": {
              "description": "Optional. Defines a mechanism to provision server identity (public and private keys). Cannot be combined with allow_open as a permissive mode that allows both plain text and TLS is not supported.",
              "type": "object",
              "properties": {
                "certificateProviderInstance": {
                  "description": "The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.",
                  "type": "object",
                  "required": ["pluginInstance"],
                  "properties": {
                    "pluginInstance": {
                      "description": "Required. Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to \"google_cloud_private_spiffe\" to use Certificate Authority Service certificate provider instance.",
                      "type": "string"
                    }
                  }
                },
                "grpcEndpoint": {
                  "description": "gRPC specific configuration to access the gRPC server to obtain the cert and private key.",
                  "type": "object",
                  "required": ["targetUri"],
                  "properties": {
                    "targetUri": {
                      "description": "Required. The target URI of the gRPC endpoint. Only UDS path is supported, and should start with \u201cunix:\u201d.",
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The timestamp when the resource was created.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Output only. The timestamp when the resource was updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networksecurity.cnrm.cloud.google.com",
          "kind": "NetworkSecurityServerTLSPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networksecurity.v1beta1.NetworkSecurityServerTLSPolicyList": {
      "description": "NetworkSecurityServerTLSPolicyList is a list of NetworkSecurityServerTLSPolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networksecurity.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of networksecurityservertlspolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.networksecurity.v1beta1.NetworkSecurityServerTLSPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkSecurityServerTLSPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networksecurity.cnrm.cloud.google.com",
          "kind": "NetworkSecurityServerTLSPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesEndpointPolicy": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networkservices.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkServicesEndpointPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["endpointMatcher", "location", "projectRef", "type"],
          "properties": {
            "authorizationPolicyRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "Optional. This field specifies the URL of AuthorizationPolicy resource that applies authorization policies to the inbound traffic at the matched endpoints. Refer to Authorization. If this field is not specified, authorization is disabled(no authz checks) for this endpoint. Applicable only when EndpointPolicyType is SIDECAR_PROXY.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "clientTlsPolicyRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "Optional. A URL referring to a ClientTlsPolicy resource. ClientTlsPolicy can be set to specify the authentication for traffic from the proxy to the actual endpoints. More specifically, it is applied to the outgoing traffic from the proxy to the endpoint. This is typically used for sidecar model where the proxy identifies itself as endpoint to the control plane, with the connection between sidecar and endpoint requiring authentication. If this field is not set, authentication is disabled(open). Applicable only when EndpointPolicyType is SIDECAR_PROXY.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "description": {
              "description": "Optional. A free-text description of the resource. Max length 1024 characters.",
              "type": "string"
            },
            "endpointMatcher": {
              "description": "Required. A matcher that selects endpoints to which the policies should be applied.",
              "type": "object",
              "properties": {
                "metadataLabelMatcher": {
                  "description": "The matcher is based on node metadata presented by xDS clients.",
                  "type": "object",
                  "properties": {
                    "metadataLabelMatchCriteria": {
                      "description": "Specifies how matching should be done. Supported values are: MATCH_ANY: At least one of the Labels specified in the matcher should match the metadata presented by xDS client. MATCH_ALL: The metadata presented by the xDS client should contain all of the labels specified here. The selection is determined based on the best match. For example, suppose there are three EndpointPolicy resources P1, P2 and P3 and if P1 has a the matcher as MATCH_ANY , P2 has MATCH_ALL , and P3 has MATCH_ALL . If a client with label connects, the config from P1 will be selected. If a client with label connects, the config from P2 will be selected. If a client with label connects, the config from P3 will be selected. If there is more than one best match, (for example, if a config P4 with selector exists and if a client with label connects), an error will be thrown. Possible values: METADATA_LABEL_MATCH_CRITERIA_UNSPECIFIED, MATCH_ANY, MATCH_ALL",
                      "type": "string"
                    },
                    "metadataLabels": {
                      "description": "The list of label value pairs that must match labels in the provided metadata based on filterMatchCriteria This list can have at most 64 entries. The list can be empty if the match criteria is MATCH_ANY, to specify a wildcard match (i.e this matches any client).",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": ["labelName", "labelValue"],
                        "properties": {
                          "labelName": {
                            "description": "Required. Label name presented as key in xDS Node Metadata.",
                            "type": "string"
                          },
                          "labelValue": {
                            "description": "Required. Label value presented as value corresponding to the above key, in xDS Node Metadata.",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "serverTlsPolicyRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "Optional. A URL referring to ServerTlsPolicy resource. ServerTlsPolicy is used to determine the authentication policy to be applied to terminate the inbound traffic at the identified backends. If this field is not set, authentication is disabled(open) for this endpoint.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "trafficPortSelector": {
              "description": "Optional. Port selector for the (matched) endpoints. If no port selector is provided, the matched config is applied to all ports.",
              "type": "object",
              "properties": {
                "ports": {
                  "description": "Optional. A list of ports. Can be port numbers or port range (example, specifies all ports from 80 to 90, including 80 and 90) or named ports or * to specify all ports. If the list is empty, all ports are selected.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "type": {
              "description": "Required. The type of endpoint config. This is primarily used to validate the configuration. Possible values: ENDPOINT_CONFIG_SELECTOR_TYPE_UNSPECIFIED, SIDECAR_PROXY, GRPC_SERVER",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The timestamp when the resource was created.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Output only. The timestamp when the resource was updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networkservices.cnrm.cloud.google.com",
          "kind": "NetworkServicesEndpointPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesEndpointPolicyList": {
      "description": "NetworkServicesEndpointPolicyList is a list of NetworkServicesEndpointPolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networkservices.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of networkservicesendpointpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesEndpointPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkServicesEndpointPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networkservices.cnrm.cloud.google.com",
          "kind": "NetworkServicesEndpointPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesGRPCRoute": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networkservices.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkServicesGRPCRoute"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["hostnames", "location", "projectRef", "rules"],
          "properties": {
            "description": {
              "description": "Optional. A free-text description of the resource. Max length 1024 characters.",
              "type": "string"
            },
            "gateways": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "external": {
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "hostnames": {
              "description": "Required. Service hostnames with an optional port for which this route describes traffic. Format: [:] Hostname is the fully qualified domain name of a network host. This matches the RFC 1123 definition of a hostname with 2 notable exceptions: - IPs are not allowed. - A hostname may be prefixed with a wildcard label (*.). The wildcard label must appear by itself as the first label. Hostname can be \u201cprecise\u201d which is a domain name without the terminating dot of a network host (e.g. \u201cfoo.example.com\u201d) or \u201cwildcard\u201d, which is a domain name prefixed with a single wildcard label (e.g. *.example.com). Note that as per RFC1035 and RFC1123, a label must consist of lower case alphanumeric characters or \u2018-\u2019, and must start and end with an alphanumeric character. No other punctuation is allowed. The routes associated with a Router must have unique hostnames. If you attempt to attach multiple routes with conflicting hostnames, the configuration will be rejected. For example, while it is acceptable for routes for the hostnames \"*.foo.bar.com\" and \"*.bar.com\" to be associated with the same route, it is not possible to associate two routes both with \"*.bar.com\" or both with \"bar.com\". In the case that multiple routes match the hostname, the most specific match will be selected. For example, \"foo.bar.baz.com\" will take precedence over \"*.bar.baz.com\" and \"*.bar.baz.com\" will take precedence over \"*.baz.com\". If a port is specified, then gRPC clients must use the channel URI with the port to match this rule (i.e. \"xds:///service:123\"), otherwise they must supply the URI without a port (i.e. \"xds:///service\").",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "labels": {
              "description": "Optional. Set of label tags associated with the GrpcRoute resource.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "meshes": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "external": {
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "routers": {
              "description": "Optional. Routers define a list of routers this GrpcRoute should be served by. Each router reference should match the pattern: `projects/*/locations/global/routers/`",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "rules": {
              "description": "Required. A list of detailed rules defining how to route traffic. Within a single GrpcRoute, the GrpcRoute.RouteAction associated with the first matching GrpcRoute.RouteRule will be executed. At least one rule must be supplied.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["action"],
                "properties": {
                  "action": {
                    "description": "Required. A detailed rule defining how to route traffic. This field is required.",
                    "type": "object",
                    "properties": {
                      "destinations": {
                        "description": "Optional. The destination services to which traffic should be forwarded. If multiple destinations are specified, traffic will be split between Backend Service(s) according to the weight field of these destinations.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "required": ["serviceRef"],
                          "properties": {
                            "serviceRef": {
                              "type": "object",
                              "properties": {
                                "external": {
                                  "description": "Required. The URL of a destination service to which to route traffic. Must refer to either a BackendService or ServiceDirectoryService.",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                  "type": "string"
                                },
                                "namespace": {
                                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                  "type": "string"
                                }
                              }
                            },
                            "weight": {
                              "description": "Optional. Specifies the proportion of requests forwarded to the backend referenced by the serviceName field. This is computed as: weight/Sum(weights in this destination list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. If only one serviceName is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weights are specified for any one service name, they need to be specified for all of them. If weights are unspecified for all services, then, traffic is distributed in equal proportions to all of them.",
                              "type": "integer",
                              "format": "int64"
                            }
                          }
                        }
                      },
                      "faultInjectionPolicy": {
                        "description": "Optional. The specification for fault injection introduced into traffic to test the resiliency of clients to destination service failure. As part of fault injection, when clients send requests to a destination, delays can be introduced on a percentage of requests before sending those requests to the destination service. Similarly requests from clients can be aborted by for a percentage of requests. timeout and retry_policy will be ignored by clients that are configured with a fault_injection_policy",
                        "type": "object",
                        "properties": {
                          "abort": {
                            "description": "The specification for aborting to client requests.",
                            "type": "object",
                            "properties": {
                              "httpStatus": {
                                "description": "The HTTP status code used to abort the request. The value must be between 200 and 599 inclusive.",
                                "type": "integer",
                                "format": "int64"
                              },
                              "percentage": {
                                "description": "The percentage of traffic which will be aborted. The value must be between [0, 100]",
                                "type": "integer",
                                "format": "int64"
                              }
                            }
                          },
                          "delay": {
                            "description": "The specification for injecting delay to client requests.",
                            "type": "object",
                            "properties": {
                              "fixedDelay": {
                                "description": "Specify a fixed delay before forwarding the request.",
                                "type": "string"
                              },
                              "percentage": {
                                "description": "The percentage of traffic on which delay will be injected. The value must be between [0, 100]",
                                "type": "integer",
                                "format": "int64"
                              }
                            }
                          }
                        }
                      },
                      "retryPolicy": {
                        "description": "Optional. Specifies the retry policy associated with this route.",
                        "type": "object",
                        "properties": {
                          "numRetries": {
                            "description": "Specifies the allowed number of retries. This number must be > 0. If not specpfied, default to 1.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "retryConditions": {
                            "description": "- connect-failure: Router will retry on failures connecting to Backend Services, for example due to connection timeouts. - refused-stream: Router will retry if the backend service resets the stream with a REFUSED_STREAM error code. This reset type indicates that it is safe to retry. - cancelled: Router will retry if the gRPC status code in the response header is set to cancelled - deadline-exceeded: Router will retry if the gRPC status code in the response header is set to deadline-exceeded - resource-exhausted: Router will retry if the gRPC status code in the response header is set to resource-exhausted - unavailable: Router will retry if the gRPC status code in the response header is set to unavailable",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "timeout": {
                        "description": "Optional. Specifies the timeout for selected route. Timeout is computed from the time the request has been fully processed (i.e. end of stream) up until the response has been completely processed. Timeout includes all retries.",
                        "type": "string"
                      }
                    }
                  },
                  "matches": {
                    "description": "Optional. Matches define conditions used for matching the rule against incoming gRPC requests. Each match is independent, i.e. this rule will be matched if ANY one of the matches is satisfied. If no matches field is specified, this rule will unconditionally match traffic.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "headers": {
                          "description": "Optional. Specifies a collection of headers to match.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "required": ["key", "value"],
                            "properties": {
                              "key": {
                                "description": "Required. The key of the header.",
                                "type": "string"
                              },
                              "type": {
                                "description": "Optional. Specifies how to match against the value of the header. If not specified, a default value of EXACT is used. Possible values: MATCH_TYPE_UNSPECIFIED, MATCH_ANY, MATCH_ALL",
                                "type": "string"
                              },
                              "value": {
                                "description": "Required. The value of the header.",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "method": {
                          "description": "Optional. A gRPC method to match against. If this field is empty or omitted, will match all methods.",
                          "type": "object",
                          "required": ["grpcMethod", "grpcService"],
                          "properties": {
                            "caseSensitive": {
                              "description": "Optional. Specifies that matches are case sensitive. The default value is true. case_sensitive must not be used with a type of REGULAR_EXPRESSION.",
                              "type": "boolean"
                            },
                            "grpcMethod": {
                              "description": "Required. Name of the method to match against. If unspecified, will match all methods.",
                              "type": "string"
                            },
                            "grpcService": {
                              "description": "Required. Name of the service to match against. If unspecified, will match all services.",
                              "type": "string"
                            },
                            "type": {
                              "description": "Optional. Specifies how to match against the name. If not specified, a default value of \"EXACT\" is used. Possible values: MATCH_TYPE_UNSPECIFIED, MATCH_ANY, MATCH_ALL",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The timestamp when the resource was created.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Output only. The timestamp when the resource was updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networkservices.cnrm.cloud.google.com",
          "kind": "NetworkServicesGRPCRoute",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesGRPCRouteList": {
      "description": "NetworkServicesGRPCRouteList is a list of NetworkServicesGRPCRoute",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networkservices.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of networkservicesgrpcroutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesGRPCRoute"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkServicesGRPCRouteList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networkservices.cnrm.cloud.google.com",
          "kind": "NetworkServicesGRPCRouteList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesGateway": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networkservices.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkServicesGateway"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location", "ports", "projectRef", "scope"],
          "properties": {
            "addresses": {
              "description": "One or more addresses with ports in format of \":\" that the Gateway must receive traffic on. The proxy binds to the ports specified. IP address can be anything that is allowed by the underlying infrastructure (auto-allocation, static IP, BYOIP).",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "authorizationPolicy": {
              "description": "Optional. A fully-qualified AuthorizationPolicy URL reference. Specifies how traffic is authorized. If empty, authorization checks are disabled.",
              "type": "string"
            },
            "description": {
              "description": "Optional. A free-text description of the resource. Max length 1024 characters.",
              "type": "string"
            },
            "labels": {
              "description": "Optional. Set of label tags associated with the Gateway resource.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "ports": {
              "description": "Required. One or more ports that the Gateway must receive traffic on. The proxy binds to the ports specified. Gateway listen on 0.0.0.0 on the ports specified below.",
              "type": "array",
              "items": {
                "type": "integer",
                "format": "int64"
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "scope": {
              "description": "Required. Immutable. Scope determines how configuration across multiple Gateway instances are merged. The configuration for multiple Gateway instances with the same scope will be merged as presented as a single coniguration to the proxy/load balancer. Max length 64 characters. Scope should start with a letter and can only have letters, numbers, hyphens.",
              "type": "string"
            },
            "serverTlsPolicy": {
              "description": "Optional. A fully-qualified ServerTLSPolicy URL reference. Specifies how TLS traffic is terminated. If empty, TLS termination is disabled.",
              "type": "string"
            },
            "type": {
              "description": "Immutable. The type of the customer managed gateway. Possible values: MATCH_TYPE_UNSPECIFIED, MATCH_ANY, MATCH_ALL",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The timestamp when the resource was created.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Output only. The timestamp when the resource was updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networkservices.cnrm.cloud.google.com",
          "kind": "NetworkServicesGateway",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesGatewayList": {
      "description": "NetworkServicesGatewayList is a list of NetworkServicesGateway",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networkservices.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of networkservicesgateways. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesGateway"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkServicesGatewayList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networkservices.cnrm.cloud.google.com",
          "kind": "NetworkServicesGatewayList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesHTTPRoute": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networkservices.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkServicesHTTPRoute"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["hostnames", "location", "projectRef", "rules"],
          "properties": {
            "description": {
              "description": "Optional. A free-text description of the resource. Max length 1024 characters.",
              "type": "string"
            },
            "gateways": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "external": {
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "hostnames": {
              "description": "Required. Hostnames define a set of hosts that should match against the HTTP host header to select a HttpRoute to process the request. Hostname is the fully qualified domain name of a network host, as defined by RFC 1123 with the exception that ip addresses are not allowed. Wildcard hosts are supported as \"*\" (no prefix or suffix allowed).",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "labels": {
              "description": "Optional. Set of label tags associated with the HttpRoute resource.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "meshes": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "external": {
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "routers": {
              "description": "Optional. Routers define a list of routers this HttpRoute should be served by. Each router reference should match the pattern: `projects/*/locations/global/routers/` The attached Router should be of a type PROXY",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "rules": {
              "description": "Required. Rules that define how traffic is routed and handled.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "action": {
                    "description": "The detailed rule defining how to route matched traffic.",
                    "type": "object",
                    "properties": {
                      "corsPolicy": {
                        "description": "The specification for allowing client side cross-origin requests.",
                        "type": "object",
                        "properties": {
                          "allowCredentials": {
                            "description": "In response to a preflight request, setting this to true indicates that the actual request can include user credentials. This translates to the Access-Control-Allow-Credentials header. Default value is false.",
                            "type": "boolean"
                          },
                          "allowHeaders": {
                            "description": "Specifies the content for Access-Control-Allow-Headers header.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "allowMethods": {
                            "description": "Specifies the content for Access-Control-Allow-Methods header.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "allowOriginRegexes": {
                            "description": "Specifies the regular expression patterns that match allowed origins. For regular expression grammar, please see https://github.com/google/re2/wiki/Syntax.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "allowOrigins": {
                            "description": "Specifies the list of origins that will be allowed to do CORS requests. An origin is allowed if it matches either an item in allow_origins or an item in allow_origin_regexes.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "disabled": {
                            "description": "If true, the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.",
                            "type": "boolean"
                          },
                          "exposeHeaders": {
                            "description": "Specifies the content for Access-Control-Expose-Headers header.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "maxAge": {
                            "description": "Specifies how long result of a preflight request can be cached in seconds. This translates to the Access-Control-Max-Age header.",
                            "type": "string"
                          }
                        }
                      },
                      "destinations": {
                        "description": "The destination to which traffic should be forwarded.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "serviceRef": {
                              "type": "object",
                              "properties": {
                                "external": {
                                  "description": "The URL of a BackendService to route traffic to.",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                  "type": "string"
                                },
                                "namespace": {
                                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                  "type": "string"
                                }
                              }
                            },
                            "weight": {
                              "description": "Specifies the proportion of requests forwarded to the backend referenced by the serviceName field. This is computed as: weight/Sum(weights in this destination list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. If only one serviceName is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weights are specified for any one service name, they need to be specified for all of them. If weights are unspecified for all services, then, traffic is distributed in equal proportions to all of them.",
                              "type": "integer",
                              "format": "int64"
                            }
                          }
                        }
                      },
                      "faultInjectionPolicy": {
                        "description": "The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure. As part of fault injection, when clients send requests to a backend service, delays can be introduced on a percentage of requests before sending those requests to the backend service. Similarly requests from clients can be aborted for a percentage of requests. timeout and retry_policy will be ignored by clients that are configured with a fault_injection_policy",
                        "type": "object",
                        "properties": {
                          "abort": {
                            "description": "The specification for aborting to client requests.",
                            "type": "object",
                            "properties": {
                              "httpStatus": {
                                "description": "The HTTP status code used to abort the request. The value must be between 200 and 599 inclusive.",
                                "type": "integer",
                                "format": "int64"
                              },
                              "percentage": {
                                "description": "The percentage of traffic which will be aborted. The value must be between [0, 100]",
                                "type": "integer",
                                "format": "int64"
                              }
                            }
                          },
                          "delay": {
                            "description": "The specification for injecting delay to client requests.",
                            "type": "object",
                            "properties": {
                              "fixedDelay": {
                                "description": "Specify a fixed delay before forwarding the request.",
                                "type": "string"
                              },
                              "percentage": {
                                "description": "The percentage of traffic on which delay will be injected. The value must be between [0, 100]",
                                "type": "integer",
                                "format": "int64"
                              }
                            }
                          }
                        }
                      },
                      "originalDestination": {
                        "description": "If true, the matched traffic will use the destination ip and port of the original connection (as it was not processed by proxy) as the destination of the request. Only one of destinations, redirect, original_destination can be set.",
                        "type": "boolean"
                      },
                      "redirect": {
                        "description": "If set, the request is directed as configured by this field.",
                        "type": "object",
                        "properties": {
                          "hostRedirect": {
                            "description": "The host that will be used in the redirect response instead of the one that was supplied in the request.",
                            "type": "string"
                          },
                          "httpsRedirect": {
                            "description": "If set to true, the URL scheme in the redirected request is set to https. If set to false, the URL scheme of the redirected request will remain the same as that of the request. The default is set to false.",
                            "type": "boolean"
                          },
                          "pathRedirect": {
                            "description": "The path that will be used in the redirect response instead of the one that was supplied in the request. path_redirect can not be supplied together with prefix_redirect. Supply one alone or neither. If neither is supplied, the path of the original request will be used for the redirect.",
                            "type": "string"
                          },
                          "portRedirect": {
                            "description": "The port that will be used in the redirected request instead of the one that was supplied in the request.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "prefixRewrite": {
                            "description": "Indicates that during redirection, the matched prefix (or path) should be swapped with this value. This option allows URLs be dynamically created based on the request.",
                            "type": "string"
                          },
                          "responseCode": {
                            "description": "The HTTP Status code to use for the redirect. Possible values: MOVED_PERMANENTLY_DEFAULT, FOUND, SEE_OTHER, TEMPORARY_REDIRECT, PERMANENT_REDIRECT",
                            "type": "string"
                          },
                          "stripQuery": {
                            "description": "if set to true, any accompanying query portion of the original URL is removed prior to redirecting the request. If set to false, the query portion of the original URL is retained. The default is set to false.",
                            "type": "boolean"
                          }
                        }
                      },
                      "requestHeaderModifier": {
                        "description": "The specification for modifying the headers of a matching request prior to delivery of the request to the destination.",
                        "type": "object",
                        "properties": {
                          "add": {
                            "description": "Add the headers with given map where key is the name of the header, value is the value of the header.",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          },
                          "remove": {
                            "description": "Remove headers (matching by header names) specified in the list.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "set": {
                            "description": "Completely overwrite/replace the headers with given map where key is the name of the header, value is the value of the header.",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "requestMirrorPolicy": {
                        "description": "Specifies the policy on how requests intended for the routes destination are shadowed to a separate mirrored destination. Proxy will not wait for the shadow destination to respond before returning the response. Prior to sending traffic to the shadow service, the host/authority header is suffixed with -shadow.",
                        "type": "object",
                        "properties": {
                          "destination": {
                            "description": "The destination the requests will be mirrored to. The weight of the destination will be ignored.",
                            "type": "object",
                            "properties": {
                              "serviceRef": {
                                "type": "object",
                                "properties": {
                                  "external": {
                                    "description": "The URL of a BackendService to route traffic to.",
                                    "type": "string"
                                  },
                                  "name": {
                                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                    "type": "string"
                                  },
                                  "namespace": {
                                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                    "type": "string"
                                  }
                                }
                              },
                              "weight": {
                                "description": "Specifies the proportion of requests forwarded to the backend referenced by the serviceName field. This is computed as: weight/Sum(weights in this destination list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. If only one serviceName is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weights are specified for any one service name, they need to be specified for all of them. If weights are unspecified for all services, then, traffic is distributed in equal proportions to all of them.",
                                "type": "integer",
                                "format": "int64"
                              }
                            }
                          }
                        }
                      },
                      "responseHeaderModifier": {
                        "description": "The specification for modifying the headers of a response prior to sending the response back to the client.",
                        "type": "object",
                        "properties": {
                          "add": {
                            "description": "Add the headers with given map where key is the name of the header, value is the value of the header.",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          },
                          "remove": {
                            "description": "Remove headers (matching by header names) specified in the list.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "set": {
                            "description": "Completely overwrite/replace the headers with given map where key is the name of the header, value is the value of the header.",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "retryPolicy": {
                        "description": "Specifies the retry policy associated with this route.",
                        "type": "object",
                        "properties": {
                          "numRetries": {
                            "description": "Specifies the allowed number of retries. This number must be > 0. If not specified, default to 1.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "perTryTimeout": {
                            "description": "Specifies a non-zero timeout per retry attempt.",
                            "type": "string"
                          },
                          "retryConditions": {
                            "description": "Specifies one or more conditions when this retry policy applies. Valid values are: 5xx: Proxy will attempt a retry if the destination service responds with any 5xx response code, of if the destination service does not respond at all, example: disconnect, reset, read timeout, connection failure and refused streams. gateway-error: Similar to 5xx, but only applies to response codes 502, 503, 504. reset: Proxy will attempt a retry if the destination service does not respond at all (disconnect/reset/read timeout) connect-failure: Proxy will retry on failures connecting to destination for example due to connection timeouts. retriable-4xx: Proxy will retry fro retriable 4xx response codes. Currently the only retriable error supported is 409. refused-stream: Proxy will retry if the destination resets the stream with a REFUSED_STREAM error code. This reset type indicates that it is safe to retry.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "timeout": {
                        "description": "Specifies the timeout for selected route. Timeout is computed from the time the request has been fully processed (i.e. end of stream) up until the response has been completely processed. Timeout includes all retries.",
                        "type": "string"
                      },
                      "urlRewrite": {
                        "description": "The specification for rewrite URL before forwarding requests to the destination.",
                        "type": "object",
                        "properties": {
                          "hostRewrite": {
                            "description": "Prior to forwarding the request to the selected destination, the requests host header is replaced by this value.",
                            "type": "string"
                          },
                          "pathPrefixRewrite": {
                            "description": "Prior to forwarding the request to the selected destination, the matching portion of the requests path is replaced by this value.",
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "matches": {
                    "description": "A list of matches define conditions used for matching the rule against incoming HTTP requests. Each match is independent, i.e. this rule will be matched if ANY one of the matches is satisfied.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "fullPathMatch": {
                          "description": "The HTTP request path value should exactly match this value. Only one of full_path_match, prefix_match, or regex_match should be used.",
                          "type": "string"
                        },
                        "headers": {
                          "description": "Specifies a list of HTTP request headers to match against. ALL of the supplied headers must be matched.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "exactMatch": {
                                "description": "The value of the header should match exactly the content of exact_match.",
                                "type": "string"
                              },
                              "header": {
                                "description": "The name of the HTTP header to match against.",
                                "type": "string"
                              },
                              "invertMatch": {
                                "description": "If specified, the match result will be inverted before checking. Default value is set to false.",
                                "type": "boolean"
                              },
                              "prefixMatch": {
                                "description": "The value of the header must start with the contents of prefix_match.",
                                "type": "string"
                              },
                              "presentMatch": {
                                "description": "A header with header_name must exist. The match takes place whether or not the header has a value.",
                                "type": "boolean"
                              },
                              "rangeMatch": {
                                "description": "If specified, the rule will match if the request header value is within the range.",
                                "type": "object",
                                "properties": {
                                  "end": {
                                    "description": "End of the range (exclusive)",
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "start": {
                                    "description": "Start of the range (inclusive)",
                                    "type": "integer",
                                    "format": "int64"
                                  }
                                }
                              },
                              "regexMatch": {
                                "description": "The value of the header must match the regular expression specified in regex_match. For regular expression grammar, please see: https://github.com/google/re2/wiki/Syntax",
                                "type": "string"
                              },
                              "suffixMatch": {
                                "description": "The value of the header must end with the contents of suffix_match.",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "ignoreCase": {
                          "description": "Specifies if prefix_match and full_path_match matches are case sensitive. The default value is false.",
                          "type": "boolean"
                        },
                        "prefixMatch": {
                          "description": "The HTTP request path value must begin with specified prefix_match. prefix_match must begin with a /. Only one of full_path_match, prefix_match, or regex_match should be used.",
                          "type": "string"
                        },
                        "queryParameters": {
                          "description": "Specifies a list of query parameters to match against. ALL of the query parameters must be matched.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "exactMatch": {
                                "description": "The value of the query parameter must exactly match the contents of exact_match. Only one of exact_match, regex_match, or present_match must be set.",
                                "type": "string"
                              },
                              "presentMatch": {
                                "description": "Specifies that the QueryParameterMatcher matches if request contains query parameter, irrespective of whether the parameter has a value or not. Only one of exact_match, regex_match, or present_match must be set.",
                                "type": "boolean"
                              },
                              "queryParameter": {
                                "description": "The name of the query parameter to match.",
                                "type": "string"
                              },
                              "regexMatch": {
                                "description": "The value of the query parameter must match the regular expression specified by regex_match. For regular expression grammar, please see https://github.com/google/re2/wiki/Syntax Only one of exact_match, regex_match, or present_match must be set.",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "regexMatch": {
                          "description": "The HTTP request path value must satisfy the regular expression specified by regex_match after removing any query parameters and anchor supplied with the original URL. For regular expression grammar, please see https://github.com/google/re2/wiki/Syntax Only one of full_path_match, prefix_match, or regex_match should be used.",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The timestamp when the resource was created.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Output only. The timestamp when the resource was updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networkservices.cnrm.cloud.google.com",
          "kind": "NetworkServicesHTTPRoute",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesHTTPRouteList": {
      "description": "NetworkServicesHTTPRouteList is a list of NetworkServicesHTTPRoute",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networkservices.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of networkserviceshttproutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesHTTPRoute"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkServicesHTTPRouteList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networkservices.cnrm.cloud.google.com",
          "kind": "NetworkServicesHTTPRouteList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesMesh": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networkservices.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkServicesMesh"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location", "projectRef"],
          "properties": {
            "description": {
              "description": "Optional. A free-text description of the resource. Max length 1024 characters.",
              "type": "string"
            },
            "interceptionPort": {
              "description": "Optional. If set to a valid TCP port (1-65535), instructs the SIDECAR proxy to listen on the specified port of localhost (127.0.0.1) address. The SIDECAR proxy will expect all traffic to be redirected to this port regardless of its actual ip:port destination. If unset, a port '15001' is used as the interception port. This field is only valid if the type of Mesh is SIDECAR.",
              "type": "integer",
              "format": "int64"
            },
            "labels": {
              "description": "Optional. Set of label tags associated with the Mesh resource.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The timestamp when the resource was created.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Output only. The timestamp when the resource was updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networkservices.cnrm.cloud.google.com",
          "kind": "NetworkServicesMesh",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesMeshList": {
      "description": "NetworkServicesMeshList is a list of NetworkServicesMesh",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networkservices.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of networkservicesmeshes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesMesh"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkServicesMeshList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networkservices.cnrm.cloud.google.com",
          "kind": "NetworkServicesMeshList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesTCPRoute": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networkservices.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkServicesTCPRoute"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location", "projectRef", "rules"],
          "properties": {
            "description": {
              "description": "Optional. A free-text description of the resource. Max length 1024 characters.",
              "type": "string"
            },
            "gateways": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "external": {
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "labels": {
              "description": "Optional. Set of label tags associated with the TcpRoute resource.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "meshes": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "external": {
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "routers": {
              "description": "Optional. Routers define a list of routers this TcpRoute should be served by. Each router reference should match the pattern: `projects/*/locations/global/routers/` The attached Router should be of a type PROXY",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "rules": {
              "description": "Required. Rules that define how traffic is routed and handled. At least one RouteRule must be supplied. If there are multiple rules then the action taken will be the first rule to match.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["action"],
                "properties": {
                  "action": {
                    "description": "Required. The detailed rule defining how to route matched traffic.",
                    "type": "object",
                    "properties": {
                      "destinations": {
                        "description": "Optional. The destination services to which traffic should be forwarded. At least one destination service is required.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "required": ["serviceRef"],
                          "properties": {
                            "serviceRef": {
                              "type": "object",
                              "properties": {
                                "external": {
                                  "description": "Required. The URL of a BackendService to route traffic to.",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                  "type": "string"
                                },
                                "namespace": {
                                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                  "type": "string"
                                }
                              }
                            },
                            "weight": {
                              "description": "Optional. Specifies the proportion of requests forwarded to the backend referenced by the serviceName field. This is computed as: weight/Sum(weights in this destination list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. If only one serviceName is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weights are specified for any one service name, they need to be specified for all of them. If weights are unspecified for all services, then, traffic is distributed in equal proportions to all of them.",
                              "type": "integer",
                              "format": "int64"
                            }
                          }
                        }
                      },
                      "originalDestination": {
                        "description": "Optional. If true, Router will use the destination IP and port of the original connection as the destination of the request. Default is false.",
                        "type": "boolean"
                      }
                    }
                  },
                  "matches": {
                    "description": "Optional. RouteMatch defines the predicate used to match requests to a given action. Multiple match types are \u201cOR\u201ded for evaluation. If no routeMatch field is specified, this rule will unconditionally match traffic.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": ["address", "port"],
                      "properties": {
                        "address": {
                          "description": "Required. Must be specified in the CIDR range format. A CIDR range consists of an IP Address and a prefix length to construct the subnet mask. By default, the prefix length is 32 (i.e. matches a single IP address). Only IPV4 addresses are supported. Examples: \u201c10.0.0.1\u201d - matches against this exact IP address. \u201c10.0.0.0/8\" - matches against any IP address within the 10.0.0.0 subnet and 255.255.255.0 mask. \"0.0.0.0/0\" - matches against any IP address'.",
                          "type": "string"
                        },
                        "port": {
                          "description": "Required. Specifies the destination port to match against.",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The timestamp when the resource was created.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Output only. The timestamp when the resource was updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networkservices.cnrm.cloud.google.com",
          "kind": "NetworkServicesTCPRoute",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesTCPRouteList": {
      "description": "NetworkServicesTCPRouteList is a list of NetworkServicesTCPRoute",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networkservices.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of networkservicestcproutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.networkservices.v1beta1.NetworkServicesTCPRoute"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkServicesTCPRouteList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networkservices.cnrm.cloud.google.com",
          "kind": "NetworkServicesTCPRouteList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.osconfig.v1beta1.OSConfigGuestPolicy": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["osconfig.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["OSConfigGuestPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "assignment": {
              "description": "Specifies the VMs that are assigned this policy. This allows you to target sets or groups of VMs by different parameters such as labels, names, OS, or zones. Empty assignments will target ALL VMs underneath this policy. Conflict Management Policies that exist higher up in the resource hierarchy (closer to the Org) will override those lower down if there is a conflict. At the same level in the resource hierarchy (ie. within a project), the service will prevent the creation of multiple policies that conflict with each other. If there are multiple policies that specify the same config (eg. package, software recipe, repository, etc.), the service will ensure that no VM could potentially receive instructions from both policies. To create multiple policies that specify different versions of a package or different configs for different Operating Systems, each policy must be mutually exclusive in their targeting according to labels, OS, or other criteria. Different configs are identified for conflicts in different ways. Packages are identified by their name and the package manager(s) they target. Package repositories are identified by their unique id where applicable. Some package managers don't have a unique identifier for repositories and where that's the case, no uniqueness is validated by the service. Note that if OS Inventory is disabled, a VM will not be assigned a policy that targets by OS because the service will see this VM's OS as unknown.",
              "type": "object",
              "properties": {
                "groupLabels": {
                  "description": "Targets instances matching at least one of these label sets. This allows an assignment to target disparate groups, for example \"env=prod or env=staging\".",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "labels": {
                        "description": "Google Compute Engine instance labels that must be present for an instance to be included in this assignment group.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "instanceNamePrefixes": {
                  "description": "Targets VM instances whose name starts with one of these prefixes. Like labels, this is another way to group VM instances when targeting configs, for example prefix=\"prod-\". Only supported for project-level policies.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "instances": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  }
                },
                "osTypes": {
                  "description": "Targets VM instances matching at least one of the following OS types. VM instances must match all supplied criteria for a given OsType to be included.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "osArchitecture": {
                        "description": "Targets VM instances with OS Inventory enabled and having the following OS architecture.",
                        "type": "string"
                      },
                      "osShortName": {
                        "description": "Targets VM instances with OS Inventory enabled and having the following OS short name, for example \"debian\" or \"windows\".",
                        "type": "string"
                      },
                      "osVersion": {
                        "description": "Targets VM instances with OS Inventory enabled and having the following following OS version.",
                        "type": "string"
                      }
                    }
                  }
                },
                "zones": {
                  "description": "Targets instances in any of these zones. Leave empty to target instances in any zone. Zonal targeting is uncommon and is supported to facilitate the management of changes by zone.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "description": {
              "description": "Description of the GuestPolicy. Length of the description is limited to 1024 characters.",
              "type": "string"
            },
            "packageRepositories": {
              "description": "List of package repository configurations assigned to the VM instance.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "apt": {
                    "description": "An Apt Repository.",
                    "type": "object",
                    "required": ["distribution", "uri"],
                    "properties": {
                      "archiveType": {
                        "description": "Type of archive files in this repository. The default behavior is DEB. Possible values: ARCHIVE_TYPE_UNSPECIFIED, DEB, DEB_SRC",
                        "type": "string"
                      },
                      "components": {
                        "description": "Required. List of components for this repository. Must contain at least one item.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "distribution": {
                        "description": "Required. Distribution of this repository.",
                        "type": "string"
                      },
                      "gpgKey": {
                        "description": "URI of the key file for this repository. The agent maintains a keyring at `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg` containing all the keys in any applied guest policy.",
                        "type": "string"
                      },
                      "uri": {
                        "description": "Required. URI for this repository.",
                        "type": "string"
                      }
                    }
                  },
                  "goo": {
                    "description": "A Goo Repository.",
                    "type": "object",
                    "required": ["name", "url"],
                    "properties": {
                      "name": {
                        "description": "Required. The name of the repository.",
                        "type": "string"
                      },
                      "url": {
                        "description": "Required. The url of the repository.",
                        "type": "string"
                      }
                    }
                  },
                  "yum": {
                    "description": "A Yum Repository.",
                    "type": "object",
                    "required": ["baseUrl", "id"],
                    "properties": {
                      "baseUrl": {
                        "description": "Required. The location of the repository directory.",
                        "type": "string"
                      },
                      "displayName": {
                        "description": "The display name of the repository.",
                        "type": "string"
                      },
                      "gpgKeys": {
                        "description": "URIs of GPG keys.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "id": {
                        "description": "Required. A one word, unique name for this repository. This is the `repo id` in the Yum config file and also the `display_name` if `display_name` is omitted. This id is also used as the unique identifier when checking for guest policy conflicts.",
                        "type": "string"
                      }
                    }
                  },
                  "zypper": {
                    "description": "A Zypper Repository.",
                    "type": "object",
                    "required": ["baseUrl", "id"],
                    "properties": {
                      "baseUrl": {
                        "description": "Required. The location of the repository directory.",
                        "type": "string"
                      },
                      "displayName": {
                        "description": "The display name of the repository.",
                        "type": "string"
                      },
                      "gpgKeys": {
                        "description": "URIs of GPG keys.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "id": {
                        "description": "Required. A one word, unique name for this repository. This is the `repo id` in the zypper config file and also the `display_name` if `display_name` is omitted. This id is also used as the unique identifier when checking for guest policy conflicts.",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "packages": {
              "description": "List of package configurations assigned to the VM instance.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "desiredState": {
                    "description": "The desired_state the agent should maintain for this package. The default is to ensure the package is installed. Possible values: DESIRED_STATE_UNSPECIFIED, INSTALLED, REMOVED",
                    "type": "string"
                  },
                  "manager": {
                    "description": "Type of package manager that can be used to install this package. If a system does not have the package manager, the package is not installed or removed no error message is returned. By default, or if you specify `ANY`, the agent attempts to install and remove this package using the default package manager. This is useful when creating a policy that applies to different types of systems. The default behavior is ANY. Possible values: MANAGER_UNSPECIFIED, ANY, APT, YUM, ZYPPER, GOO",
                    "type": "string"
                  },
                  "name": {
                    "description": "Required. The name of the package. A package is uniquely identified for conflict validation by checking the package name and the manager(s) that the package targets.",
                    "type": "string"
                  }
                }
              }
            },
            "recipes": {
              "description": "Optional. A list of Recipes to install on the VM.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "artifacts": {
                    "description": "Resources available to be used in the steps in the recipe.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "allowInsecure": {
                          "description": "Defaults to false. When false, recipes are subject to validations based on the artifact type: Remote: A checksum must be specified, and only protocols with transport-layer security are permitted. GCS: An object generation number must be specified.",
                          "type": "boolean"
                        },
                        "gcs": {
                          "description": "A Google Cloud Storage artifact.",
                          "type": "object",
                          "properties": {
                            "bucketRef": {
                              "type": "object",
                              "properties": {
                                "external": {
                                  "description": "Bucket of the Google Cloud Storage object. Given an example URL: `https://storage.googleapis.com/my-bucket/foo/bar#1234567` this value would be `my-bucket`.",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                  "type": "string"
                                },
                                "namespace": {
                                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                  "type": "string"
                                }
                              }
                            },
                            "generation": {
                              "description": "Must be provided if allow_insecure is false. Generation number of the Google Cloud Storage object. `https://storage.googleapis.com/my-bucket/foo/bar#1234567` this value would be `1234567`.",
                              "type": "integer",
                              "format": "int64"
                            },
                            "object": {
                              "description": "Name of the Google Cloud Storage object. As specified [here] (https://cloud.google.com/storage/docs/naming#objectnames) Given an example URL: `https://storage.googleapis.com/my-bucket/foo/bar#1234567` this value would be `foo/bar`.",
                              "type": "string"
                            }
                          }
                        },
                        "id": {
                          "description": "Required. Id of the artifact, which the installation and update steps of this recipe can reference. Artifacts in a recipe cannot have the same id.",
                          "type": "string"
                        },
                        "remote": {
                          "description": "A generic remote artifact.",
                          "type": "object",
                          "properties": {
                            "checksum": {
                              "description": "Must be provided if `allow_insecure` is `false`. SHA256 checksum in hex format, to compare to the checksum of the artifact. If the checksum is not empty and it doesn't match the artifact then the recipe installation fails before running any of the steps.",
                              "type": "string"
                            },
                            "uri": {
                              "description": "URI from which to fetch the object. It should contain both the protocol and path following the format: {protocol}://{location}.",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  },
                  "desiredState": {
                    "description": "Default is INSTALLED. The desired state the agent should maintain for this recipe. INSTALLED: The software recipe is installed on the instance but won't be updated to new versions. UPDATED: The software recipe is installed on the instance. The recipe is updated to a higher version, if a higher version of the recipe is assigned to this instance. REMOVE: Remove is unsupported for software recipes and attempts to create or update a recipe to the REMOVE state is rejected. Possible values: DESIRED_STATE_UNSPECIFIED, INSTALLED, REMOVED",
                    "type": "string"
                  },
                  "installSteps": {
                    "description": "Actions to be taken for installing this recipe. On failure it stops executing steps and does not attempt another installation. Any steps taken (including partially completed steps) are not rolled back.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "archiveExtraction": {
                          "description": "Extracts an archive into the specified directory.",
                          "type": "object",
                          "properties": {
                            "artifactId": {
                              "description": "Required. The id of the relevant artifact in the recipe.",
                              "type": "string"
                            },
                            "destination": {
                              "description": "Directory to extract archive to. Defaults to `/` on Linux or `C:` on Windows.",
                              "type": "string"
                            },
                            "type": {
                              "description": "Required. The type of the archive to extract. Possible values: TYPE_UNSPECIFIED, VALIDATION, DESIRED_STATE_CHECK, DESIRED_STATE_ENFORCEMENT, DESIRED_STATE_CHECK_POST_ENFORCEMENT",
                              "type": "string"
                            }
                          }
                        },
                        "dpkgInstallation": {
                          "description": "Installs a deb file via dpkg.",
                          "type": "object",
                          "properties": {
                            "artifactId": {
                              "description": "Required. The id of the relevant artifact in the recipe.",
                              "type": "string"
                            }
                          }
                        },
                        "fileCopy": {
                          "description": "Copies a file onto the instance.",
                          "type": "object",
                          "properties": {
                            "artifactId": {
                              "description": "Required. The id of the relevant artifact in the recipe.",
                              "type": "string"
                            },
                            "destination": {
                              "description": "Required. The absolute path on the instance to put the file.",
                              "type": "string"
                            },
                            "overwrite": {
                              "description": "Whether to allow this step to overwrite existing files. If this is false and the file already exists the file is not overwritten and the step is considered a success. Defaults to false.",
                              "type": "boolean"
                            },
                            "permissions": {
                              "description": "Consists of three octal digits which represent, in order, the permissions of the owner, group, and other users for the file (similarly to the numeric mode used in the linux chmod utility). Each digit represents a three bit number with the 4 bit corresponding to the read permissions, the 2 bit corresponds to the write bit, and the one bit corresponds to the execute permission. Default behavior is 755. Below are some examples of permissions and their associated values: read, write, and execute: 7 read and execute: 5 read and write: 6 read only: 4",
                              "type": "string"
                            }
                          }
                        },
                        "fileExec": {
                          "description": "Executes an artifact or local file.",
                          "type": "object",
                          "properties": {
                            "allowedExitCodes": {
                              "description": "Defaults to [0]. A list of possible return values that the program can return to indicate a success.",
                              "type": "array",
                              "items": {
                                "type": "integer",
                                "format": "int64"
                              }
                            },
                            "args": {
                              "description": "Arguments to be passed to the provided executable.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "artifactId": {
                              "description": "The id of the relevant artifact in the recipe.",
                              "type": "string"
                            },
                            "localPath": {
                              "description": "The absolute path of the file on the local filesystem.",
                              "type": "string"
                            }
                          }
                        },
                        "msiInstallation": {
                          "description": "Installs an MSI file.",
                          "type": "object",
                          "properties": {
                            "allowedExitCodes": {
                              "description": "Return codes that indicate that the software installed or updated successfully. Behaviour defaults to [0]",
                              "type": "array",
                              "items": {
                                "type": "integer",
                                "format": "int64"
                              }
                            },
                            "artifactId": {
                              "description": "Required. The id of the relevant artifact in the recipe.",
                              "type": "string"
                            },
                            "flags": {
                              "description": "The flags to use when installing the MSI defaults to [\"/i\"] (i.e. the install flag).",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        },
                        "rpmInstallation": {
                          "description": "Installs an rpm file via the rpm utility.",
                          "type": "object",
                          "properties": {
                            "artifactId": {
                              "description": "Required. The id of the relevant artifact in the recipe.",
                              "type": "string"
                            }
                          }
                        },
                        "scriptRun": {
                          "description": "Runs commands in a shell.",
                          "type": "object",
                          "properties": {
                            "allowedExitCodes": {
                              "description": "Return codes that indicate that the software installed or updated successfully. Behaviour defaults to [0]",
                              "type": "array",
                              "items": {
                                "type": "integer",
                                "format": "int64"
                              }
                            },
                            "interpreter": {
                              "description": "The script interpreter to use to run the script. If no interpreter is specified the script is executed directly, which likely only succeed for scripts with [shebang lines](https://en.wikipedia.org/wiki/Shebang_(Unix)). Possible values: INTERPRETER_UNSPECIFIED, NONE, SHELL, POWERSHELL",
                              "type": "string"
                            },
                            "script": {
                              "description": "Required. The shell script to be executed.",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  },
                  "name": {
                    "description": "Required. Unique identifier for the recipe. Only one recipe with a given name is installed on an instance. Names are also used to identify resources which helps to determine whether guest policies have conflicts. This means that requests to create multiple recipes with the same name and version are rejected since they could potentially have conflicting assignments.",
                    "type": "string"
                  },
                  "updateSteps": {
                    "description": "Actions to be taken for updating this recipe. On failure it stops executing steps and does not attempt another update for this recipe. Any steps taken (including partially completed steps) are not rolled back.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "archiveExtraction": {
                          "description": "Extracts an archive into the specified directory.",
                          "type": "object",
                          "properties": {
                            "artifactId": {
                              "description": "Required. The id of the relevant artifact in the recipe.",
                              "type": "string"
                            },
                            "destination": {
                              "description": "Directory to extract archive to. Defaults to `/` on Linux or `C:` on Windows.",
                              "type": "string"
                            },
                            "type": {
                              "description": "Required. The type of the archive to extract. Possible values: TYPE_UNSPECIFIED, VALIDATION, DESIRED_STATE_CHECK, DESIRED_STATE_ENFORCEMENT, DESIRED_STATE_CHECK_POST_ENFORCEMENT",
                              "type": "string"
                            }
                          }
                        },
                        "dpkgInstallation": {
                          "description": "Installs a deb file via dpkg.",
                          "type": "object",
                          "properties": {
                            "artifactId": {
                              "description": "Required. The id of the relevant artifact in the recipe.",
                              "type": "string"
                            }
                          }
                        },
                        "fileCopy": {
                          "description": "Copies a file onto the instance.",
                          "type": "object",
                          "properties": {
                            "artifactId": {
                              "description": "Required. The id of the relevant artifact in the recipe.",
                              "type": "string"
                            },
                            "destination": {
                              "description": "Required. The absolute path on the instance to put the file.",
                              "type": "string"
                            },
                            "overwrite": {
                              "description": "Whether to allow this step to overwrite existing files. If this is false and the file already exists the file is not overwritten and the step is considered a success. Defaults to false.",
                              "type": "boolean"
                            },
                            "permissions": {
                              "description": "Consists of three octal digits which represent, in order, the permissions of the owner, group, and other users for the file (similarly to the numeric mode used in the linux chmod utility). Each digit represents a three bit number with the 4 bit corresponding to the read permissions, the 2 bit corresponds to the write bit, and the one bit corresponds to the execute permission. Default behavior is 755. Below are some examples of permissions and their associated values: read, write, and execute: 7 read and execute: 5 read and write: 6 read only: 4",
                              "type": "string"
                            }
                          }
                        },
                        "fileExec": {
                          "description": "Executes an artifact or local file.",
                          "type": "object",
                          "properties": {
                            "allowedExitCodes": {
                              "description": "Defaults to [0]. A list of possible return values that the program can return to indicate a success.",
                              "type": "array",
                              "items": {
                                "type": "integer",
                                "format": "int64"
                              }
                            },
                            "args": {
                              "description": "Arguments to be passed to the provided executable.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "artifactId": {
                              "description": "The id of the relevant artifact in the recipe.",
                              "type": "string"
                            },
                            "localPath": {
                              "description": "The absolute path of the file on the local filesystem.",
                              "type": "string"
                            }
                          }
                        },
                        "msiInstallation": {
                          "description": "Installs an MSI file.",
                          "type": "object",
                          "properties": {
                            "allowedExitCodes": {
                              "description": "Return codes that indicate that the software installed or updated successfully. Behaviour defaults to [0]",
                              "type": "array",
                              "items": {
                                "type": "integer",
                                "format": "int64"
                              }
                            },
                            "artifactId": {
                              "description": "Required. The id of the relevant artifact in the recipe.",
                              "type": "string"
                            },
                            "flags": {
                              "description": "The flags to use when installing the MSI defaults to [\"/i\"] (i.e. the install flag).",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        },
                        "rpmInstallation": {
                          "description": "Installs an rpm file via the rpm utility.",
                          "type": "object",
                          "properties": {
                            "artifactId": {
                              "description": "Required. The id of the relevant artifact in the recipe.",
                              "type": "string"
                            }
                          }
                        },
                        "scriptRun": {
                          "description": "Runs commands in a shell.",
                          "type": "object",
                          "properties": {
                            "allowedExitCodes": {
                              "description": "Return codes that indicate that the software installed or updated successfully. Behaviour defaults to [0]",
                              "type": "array",
                              "items": {
                                "type": "integer",
                                "format": "int64"
                              }
                            },
                            "interpreter": {
                              "description": "The script interpreter to use to run the script. If no interpreter is specified the script is executed directly, which likely only succeed for scripts with [shebang lines](https://en.wikipedia.org/wiki/Shebang_(Unix)). Possible values: INTERPRETER_UNSPECIFIED, NONE, SHELL, POWERSHELL",
                              "type": "string"
                            },
                            "script": {
                              "description": "Required. The shell script to be executed.",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  },
                  "version": {
                    "description": "The version of this software recipe. Version can be up to 4 period separated numbers (e.g. 12.34.56.78).",
                    "type": "string"
                  }
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. Time this GuestPolicy was created.",
              "type": "string",
              "format": "date-time"
            },
            "etag": {
              "description": "The etag for this GuestPolicy. If this is provided on update, it must match the server's etag.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Output only. Last time this GuestPolicy was updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "osconfig.cnrm.cloud.google.com",
          "kind": "OSConfigGuestPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.osconfig.v1beta1.OSConfigGuestPolicyList": {
      "description": "OSConfigGuestPolicyList is a list of OSConfigGuestPolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["osconfig.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of osconfigguestpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.osconfig.v1beta1.OSConfigGuestPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["OSConfigGuestPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "osconfig.cnrm.cloud.google.com",
          "kind": "OSConfigGuestPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.osconfig.v1beta1.OSConfigOSPolicyAssignment": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["osconfig.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["OSConfigOSPolicyAssignment"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": [
            "instanceFilter",
            "location",
            "osPolicies",
            "projectRef",
            "rollout"
          ],
          "properties": {
            "description": {
              "description": "OS policy assignment description. Length of the description is limited to 1024 characters.",
              "type": "string"
            },
            "instanceFilter": {
              "description": "Required. Filter to select VMs.",
              "type": "object",
              "properties": {
                "all": {
                  "description": "Target all VMs in the project. If true, no other criteria is permitted.",
                  "type": "boolean"
                },
                "exclusionLabels": {
                  "description": "List of label sets used for VM exclusion. If the list has more than one label set, the VM is excluded if any of the label sets are applicable for the VM.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "labels": {
                        "description": "Labels are identified by key/value pairs in this map. A VM should contain all the key/value pairs specified in this map to be selected.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "inclusionLabels": {
                  "description": "List of label sets used for VM inclusion. If the list has more than one `LabelSet`, the VM is included if any of the label sets are applicable for the VM.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "labels": {
                        "description": "Labels are identified by key/value pairs in this map. A VM should contain all the key/value pairs specified in this map to be selected.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "inventories": {
                  "description": "List of inventories to select VMs. A VM is selected if its inventory data matches at least one of the following inventories.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["osShortName"],
                    "properties": {
                      "osShortName": {
                        "description": "Required. The OS short name",
                        "type": "string"
                      },
                      "osVersion": {
                        "description": "The OS version Prefix matches are supported if asterisk(*) is provided as the last character. For example, to match all versions with a major version of `7`, specify the following value for this field `7.*` An empty string matches all OS versions.",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "osPolicies": {
              "description": "Required. List of OS policies to be applied to the VMs.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["id", "mode", "resourceGroups"],
                "properties": {
                  "allowNoResourceGroupMatch": {
                    "description": "This flag determines the OS policy compliance status when none of the resource groups within the policy are applicable for a VM. Set this value to `true` if the policy needs to be reported as compliant even if the policy has nothing to validate or enforce.",
                    "type": "boolean"
                  },
                  "description": {
                    "description": "Policy description. Length of the description is limited to 1024 characters.",
                    "type": "string"
                  },
                  "id": {
                    "description": "Required. The id of the OS policy with the following restrictions: * Must contain only lowercase letters, numbers, and hyphens. * Must start with a letter. * Must be between 1-63 characters. * Must end with a number or a letter. * Must be unique within the assignment.",
                    "type": "string"
                  },
                  "mode": {
                    "description": "Required. Policy mode Possible values: MODE_UNSPECIFIED, VALIDATION, ENFORCEMENT",
                    "type": "string"
                  },
                  "resourceGroups": {
                    "description": "Required. List of resource groups for the policy. For a particular VM, resource groups are evaluated in the order specified and the first resource group that is applicable is selected and the rest are ignored. If none of the resource groups are applicable for a VM, the VM is considered to be non-compliant w.r.t this policy. This behavior can be toggled by the flag `allow_no_resource_group_match`",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": ["resources"],
                      "properties": {
                        "inventoryFilters": {
                          "description": "List of inventory filters for the resource group. The resources in this resource group are applied to the target VM if it satisfies at least one of the following inventory filters. For example, to apply this resource group to VMs running either `RHEL` or `CentOS` operating systems, specify 2 items for the list with following values: inventory_filters[0].os_short_name='rhel' and inventory_filters[1].os_short_name='centos' If the list is empty, this resource group will be applied to the target VM unconditionally.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "required": ["osShortName"],
                            "properties": {
                              "osShortName": {
                                "description": "Required. The OS short name",
                                "type": "string"
                              },
                              "osVersion": {
                                "description": "The OS version Prefix matches are supported if asterisk(*) is provided as the last character. For example, to match all versions with a major version of `7`, specify the following value for this field `7.*` An empty string matches all OS versions.",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "resources": {
                          "description": "Required. List of resources configured for this resource group. The resources are executed in the exact order specified here.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "required": ["id"],
                            "properties": {
                              "exec": {
                                "description": "Exec resource",
                                "type": "object",
                                "required": ["validate"],
                                "properties": {
                                  "enforce": {
                                    "description": "Required. What to run to validate this resource is in the desired state. An exit code of 100 indicates \"in desired state\", and exit code of 101 indicates \"not in desired state\". Any other exit code indicates a failure running validate.",
                                    "type": "object",
                                    "required": ["interpreter"],
                                    "properties": {
                                      "args": {
                                        "description": "Optional arguments to pass to the source during execution.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "file": {
                                        "description": "Required. A deb package.",
                                        "type": "object",
                                        "properties": {
                                          "allowInsecure": {
                                            "description": "Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.",
                                            "type": "boolean"
                                          },
                                          "gcs": {
                                            "description": "A Cloud Storage object.",
                                            "type": "object",
                                            "required": ["bucket", "object"],
                                            "properties": {
                                              "bucket": {
                                                "description": "Required. Bucket of the Cloud Storage object.",
                                                "type": "string"
                                              },
                                              "generation": {
                                                "description": "Generation number of the Cloud Storage object.",
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "object": {
                                                "description": "Required. Name of the Cloud Storage object.",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "localPath": {
                                            "description": "A local path within the VM to use.",
                                            "type": "string"
                                          },
                                          "remote": {
                                            "description": "A generic remote file.",
                                            "type": "object",
                                            "required": ["uri"],
                                            "properties": {
                                              "sha256Checksum": {
                                                "description": "SHA256 checksum of the remote file.",
                                                "type": "string"
                                              },
                                              "uri": {
                                                "description": "Required. URI from which to fetch the object. It should contain both the protocol and path following the format `{protocol}://{location}`.",
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "interpreter": {
                                        "description": "Required. The script interpreter to use. Possible values: INTERPRETER_UNSPECIFIED, NONE, SHELL, POWERSHELL",
                                        "type": "string"
                                      },
                                      "outputFilePath": {
                                        "description": "Only recorded for enforce Exec. Path to an output file (that is created by this Exec) whose content will be recorded in OSPolicyResourceCompliance after a successful run. Absence or failure to read this file will result in this ExecResource being non-compliant. Output file size is limited to 100K bytes.",
                                        "type": "string"
                                      },
                                      "script": {
                                        "description": "An inline script. The size of the script is limited to 1024 characters.",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "validate": {
                                    "description": "Required. What to run to validate this resource is in the desired state. An exit code of 100 indicates \"in desired state\", and exit code of 101 indicates \"not in desired state\". Any other exit code indicates a failure running validate.",
                                    "type": "object",
                                    "required": ["interpreter"],
                                    "properties": {
                                      "args": {
                                        "description": "Optional arguments to pass to the source during execution.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "file": {
                                        "description": "Required. A deb package.",
                                        "type": "object",
                                        "properties": {
                                          "allowInsecure": {
                                            "description": "Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.",
                                            "type": "boolean"
                                          },
                                          "gcs": {
                                            "description": "A Cloud Storage object.",
                                            "type": "object",
                                            "required": ["bucket", "object"],
                                            "properties": {
                                              "bucket": {
                                                "description": "Required. Bucket of the Cloud Storage object.",
                                                "type": "string"
                                              },
                                              "generation": {
                                                "description": "Generation number of the Cloud Storage object.",
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "object": {
                                                "description": "Required. Name of the Cloud Storage object.",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "localPath": {
                                            "description": "A local path within the VM to use.",
                                            "type": "string"
                                          },
                                          "remote": {
                                            "description": "A generic remote file.",
                                            "type": "object",
                                            "required": ["uri"],
                                            "properties": {
                                              "sha256Checksum": {
                                                "description": "SHA256 checksum of the remote file.",
                                                "type": "string"
                                              },
                                              "uri": {
                                                "description": "Required. URI from which to fetch the object. It should contain both the protocol and path following the format `{protocol}://{location}`.",
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "interpreter": {
                                        "description": "Required. The script interpreter to use. Possible values: INTERPRETER_UNSPECIFIED, NONE, SHELL, POWERSHELL",
                                        "type": "string"
                                      },
                                      "outputFilePath": {
                                        "description": "Only recorded for enforce Exec. Path to an output file (that is created by this Exec) whose content will be recorded in OSPolicyResourceCompliance after a successful run. Absence or failure to read this file will result in this ExecResource being non-compliant. Output file size is limited to 100K bytes.",
                                        "type": "string"
                                      },
                                      "script": {
                                        "description": "An inline script. The size of the script is limited to 1024 characters.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              },
                              "file": {
                                "description": "File resource",
                                "type": "object",
                                "required": ["path", "state"],
                                "properties": {
                                  "content": {
                                    "description": "A a file with this content. The size of the content is limited to 1024 characters.",
                                    "type": "string"
                                  },
                                  "file": {
                                    "description": "Required. A deb package.",
                                    "type": "object",
                                    "properties": {
                                      "allowInsecure": {
                                        "description": "Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.",
                                        "type": "boolean"
                                      },
                                      "gcs": {
                                        "description": "A Cloud Storage object.",
                                        "type": "object",
                                        "required": ["bucket", "object"],
                                        "properties": {
                                          "bucket": {
                                            "description": "Required. Bucket of the Cloud Storage object.",
                                            "type": "string"
                                          },
                                          "generation": {
                                            "description": "Generation number of the Cloud Storage object.",
                                            "type": "integer",
                                            "format": "int64"
                                          },
                                          "object": {
                                            "description": "Required. Name of the Cloud Storage object.",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "localPath": {
                                        "description": "A local path within the VM to use.",
                                        "type": "string"
                                      },
                                      "remote": {
                                        "description": "A generic remote file.",
                                        "type": "object",
                                        "required": ["uri"],
                                        "properties": {
                                          "sha256Checksum": {
                                            "description": "SHA256 checksum of the remote file.",
                                            "type": "string"
                                          },
                                          "uri": {
                                            "description": "Required. URI from which to fetch the object. It should contain both the protocol and path following the format `{protocol}://{location}`.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "path": {
                                    "description": "Required. The absolute path of the file within the VM.",
                                    "type": "string"
                                  },
                                  "permissions": {
                                    "description": "Consists of three octal digits which represent, in order, the permissions of the owner, group, and other users for the file (similarly to the numeric mode used in the linux chmod utility). Each digit represents a three bit number with the 4 bit corresponding to the read permissions, the 2 bit corresponds to the write bit, and the one bit corresponds to the execute permission. Default behavior is 755. Below are some examples of permissions and their associated values: read, write, and execute: 7 read and execute: 5 read and write: 6 read only: 4",
                                    "type": "string"
                                  },
                                  "state": {
                                    "description": "Required. Desired state of the file. Possible values: OS_POLICY_COMPLIANCE_STATE_UNSPECIFIED, COMPLIANT, NON_COMPLIANT, UNKNOWN, NO_OS_POLICIES_APPLICABLE",
                                    "type": "string"
                                  }
                                }
                              },
                              "id": {
                                "description": "Required. The id of the resource with the following restrictions: * Must contain only lowercase letters, numbers, and hyphens. * Must start with a letter. * Must be between 1-63 characters. * Must end with a number or a letter. * Must be unique within the OS policy.",
                                "type": "string"
                              },
                              "pkg": {
                                "description": "Package resource",
                                "type": "object",
                                "required": ["desiredState"],
                                "properties": {
                                  "apt": {
                                    "description": "A package managed by Apt.",
                                    "type": "object",
                                    "required": ["name"],
                                    "properties": {
                                      "name": {
                                        "description": "Required. Package name.",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "deb": {
                                    "description": "A deb package file.",
                                    "type": "object",
                                    "required": ["source"],
                                    "properties": {
                                      "pullDeps": {
                                        "description": "Whether dependencies should also be installed. - install when false: `dpkg -i package` - install when true: `apt-get update && apt-get -y install package.deb`",
                                        "type": "boolean"
                                      },
                                      "source": {
                                        "description": "Required. A deb package.",
                                        "type": "object",
                                        "properties": {
                                          "allowInsecure": {
                                            "description": "Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.",
                                            "type": "boolean"
                                          },
                                          "gcs": {
                                            "description": "A Cloud Storage object.",
                                            "type": "object",
                                            "required": ["bucket", "object"],
                                            "properties": {
                                              "bucket": {
                                                "description": "Required. Bucket of the Cloud Storage object.",
                                                "type": "string"
                                              },
                                              "generation": {
                                                "description": "Generation number of the Cloud Storage object.",
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "object": {
                                                "description": "Required. Name of the Cloud Storage object.",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "localPath": {
                                            "description": "A local path within the VM to use.",
                                            "type": "string"
                                          },
                                          "remote": {
                                            "description": "A generic remote file.",
                                            "type": "object",
                                            "required": ["uri"],
                                            "properties": {
                                              "sha256Checksum": {
                                                "description": "SHA256 checksum of the remote file.",
                                                "type": "string"
                                              },
                                              "uri": {
                                                "description": "Required. URI from which to fetch the object. It should contain both the protocol and path following the format `{protocol}://{location}`.",
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "desiredState": {
                                    "description": "Required. The desired state the agent should maintain for this package. Possible values: DESIRED_STATE_UNSPECIFIED, INSTALLED, REMOVED",
                                    "type": "string"
                                  },
                                  "googet": {
                                    "description": "A package managed by GooGet.",
                                    "type": "object",
                                    "required": ["name"],
                                    "properties": {
                                      "name": {
                                        "description": "Required. Package name.",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "msi": {
                                    "description": "An MSI package.",
                                    "type": "object",
                                    "required": ["source"],
                                    "properties": {
                                      "properties": {
                                        "description": "Additional properties to use during installation. This should be in the format of Property=Setting. Appended to the defaults of `ACTION=INSTALL REBOOT=ReallySuppress`.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "source": {
                                        "description": "Required. A deb package.",
                                        "type": "object",
                                        "properties": {
                                          "allowInsecure": {
                                            "description": "Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.",
                                            "type": "boolean"
                                          },
                                          "gcs": {
                                            "description": "A Cloud Storage object.",
                                            "type": "object",
                                            "required": ["bucket", "object"],
                                            "properties": {
                                              "bucket": {
                                                "description": "Required. Bucket of the Cloud Storage object.",
                                                "type": "string"
                                              },
                                              "generation": {
                                                "description": "Generation number of the Cloud Storage object.",
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "object": {
                                                "description": "Required. Name of the Cloud Storage object.",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "localPath": {
                                            "description": "A local path within the VM to use.",
                                            "type": "string"
                                          },
                                          "remote": {
                                            "description": "A generic remote file.",
                                            "type": "object",
                                            "required": ["uri"],
                                            "properties": {
                                              "sha256Checksum": {
                                                "description": "SHA256 checksum of the remote file.",
                                                "type": "string"
                                              },
                                              "uri": {
                                                "description": "Required. URI from which to fetch the object. It should contain both the protocol and path following the format `{protocol}://{location}`.",
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "rpm": {
                                    "description": "An rpm package file.",
                                    "type": "object",
                                    "required": ["source"],
                                    "properties": {
                                      "pullDeps": {
                                        "description": "Whether dependencies should also be installed. - install when false: `rpm --upgrade --replacepkgs package.rpm` - install when true: `yum -y install package.rpm` or `zypper -y install package.rpm`",
                                        "type": "boolean"
                                      },
                                      "source": {
                                        "description": "Required. A deb package.",
                                        "type": "object",
                                        "properties": {
                                          "allowInsecure": {
                                            "description": "Defaults to false. When false, files are subject to validations based on the file type: Remote: A checksum must be specified. Cloud Storage: An object generation number must be specified.",
                                            "type": "boolean"
                                          },
                                          "gcs": {
                                            "description": "A Cloud Storage object.",
                                            "type": "object",
                                            "required": ["bucket", "object"],
                                            "properties": {
                                              "bucket": {
                                                "description": "Required. Bucket of the Cloud Storage object.",
                                                "type": "string"
                                              },
                                              "generation": {
                                                "description": "Generation number of the Cloud Storage object.",
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "object": {
                                                "description": "Required. Name of the Cloud Storage object.",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "localPath": {
                                            "description": "A local path within the VM to use.",
                                            "type": "string"
                                          },
                                          "remote": {
                                            "description": "A generic remote file.",
                                            "type": "object",
                                            "required": ["uri"],
                                            "properties": {
                                              "sha256Checksum": {
                                                "description": "SHA256 checksum of the remote file.",
                                                "type": "string"
                                              },
                                              "uri": {
                                                "description": "Required. URI from which to fetch the object. It should contain both the protocol and path following the format `{protocol}://{location}`.",
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "yum": {
                                    "description": "A package managed by YUM.",
                                    "type": "object",
                                    "required": ["name"],
                                    "properties": {
                                      "name": {
                                        "description": "Required. Package name.",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "zypper": {
                                    "description": "A package managed by Zypper.",
                                    "type": "object",
                                    "required": ["name"],
                                    "properties": {
                                      "name": {
                                        "description": "Required. Package name.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              },
                              "repository": {
                                "description": "Package repository resource",
                                "type": "object",
                                "properties": {
                                  "apt": {
                                    "description": "An Apt Repository.",
                                    "type": "object",
                                    "required": [
                                      "archiveType",
                                      "components",
                                      "distribution",
                                      "uri"
                                    ],
                                    "properties": {
                                      "archiveType": {
                                        "description": "Required. Type of archive files in this repository. Possible values: ARCHIVE_TYPE_UNSPECIFIED, DEB, DEB_SRC",
                                        "type": "string"
                                      },
                                      "components": {
                                        "description": "Required. List of components for this repository. Must contain at least one item.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "distribution": {
                                        "description": "Required. Distribution of this repository.",
                                        "type": "string"
                                      },
                                      "gpgKey": {
                                        "description": "URI of the key file for this repository. The agent maintains a keyring at `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg`.",
                                        "type": "string"
                                      },
                                      "uri": {
                                        "description": "Required. URI for this repository.",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "goo": {
                                    "description": "A Goo Repository.",
                                    "type": "object",
                                    "required": ["name", "url"],
                                    "properties": {
                                      "name": {
                                        "description": "Required. The name of the repository.",
                                        "type": "string"
                                      },
                                      "url": {
                                        "description": "Required. The url of the repository.",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "yum": {
                                    "description": "A Yum Repository.",
                                    "type": "object",
                                    "required": ["baseUrl", "id"],
                                    "properties": {
                                      "baseUrl": {
                                        "description": "Required. The location of the repository directory.",
                                        "type": "string"
                                      },
                                      "displayName": {
                                        "description": "The display name of the repository.",
                                        "type": "string"
                                      },
                                      "gpgKeys": {
                                        "description": "URIs of GPG keys.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "id": {
                                        "description": "Required. A one word, unique name for this repository. This is the `repo id` in the yum config file and also the `display_name` if `display_name` is omitted. This id is also used as the unique identifier when checking for resource conflicts.",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "zypper": {
                                    "description": "A Zypper Repository.",
                                    "type": "object",
                                    "required": ["baseUrl", "id"],
                                    "properties": {
                                      "baseUrl": {
                                        "description": "Required. The location of the repository directory.",
                                        "type": "string"
                                      },
                                      "displayName": {
                                        "description": "The display name of the repository.",
                                        "type": "string"
                                      },
                                      "gpgKeys": {
                                        "description": "URIs of GPG keys.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "id": {
                                        "description": "Required. A one word, unique name for this repository. This is the `repo id` in the zypper config file and also the `display_name` if `display_name` is omitted. This id is also used as the unique identifier when checking for GuestPolicy conflicts.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "rollout": {
              "description": "Required. Rollout to deploy the OS policy assignment. A rollout is triggered in the following situations: 1) OSPolicyAssignment is created. 2) OSPolicyAssignment is updated and the update contains changes to one of the following fields: - instance_filter - os_policies 3) OSPolicyAssignment is deleted.",
              "type": "object",
              "required": ["disruptionBudget", "minWaitDuration"],
              "properties": {
                "disruptionBudget": {
                  "description": "Required. The maximum number (or percentage) of VMs per zone to disrupt at any given moment.",
                  "type": "object",
                  "properties": {
                    "fixed": {
                      "description": "Specifies a fixed value.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "percent": {
                      "description": "Specifies the relative value defined as a percentage, which will be multiplied by a reference value.",
                      "type": "integer",
                      "format": "int64"
                    }
                  }
                },
                "minWaitDuration": {
                  "description": "Required. This determines the minimum duration of time to wait after the configuration changes are applied through the current rollout. A VM continues to count towards the `disruption_budget` at least until this duration of time has passed after configuration changes are applied.",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "baseline": {
              "description": "Output only. Indicates that this revision has been successfully rolled out in this zone and new VMs will be assigned OS policies from this revision. For a given OS policy assignment, there is only one revision with a value of `true` for this field.",
              "type": "boolean"
            },
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "deleted": {
              "description": "Output only. Indicates that this revision deletes the OS policy assignment.",
              "type": "boolean"
            },
            "etag": {
              "description": "The etag for this OS policy assignment. If this is provided on update, it must match the server's etag.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "reconciling": {
              "description": "Output only. Indicates that reconciliation is in progress for the revision. This value is `true` when the `rollout_state` is one of: * IN_PROGRESS * CANCELLING",
              "type": "boolean"
            },
            "revisionCreateTime": {
              "description": "Output only. The timestamp that the revision was created.",
              "type": "string",
              "format": "date-time"
            },
            "revisionId": {
              "description": "Output only. The assignment revision ID A new revision is committed whenever a rollout is triggered for a OS policy assignment",
              "type": "string"
            },
            "rolloutState": {
              "description": "Output only. OS policy assignment rollout state Possible values: ROLLOUT_STATE_UNSPECIFIED, IN_PROGRESS, CANCELLING, CANCELLED, SUCCEEDED",
              "type": "string"
            },
            "uid": {
              "description": "Output only. Server generated unique id for the OS policy assignment resource.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "osconfig.cnrm.cloud.google.com",
          "kind": "OSConfigOSPolicyAssignment",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.osconfig.v1beta1.OSConfigOSPolicyAssignmentList": {
      "description": "OSConfigOSPolicyAssignmentList is a list of OSConfigOSPolicyAssignment",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["osconfig.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of osconfigospolicyassignments. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.osconfig.v1beta1.OSConfigOSPolicyAssignment"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["OSConfigOSPolicyAssignmentList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "osconfig.cnrm.cloud.google.com",
          "kind": "OSConfigOSPolicyAssignmentList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.privateca.v1beta1.PrivateCACAPool": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["privateca.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PrivateCACAPool"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location", "projectRef", "tier"],
          "properties": {
            "issuancePolicy": {
              "description": "Optional. The IssuancePolicy to control how Certificates will be issued from this CaPool.",
              "type": "object",
              "properties": {
                "allowedIssuanceModes": {
                  "description": "Optional. If specified, then only methods allowed in the IssuanceModes may be used to issue Certificates.",
                  "type": "object",
                  "properties": {
                    "allowConfigBasedIssuance": {
                      "description": "Optional. When true, allows callers to create Certificates by specifying a CertificateConfig.",
                      "type": "boolean"
                    },
                    "allowCsrBasedIssuance": {
                      "description": "Optional. When true, allows callers to create Certificates by specifying a CSR.",
                      "type": "boolean"
                    }
                  }
                },
                "allowedKeyTypes": {
                  "description": "Optional. If any AllowedKeyType is specified, then the certificate request's public key must match one of the key types listed here. Otherwise, any key may be used.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "ellipticCurve": {
                        "description": "Represents an allowed Elliptic Curve key type.",
                        "type": "object",
                        "properties": {
                          "signatureAlgorithm": {
                            "description": "Optional. A signature algorithm that must be used. If this is omitted, any EC-based signature algorithm will be allowed. Possible values: EC_SIGNATURE_ALGORITHM_UNSPECIFIED, ECDSA_P256, ECDSA_P384, EDDSA_25519",
                            "type": "string"
                          }
                        }
                      },
                      "rsa": {
                        "description": "Represents an allowed RSA key type.",
                        "type": "object",
                        "properties": {
                          "maxModulusSize": {
                            "description": "Optional. The maximum allowed RSA modulus size, in bits. If this is not set, or if set to zero, the service will not enforce an explicit upper bound on RSA modulus sizes.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "minModulusSize": {
                            "description": "Optional. The minimum allowed RSA modulus size, in bits. If this is not set, or if set to zero, the service-level min RSA modulus size will continue to apply.",
                            "type": "integer",
                            "format": "int64"
                          }
                        }
                      }
                    }
                  }
                },
                "baselineValues": {
                  "description": "Optional. A set of X.509 values that will be applied to all certificates issued through this CaPool. If a certificate request includes conflicting values for the same properties, they will be overwritten by the values defined here. If a certificate request uses a CertificateTemplate that defines conflicting predefined_values for the same properties, the certificate issuance request will fail.",
                  "type": "object",
                  "properties": {
                    "additionalExtensions": {
                      "description": "Optional. Describes custom X.509 extensions.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": ["objectId", "value"],
                        "properties": {
                          "critical": {
                            "description": "Optional. Indicates whether or not this extension is critical (i.e., if the client does not know how to handle this extension, the client should consider this to be an error).",
                            "type": "boolean"
                          },
                          "objectId": {
                            "description": "Required. The OID for this X.509 extension.",
                            "type": "object",
                            "required": ["objectIdPath"],
                            "properties": {
                              "objectIdPath": {
                                "description": "Required. The parts of an OID path. The most significant parts of the path come first.",
                                "type": "array",
                                "items": {
                                  "type": "integer",
                                  "format": "int64"
                                }
                              }
                            }
                          },
                          "value": {
                            "description": "Required. The value of this X.509 extension.",
                            "type": "string"
                          }
                        }
                      }
                    },
                    "aiaOcspServers": {
                      "description": "Optional. Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the \"Authority Information Access\" extension in the certificate.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "caOptions": {
                      "description": "Optional. Describes options in this X509Parameters that are relevant in a CA certificate.",
                      "type": "object",
                      "properties": {
                        "isCa": {
                          "description": "Optional. Refers to the \"CA\" X.509 extension, which is a boolean value. When this value is missing, the extension will be omitted from the CA certificate.",
                          "type": "boolean"
                        },
                        "maxIssuerPathLength": {
                          "description": "Optional. Refers to the path length restriction X.509 extension. For a CA certificate, this value describes the depth of subordinate CA certificates that are allowed. If this value is less than 0, the request will fail. If this value is missing, the max path length will be omitted from the CA certificate.",
                          "type": "integer",
                          "format": "int64"
                        }
                      }
                    },
                    "keyUsage": {
                      "description": "Optional. Indicates the intended use for keys that correspond to a certificate.",
                      "type": "object",
                      "properties": {
                        "baseKeyUsage": {
                          "description": "Describes high-level ways in which a key may be used.",
                          "type": "object",
                          "properties": {
                            "certSign": {
                              "description": "The key may be used to sign certificates.",
                              "type": "boolean"
                            },
                            "contentCommitment": {
                              "description": "The key may be used for cryptographic commitments. Note that this may also be referred to as \"non-repudiation\".",
                              "type": "boolean"
                            },
                            "crlSign": {
                              "description": "The key may be used sign certificate revocation lists.",
                              "type": "boolean"
                            },
                            "dataEncipherment": {
                              "description": "The key may be used to encipher data.",
                              "type": "boolean"
                            },
                            "decipherOnly": {
                              "description": "The key may be used to decipher only.",
                              "type": "boolean"
                            },
                            "digitalSignature": {
                              "description": "The key may be used for digital signatures.",
                              "type": "boolean"
                            },
                            "encipherOnly": {
                              "description": "The key may be used to encipher only.",
                              "type": "boolean"
                            },
                            "keyAgreement": {
                              "description": "The key may be used in a key agreement protocol.",
                              "type": "boolean"
                            },
                            "keyEncipherment": {
                              "description": "The key may be used to encipher other keys.",
                              "type": "boolean"
                            }
                          }
                        },
                        "extendedKeyUsage": {
                          "description": "Detailed scenarios in which a key may be used.",
                          "type": "object",
                          "properties": {
                            "clientAuth": {
                              "description": "Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as \"TLS WWW client authentication\", though regularly used for non-WWW TLS.",
                              "type": "boolean"
                            },
                            "codeSigning": {
                              "description": "Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as \"Signing of downloadable executable code client authentication\".",
                              "type": "boolean"
                            },
                            "emailProtection": {
                              "description": "Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as \"Email protection\".",
                              "type": "boolean"
                            },
                            "ocspSigning": {
                              "description": "Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as \"Signing OCSP responses\".",
                              "type": "boolean"
                            },
                            "serverAuth": {
                              "description": "Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as \"TLS WWW server authentication\", though regularly used for non-WWW TLS.",
                              "type": "boolean"
                            },
                            "timeStamping": {
                              "description": "Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as \"Binding the hash of an object to a time\".",
                              "type": "boolean"
                            }
                          }
                        },
                        "unknownExtendedKeyUsages": {
                          "description": "Used to describe extended key usages that are not listed in the KeyUsage.ExtendedKeyUsageOptions message.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "required": ["objectIdPath"],
                            "properties": {
                              "objectIdPath": {
                                "description": "Required. The parts of an OID path. The most significant parts of the path come first.",
                                "type": "array",
                                "items": {
                                  "type": "integer",
                                  "format": "int64"
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "policyIds": {
                      "description": "Optional. Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": ["objectIdPath"],
                        "properties": {
                          "objectIdPath": {
                            "description": "Required. The parts of an OID path. The most significant parts of the path come first.",
                            "type": "array",
                            "items": {
                              "type": "integer",
                              "format": "int64"
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "identityConstraints": {
                  "description": "Optional. Describes constraints on identities that may appear in Certificates issued through this CaPool. If this is omitted, then this CaPool will not add restrictions on a certificate's identity.",
                  "type": "object",
                  "required": [
                    "allowSubjectAltNamesPassthrough",
                    "allowSubjectPassthrough"
                  ],
                  "properties": {
                    "allowSubjectAltNamesPassthrough": {
                      "description": "Required. If this is true, the SubjectAltNames extension may be copied from a certificate request into the signed certificate. Otherwise, the requested SubjectAltNames will be discarded.",
                      "type": "boolean"
                    },
                    "allowSubjectPassthrough": {
                      "description": "Required. If this is true, the Subject field may be copied from a certificate request into the signed certificate. Otherwise, the requested Subject will be discarded.",
                      "type": "boolean"
                    },
                    "celExpression": {
                      "description": "Optional. A CEL expression that may be used to validate the resolved X.509 Subject and/or Subject Alternative Name before a certificate is signed. To see the full allowed syntax and some examples, see https://cloud.google.com/certificate-authority-service/docs/using-cel",
                      "type": "object",
                      "properties": {
                        "description": {
                          "description": "Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.",
                          "type": "string"
                        },
                        "expression": {
                          "description": "Textual representation of an expression in Common Expression Language syntax.",
                          "type": "string"
                        },
                        "location": {
                          "description": "Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.",
                          "type": "string"
                        },
                        "title": {
                          "description": "Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "maximumLifetime": {
                  "description": "Optional. The maximum lifetime allowed for issued Certificates. Note that if the issuing CertificateAuthority expires before a Certificate's requested maximum_lifetime, the effective lifetime will be explicitly truncated to match it.",
                  "type": "string"
                },
                "passthroughExtensions": {
                  "description": "Optional. Describes the set of X.509 extensions that may appear in a Certificate issued through this CaPool. If a certificate request sets extensions that don't appear in the passthrough_extensions, those extensions will be dropped. If a certificate request uses a CertificateTemplate with predefined_values that don't appear here, the certificate issuance request will fail. If this is omitted, then this CaPool will not add restrictions on a certificate's X.509 extensions. These constraints do not apply to X.509 extensions set in this CaPool's baseline_values.",
                  "type": "object",
                  "properties": {
                    "additionalExtensions": {
                      "description": "Optional. A set of ObjectIds identifying custom X.509 extensions. Will be combined with known_extensions to determine the full set of X.509 extensions.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": ["objectIdPath"],
                        "properties": {
                          "objectIdPath": {
                            "description": "Required. The parts of an OID path. The most significant parts of the path come first.",
                            "type": "array",
                            "items": {
                              "type": "integer",
                              "format": "int64"
                            }
                          }
                        }
                      }
                    },
                    "knownExtensions": {
                      "description": "Optional. A set of named X.509 extensions. Will be combined with additional_extensions to determine the full set of X.509 extensions.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "publishingOptions": {
              "description": "Optional. The PublishingOptions to follow when issuing Certificates from any CertificateAuthority in this CaPool.",
              "type": "object",
              "properties": {
                "publishCaCert": {
                  "description": "Optional. When true, publishes each CertificateAuthority's CA certificate and includes its URL in the \"Authority Information Access\" X.509 extension in all issued Certificates. If this is false, the CA certificate will not be published and the corresponding X.509 extension will not be written in issued certificates.",
                  "type": "boolean"
                },
                "publishCrl": {
                  "description": "Optional. When true, publishes each CertificateAuthority's CRL and includes its URL in the \"CRL Distribution Points\" X.509 extension in all issued Certificates. If this is false, CRLs will not be published and the corresponding X.509 extension will not be written in issued certificates. CRLs will expire 7 days from their creation. However, we will rebuild daily. CRLs are also rebuilt shortly after a certificate is revoked.",
                  "type": "boolean"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "tier": {
              "description": "Required. Immutable. The Tier of this CaPool. Possible values: TIER_UNSPECIFIED, ENTERPRISE, DEVOPS",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "privateca.cnrm.cloud.google.com",
          "kind": "PrivateCACAPool",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.privateca.v1beta1.PrivateCACAPoolList": {
      "description": "PrivateCACAPoolList is a list of PrivateCACAPool",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["privateca.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of privatecacapools. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.privateca.v1beta1.PrivateCACAPool"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PrivateCACAPoolList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "privateca.cnrm.cloud.google.com",
          "kind": "PrivateCACAPoolList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.privateca.v1beta1.PrivateCACertificateTemplate": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["privateca.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PrivateCACertificateTemplate"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location", "projectRef"],
          "properties": {
            "description": {
              "description": "Optional. A human-readable description of scenarios this template is intended for.",
              "type": "string"
            },
            "identityConstraints": {
              "description": "Optional. Describes constraints on identities that may be appear in Certificates issued using this template. If this is omitted, then this template will not add restrictions on a certificate's identity.",
              "type": "object",
              "required": [
                "allowSubjectAltNamesPassthrough",
                "allowSubjectPassthrough"
              ],
              "properties": {
                "allowSubjectAltNamesPassthrough": {
                  "description": "Required. If this is true, the SubjectAltNames extension may be copied from a certificate request into the signed certificate. Otherwise, the requested SubjectAltNames will be discarded.",
                  "type": "boolean"
                },
                "allowSubjectPassthrough": {
                  "description": "Required. If this is true, the Subject field may be copied from a certificate request into the signed certificate. Otherwise, the requested Subject will be discarded.",
                  "type": "boolean"
                },
                "celExpression": {
                  "description": "Optional. A CEL expression that may be used to validate the resolved X.509 Subject and/or Subject Alternative Name before a certificate is signed. To see the full allowed syntax and some examples, see https://cloud.google.com/certificate-authority-service/docs/using-cel",
                  "type": "object",
                  "properties": {
                    "description": {
                      "description": "Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.",
                      "type": "string"
                    },
                    "expression": {
                      "description": "Textual representation of an expression in Common Expression Language syntax.",
                      "type": "string"
                    },
                    "location": {
                      "description": "Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.",
                      "type": "string"
                    },
                    "title": {
                      "description": "Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "passthroughExtensions": {
              "description": "Optional. Describes the set of X.509 extensions that may appear in a Certificate issued using this CertificateTemplate. If a certificate request sets extensions that don't appear in the passthrough_extensions, those extensions will be dropped. If the issuing CaPool's IssuancePolicy defines baseline_values that don't appear here, the certificate issuance request will fail. If this is omitted, then this template will not add restrictions on a certificate's X.509 extensions. These constraints do not apply to X.509 extensions set in this CertificateTemplate's predefined_values.",
              "type": "object",
              "properties": {
                "additionalExtensions": {
                  "description": "Optional. A set of ObjectIds identifying custom X.509 extensions. Will be combined with known_extensions to determine the full set of X.509 extensions.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["objectIdPath"],
                    "properties": {
                      "objectIdPath": {
                        "description": "Required. The parts of an OID path. The most significant parts of the path come first.",
                        "type": "array",
                        "items": {
                          "type": "integer",
                          "format": "int64"
                        }
                      }
                    }
                  }
                },
                "knownExtensions": {
                  "description": "Optional. A set of named X.509 extensions. Will be combined with additional_extensions to determine the full set of X.509 extensions.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "predefinedValues": {
              "description": "Optional. A set of X.509 values that will be applied to all issued certificates that use this template. If the certificate request includes conflicting values for the same properties, they will be overwritten by the values defined here. If the issuing CaPool's IssuancePolicy defines conflicting baseline_values for the same properties, the certificate issuance request will fail.",
              "type": "object",
              "properties": {
                "additionalExtensions": {
                  "description": "Optional. Describes custom X.509 extensions.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["objectId", "value"],
                    "properties": {
                      "critical": {
                        "description": "Optional. Indicates whether or not this extension is critical (i.e., if the client does not know how to handle this extension, the client should consider this to be an error).",
                        "type": "boolean"
                      },
                      "objectId": {
                        "description": "Required. The OID for this X.509 extension.",
                        "type": "object",
                        "required": ["objectIdPath"],
                        "properties": {
                          "objectIdPath": {
                            "description": "Required. The parts of an OID path. The most significant parts of the path come first.",
                            "type": "array",
                            "items": {
                              "type": "integer",
                              "format": "int64"
                            }
                          }
                        }
                      },
                      "value": {
                        "description": "Required. The value of this X.509 extension.",
                        "type": "string"
                      }
                    }
                  }
                },
                "aiaOcspServers": {
                  "description": "Optional. Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the \"Authority Information Access\" extension in the certificate.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "caOptions": {
                  "description": "Optional. Describes options in this X509Parameters that are relevant in a CA certificate.",
                  "type": "object",
                  "properties": {
                    "isCa": {
                      "description": "Optional. Refers to the \"CA\" X.509 extension, which is a boolean value. When this value is missing, the extension will be omitted from the CA certificate.",
                      "type": "boolean"
                    },
                    "maxIssuerPathLength": {
                      "description": "Optional. Refers to the path length restriction X.509 extension. For a CA certificate, this value describes the depth of subordinate CA certificates that are allowed. If this value is less than 0, the request will fail. If this value is missing, the max path length will be omitted from the CA certificate.",
                      "type": "integer",
                      "format": "int64"
                    }
                  }
                },
                "keyUsage": {
                  "description": "Optional. Indicates the intended use for keys that correspond to a certificate.",
                  "type": "object",
                  "properties": {
                    "baseKeyUsage": {
                      "description": "Describes high-level ways in which a key may be used.",
                      "type": "object",
                      "properties": {
                        "certSign": {
                          "description": "The key may be used to sign certificates.",
                          "type": "boolean"
                        },
                        "contentCommitment": {
                          "description": "The key may be used for cryptographic commitments. Note that this may also be referred to as \"non-repudiation\".",
                          "type": "boolean"
                        },
                        "crlSign": {
                          "description": "The key may be used sign certificate revocation lists.",
                          "type": "boolean"
                        },
                        "dataEncipherment": {
                          "description": "The key may be used to encipher data.",
                          "type": "boolean"
                        },
                        "decipherOnly": {
                          "description": "The key may be used to decipher only.",
                          "type": "boolean"
                        },
                        "digitalSignature": {
                          "description": "The key may be used for digital signatures.",
                          "type": "boolean"
                        },
                        "encipherOnly": {
                          "description": "The key may be used to encipher only.",
                          "type": "boolean"
                        },
                        "keyAgreement": {
                          "description": "The key may be used in a key agreement protocol.",
                          "type": "boolean"
                        },
                        "keyEncipherment": {
                          "description": "The key may be used to encipher other keys.",
                          "type": "boolean"
                        }
                      }
                    },
                    "extendedKeyUsage": {
                      "description": "Detailed scenarios in which a key may be used.",
                      "type": "object",
                      "properties": {
                        "clientAuth": {
                          "description": "Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as \"TLS WWW client authentication\", though regularly used for non-WWW TLS.",
                          "type": "boolean"
                        },
                        "codeSigning": {
                          "description": "Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as \"Signing of downloadable executable code client authentication\".",
                          "type": "boolean"
                        },
                        "emailProtection": {
                          "description": "Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as \"Email protection\".",
                          "type": "boolean"
                        },
                        "ocspSigning": {
                          "description": "Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as \"Signing OCSP responses\".",
                          "type": "boolean"
                        },
                        "serverAuth": {
                          "description": "Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as \"TLS WWW server authentication\", though regularly used for non-WWW TLS.",
                          "type": "boolean"
                        },
                        "timeStamping": {
                          "description": "Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as \"Binding the hash of an object to a time\".",
                          "type": "boolean"
                        }
                      }
                    },
                    "unknownExtendedKeyUsages": {
                      "description": "Used to describe extended key usages that are not listed in the KeyUsage.ExtendedKeyUsageOptions message.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": ["objectIdPath"],
                        "properties": {
                          "objectIdPath": {
                            "description": "Required. The parts of an OID path. The most significant parts of the path come first.",
                            "type": "array",
                            "items": {
                              "type": "integer",
                              "format": "int64"
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "policyIds": {
                  "description": "Optional. Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["objectIdPath"],
                    "properties": {
                      "objectIdPath": {
                        "description": "Required. The parts of an OID path. The most significant parts of the path come first.",
                        "type": "array",
                        "items": {
                          "type": "integer",
                          "format": "int64"
                        }
                      }
                    }
                  }
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The time at which this CertificateTemplate was created.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "Output only. The time at which this CertificateTemplate was updated.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "privateca.cnrm.cloud.google.com",
          "kind": "PrivateCACertificateTemplate",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.privateca.v1beta1.PrivateCACertificateTemplateList": {
      "description": "PrivateCACertificateTemplateList is a list of PrivateCACertificateTemplate",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["privateca.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of privatecacertificatetemplates. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.privateca.v1beta1.PrivateCACertificateTemplate"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PrivateCACertificateTemplateList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "privateca.cnrm.cloud.google.com",
          "kind": "PrivateCACertificateTemplateList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.pubsub.v1beta1.PubSubSubscription": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["pubsub.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PubSubSubscription"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["topicRef"],
          "properties": {
            "ackDeadlineSeconds": {
              "description": "This value is the maximum time after a subscriber receives a message\nbefore the subscriber should acknowledge the message. After message\ndelivery but before the ack deadline expires and before the message is\nacknowledged, it is an outstanding message and will not be delivered\nagain during that time (on a best-effort basis).\n\nFor pull subscriptions, this value is used as the initial value for\nthe ack deadline. To override this value for a given message, call\nsubscriptions.modifyAckDeadline with the corresponding ackId if using\npull. The minimum custom deadline you can specify is 10 seconds. The\nmaximum custom deadline you can specify is 600 seconds (10 minutes).\nIf this parameter is 0, a default value of 10 seconds is used.\n\nFor push delivery, this value is also used to set the request timeout\nfor the call to the push endpoint.\n\nIf the subscriber never acknowledges the message, the Pub/Sub system\nwill eventually redeliver the message.",
              "type": "integer"
            },
            "deadLetterPolicy": {
              "description": "A policy that specifies the conditions for dead lettering messages in\nthis subscription. If dead_letter_policy is not set, dead lettering\nis disabled.\n\nThe Cloud Pub/Sub service account associated with this subscription's\nparent project (i.e.,\nservice-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have\npermission to Acknowledge() messages on this subscription.",
              "type": "object",
              "properties": {
                "deadLetterTopicRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "A string of the format \"projects/{{project}}/topics/{{value}}\", where {{value}} is the name of a PubSubTopic.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "maxDeliveryAttempts": {
                  "description": "The maximum number of delivery attempts for any message. The value must be\nbetween 5 and 100.\n\nThe number of delivery attempts is defined as 1 + (the sum of number of \nNACKs and number of times the acknowledgement deadline has been exceeded for the message).\n\nA NACK is any call to ModifyAckDeadline with a 0 deadline. Note that\nclient libraries may automatically extend ack_deadlines.\n\nThis field will be honored on a best effort basis.\n\nIf this parameter is 0, a default value of 5 is used.",
                  "type": "integer"
                }
              }
            },
            "enableMessageOrdering": {
              "description": "Immutable. If 'true', messages published with the same orderingKey in PubsubMessage will be delivered to\nthe subscribers in the order in which they are received by the Pub/Sub system. Otherwise, they\nmay be delivered in any order.",
              "type": "boolean"
            },
            "expirationPolicy": {
              "description": "A policy that specifies the conditions for this subscription's expiration.\nA subscription is considered active as long as any connected subscriber\nis successfully consuming messages from the subscription or is issuing\noperations on the subscription. If expirationPolicy is not set, a default\npolicy with ttl of 31 days will be used.  If it is set but ttl is \"\", the\nresource never expires.  The minimum allowed value for expirationPolicy.ttl\nis 1 day.",
              "type": "object",
              "required": ["ttl"],
              "properties": {
                "ttl": {
                  "description": "Specifies the \"time-to-live\" duration for an associated resource. The\nresource expires if it is not active for a period of ttl.\nIf ttl is not set, the associated resource never expires.\nA duration in seconds with up to nine fractional digits, terminated by 's'.\nExample - \"3.5s\".",
                  "type": "string"
                }
              }
            },
            "filter": {
              "description": "Immutable. The subscription only delivers the messages that match the filter. \nPub/Sub automatically acknowledges the messages that don't match the filter. You can filter messages\nby their attributes. The maximum length of a filter is 256 bytes. After creating the subscription, \nyou can't modify the filter.",
              "type": "string"
            },
            "messageRetentionDuration": {
              "description": "How long to retain unacknowledged messages in the subscription's\nbacklog, from the moment a message is published. If\nretainAckedMessages is true, then this also configures the retention\nof acknowledged messages, and thus configures how far back in time a\nsubscriptions.seek can be done. Defaults to 7 days. Cannot be more\nthan 7 days ('\"604800s\"') or less than 10 minutes ('\"600s\"').\n\nA duration in seconds with up to nine fractional digits, terminated\nby 's'. Example: '\"600.5s\"'.",
              "type": "string"
            },
            "pushConfig": {
              "description": "If push delivery is used with this subscription, this field is used to\nconfigure it. An empty pushConfig signifies that the subscriber will\npull and ack messages using API methods.",
              "type": "object",
              "required": ["pushEndpoint"],
              "properties": {
                "attributes": {
                  "description": "Endpoint configuration attributes.\n\nEvery endpoint has a set of API supported attributes that can\nbe used to control different aspects of the message delivery.\n\nThe currently supported attribute is x-goog-version, which you\ncan use to change the format of the pushed message. This\nattribute indicates the version of the data expected by\nthe endpoint. This controls the shape of the pushed message\n(i.e., its fields and metadata). The endpoint version is\nbased on the version of the Pub/Sub API.\n\nIf not present during the subscriptions.create call,\nit will default to the version of the API used to make\nsuch call. If not present during a subscriptions.modifyPushConfig\ncall, its value will not be changed. subscriptions.get\ncalls will always return a valid version, even if the\nsubscription was created without this attribute.\n\nThe possible values for this attribute are:\n\n- v1beta1: uses the push format defined in the v1beta1 Pub/Sub API.\n- v1 or v1beta2: uses the push format defined in the v1 Pub/Sub API.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "oidcToken": {
                  "description": "If specified, Pub/Sub will generate and attach an OIDC JWT token as\nan Authorization header in the HTTP request for every pushed message.",
                  "type": "object",
                  "required": ["serviceAccountEmail"],
                  "properties": {
                    "audience": {
                      "description": "Audience to be used when generating OIDC token. The audience claim\nidentifies the recipients that the JWT is intended for. The audience\nvalue is a single case-sensitive string. Having multiple values (array)\nfor the audience field is not supported. More info about the OIDC JWT\ntoken audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3\nNote: if not specified, the Push endpoint URL will be used.",
                      "type": "string"
                    },
                    "serviceAccountEmail": {
                      "description": "Service account email to be used for generating the OIDC token.\nThe caller (for subscriptions.create, subscriptions.patch, and\nsubscriptions.modifyPushConfig RPCs) must have the\niam.serviceAccounts.actAs permission for the service account.",
                      "type": "string"
                    }
                  }
                },
                "pushEndpoint": {
                  "description": "A URL locating the endpoint to which messages should be pushed.\nFor example, a Webhook endpoint might use\n\"https://example.com/push\".",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "retainAckedMessages": {
              "description": "Indicates whether to retain acknowledged messages. If 'true', then\nmessages are not expunged from the subscription's backlog, even if\nthey are acknowledged, until they fall out of the\nmessageRetentionDuration window.",
              "type": "boolean"
            },
            "retryPolicy": {
              "description": "A policy that specifies how Pub/Sub retries message delivery for this subscription.\n\nIf not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers. \nRetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message.",
              "type": "object",
              "properties": {
                "maximumBackoff": {
                  "description": "The maximum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 600 seconds. \nA duration in seconds with up to nine fractional digits, terminated by 's'. Example: \"3.5s\".",
                  "type": "string"
                },
                "minimumBackoff": {
                  "description": "The minimum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.\nA duration in seconds with up to nine fractional digits, terminated by 's'. Example: \"3.5s\".",
                  "type": "string"
                }
              }
            },
            "topicRef": {
              "description": "Reference to a PubSubTopic.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "A string of the format \"projects/{{project}}/topics/{{value}}\", where {{value}} is the name of a PubSubTopic.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "pubsub.cnrm.cloud.google.com",
          "kind": "PubSubSubscription",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.pubsub.v1beta1.PubSubSubscriptionList": {
      "description": "PubSubSubscriptionList is a list of PubSubSubscription",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["pubsub.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of pubsubsubscriptions. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.pubsub.v1beta1.PubSubSubscription"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PubSubSubscriptionList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "pubsub.cnrm.cloud.google.com",
          "kind": "PubSubSubscriptionList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.pubsub.v1beta1.PubSubTopic": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["pubsub.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PubSubTopic"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "kmsKeyRef": {
              "description": "The KMSCryptoKey to be used to protect access to messages published\non this topic. Your project's Pub/Sub service account\n('service-{{PROJECT_NUMBER}}@gcp-sa-pubsub.iam.gserviceaccount.com')\nmust have 'roles/cloudkms.cryptoKeyEncrypterDecrypter' to use this\nfeature.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a KMSCryptoKey.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "messageRetentionDuration": {
              "description": "Indicates the minimum duration to retain a message after it is published\nto the topic. If this field is set, messages published to the topic in\nthe last messageRetentionDuration are always available to subscribers.\nFor instance, it allows any attached subscription to seek to a timestamp\nthat is up to messageRetentionDuration in the past. If this field is not\nset, message retention is controlled by settings on individual subscriptions.\nCannot be more than 7 days or less than 10 minutes.",
              "type": "string"
            },
            "messageStoragePolicy": {
              "description": "Policy constraining the set of Google Cloud Platform regions where\nmessages published to the topic may be stored. If not present, then no\nconstraints are in effect.",
              "type": "object",
              "required": ["allowedPersistenceRegions"],
              "properties": {
                "allowedPersistenceRegions": {
                  "description": "A list of IDs of GCP regions where messages that are published to\nthe topic may be persisted in storage. Messages published by\npublishers running in non-allowed GCP regions (or running outside\nof GCP altogether) will be routed for storage in one of the\nallowed regions. An empty list means that no regions are allowed,\nand is not a valid configuration.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "pubsub.cnrm.cloud.google.com",
          "kind": "PubSubTopic",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.pubsub.v1beta1.PubSubTopicList": {
      "description": "PubSubTopicList is a list of PubSubTopic",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["pubsub.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of pubsubtopics. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.pubsub.v1beta1.PubSubTopic"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PubSubTopicList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "pubsub.cnrm.cloud.google.com",
          "kind": "PubSubTopicList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.recaptchaenterprise.v1beta1.RecaptchaEnterpriseKey": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["recaptchaenterprise.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["RecaptchaEnterpriseKey"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["displayName", "projectRef"],
          "properties": {
            "androidSettings": {
              "description": "Settings for keys that can be used by Android apps.",
              "type": "object",
              "properties": {
                "allowAllPackageNames": {
                  "description": "If set to true, it means allowed_package_names will not be enforced.",
                  "type": "boolean"
                },
                "allowedPackageNames": {
                  "description": "Android package names of apps allowed to use the key. Example: 'com.companyname.appname'",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "displayName": {
              "description": "Human-readable display name of this key. Modifiable by user.",
              "type": "string"
            },
            "iosSettings": {
              "description": "Settings for keys that can be used by iOS apps.",
              "type": "object",
              "properties": {
                "allowAllBundleIds": {
                  "description": "If set to true, it means allowed_bundle_ids will not be enforced.",
                  "type": "boolean"
                },
                "allowedBundleIds": {
                  "description": "iOS bundle ids of apps allowed to use the key. Example: 'com.companyname.productname.appname'",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            },
            "testingOptions": {
              "description": "Options for user acceptance testing.",
              "type": "object",
              "properties": {
                "testingChallenge": {
                  "description": "For challenge-based keys only (CHECKBOX, INVISIBLE), all challenge requests for this site will return nocaptcha if NOCAPTCHA, or an unsolvable challenge if UNSOLVABLE_CHALLENGE. Possible values: TESTING_CHALLENGE_UNSPECIFIED, NOCAPTCHA, UNSOLVABLE_CHALLENGE",
                  "type": "string"
                },
                "testingScore": {
                  "description": "All assessments for this Key will return this score. Must be between 0 (likely not legitimate) and 1 (likely legitimate) inclusive.",
                  "type": "number",
                  "format": "double"
                }
              }
            },
            "webSettings": {
              "description": "Settings for keys that can be used by websites.",
              "type": "object",
              "required": ["integrationType"],
              "properties": {
                "allowAllDomains": {
                  "description": "If set to true, it means allowed_domains will not be enforced.",
                  "type": "boolean"
                },
                "allowAmpTraffic": {
                  "description": "If set to true, the key can be used on AMP (Accelerated Mobile Pages) websites. This is supported only for the SCORE integration type.",
                  "type": "boolean"
                },
                "allowedDomains": {
                  "description": "Domains or subdomains of websites allowed to use the key. All subdomains of an allowed domain are automatically allowed. A valid domain requires a host and must not include any path, port, query or fragment. Examples: 'example.com' or 'subdomain.example.com'",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "challengeSecurityPreference": {
                  "description": "Settings for the frequency and difficulty at which this key triggers captcha challenges. This should only be specified for IntegrationTypes CHECKBOX and INVISIBLE. Possible values: CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED, USABILITY, BALANCE, SECURITY",
                  "type": "string"
                },
                "integrationType": {
                  "description": "Required. Describes how this key is integrated with the website. Possible values: SCORE, CHECKBOX, INVISIBLE",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "The timestamp corresponding to the creation of this Key.",
              "type": "string",
              "format": "date-time"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "recaptchaenterprise.cnrm.cloud.google.com",
          "kind": "RecaptchaEnterpriseKey",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.recaptchaenterprise.v1beta1.RecaptchaEnterpriseKeyList": {
      "description": "RecaptchaEnterpriseKeyList is a list of RecaptchaEnterpriseKey",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["recaptchaenterprise.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of recaptchaenterprisekeys. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.recaptchaenterprise.v1beta1.RecaptchaEnterpriseKey"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["RecaptchaEnterpriseKeyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "recaptchaenterprise.cnrm.cloud.google.com",
          "kind": "RecaptchaEnterpriseKeyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.redis.v1beta1.RedisInstance": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["redis.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["RedisInstance"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["memorySizeGb", "region"],
          "properties": {
            "alternativeLocationId": {
              "description": "Immutable. Only applicable to STANDARD_HA tier which protects the instance\nagainst zonal failures by provisioning it across two zones.\nIf provided, it must be a different zone from the one provided in\n[locationId].",
              "type": "string"
            },
            "authEnabled": {
              "description": "Optional. Indicates whether OSS Redis AUTH is enabled for the\ninstance. If set to \"true\" AUTH is enabled on the instance.\nDefault value is \"false\" meaning AUTH is disabled.",
              "type": "boolean"
            },
            "authString": {
              "description": "AUTH String set on the instance. This field will only be populated if auth_enabled is true.",
              "type": "string"
            },
            "authorizedNetworkRef": {
              "description": "The network to which the instance is connected. If left\nunspecified, the default network will be used.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The selfLink of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "connectMode": {
              "description": "Immutable. The connection mode of the Redis instance. Default value: \"DIRECT_PEERING\" Possible values: [\"DIRECT_PEERING\", \"PRIVATE_SERVICE_ACCESS\"].",
              "type": "string"
            },
            "displayName": {
              "description": "An arbitrary and optional user-provided name for the instance.",
              "type": "string"
            },
            "locationId": {
              "description": "Immutable. The zone where the instance will be provisioned. If not provided,\nthe service will choose a zone for the instance. For STANDARD_HA tier,\ninstances will be created across two zones for protection against\nzonal failures. If [alternativeLocationId] is also provided, it must\nbe different from [locationId].",
              "type": "string"
            },
            "memorySizeGb": {
              "description": "Redis memory size in GiB.",
              "type": "integer"
            },
            "readReplicasMode": {
              "description": "Immutable. Optional. Read replica mode. Can only be specified when trying to create the instance.\nIf not set, Memorystore Redis backend will default to READ_REPLICAS_DISABLED.\n- READ_REPLICAS_DISABLED: If disabled, read endpoint will not be provided and the \ninstance cannot scale up or down the number of replicas.\n- READ_REPLICAS_ENABLED: If enabled, read endpoint will be provided and the instance \ncan scale up and down the number of replicas. Default value: \"READ_REPLICAS_DISABLED\" Possible values: [\"READ_REPLICAS_DISABLED\", \"READ_REPLICAS_ENABLED\"].",
              "type": "string"
            },
            "redisConfigs": {
              "description": "Redis configuration parameters, according to http://redis.io/topics/config.\nPlease check Memorystore documentation for the list of supported parameters:\nhttps://cloud.google.com/memorystore/docs/redis/reference/rest/v1/projects.locations.instances#Instance.FIELDS.redis_configs.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "redisVersion": {
              "description": "The version of Redis software. If not provided, latest supported\nversion will be used. Please check the API documentation linked \nat the top for the latest valid values.",
              "type": "string"
            },
            "region": {
              "description": "Immutable. The name of the Redis region of the instance.",
              "type": "string"
            },
            "replicaCount": {
              "description": "Optional. The number of replica nodes. The valid range for the Standard Tier with \nread replicas enabled is [1-5] and defaults to 2. If read replicas are not enabled\nfor a Standard Tier instance, the only valid value is 1 and the default is 1. \nThe valid value for basic tier is 0 and the default is also 0.",
              "type": "integer"
            },
            "reservedIpRange": {
              "description": "Immutable. The CIDR range of internal addresses that are reserved for this\ninstance. If not provided, the service will choose an unused /29\nblock, for example, 10.0.0.0/29 or 192.168.0.0/29. Ranges must be\nunique and non-overlapping with existing subnets in an authorized\nnetwork.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "tier": {
              "description": "Immutable. The service tier of the instance. Must be one of these values:\n\n- BASIC: standalone instance\n- STANDARD_HA: highly available primary/replica instances Default value: \"BASIC\" Possible values: [\"BASIC\", \"STANDARD_HA\"].",
              "type": "string"
            },
            "transitEncryptionMode": {
              "description": "Immutable. The TLS mode of the Redis instance, If not provided, TLS is disabled for the instance.\n\n- SERVER_AUTHENTICATION: Client to Server traffic encryption enabled with server authentication Default value: \"DISABLED\" Possible values: [\"SERVER_AUTHENTICATION\", \"DISABLED\"].",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "The time the instance was created in RFC3339 UTC \"Zulu\" format,\naccurate to nanoseconds.",
              "type": "string"
            },
            "currentLocationId": {
              "description": "The current zone where the Redis endpoint is placed.\nFor Basic Tier instances, this will always be the same as the\n[locationId] provided by the user at creation time. For Standard Tier\ninstances, this can be either [locationId] or [alternativeLocationId]\nand can change after a failover event.",
              "type": "string"
            },
            "host": {
              "description": "Hostname or IP address of the exposed Redis endpoint used by clients\nto connect to the service.",
              "type": "string"
            },
            "nodes": {
              "description": "Output only. Info per node.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "id": {
                    "description": "Node identifying string. e.g. 'node-0', 'node-1'.",
                    "type": "string"
                  },
                  "zone": {
                    "description": "Location of the node.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "persistenceIamIdentity": {
              "description": "Output only. Cloud IAM identity used by import / export operations\nto transfer data to/from Cloud Storage. Format is \"serviceAccount:\".\nThe value may change over time for a given instance so should be\nchecked before each import/export operation.",
              "type": "string"
            },
            "port": {
              "description": "The port number of the exposed Redis endpoint.",
              "type": "integer"
            },
            "readEndpoint": {
              "description": "Output only. Hostname or IP address of the exposed readonly Redis endpoint. Standard tier only.\nTargets all healthy replica nodes in instance. Replication is asynchronous and replica nodes\nwill exhibit some lag behind the primary. Write requests must target 'host'.",
              "type": "string"
            },
            "readEndpointPort": {
              "description": "Output only. The port number of the exposed readonly redis endpoint. Standard tier only. \nWrite requests should target 'port'.",
              "type": "integer"
            },
            "serverCaCerts": {
              "description": "List of server CA certificates for the instance.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "cert": {
                    "description": "Serial number, as extracted from the certificate.",
                    "type": "string"
                  },
                  "createTime": {
                    "description": "The time when the certificate was created.",
                    "type": "string"
                  },
                  "expireTime": {
                    "description": "The time when the certificate expires.",
                    "type": "string"
                  },
                  "serialNumber": {
                    "description": "Serial number, as extracted from the certificate.",
                    "type": "string"
                  },
                  "sha1Fingerprint": {
                    "description": "Sha1 Fingerprint of the certificate.",
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "redis.cnrm.cloud.google.com",
          "kind": "RedisInstance",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.redis.v1beta1.RedisInstanceList": {
      "description": "RedisInstanceList is a list of RedisInstance",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["redis.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of redisinstances. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.redis.v1beta1.RedisInstance"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["RedisInstanceList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "redis.cnrm.cloud.google.com",
          "kind": "RedisInstanceList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.resourcemanager.v1beta1.Folder": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["resourcemanager.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Folder"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["displayName"],
          "properties": {
            "displayName": {
              "description": "The folder's display name. A folder's display name must be unique amongst its siblings, e.g. no two folders with the same parent can share the same display name. The display name must start and end with a letter or digit, may contain letters, digits, spaces, hyphens and underscores and can be no longer than 30 characters.",
              "type": "string"
            },
            "folderRef": {
              "description": "The folder that this resource belongs to. Changing this forces the\nresource to be migrated to the newly specified folder. Only one of\nfolderRef or organizationRef may be specified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The folderId of a Folder.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "organizationRef": {
              "description": "The organization that this resource belongs to. Changing this\nforces the resource to be migrated to the newly specified\norganization. Only one of folderRef or organizationRef may be\nspecified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of an Organization.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Timestamp when the Folder was created. Assigned by the server. A timestamp in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds. Example: \"2014-10-02T15:01:23.045123456Z\".",
              "type": "string"
            },
            "folderId": {
              "description": "The folder id from the name \"folders/{folder_id}\".",
              "type": "string"
            },
            "lifecycleState": {
              "description": "The lifecycle state of the folder such as ACTIVE or DELETE_REQUESTED.",
              "type": "string"
            },
            "name": {
              "description": "The resource name of the Folder. Its format is folders/{folder_id}.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "resourcemanager.cnrm.cloud.google.com",
          "kind": "Folder",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.resourcemanager.v1beta1.FolderList": {
      "description": "FolderList is a list of Folder",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["resourcemanager.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of folders. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.resourcemanager.v1beta1.Folder"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["FolderList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "resourcemanager.cnrm.cloud.google.com",
          "kind": "FolderList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.resourcemanager.v1beta1.Project": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["resourcemanager.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Project"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["name"],
          "properties": {
            "billingAccountRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a BillingAccount.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "folderRef": {
              "description": "The folder that this resource belongs to. Changing this forces the\nresource to be migrated to the newly specified folder. Only one of\nfolderRef or organizationRef may be specified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The folderId of a Folder.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "name": {
              "description": "The display name of the project.",
              "type": "string"
            },
            "organizationRef": {
              "description": "The organization that this resource belongs to. Changing this\nforces the resource to be migrated to the newly specified\norganization. Only one of folderRef or organizationRef may be\nspecified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of an Organization.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The projectId of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "number": {
              "description": "The numeric identifier of the project.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "resourcemanager.cnrm.cloud.google.com",
          "kind": "Project",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.resourcemanager.v1beta1.ProjectList": {
      "description": "ProjectList is a list of Project",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["resourcemanager.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of projects. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.resourcemanager.v1beta1.Project"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ProjectList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "resourcemanager.cnrm.cloud.google.com",
          "kind": "ProjectList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.resourcemanager.v1beta1.ResourceManagerLien": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["resourcemanager.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ResourceManagerLien"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["origin", "parent", "reason", "restrictions"],
          "properties": {
            "origin": {
              "description": "Immutable. A stable, user-visible/meaningful string identifying the origin\nof the Lien, intended to be inspected programmatically. Maximum length of\n200 characters.",
              "type": "string"
            },
            "parent": {
              "type": "object",
              "properties": {
                "projectRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "A string of the format \"projects/{{value}}\", where {{value}} is the number of a Project.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "reason": {
              "description": "Immutable. Concise user-visible strings indicating why an action cannot be performed\non a resource. Maximum length of 200 characters.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            },
            "restrictions": {
              "description": "Immutable. The types of operations which should be blocked as a result of this Lien.\nEach value should correspond to an IAM permission. The server will validate\nthe permissions against those for which Liens are supported.  An empty\nlist is meaningless and will be rejected.\ne.g. ['resourcemanager.projects.delete'].",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Time of creation.",
              "type": "string"
            },
            "name": {
              "description": "A system-generated unique identifier for this Lien.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "resourcemanager.cnrm.cloud.google.com",
          "kind": "ResourceManagerLien",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.resourcemanager.v1beta1.ResourceManagerLienList": {
      "description": "ResourceManagerLienList is a list of ResourceManagerLien",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["resourcemanager.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of resourcemanagerliens. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.resourcemanager.v1beta1.ResourceManagerLien"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ResourceManagerLienList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "resourcemanager.cnrm.cloud.google.com",
          "kind": "ResourceManagerLienList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.resourcemanager.v1beta1.ResourceManagerPolicy": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["resourcemanager.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ResourceManagerPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["constraint"],
          "properties": {
            "booleanPolicy": {
              "description": "A boolean policy is a constraint that is either enforced or not.",
              "type": "object",
              "required": ["enforced"],
              "properties": {
                "enforced": {
                  "description": "If true, then the Policy is enforced. If false, then any configuration is acceptable.",
                  "type": "boolean"
                }
              }
            },
            "constraint": {
              "description": "Immutable. The name of the Constraint the Policy is configuring, for example, serviceuser.services.",
              "type": "string"
            },
            "folderRef": {
              "description": "The folder on which to configure the constraint. Only one of\nprojectRef, folderRef, or organizationRef may be specified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a Folder.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "listPolicy": {
              "description": "A policy that can define specific values that are allowed or denied for the given constraint. It can also be used to allow or deny all values. .",
              "type": "object",
              "properties": {
                "allow": {
                  "description": "One or the other must be set.",
                  "type": "object",
                  "properties": {
                    "all": {
                      "description": "The policy allows or denies all values.",
                      "type": "boolean"
                    },
                    "values": {
                      "description": "The policy can define specific values that are allowed or denied.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                },
                "deny": {
                  "description": "One or the other must be set.",
                  "type": "object",
                  "properties": {
                    "all": {
                      "description": "The policy allows or denies all values.",
                      "type": "boolean"
                    },
                    "values": {
                      "description": "The policy can define specific values that are allowed or denied.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                },
                "inheritFromParent": {
                  "description": "If set to true, the values from the effective Policy of the parent resource are inherited, meaning the values set in this Policy are added to the values inherited up the hierarchy.",
                  "type": "boolean"
                },
                "suggestedValue": {
                  "description": "The Google Cloud Console will try to default to a configuration that matches the value specified in this field.",
                  "type": "string"
                }
              }
            },
            "organizationRef": {
              "description": "The organization on which to configure the constraint. Only one of\nprojectRef, folderRef, or organizationRef may be specified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of an Organization.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "projectRef": {
              "description": "The project on which to configure the constraint. Only one of\nprojectRef, folderRef, or organizationRef may be specified.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a Project.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "restorePolicy": {
              "description": "A restore policy is a constraint to restore the default policy.",
              "type": "object",
              "required": ["default"],
              "properties": {
                "default": {
                  "description": "May only be set to true. If set, then the default Policy is restored.",
                  "type": "boolean"
                }
              }
            },
            "version": {
              "description": "Version of the Policy. Default version is 0.",
              "type": "integer"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "etag": {
              "description": "The etag of the organization policy. etag is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "updateTime": {
              "description": "The timestamp in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds, representing when the variable was last updated. Example: \"2016-10-09T12:33:37.578138407Z\".",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "resourcemanager.cnrm.cloud.google.com",
          "kind": "ResourceManagerPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.resourcemanager.v1beta1.ResourceManagerPolicyList": {
      "description": "ResourceManagerPolicyList is a list of ResourceManagerPolicy",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["resourcemanager.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of resourcemanagerpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.resourcemanager.v1beta1.ResourceManagerPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ResourceManagerPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "resourcemanager.cnrm.cloud.google.com",
          "kind": "ResourceManagerPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.run.v1beta1.RunService": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["run.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["RunService"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location", "projectRef", "template"],
          "properties": {
            "annotations": {
              "description": "Unstructured key value map that may be set by external tools to store and arbitrary metadata. They are not queryable and should be preserved when modifying objects. Cloud Run will populate some annotations using 'run.googleapis.com' or 'serving.knative.dev' namespaces. This field follows Kubernetes annotations' namespacing, limits, and rules. More info: http://kubernetes.io/docs/user-guide/annotations",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "binaryAuthorization": {
              "description": "Settings for the Binary Authorization feature.",
              "type": "object",
              "properties": {
                "breakglassJustification": {
                  "description": "If present, indicates to use Breakglass using this justification. For more information on breakglass, see https://cloud.google.com/binary-authorization/docs/using-breakglass",
                  "type": "string"
                },
                "useDefault": {
                  "description": "If True, indicates to use the default project's binary authorization policy. If False, binary authorization will be disabled",
                  "type": "boolean"
                }
              }
            },
            "client": {
              "description": "Arbitrary identifier for the API client.",
              "type": "string"
            },
            "clientVersion": {
              "description": "Arbitrary version identifier for the API client.",
              "type": "string"
            },
            "description": {
              "description": "User-provided description of the Service.",
              "type": "string"
            },
            "ingress": {
              "description": "Provides the ingress settings for this Service. On output, returns the currently observed ingress settings, or INGRESS_TRAFFIC_UNSPECIFIED if no revision is active.",
              "type": "string"
            },
            "launchStage": {
              "description": "The launch stage as defined by [Google Cloud Platform Launch Stages](http://cloud.google.com/terms/launch-stages). Cloud Run supports `ALPHA`, `BETA`, and `GA`. If no value is specified, GA is assumed. Possible values: LAUNCH_STAGE_UNSPECIFIED, UNIMPLEMENTED, PRELAUNCH, EARLY_ACCESS, ALPHA, BETA, GA, DEPRECATED",
              "type": "string"
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "template": {
              "description": "Required. The template used to create revisions for this Service.",
              "type": "object",
              "properties": {
                "annotations": {
                  "description": "KRM-style annotations for the resource.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "confidential": {
                  "description": "Enables Confidential Cloud Run in Revisions created using this template.",
                  "type": "boolean"
                },
                "containerConcurrency": {
                  "description": "Sets the maximum number of requests that each serving instance can receive.",
                  "type": "integer",
                  "format": "int64"
                },
                "containers": {
                  "description": "Holds the single container that defines the unit of execution for this Revision.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["image"],
                    "properties": {
                      "args": {
                        "description": "Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "command": {
                        "description": "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "env": {
                        "description": "List of environment variables to set in the container.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "required": ["name"],
                          "properties": {
                            "name": {
                              "description": "Required. Name of the environment variable. Must be a C_IDENTIFIER, and mnay not exceed 32768 characters.",
                              "type": "string"
                            },
                            "value": {
                              "description": "Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any route environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to \"\", and the maximum length is 32768 bytes.",
                              "type": "string"
                            },
                            "valueSource": {
                              "description": "Source for the environment variable's value.",
                              "type": "object",
                              "properties": {
                                "secretKeyRef": {
                                  "description": "Selects a secret and a specific version from Cloud Secret Manager.",
                                  "type": "object",
                                  "required": ["secretRef"],
                                  "properties": {
                                    "secretRef": {
                                      "type": "object",
                                      "properties": {
                                        "external": {
                                          "description": "Required. The name of the secret in Cloud Secret Manager. Format: {secret_name} if the secret is in the same project. projects/{project}/secrets/{secret_name} if the secret is in a different project.",
                                          "type": "string"
                                        },
                                        "name": {
                                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                          "type": "string"
                                        },
                                        "namespace": {
                                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "versionRef": {
                                      "type": "object",
                                      "properties": {
                                        "external": {
                                          "description": "The Cloud Secret Manager secret version. Can be 'latest' for the latest value or an integer for a specific version.",
                                          "type": "string"
                                        },
                                        "name": {
                                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                          "type": "string"
                                        },
                                        "namespace": {
                                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                          "type": "string"
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "image": {
                        "description": "Required. URL of the Container image in Google Container Registry or Docker More info: https://kubernetes.io/docs/concepts/containers/images",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the container specified as a DNS_LABEL.",
                        "type": "string"
                      },
                      "ports": {
                        "description": "List of ports to expose from the container. Only a single port can be specified. The specified ports must be listening on all interfaces (0.0.0.0) within the container to be accessible. If omitted, a port number will be chosen and passed to the container through the PORT environment variable for the container to listen on.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "containerPort": {
                              "description": "Port number the container listens on. This must be a valid TCP port number, 0 < container_port < 65536.",
                              "type": "integer",
                              "format": "int64"
                            },
                            "name": {
                              "description": "If specified, used to specify which protocol to use. Allowed values are \"http1\" and \"h2c\".",
                              "type": "string"
                            }
                          }
                        }
                      },
                      "resources": {
                        "description": "Compute Resource requirements by this container. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources",
                        "type": "object",
                        "properties": {
                          "cpuIdle": {
                            "description": "Determines whether CPU should be throttled or not outside of requests.",
                            "type": "boolean"
                          },
                          "limits": {
                            "description": "Only memory and CPU are supported. Note: The only supported values for CPU are '1', '2', and '4'. Setting 4 CPU requires at least 2Gi of memory. The values of the map is string form of the 'quantity' k8s type: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "volumeMounts": {
                        "description": "Volume to mount into the container's filesystem.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "required": ["mountPath", "name"],
                          "properties": {
                            "mountPath": {
                              "description": "Required. Path within the container at which the volume should be mounted. Must not contain ':'. For Cloud SQL volumes, it can be left empty, or must otherwise be `/cloudsql`. All instances defined in the Volume will be available as `/cloudsql/[instance]`. For more information on Cloud SQL volumes, visit https://cloud.google.com/sql/docs/mysql/connect-run",
                              "type": "string"
                            },
                            "name": {
                              "description": "Required. This must match the Name of a Volume.",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "executionEnvironment": {
                  "description": "The sandbox environment to host this Revision. Possible values: EXECUTION_ENVIRONMENT_UNSPECIFIED, EXECUTION_ENVIRONMENT_DEFAULT, EXECUTION_ENVIRONMENT_GEN2",
                  "type": "string"
                },
                "labels": {
                  "description": "KRM-style labels for the resource.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "revision": {
                  "description": "The unique name for the revision. If this field is omitted, it will be automatically generated based on the Service name.",
                  "type": "string"
                },
                "scaling": {
                  "description": "Scaling settings for this Revision.",
                  "type": "object",
                  "properties": {
                    "maxInstanceCount": {
                      "description": "Maximum number of serving instances that this resource should have.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "minInstanceCount": {
                      "description": "Minimum number of serving instances that this resource should have.",
                      "type": "integer",
                      "format": "int64"
                    }
                  }
                },
                "serviceAccountRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "Email address of the IAM service account associated with the revision of the service. The service account represents the identity of the running revision, and determines what permissions the revision has. If not provided, the revision will use the project's default service account.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "timeout": {
                  "description": "Max allowed time for an instance to respond to a request.",
                  "type": "string"
                },
                "volumes": {
                  "description": "A list of Volumes to make available to containers.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["name"],
                    "properties": {
                      "cloudSqlInstance": {
                        "description": "For Cloud SQL volumes, contains the specific instances that should be mounted. Visit https://cloud.google.com/sql/docs/mysql/connect-run for more information on how to connect Cloud SQL and Cloud Run.",
                        "type": "object",
                        "properties": {
                          "connections": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "external": {
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                  "type": "string"
                                },
                                "namespace": {
                                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      },
                      "name": {
                        "description": "Required. Volume's name.",
                        "type": "string"
                      },
                      "secret": {
                        "description": "Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret",
                        "type": "object",
                        "required": ["secretRef"],
                        "properties": {
                          "defaultMode": {
                            "description": "Integer representation of mode bits to use on created files by default. Must be a value between 0000 and 0777 (octal), defaulting to 0644. Directories within the path are not affected by this setting. Notes * Internally, a umask of 0222 will be applied to any non-zero value. * This is an integer representation of the mode bits. So, the octal integer value should look exactly as the chmod numeric notation with a leading zero. Some examples: for chmod 777 (a=rwx), set to 0777 (octal) or 511 (base-10). For chmod 640 (u=rw,g=r), set to 0640 (octal) or 416 (base-10). For chmod 755 (u=rwx,g=rx,o=rx), set to 0755 (octal) or 493 (base-10). * This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. This might be in conflict with other options that affect the file mode, like fsGroup, and as a result, other mode bits could be set.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "items": {
                            "description": "If unspecified, the volume will expose a file whose name is the secret, relative to VolumeMount.mount_path. If specified, the key will be used as the version to fetch from Cloud Secret Manager and the path will be the name of the file exposed in the volume. When items are defined, they must specify a path and a version.",
                            "type": "array",
                            "items": {
                              "type": "object",
                              "required": ["path"],
                              "properties": {
                                "mode": {
                                  "description": "Integer octal mode bits to use on this file, must be a value between 01 and 0777 (octal). If 0 or not set, the Volume's default mode will be used. Notes * Internally, a umask of 0222 will be applied to any non-zero value. * This is an integer representation of the mode bits. So, the octal integer value should look exactly as the chmod numeric notation with a leading zero. Some examples: for chmod 777 (a=rwx), set to 0777 (octal) or 511 (base-10). For chmod 640 (u=rw,g=r), set to 0640 (octal) or 416 (base-10). For chmod 755 (u=rwx,g=rx,o=rx), set to 0755 (octal) or 493 (base-10). * This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "path": {
                                  "description": "Required. The relative path of the secret in the container.",
                                  "type": "string"
                                },
                                "versionRef": {
                                  "type": "object",
                                  "properties": {
                                    "external": {
                                      "description": "The Cloud Secret Manager secret version. Can be 'latest' for the latest value or an integer for a specific version.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "secretRef": {
                            "type": "object",
                            "properties": {
                              "external": {
                                "description": "Required. The name of the secret in Cloud Secret Manager. Format: {secret} if the secret is in the same project. projects/{project}/secrets/{secret} if the secret is in a different project.",
                                "type": "string"
                              },
                              "name": {
                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                "type": "string"
                              },
                              "namespace": {
                                "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "vpcAccess": {
                  "description": "VPC Access configuration to use for this Revision. For more information, visit https://cloud.google.com/run/docs/configuring/connecting-vpc.",
                  "type": "object",
                  "properties": {
                    "connectorRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "VPC Access connector name. Format: projects/{project}/locations/{location}/connectors/{connector}",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    },
                    "egress": {
                      "description": "Traffic VPC egress settings. Possible values: VPC_EGRESS_UNSPECIFIED, ALL_TRAFFIC, PRIVATE_RANGES_ONLY",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "traffic": {
              "description": "Specifies how to distribute traffic over a collection of Revisions belonging to the Service. If traffic is empty or not provided, defaults to 100% traffic to the latest `Ready` Revision.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "percent": {
                    "description": "Specifies percent of the traffic to this Revision. This defaults to zero if unspecified. Cloud Run currently requires 100 percent for a single TrafficTarget entry.",
                    "type": "integer",
                    "format": "int64"
                  },
                  "revision": {
                    "description": "Revision to which to send this portion of traffic, if traffic allocation is by revision.",
                    "type": "string"
                  },
                  "tag": {
                    "description": "Indicates a string to be part of the URI to exclusively reference this target.",
                    "type": "string"
                  },
                  "type": {
                    "description": "The allocation type for this traffic target. Possible values: TRAFFIC_TARGET_ALLOCATION_TYPE_UNSPECIFIED, TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST, TRAFFIC_TARGET_ALLOCATION_TYPE_REVISION",
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "Output only. The creation time.",
              "type": "string",
              "format": "date-time"
            },
            "creator": {
              "description": "Output only. Email address of the authenticated creator.",
              "type": "string"
            },
            "deleteTime": {
              "description": "Output only. The deletion time.",
              "type": "string",
              "format": "date-time"
            },
            "etag": {
              "description": "Output only. A system-generated fingerprint for this version of the resource. May be used to detect modification conflict during updates.",
              "type": "string"
            },
            "expireTime": {
              "description": "Output only. For a deleted resource, the time after which it will be permamently deleted.",
              "type": "string",
              "format": "date-time"
            },
            "labels": {
              "description": "Map of string keys and values that can be used to organize and categorize objects. User-provided labels are shared with Google's billing system, so they can be used to filter, or break down billing charges by team, component, environment, state, etc. For more information, visit https://cloud.google.com/resource-manager/docs/creating-managing-labels or https://cloud.google.com/run/docs/configuring/labels Cloud Run will populate some labels with 'run.googleapis.com' or 'serving.knative.dev' namespaces. Those labels are read-only, and user changes will not be preserved.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "lastModifier": {
              "description": "Output only. Email address of the last authenticated modifier.",
              "type": "string"
            },
            "latestCreatedRevision": {
              "description": "Output only. Name of the last created revision. See comments in `reconciling` for additional information on reconciliation process in Cloud Run.",
              "type": "string"
            },
            "latestReadyRevision": {
              "description": "Output only. Name of the latest revision that is serving traffic. See comments in `reconciling` for additional information on reconciliation process in Cloud Run.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "reconciling": {
              "description": "Output only. Returns true if the Service is currently being acted upon by the system to bring it into the desired state. When a new Service is created, or an existing one is updated, Cloud Run will asynchronously perform all necessary steps to bring the Service to the desired serving state. This process is called reconciliation. While reconciliation is in process, `observed_generation`, `latest_ready_revison`, `traffic_statuses`, and `uri` will have transient values that might mismatch the intended state: Once reconciliation is over (and this field is false), there are two possible outcomes: reconciliation succeeded and the serving state matches the Service, or there was an error, and reconciliation failed. This state can be found in `terminal_condition.state`. If reconciliation succeeded, the following fields will match: `traffic` and `traffic_statuses`, `observed_generation` and `generation`, `latest_ready_revision` and `latest_created_revision`. If reconciliation failed, `traffic_statuses`, `observed_generation`, and `latest_ready_revision` will have the state of the last serving revision, or empty for newly created Services. Additional information on the failure can be found in `terminal_condition` and `conditions`.",
              "type": "boolean"
            },
            "resourceGeneration": {
              "description": "Output only. A number that monotonically increases every time the user modifies the desired state.",
              "type": "integer",
              "format": "int64"
            },
            "terminalCondition": {
              "description": "Output only. The Condition of this Service, containing its readiness status, and detailed error information in case it did not reach a serving state. See comments in `reconciling` for additional information on reconciliation process in Cloud Run.",
              "type": "object",
              "properties": {
                "domainMappingReason": {
                  "description": "A reason for the domain mapping condition. Possible values: DOMAIN_MAPPING_REASON_UNDEFINED, ROUTE_NOT_READY, PERMISSION_DENIED, CERTIFICATE_ALREADY_EXISTS, MAPPING_ALREADY_EXISTS, CERTIFICATE_PENDING, CERTIFICATE_FAILED",
                  "type": "string"
                },
                "internalReason": {
                  "description": "A reason for the internal condition. Possible values: INTERNAL_REASON_UNDEFINED, CONFLICTING_REVISION_NAME, REVISION_MISSING, CONFIGURATION_MISSING, ASSIGNING_TRAFFIC, UPDATING_INGRESS_TRAFFIC_ALLOWED, REVISION_ORG_POLICY_VIOLATION, ENABLING_GCFV2_URI_SUPPORT",
                  "type": "string"
                },
                "jobReason": {
                  "description": "A reason for the job condition. Possible values: JOB_REASON_UNDEFINED, JOB_STATUS_SERVICE_POLLING_ERROR",
                  "type": "string"
                },
                "lastTransitionTime": {
                  "description": "Last time the condition transitioned from one status to another.",
                  "type": "string",
                  "format": "date-time"
                },
                "message": {
                  "description": "Human readable message indicating details about the current status.",
                  "type": "string"
                },
                "reason": {
                  "description": "A common (service-level) reason for this condition. Possible values: COMMON_REASON_UNDEFINED, UNKNOWN, ROUTE_MISSING, REVISION_FAILED, PROGRESS_DEADLINE_EXCEEDED, BUILD_STEP_FAILED, CONTAINER_MISSING, CONTAINER_PERMISSION_DENIED, CONTAINER_IMAGE_UNAUTHORIZED, CONTAINER_IMAGE_AUTHORIZATION_CHECK_FAILED, ENCRYPTION_KEY_PERMISSION_DENIED, ENCRYPTION_KEY_CHECK_FAILED, SECRETS_ACCESS_CHECK_FAILED, WAITING_FOR_OPERATION, IMMEDIATE_RETRY, POSTPONED_RETRY",
                  "type": "string"
                },
                "revisionReason": {
                  "description": "A reason for the revision condition. Possible values: REVISION_REASON_UNDEFINED, PENDING, RESERVE, RETIRED, RETIRING, RECREATING, HEALTH_CHECK_CONTAINER_ERROR, CUSTOMIZED_PATH_RESPONSE_PENDING, MIN_INSTANCES_NOT_PROVISIONED, ACTIVE_REVISION_LIMIT_REACHED, NO_DEPLOYMENT",
                  "type": "string"
                },
                "severity": {
                  "description": "How to interpret failures of this condition, one of Error, Warning, Info Possible values: SEVERITY_UNSPECIFIED, ERROR, WARNING, INFO",
                  "type": "string"
                },
                "state": {
                  "description": "State of the condition. Possible values: STATE_UNSPECIFIED, CONDITION_PENDING, CONDITION_RECONCILING, CONDITION_FAILED, CONDITION_SUCCEEDED",
                  "type": "string"
                },
                "type": {
                  "description": "type is used to communicate the status of the reconciliation process. See also: https://github.com/knative/serving/blob/main/docs/spec/errors.md#error-conditions-and-reporting Types common to all resources include: * \"Ready\": True when the Resource is ready.",
                  "type": "string"
                }
              }
            },
            "trafficStatuses": {
              "description": "Output only. Detailed status information for corresponding traffic targets. See comments in `reconciling` for additional information on reconciliation process in Cloud Run.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "percent": {
                    "description": "Specifies percent of the traffic to this Revision.",
                    "type": "integer",
                    "format": "int64"
                  },
                  "revision": {
                    "description": "Revision to which this traffic is sent.",
                    "type": "string"
                  },
                  "tag": {
                    "description": "Indicates the string used in the URI to exclusively reference this target.",
                    "type": "string"
                  },
                  "type": {
                    "description": "The allocation type for this traffic target. Possible values: TRAFFIC_TARGET_ALLOCATION_TYPE_UNSPECIFIED, TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST, TRAFFIC_TARGET_ALLOCATION_TYPE_REVISION",
                    "type": "string"
                  },
                  "uri": {
                    "description": "Displays the target URI.",
                    "type": "string"
                  }
                }
              }
            },
            "uid": {
              "description": "Output only. Server assigned unique identifier for the trigger. The value is a UUID4 string and guaranteed to remain unchanged until the resource is deleted.",
              "type": "string"
            },
            "updateTime": {
              "description": "Output only. The last-modified time.",
              "type": "string",
              "format": "date-time"
            },
            "uri": {
              "description": "Output only. The main URI in which this Service is serving traffic.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "run.cnrm.cloud.google.com",
          "kind": "RunService",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.run.v1beta1.RunServiceList": {
      "description": "RunServiceList is a list of RunService",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["run.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of runservices. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.run.v1beta1.RunService"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["RunServiceList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "run.cnrm.cloud.google.com",
          "kind": "RunServiceList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.secretmanager.v1beta1.SecretManagerSecret": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["secretmanager.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SecretManagerSecret"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["replication"],
          "properties": {
            "expireTime": {
              "description": "Timestamp in UTC when the Secret is scheduled to expire. This is always provided on output, regardless of what was sent on input.\nA timestamp in RFC3339 UTC \"Zulu\" format, with nanosecond resolution and up to nine fractional digits. Examples: \"2014-10-02T15:01:23Z\" and \"2014-10-02T15:01:23.045123456Z\".",
              "type": "string"
            },
            "replication": {
              "description": "Immutable. The replication policy of the secret data attached to the Secret. It cannot be changed\nafter the Secret has been created.",
              "type": "object",
              "properties": {
                "automatic": {
                  "description": "Immutable. The Secret will automatically be replicated without any restrictions.",
                  "type": "boolean"
                },
                "userManaged": {
                  "description": "Immutable. The Secret will automatically be replicated without any restrictions.",
                  "type": "object",
                  "required": ["replicas"],
                  "properties": {
                    "replicas": {
                      "description": "Immutable. The list of Replicas for this Secret. Cannot be empty.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": ["location"],
                        "properties": {
                          "customerManagedEncryption": {
                            "description": "Immutable. Customer Managed Encryption for the secret.",
                            "type": "object",
                            "required": ["kmsKeyRef"],
                            "properties": {
                              "kmsKeyRef": {
                                "description": "Customer Managed Encryption for the secret.",
                                "type": "object",
                                "properties": {
                                  "external": {
                                    "description": "The selfLink of a KMSCryptoKey.",
                                    "type": "string"
                                  },
                                  "name": {
                                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                    "type": "string"
                                  },
                                  "namespace": {
                                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "location": {
                            "description": "Immutable. The canonical IDs of the location to replicate data. For example: \"us-east1\".",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The secretId of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "rotation": {
              "description": "The rotation time and period for a Secret. At 'next_rotation_time', Secret Manager will send a Pub/Sub notification to the topics configured on the Secret. 'topics' must be set to configure rotation.",
              "type": "object",
              "properties": {
                "nextRotationTime": {
                  "description": "Timestamp in UTC at which the Secret is scheduled to rotate.\nA timestamp in RFC3339 UTC \"Zulu\" format, with nanosecond resolution and up to nine fractional digits. Examples: \"2014-10-02T15:01:23Z\" and \"2014-10-02T15:01:23.045123456Z\".",
                  "type": "string"
                },
                "rotationPeriod": {
                  "description": "Immutable. The Duration between rotation notifications. Must be in seconds and at least 3600s (1h) and at most 3153600000s (100 years).\nIf rotationPeriod is set, 'next_rotation_time' must be set. 'next_rotation_time' will be advanced by this period when the service automatically sends rotation notifications.",
                  "type": "string"
                }
              }
            },
            "topics": {
              "type": "array",
              "items": {
                "description": "A list of up to 10 Pub/Sub topics to which messages are\npublished when control plane operations are called on the secret\nor its versions.",
                "type": "object",
                "properties": {
                  "external": {
                    "description": "A string of the format \"projects/{{project}}/topics/{{value}}\", where {{value}} is the name of a PubSubTopic.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "ttl": {
              "description": "Immutable. The TTL for the Secret.\nA duration in seconds with up to nine fractional digits, terminated by 's'. Example: \"3.5s\".",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "The time at which the Secret was created.",
              "type": "string"
            },
            "name": {
              "description": "The resource name of the Secret. Format:\n'projects/{{project}}/secrets/{{secret_id}}'.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "secretmanager.cnrm.cloud.google.com",
          "kind": "SecretManagerSecret",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.secretmanager.v1beta1.SecretManagerSecretList": {
      "description": "SecretManagerSecretList is a list of SecretManagerSecret",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["secretmanager.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of secretmanagersecrets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.secretmanager.v1beta1.SecretManagerSecret"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SecretManagerSecretList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "secretmanager.cnrm.cloud.google.com",
          "kind": "SecretManagerSecretList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.secretmanager.v1beta1.SecretManagerSecretVersion": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["secretmanager.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SecretManagerSecretVersion"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["secretData", "secretRef"],
          "properties": {
            "enabled": {
              "description": "The current state of the SecretVersion.",
              "type": "boolean"
            },
            "resourceID": {
              "description": "Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            },
            "secretData": {
              "description": "Immutable. The secret data. Must be no larger than 64KiB.",
              "type": "object",
              "properties": {
                "value": {
                  "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                  "type": "string"
                },
                "valueFrom": {
                  "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                  "type": "object",
                  "properties": {
                    "secretKeyRef": {
                      "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                      "type": "object",
                      "required": ["name", "key"],
                      "properties": {
                        "key": {
                          "description": "Key that identifies the value to be extracted.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the Secret to extract a value from.",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "secretRef": {
              "description": "Secret Manager secret resource",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a SecretManagerSecret.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "The time at which the Secret was created.",
              "type": "string"
            },
            "destroyTime": {
              "description": "The time at which the Secret was destroyed. Only present if state is DESTROYED.",
              "type": "string"
            },
            "name": {
              "description": "The resource name of the SecretVersion. Format:\n'projects/{{project}}/secrets/{{secret_id}}/versions/{{version}}'.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "secretmanager.cnrm.cloud.google.com",
          "kind": "SecretManagerSecretVersion",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.secretmanager.v1beta1.SecretManagerSecretVersionList": {
      "description": "SecretManagerSecretVersionList is a list of SecretManagerSecretVersion",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["secretmanager.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of secretmanagersecretversions. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.secretmanager.v1beta1.SecretManagerSecretVersion"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SecretManagerSecretVersionList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "secretmanager.cnrm.cloud.google.com",
          "kind": "SecretManagerSecretVersionList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.servicenetworking.v1beta1.ServiceNetworkingConnection": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["servicenetworking.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ServiceNetworkingConnection"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["networkRef", "reservedPeeringRanges", "service"],
          "properties": {
            "networkRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a ComputeNetwork.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "reservedPeeringRanges": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "external": {
                    "description": "The name of a ComputeAddress.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                    "type": "string"
                  }
                }
              }
            },
            "service": {
              "description": "Immutable. Provider peering service that is managing peering connectivity for a service provider organization. For Google services that support this functionality it is 'servicenetworking.googleapis.com'.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "peering": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "servicenetworking.cnrm.cloud.google.com",
          "kind": "ServiceNetworkingConnection",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.servicenetworking.v1beta1.ServiceNetworkingConnectionList": {
      "description": "ServiceNetworkingConnectionList is a list of ServiceNetworkingConnection",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["servicenetworking.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of servicenetworkingconnections. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.servicenetworking.v1beta1.ServiceNetworkingConnection"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ServiceNetworkingConnectionList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "servicenetworking.cnrm.cloud.google.com",
          "kind": "ServiceNetworkingConnectionList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.serviceusage.v1beta1.Service": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["serviceusage.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Service"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "projectRef": {
              "description": "The project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a Project.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The service of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "serviceusage.cnrm.cloud.google.com",
          "kind": "Service",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.serviceusage.v1beta1.ServiceList": {
      "description": "ServiceList is a list of Service",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["serviceusage.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of services. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.serviceusage.v1beta1.Service"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ServiceList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "serviceusage.cnrm.cloud.google.com",
          "kind": "ServiceList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.sourcerepo.v1beta1.SourceRepoRepository": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["sourcerepo.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SourceRepoRepository"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "pubsubConfigs": {
              "description": "How this repository publishes a change in the repository through Cloud Pub/Sub. \nKeyed by the topic names.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["messageFormat", "topicRef"],
                "properties": {
                  "messageFormat": {
                    "description": "The format of the Cloud Pub/Sub messages. \n- PROTOBUF: The message payload is a serialized protocol buffer of SourceRepoEvent.\n- JSON: The message payload is a JSON string of SourceRepoEvent. Possible values: [\"PROTOBUF\", \"JSON\"].",
                    "type": "string"
                  },
                  "serviceAccountRef": {
                    "description": "Service account used for publishing Cloud Pub/Sub messages. This\nservice account needs to be in the same project as the\npubsubConfig. When added, the caller needs to have\niam.serviceAccounts.actAs permission on this service account. If\nunspecified, it defaults to the compute engine default service\naccount.",
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The email of an IAMServiceAccount.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  },
                  "topicRef": {
                    "type": "object",
                    "properties": {
                      "external": {
                        "description": "The name of a PubSubTopic.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "size": {
              "description": "The disk usage of the repo, in bytes.",
              "type": "integer"
            },
            "url": {
              "description": "URL to clone the repository from Google Cloud Source Repositories.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sourcerepo.cnrm.cloud.google.com",
          "kind": "SourceRepoRepository",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.sourcerepo.v1beta1.SourceRepoRepositoryList": {
      "description": "SourceRepoRepositoryList is a list of SourceRepoRepository",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["sourcerepo.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of sourcereporepositories. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.sourcerepo.v1beta1.SourceRepoRepository"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SourceRepoRepositoryList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sourcerepo.cnrm.cloud.google.com",
          "kind": "SourceRepoRepositoryList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.spanner.v1beta1.SpannerDatabase": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["spanner.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SpannerDatabase"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["instanceRef"],
          "properties": {
            "ddl": {
              "description": "An optional list of DDL statements to run inside the newly created\ndatabase. Statements can create tables, indexes, etc. These statements\nexecute atomically with the creation of the database: if there is an\nerror in any statement, the database is not created.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "encryptionConfig": {
              "description": "Immutable. Encryption configuration for the database.",
              "type": "object",
              "required": ["kmsKeyRef"],
              "properties": {
                "kmsKeyRef": {
                  "description": "Fully qualified name of the KMS key to use to encrypt this database. This key\nmust exist in the same location as the Spanner Database.",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a KMSCryptoKey.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "instanceRef": {
              "description": "The instance to create the database on.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a SpannerInstance.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "state": {
              "description": "An explanation of the status of the database.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "spanner.cnrm.cloud.google.com",
          "kind": "SpannerDatabase",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.spanner.v1beta1.SpannerDatabaseList": {
      "description": "SpannerDatabaseList is a list of SpannerDatabase",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["spanner.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of spannerdatabases. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.spanner.v1beta1.SpannerDatabase"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SpannerDatabaseList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "spanner.cnrm.cloud.google.com",
          "kind": "SpannerDatabaseList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.spanner.v1beta1.SpannerInstance": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["spanner.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SpannerInstance"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["config", "displayName"],
          "properties": {
            "config": {
              "description": "Immutable. The name of the instance's configuration (similar but not\nquite the same as a region) which defines the geographic placement and\nreplication of your databases in this instance. It determines where your data\nis stored. Values are typically of the form 'regional-europe-west1' , 'us-central' etc.\nIn order to obtain a valid list please consult the\n[Configuration section of the docs](https://cloud.google.com/spanner/docs/instances).",
              "type": "string"
            },
            "displayName": {
              "description": "The descriptive name for this instance as it appears in UIs. Must be\nunique per project and between 4 and 30 characters in length.",
              "type": "string"
            },
            "numNodes": {
              "type": "integer"
            },
            "processingUnits": {
              "type": "integer"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "state": {
              "description": "Instance status: 'CREATING' or 'READY'.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "spanner.cnrm.cloud.google.com",
          "kind": "SpannerInstance",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.spanner.v1beta1.SpannerInstanceList": {
      "description": "SpannerInstanceList is a list of SpannerInstance",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["spanner.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of spannerinstances. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.spanner.v1beta1.SpannerInstance"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SpannerInstanceList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "spanner.cnrm.cloud.google.com",
          "kind": "SpannerInstanceList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.sql.v1beta1.SQLDatabase": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["sql.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SQLDatabase"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["instanceRef"],
          "properties": {
            "charset": {
              "description": "The charset value. See MySQL's\n[Supported Character Sets and Collations](https://dev.mysql.com/doc/refman/5.7/en/charset-charsets.html)\nand Postgres' [Character Set Support](https://www.postgresql.org/docs/9.6/static/multibyte.html)\nfor more details and supported values. Postgres databases only support\na value of 'UTF8' at creation time.",
              "type": "string"
            },
            "collation": {
              "description": "The collation value. See MySQL's\n[Supported Character Sets and Collations](https://dev.mysql.com/doc/refman/5.7/en/charset-charsets.html)\nand Postgres' [Collation Support](https://www.postgresql.org/docs/9.6/static/collation.html)\nfor more details and supported values. Postgres databases only support\na value of 'en_US.UTF8' at creation time.",
              "type": "string"
            },
            "instanceRef": {
              "description": "The Cloud SQL instance.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a SQLInstance.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sql.cnrm.cloud.google.com",
          "kind": "SQLDatabase",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.sql.v1beta1.SQLDatabaseList": {
      "description": "SQLDatabaseList is a list of SQLDatabase",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["sql.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of sqldatabases. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.sql.v1beta1.SQLDatabase"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SQLDatabaseList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sql.cnrm.cloud.google.com",
          "kind": "SQLDatabaseList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.sql.v1beta1.SQLInstance": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["sql.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SQLInstance"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["settings"],
          "properties": {
            "databaseVersion": {
              "description": "Immutable. The MySQL, PostgreSQL or SQL Server (beta) version to use. Supported values include MYSQL_5_6, MYSQL_5_7, MYSQL_8_0, POSTGRES_9_6, POSTGRES_10, POSTGRES_11, POSTGRES_12, POSTGRES_13, SQLSERVER_2017_STANDARD, SQLSERVER_2017_ENTERPRISE, SQLSERVER_2017_EXPRESS, SQLSERVER_2017_WEB. Database Version Policies includes an up-to-date reference of supported versions.",
              "type": "string"
            },
            "encryptionKMSCryptoKeyRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a KMSCryptoKey.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "masterInstanceRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a SQLInstance.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "region": {
              "description": "Immutable. The region the instance will sit in. Note, Cloud SQL is not available in all regions. A valid region must be provided to use this resource. If a region is not provided in the resource definition, the provider region will be used instead, but this will be an apply-time error for instances if the provider region is not supported with Cloud SQL. If you choose not to provide the region argument for this resource, make sure you understand this.",
              "type": "string"
            },
            "replicaConfiguration": {
              "description": "The configuration for replication.",
              "type": "object",
              "properties": {
                "caCertificate": {
                  "description": "Immutable. PEM representation of the trusted CA's x509 certificate.",
                  "type": "string"
                },
                "clientCertificate": {
                  "description": "Immutable. PEM representation of the replica's x509 certificate.",
                  "type": "string"
                },
                "clientKey": {
                  "description": "Immutable. PEM representation of the replica's private key. The corresponding public key in encoded in the client_certificate.",
                  "type": "string"
                },
                "connectRetryInterval": {
                  "description": "Immutable. The number of seconds between connect retries.",
                  "type": "integer"
                },
                "dumpFilePath": {
                  "description": "Immutable. Path to a SQL file in Google Cloud Storage from which replica instances are created. Format is gs://bucket/filename.",
                  "type": "string"
                },
                "failoverTarget": {
                  "description": "Immutable. Specifies if the replica is the failover target. If the field is set to true the replica will be designated as a failover replica. If the master instance fails, the replica instance will be promoted as the new master instance.",
                  "type": "boolean"
                },
                "masterHeartbeatPeriod": {
                  "description": "Immutable. Time in ms between replication heartbeats.",
                  "type": "integer"
                },
                "password": {
                  "description": "Immutable. Password for the replication connection.",
                  "type": "object",
                  "properties": {
                    "value": {
                      "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                      "type": "string"
                    },
                    "valueFrom": {
                      "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                      "type": "object",
                      "properties": {
                        "secretKeyRef": {
                          "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                          "type": "object",
                          "required": ["name", "key"],
                          "properties": {
                            "key": {
                              "description": "Key that identifies the value to be extracted.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the Secret to extract a value from.",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "sslCipher": {
                  "description": "Immutable. Permissible ciphers for use in SSL encryption.",
                  "type": "string"
                },
                "username": {
                  "description": "Immutable. Username for replication connection.",
                  "type": "string"
                },
                "verifyServerCertificate": {
                  "description": "Immutable. True if the master's common name value is checked during the SSL handshake.",
                  "type": "boolean"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "rootPassword": {
              "description": "Immutable. Initial root password. Required for MS SQL Server, ignored by MySQL and PostgreSQL.",
              "type": "object",
              "properties": {
                "value": {
                  "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                  "type": "string"
                },
                "valueFrom": {
                  "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                  "type": "object",
                  "properties": {
                    "secretKeyRef": {
                      "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                      "type": "object",
                      "required": ["name", "key"],
                      "properties": {
                        "key": {
                          "description": "Key that identifies the value to be extracted.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the Secret to extract a value from.",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "settings": {
              "description": "The settings to use for the database. The configuration is detailed below.",
              "type": "object",
              "required": ["tier"],
              "properties": {
                "activationPolicy": {
                  "description": "This specifies when the instance should be active. Can be either ALWAYS, NEVER or ON_DEMAND.",
                  "type": "string"
                },
                "authorizedGaeApplications": {
                  "description": "DEPRECATED \u2014 This property is only applicable to First Generation instances, and First Generation instances are now deprecated. see https://cloud.google.com/sql/docs/mysql/deprecation-notice for information on how to upgrade to Second Generation instances.\nSpecifying this field has no-ops; it's recommended to remove this field from your configuration.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "availabilityType": {
                  "description": "The availability type of the Cloud SQL instance, high availability\n(REGIONAL) or single zone (ZONAL). For MySQL instances, ensure that\nsettings.backup_configuration.enabled and\nsettings.backup_configuration.binary_log_enabled are both set to true.",
                  "type": "string"
                },
                "backupConfiguration": {
                  "type": "object",
                  "properties": {
                    "backupRetentionSettings": {
                      "type": "object",
                      "required": ["retainedBackups"],
                      "properties": {
                        "retainedBackups": {
                          "description": "Number of backups to retain.",
                          "type": "integer"
                        },
                        "retentionUnit": {
                          "description": "The unit that 'retainedBackups' represents. Defaults to COUNT.",
                          "type": "string"
                        }
                      }
                    },
                    "binaryLogEnabled": {
                      "description": "True if binary logging is enabled. If settings.backup_configuration.enabled is false, this must be as well. Cannot be used with Postgres.",
                      "type": "boolean"
                    },
                    "enabled": {
                      "description": "True if backup configuration is enabled.",
                      "type": "boolean"
                    },
                    "location": {
                      "description": "Location of the backup configuration.",
                      "type": "string"
                    },
                    "pointInTimeRecoveryEnabled": {
                      "description": "True if Point-in-time recovery is enabled.",
                      "type": "boolean"
                    },
                    "startTime": {
                      "description": "HH:MM format time indicating when backup configuration starts.",
                      "type": "string"
                    },
                    "transactionLogRetentionDays": {
                      "description": "The number of days of transaction logs we retain for point in time restore, from 1-7.",
                      "type": "integer"
                    }
                  }
                },
                "collation": {
                  "description": "The name of server instance collation.",
                  "type": "string"
                },
                "crashSafeReplication": {
                  "description": "DEPRECATED \u2014 This property is only applicable to First Generation instances, and First Generation instances are now deprecated. see https://cloud.google.com/sql/docs/mysql/deprecation-notice for information on how to upgrade to Second Generation instances.\nSpecifying this field has no-ops; it's recommended to remove this field from your configuration.",
                  "type": "boolean"
                },
                "databaseFlags": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["name", "value"],
                    "properties": {
                      "name": {
                        "description": "Name of the flag.",
                        "type": "string"
                      },
                      "value": {
                        "description": "Value of the flag.",
                        "type": "string"
                      }
                    }
                  }
                },
                "diskAutoresize": {
                  "type": "boolean"
                },
                "diskAutoresizeLimit": {
                  "description": "The maximum size, in GB, to which storage capacity can be automatically increased. The default value is 0, which specifies that there is no limit.",
                  "type": "integer"
                },
                "diskSize": {
                  "description": "The size of data disk, in GB. Size of a running instance cannot be reduced but can be increased.",
                  "type": "integer"
                },
                "diskType": {
                  "description": "The type of data disk: PD_SSD or PD_HDD.",
                  "type": "string"
                },
                "insightsConfig": {
                  "description": "Configuration of Query Insights.",
                  "type": "object",
                  "properties": {
                    "queryInsightsEnabled": {
                      "description": "True if Query Insights feature is enabled.",
                      "type": "boolean"
                    },
                    "queryStringLength": {
                      "description": "Maximum query length stored in bytes. Between 256 and 4500. Default to 1024.",
                      "type": "integer"
                    },
                    "recordApplicationTags": {
                      "description": "True if Query Insights will record application tags from query when enabled.",
                      "type": "boolean"
                    },
                    "recordClientAddress": {
                      "description": "True if Query Insights will record client address when enabled.",
                      "type": "boolean"
                    }
                  }
                },
                "ipConfiguration": {
                  "type": "object",
                  "properties": {
                    "allocatedIpRange": {
                      "description": "Immutable. The name of the allocated ip range for the private ip CloudSQL instance. For example: \"google-managed-services-default\". If set, the instance ip will be created in the allocated range. The range name must comply with RFC 1035. Specifically, the name must be 1-63 characters long and match the regular expression [a-z]([-a-z0-9]*[a-z0-9])?.",
                      "type": "string"
                    },
                    "authorizedNetworks": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": ["value"],
                        "properties": {
                          "expirationTime": {
                            "type": "string"
                          },
                          "name": {
                            "type": "string"
                          },
                          "value": {
                            "type": "string"
                          }
                        }
                      }
                    },
                    "ipv4Enabled": {
                      "description": "Whether this Cloud SQL instance should be assigned a public IPV4 address. At least ipv4_enabled must be enabled or a private_network must be configured.",
                      "type": "boolean"
                    },
                    "privateNetworkRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "The selfLink of a ComputeNetwork.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    },
                    "requireSsl": {
                      "type": "boolean"
                    }
                  }
                },
                "locationPreference": {
                  "type": "object",
                  "properties": {
                    "followGaeApplication": {
                      "description": "A Google App Engine application whose zone to remain in. Must be in the same region as this instance.",
                      "type": "string"
                    },
                    "zone": {
                      "description": "The preferred compute engine zone.",
                      "type": "string"
                    }
                  }
                },
                "maintenanceWindow": {
                  "description": "Declares a one-hour maintenance window when an Instance can automatically restart to apply updates. The maintenance window is specified in UTC time.",
                  "type": "object",
                  "properties": {
                    "day": {
                      "description": "Day of week (1-7), starting on Monday.",
                      "type": "integer"
                    },
                    "hour": {
                      "description": "Hour of day (0-23), ignored if day not set.",
                      "type": "integer"
                    },
                    "updateTrack": {
                      "description": "Receive updates earlier (canary) or later (stable).",
                      "type": "string"
                    }
                  }
                },
                "pricingPlan": {
                  "description": "Pricing plan for this instance, can only be PER_USE.",
                  "type": "string"
                },
                "replicationType": {
                  "description": "DEPRECATED \u2014 This property is only applicable to First Generation instances, and First Generation instances are now deprecated. see https://cloud.google.com/sql/docs/mysql/deprecation-notice for information on how to upgrade to Second Generation instances.\nSpecifying this field has no-ops; it's recommended to remove this field from your configuration.",
                  "type": "string"
                },
                "tier": {
                  "description": "The machine type to use. See tiers for more details and supported versions. Postgres supports only shared-core machine types, and custom machine types such as db-custom-2-13312. See the Custom Machine Type Documentation to learn about specifying custom machine types.",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "connectionName": {
              "description": "The connection name of the instance to be used in connection strings. For example, when connecting with Cloud SQL Proxy.",
              "type": "string"
            },
            "firstIpAddress": {
              "type": "string"
            },
            "ipAddress": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "ipAddress": {
                    "type": "string"
                  },
                  "timeToRetire": {
                    "type": "string"
                  },
                  "type": {
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "privateIpAddress": {
              "type": "string"
            },
            "publicIpAddress": {
              "type": "string"
            },
            "selfLink": {
              "description": "The URI of the created resource.",
              "type": "string"
            },
            "serverCaCert": {
              "type": "object",
              "properties": {
                "cert": {
                  "description": "The CA Certificate used to connect to the SQL Instance via SSL.",
                  "type": "string"
                },
                "commonName": {
                  "description": "The CN valid for the CA Cert.",
                  "type": "string"
                },
                "createTime": {
                  "description": "Creation time of the CA Cert.",
                  "type": "string"
                },
                "expirationTime": {
                  "description": "Expiration time of the CA Cert.",
                  "type": "string"
                },
                "sha1Fingerprint": {
                  "description": "SHA Fingerprint of the CA Cert.",
                  "type": "string"
                }
              }
            },
            "serviceAccountEmailAddress": {
              "description": "The service account email address assigned to the instance.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sql.cnrm.cloud.google.com",
          "kind": "SQLInstance",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.sql.v1beta1.SQLInstanceList": {
      "description": "SQLInstanceList is a list of SQLInstance",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["sql.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of sqlinstances. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.sql.v1beta1.SQLInstance"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SQLInstanceList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sql.cnrm.cloud.google.com",
          "kind": "SQLInstanceList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.sql.v1beta1.SQLSSLCert": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["sql.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SQLSSLCert"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["commonName", "instanceRef"],
          "properties": {
            "commonName": {
              "description": "Immutable. The common name to be used in the certificate to identify the client. Constrained to [a-zA-Z.-_ ]+. Changing this forces a new resource to be created.",
              "type": "string"
            },
            "instanceRef": {
              "description": "The Cloud SQL instance.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a SQLInstance.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The service-generated sha1Fingerprint of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "cert": {
              "description": "The actual certificate data for this client certificate.",
              "type": "string"
            },
            "certSerialNumber": {
              "description": "The serial number extracted from the certificate data.",
              "type": "string"
            },
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "createTime": {
              "description": "The time when the certificate was created in RFC 3339 format, for example 2012-11-15T16:19:00.094Z.",
              "type": "string"
            },
            "expirationTime": {
              "description": "The time when the certificate expires in RFC 3339 format, for example 2012-11-15T16:19:00.094Z.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "privateKey": {
              "description": "The private key associated with the client certificate.",
              "type": "string"
            },
            "serverCaCert": {
              "description": "The CA cert of the server this client cert was generated from.",
              "type": "string"
            },
            "sha1Fingerprint": {
              "description": "The SHA1 Fingerprint of the certificate.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sql.cnrm.cloud.google.com",
          "kind": "SQLSSLCert",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.sql.v1beta1.SQLSSLCertList": {
      "description": "SQLSSLCertList is a list of SQLSSLCert",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["sql.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of sqlsslcerts. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.sql.v1beta1.SQLSSLCert"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SQLSSLCertList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sql.cnrm.cloud.google.com",
          "kind": "SQLSSLCertList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.sql.v1beta1.SQLUser": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["sql.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SQLUser"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["instanceRef"],
          "properties": {
            "host": {
              "description": "Immutable. The host the user can connect from. This is only supported for MySQL instances. Don't set this field for PostgreSQL instances. Can be an IP address. Changing this forces a new resource to be created.",
              "type": "string"
            },
            "instanceRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a SQLInstance.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "password": {
              "description": "The password for the user. Can be updated. For Postgres instances this is a Required field, unless type is set to\n                either CLOUD_IAM_USER or CLOUD_IAM_SERVICE_ACCOUNT.",
              "type": "object",
              "properties": {
                "value": {
                  "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                  "type": "string"
                },
                "valueFrom": {
                  "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                  "type": "object",
                  "properties": {
                    "secretKeyRef": {
                      "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                      "type": "object",
                      "required": ["name", "key"],
                      "properties": {
                        "key": {
                          "description": "Key that identifies the value to be extracted.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the Secret to extract a value from.",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "type": {
              "description": "Immutable. The user type. It determines the method to authenticate the user during login.\n                The default is the database's built-in user type. Flags include \"BUILT_IN\", \"CLOUD_IAM_USER\", or \"CLOUD_IAM_SERVICE_ACCOUNT\".",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sql.cnrm.cloud.google.com",
          "kind": "SQLUser",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.sql.v1beta1.SQLUserList": {
      "description": "SQLUserList is a list of SQLUser",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["sql.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of sqlusers. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.sql.v1beta1.SQLUser"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SQLUserList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sql.cnrm.cloud.google.com",
          "kind": "SQLUserList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.storage.v1beta1.StorageBucket": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StorageBucket"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "bucketPolicyOnly": {
              "description": "DEPRECATED \u2014 Please use the `uniformBucketLevelAccess` field as this field has been renamed by Google. The `uniformBucketLevelAccess` field will supersede this field.\nEnables Bucket PolicyOnly access to a bucket.",
              "type": "boolean"
            },
            "cors": {
              "description": "The bucket's Cross-Origin Resource Sharing (CORS) configuration.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "maxAgeSeconds": {
                    "description": "The value, in seconds, to return in the Access-Control-Max-Age header used in preflight responses.",
                    "type": "integer"
                  },
                  "method": {
                    "description": "The list of HTTP methods on which to include CORS response headers, (GET, OPTIONS, POST, etc) Note: \"*\" is permitted in the list of methods, and means \"any method\".",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "origin": {
                    "description": "The list of Origins eligible to receive CORS response headers. Note: \"*\" is permitted in the list of origins, and means \"any Origin\".",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "responseHeader": {
                    "description": "The list of HTTP headers other than the simple response headers to give permission for the user-agent to share across domains.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            },
            "defaultEventBasedHold": {
              "type": "boolean"
            },
            "encryption": {
              "description": "The bucket's encryption configuration.",
              "type": "object",
              "required": ["kmsKeyRef"],
              "properties": {
                "kmsKeyRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "The selfLink of a KMSCryptoKey.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "lifecycleRule": {
              "description": "The bucket's Lifecycle Rules configuration.",
              "type": "array",
              "items": {
                "type": "object",
                "required": ["action", "condition"],
                "properties": {
                  "action": {
                    "description": "The Lifecycle Rule's action configuration. A single block of this type is supported.",
                    "type": "object",
                    "required": ["type"],
                    "properties": {
                      "storageClass": {
                        "description": "The target Storage Class of objects affected by this Lifecycle Rule. Supported values include: MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE.",
                        "type": "string"
                      },
                      "type": {
                        "description": "The type of the action of this Lifecycle Rule. Supported values include: Delete and SetStorageClass.",
                        "type": "string"
                      }
                    }
                  },
                  "condition": {
                    "description": "The Lifecycle Rule's condition configuration.",
                    "type": "object",
                    "properties": {
                      "age": {
                        "description": "Minimum age of an object in days to satisfy this condition.",
                        "type": "integer"
                      },
                      "createdBefore": {
                        "description": "Creation date of an object in RFC 3339 (e.g. 2017-06-13) to satisfy this condition.",
                        "type": "string"
                      },
                      "customTimeBefore": {
                        "description": "Creation date of an object in RFC 3339 (e.g. 2017-06-13) to satisfy this condition.",
                        "type": "string"
                      },
                      "daysSinceCustomTime": {
                        "description": "Number of days elapsed since the user-specified timestamp set on an object.",
                        "type": "integer"
                      },
                      "daysSinceNoncurrentTime": {
                        "description": "Number of days elapsed since the noncurrent timestamp of an object. This\n\t\t\t\t\t\t\t\t\t\tcondition is relevant only for versioned objects.",
                        "type": "integer"
                      },
                      "matchesStorageClass": {
                        "description": "Storage Class of objects to satisfy this condition. Supported values include: MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE, STANDARD, DURABLE_REDUCED_AVAILABILITY.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "noncurrentTimeBefore": {
                        "description": "Creation date of an object in RFC 3339 (e.g. 2017-06-13) to satisfy this condition.",
                        "type": "string"
                      },
                      "numNewerVersions": {
                        "description": "Relevant only for versioned objects. The number of newer versions of an object to satisfy this condition.",
                        "type": "integer"
                      },
                      "withState": {
                        "description": "Match to live and/or archived objects. Unversioned buckets have only live objects. Supported values include: \"LIVE\", \"ARCHIVED\", \"ANY\".",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "location": {
              "description": "Immutable. The Google Cloud Storage location.",
              "type": "string"
            },
            "logging": {
              "description": "The bucket's Access & Storage Logs configuration.",
              "type": "object",
              "required": ["logBucket"],
              "properties": {
                "logBucket": {
                  "description": "The bucket that will receive log objects.",
                  "type": "string"
                },
                "logObjectPrefix": {
                  "description": "The object prefix for log objects. If it's not provided, by default Google Cloud Storage sets this to this bucket's name.",
                  "type": "string"
                }
              }
            },
            "publicAccessPrevention": {
              "description": "Prevents public access to a bucket.",
              "type": "string"
            },
            "requesterPays": {
              "description": "Enables Requester Pays on a storage bucket.",
              "type": "boolean"
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "retentionPolicy": {
              "description": "Configuration of the bucket's data retention policy for how long objects in the bucket should be retained.",
              "type": "object",
              "required": ["retentionPeriod"],
              "properties": {
                "isLocked": {
                  "description": "If set to true, the bucket will be locked and permanently restrict edits to the bucket's retention policy.  Caution: Locking a bucket is an irreversible action.",
                  "type": "boolean"
                },
                "retentionPeriod": {
                  "description": "The period of time, in seconds, that objects in the bucket must be retained and cannot be deleted, overwritten, or archived. The value must be less than 3,155,760,000 seconds.",
                  "type": "integer"
                }
              }
            },
            "storageClass": {
              "description": "The Storage Class of the new bucket. Supported values include: STANDARD, MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE.",
              "type": "string"
            },
            "uniformBucketLevelAccess": {
              "description": "Enables uniform bucket-level access on a bucket.",
              "type": "boolean"
            },
            "versioning": {
              "description": "The bucket's Versioning configuration.",
              "type": "object",
              "required": ["enabled"],
              "properties": {
                "enabled": {
                  "description": "While set to true, versioning is fully enabled for this bucket.",
                  "type": "boolean"
                }
              }
            },
            "website": {
              "description": "Configuration if the bucket acts as a website.",
              "type": "object",
              "properties": {
                "mainPageSuffix": {
                  "description": "Behaves as the bucket's directory index where missing objects are treated as potential directories.",
                  "type": "string"
                },
                "notFoundPage": {
                  "description": "The custom object to return when a requested resource is not found.",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "description": "The URI of the created resource.",
              "type": "string"
            },
            "url": {
              "description": "The base URL of the bucket, in the format gs://<bucket-name>.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.cnrm.cloud.google.com",
          "kind": "StorageBucket",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.storage.v1beta1.StorageBucketAccessControl": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StorageBucketAccessControl"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["bucketRef", "entity"],
          "properties": {
            "bucketRef": {
              "description": "Reference to the bucket.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a StorageBucket.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "entity": {
              "description": "Immutable. The entity holding the permission, in one of the following forms:\n  user-userId\n  user-email\n  group-groupId\n  group-email\n  domain-domain\n  project-team-projectId\n  allUsers\n  allAuthenticatedUsers\nExamples:\n  The user liz@example.com would be user-liz@example.com.\n  The group example@googlegroups.com would be\n  group-example@googlegroups.com.\n  To refer to all members of the Google Apps for Business domain\n  example.com, the entity would be domain-example.com.",
              "type": "string"
            },
            "role": {
              "description": "The access permission for the entity. Possible values: [\"OWNER\", \"READER\", \"WRITER\"].",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "domain": {
              "description": "The domain associated with the entity.",
              "type": "string"
            },
            "email": {
              "description": "The email address associated with the entity.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.cnrm.cloud.google.com",
          "kind": "StorageBucketAccessControl",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.storage.v1beta1.StorageBucketAccessControlList": {
      "description": "StorageBucketAccessControlList is a list of StorageBucketAccessControl",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of storagebucketaccesscontrols. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.storage.v1beta1.StorageBucketAccessControl"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StorageBucketAccessControlList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.cnrm.cloud.google.com",
          "kind": "StorageBucketAccessControlList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.storage.v1beta1.StorageBucketList": {
      "description": "StorageBucketList is a list of StorageBucket",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of storagebuckets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.storage.v1beta1.StorageBucket"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StorageBucketList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.cnrm.cloud.google.com",
          "kind": "StorageBucketList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.storage.v1beta1.StorageDefaultObjectAccessControl": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StorageDefaultObjectAccessControl"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["bucketRef", "entity", "role"],
          "properties": {
            "bucketRef": {
              "description": "Reference to the bucket.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a StorageBucket.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "entity": {
              "description": "The entity holding the permission, in one of the following forms:\n  * user-{{userId}}\n  * user-{{email}} (such as \"user-liz@example.com\")\n  * group-{{groupId}}\n  * group-{{email}} (such as \"group-example@googlegroups.com\")\n  * domain-{{domain}} (such as \"domain-example.com\")\n  * project-team-{{projectId}}\n  * allUsers\n  * allAuthenticatedUsers.",
              "type": "string"
            },
            "object": {
              "description": "The name of the object, if applied to an object.",
              "type": "string"
            },
            "role": {
              "description": "The access permission for the entity. Possible values: [\"OWNER\", \"READER\"].",
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "domain": {
              "description": "The domain associated with the entity.",
              "type": "string"
            },
            "email": {
              "description": "The email address associated with the entity.",
              "type": "string"
            },
            "entityId": {
              "description": "The ID for the entity.",
              "type": "string"
            },
            "generation": {
              "description": "The content generation of the object, if applied to an object.",
              "type": "integer"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "projectTeam": {
              "description": "The project team associated with the entity.",
              "type": "object",
              "properties": {
                "projectNumber": {
                  "description": "The project team associated with the entity.",
                  "type": "string"
                },
                "team": {
                  "description": "The team. Possible values: [\"editors\", \"owners\", \"viewers\"].",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.cnrm.cloud.google.com",
          "kind": "StorageDefaultObjectAccessControl",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.storage.v1beta1.StorageDefaultObjectAccessControlList": {
      "description": "StorageDefaultObjectAccessControlList is a list of StorageDefaultObjectAccessControl",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of storagedefaultobjectaccesscontrols. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.storage.v1beta1.StorageDefaultObjectAccessControl"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StorageDefaultObjectAccessControlList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.cnrm.cloud.google.com",
          "kind": "StorageDefaultObjectAccessControlList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.storage.v1beta1.StorageNotification": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StorageNotification"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["bucketRef", "payloadFormat", "topicRef"],
          "properties": {
            "bucketRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "The name of a StorageBucket.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "customAttributes": {
              "description": "Immutable.  A set of key/value attribute pairs to attach to each Cloud Pub/Sub message published for this notification subscription.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "eventTypes": {
              "description": "Immutable. List of event type filters for this notification config. If not specified, Cloud Storage will send notifications for all event types. The valid types are: \"OBJECT_FINALIZE\", \"OBJECT_METADATA_UPDATE\", \"OBJECT_DELETE\", \"OBJECT_ARCHIVE\".",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "objectNamePrefix": {
              "description": "Immutable. Specifies a prefix path filter for this notification config. Cloud Storage will only send notifications for objects in this bucket whose names begin with the specified prefix.",
              "type": "string"
            },
            "payloadFormat": {
              "description": "Immutable. The desired content of the Payload. One of \"JSON_API_V1\" or \"NONE\".",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The service-generated notificationId of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            },
            "topicRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "A string of the format \"projects/{{project}}/topics/{{value}}\", where {{value}} is the name of a PubSubTopic.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "notificationId": {
              "description": "The ID of the created notification.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "selfLink": {
              "description": "The URI of the created resource.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.cnrm.cloud.google.com",
          "kind": "StorageNotification",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.storage.v1beta1.StorageNotificationList": {
      "description": "StorageNotificationList is a list of StorageNotification",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of storagenotifications. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.storage.v1beta1.StorageNotification"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StorageNotificationList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.cnrm.cloud.google.com",
          "kind": "StorageNotificationList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.storagetransfer.v1beta1.StorageTransferJob": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storagetransfer.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StorageTransferJob"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["description", "schedule", "transferSpec"],
          "properties": {
            "description": {
              "description": "Unique description to identify the Transfer Job.",
              "type": "string"
            },
            "resourceID": {
              "description": "Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.",
              "type": "string"
            },
            "schedule": {
              "description": "Schedule specification defining when the Transfer Job should be scheduled to start, end and what time to run.",
              "type": "object",
              "required": ["scheduleStartDate"],
              "properties": {
                "scheduleEndDate": {
                  "description": "Immutable. The last day the recurring transfer will be run. If schedule_end_date is the same as schedule_start_date, the transfer will be executed only once.",
                  "type": "object",
                  "required": ["day", "month", "year"],
                  "properties": {
                    "day": {
                      "description": "Immutable. Day of month. Must be from 1 to 31 and valid for the year and month.",
                      "type": "integer"
                    },
                    "month": {
                      "description": "Immutable. Month of year. Must be from 1 to 12.",
                      "type": "integer"
                    },
                    "year": {
                      "description": "Immutable. Year of date. Must be from 1 to 9999.",
                      "type": "integer"
                    }
                  }
                },
                "scheduleStartDate": {
                  "description": "Immutable. The first day the recurring transfer is scheduled to run. If schedule_start_date is in the past, the transfer will run for the first time on the following day.",
                  "type": "object",
                  "required": ["day", "month", "year"],
                  "properties": {
                    "day": {
                      "description": "Immutable. Day of month. Must be from 1 to 31 and valid for the year and month.",
                      "type": "integer"
                    },
                    "month": {
                      "description": "Immutable. Month of year. Must be from 1 to 12.",
                      "type": "integer"
                    },
                    "year": {
                      "description": "Immutable. Year of date. Must be from 1 to 9999.",
                      "type": "integer"
                    }
                  }
                },
                "startTimeOfDay": {
                  "description": "Immutable. The time in UTC at which the transfer will be scheduled to start in a day. Transfers may start later than this time. If not specified, recurring and one-time transfers that are scheduled to run today will run immediately; recurring transfers that are scheduled to run on a future date will start at approximately midnight UTC on that date. Note that when configuring a transfer with the Cloud Platform Console, the transfer's start time in a day is specified in your local timezone.",
                  "type": "object",
                  "required": ["hours", "minutes", "nanos", "seconds"],
                  "properties": {
                    "hours": {
                      "description": "Immutable. Hours of day in 24 hour format. Should be from 0 to 23.",
                      "type": "integer"
                    },
                    "minutes": {
                      "description": "Immutable. Minutes of hour of day. Must be from 0 to 59.",
                      "type": "integer"
                    },
                    "nanos": {
                      "description": "Immutable. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.",
                      "type": "integer"
                    },
                    "seconds": {
                      "description": "Immutable. Seconds of minutes of the time. Must normally be from 0 to 59.",
                      "type": "integer"
                    }
                  }
                }
              }
            },
            "status": {
              "description": "Status of the job. Default: ENABLED. NOTE: The effect of the new job status takes place during a subsequent job run. For example, if you change the job status from ENABLED to DISABLED, and an operation spawned by the transfer is running, the status change would not affect the current operation.",
              "type": "string"
            },
            "transferSpec": {
              "description": "Transfer specification.",
              "type": "object",
              "properties": {
                "awsS3DataSource": {
                  "description": "An AWS S3 data source.",
                  "type": "object",
                  "required": ["awsAccessKey", "bucketName"],
                  "properties": {
                    "awsAccessKey": {
                      "description": "AWS credentials block.",
                      "type": "object",
                      "required": ["accessKeyId", "secretAccessKey"],
                      "properties": {
                        "accessKeyId": {
                          "description": "AWS Key ID.",
                          "type": "object",
                          "properties": {
                            "value": {
                              "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                              "type": "string"
                            },
                            "valueFrom": {
                              "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                              "type": "object",
                              "properties": {
                                "secretKeyRef": {
                                  "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                                  "type": "object",
                                  "required": ["name", "key"],
                                  "properties": {
                                    "key": {
                                      "description": "Key that identifies the value to be extracted.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the Secret to extract a value from.",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "secretAccessKey": {
                          "description": "AWS Secret Access Key.",
                          "type": "object",
                          "properties": {
                            "value": {
                              "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                              "type": "string"
                            },
                            "valueFrom": {
                              "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                              "type": "object",
                              "properties": {
                                "secretKeyRef": {
                                  "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                                  "type": "object",
                                  "required": ["name", "key"],
                                  "properties": {
                                    "key": {
                                      "description": "Key that identifies the value to be extracted.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the Secret to extract a value from.",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "bucketName": {
                      "description": "S3 Bucket name.",
                      "type": "string"
                    }
                  }
                },
                "azureBlobStorageDataSource": {
                  "description": "An Azure Blob Storage data source.",
                  "type": "object",
                  "required": [
                    "azureCredentials",
                    "container",
                    "storageAccount"
                  ],
                  "properties": {
                    "azureCredentials": {
                      "description": " Credentials used to authenticate API requests to Azure.",
                      "type": "object",
                      "required": ["sasToken"],
                      "properties": {
                        "sasToken": {
                          "description": "Azure shared access signature.",
                          "type": "object",
                          "properties": {
                            "value": {
                              "description": "Value of the field. Cannot be used if 'valueFrom' is specified.",
                              "type": "string"
                            },
                            "valueFrom": {
                              "description": "Source for the field's value. Cannot be used if 'value' is specified.",
                              "type": "object",
                              "properties": {
                                "secretKeyRef": {
                                  "description": "Reference to a value with the given key in the given Secret in the resource's namespace.",
                                  "type": "object",
                                  "required": ["name", "key"],
                                  "properties": {
                                    "key": {
                                      "description": "Key that identifies the value to be extracted.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the Secret to extract a value from.",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "container": {
                      "description": "The container to transfer from the Azure Storage account.",
                      "type": "string"
                    },
                    "path": {
                      "description": "Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.",
                      "type": "string"
                    },
                    "storageAccount": {
                      "description": "The name of the Azure Storage account.",
                      "type": "string"
                    }
                  }
                },
                "gcsDataSink": {
                  "description": "A Google Cloud Storage data sink.",
                  "type": "object",
                  "required": ["bucketRef"],
                  "properties": {
                    "bucketRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "The name of a StorageBucket.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    },
                    "path": {
                      "description": "Google Cloud Storage path in bucket to transfer.",
                      "type": "string"
                    }
                  }
                },
                "gcsDataSource": {
                  "description": "A Google Cloud Storage data source.",
                  "type": "object",
                  "required": ["bucketRef"],
                  "properties": {
                    "bucketRef": {
                      "type": "object",
                      "properties": {
                        "external": {
                          "description": "The name of a StorageBucket.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                          "type": "string"
                        }
                      }
                    },
                    "path": {
                      "description": "Google Cloud Storage path in bucket to transfer.",
                      "type": "string"
                    }
                  }
                },
                "httpDataSource": {
                  "description": "A HTTP URL data source.",
                  "type": "object",
                  "required": ["listUrl"],
                  "properties": {
                    "listUrl": {
                      "description": "The URL that points to the file that stores the object list entries. This file must allow public access. Currently, only URLs with HTTP and HTTPS schemes are supported.",
                      "type": "string"
                    }
                  }
                },
                "objectConditions": {
                  "description": "Only objects that satisfy these object conditions are included in the set of data source and data sink objects. Object conditions based on objects' last_modification_time do not exclude objects in a data sink.",
                  "type": "object",
                  "properties": {
                    "excludePrefixes": {
                      "description": "exclude_prefixes must follow the requirements described for include_prefixes.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "includePrefixes": {
                      "description": "If include_refixes is specified, objects that satisfy the object conditions must have names that start with one of the include_prefixes and that do not start with any of the exclude_prefixes. If include_prefixes is not specified, all objects except those that have names starting with one of the exclude_prefixes must satisfy the object conditions.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "maxTimeElapsedSinceLastModification": {
                      "description": "A duration in seconds with up to nine fractional digits, terminated by 's'. Example: \"3.5s\".",
                      "type": "string"
                    },
                    "minTimeElapsedSinceLastModification": {
                      "description": "A duration in seconds with up to nine fractional digits, terminated by 's'. Example: \"3.5s\".",
                      "type": "string"
                    }
                  }
                },
                "transferOptions": {
                  "description": "Characteristics of how to treat files from datasource and sink during job. If the option delete_objects_unique_in_sink is true, object conditions based on objects' last_modification_time are ignored and do not exclude objects in a data source or a data sink.",
                  "type": "object",
                  "properties": {
                    "deleteObjectsFromSourceAfterTransfer": {
                      "description": "Whether objects should be deleted from the source after they are transferred to the sink. Note that this option and delete_objects_unique_in_sink are mutually exclusive.",
                      "type": "boolean"
                    },
                    "deleteObjectsUniqueInSink": {
                      "description": "Whether objects that exist only in the sink should be deleted. Note that this option and delete_objects_from_source_after_transfer are mutually exclusive.",
                      "type": "boolean"
                    },
                    "overwriteObjectsAlreadyExistingInSink": {
                      "description": "Whether overwriting objects that already exist in the sink is allowed.",
                      "type": "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "creationTime": {
              "description": "When the Transfer Job was created.",
              "type": "string"
            },
            "deletionTime": {
              "description": "When the Transfer Job was deleted.",
              "type": "string"
            },
            "lastModificationTime": {
              "description": "When the Transfer Job was last modified.",
              "type": "string"
            },
            "name": {
              "description": "The name of the Transfer Job.",
              "type": "string"
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storagetransfer.cnrm.cloud.google.com",
          "kind": "StorageTransferJob",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.storagetransfer.v1beta1.StorageTransferJobList": {
      "description": "StorageTransferJobList is a list of StorageTransferJob",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storagetransfer.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of storagetransferjobs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.storagetransfer.v1beta1.StorageTransferJob"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StorageTransferJobList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storagetransfer.cnrm.cloud.google.com",
          "kind": "StorageTransferJobList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.vpcaccess.v1beta1.VPCAccessConnector": {
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["vpcaccess.cnrm.cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["VPCAccessConnector"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "required": ["location", "projectRef"],
          "properties": {
            "ipCidrRange": {
              "description": "The range of internal addresses that follows RFC 4632 notation. Example: `10.132.0.0/28`.",
              "type": "string"
            },
            "location": {
              "description": "The location for the resource",
              "type": "string"
            },
            "machineType": {
              "description": "Machine type of VM Instance underlying connector. Default is e2-micro",
              "type": "string"
            },
            "maxInstances": {
              "description": "Maximum value of instances in autoscaling group underlying the connector.",
              "type": "integer",
              "format": "int64"
            },
            "maxThroughput": {
              "description": "Maximum throughput of the connector in Mbps. Default is 200, max is 1000.",
              "type": "integer",
              "format": "int64"
            },
            "minInstances": {
              "description": "Minimum value of instances in autoscaling group underlying the connector.",
              "type": "integer",
              "format": "int64"
            },
            "minThroughput": {
              "description": "Minimum throughput of the connector in Mbps. Default and min is 200.",
              "type": "integer",
              "format": "int64"
            },
            "networkRef": {
              "type": "object",
              "properties": {
                "external": {
                  "description": "Name of a VPC network.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "projectRef": {
              "description": "The Project that this resource belongs to.",
              "type": "object",
              "properties": {
                "external": {
                  "description": "The project for the resource",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                }
              }
            },
            "resourceID": {
              "description": "Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.",
              "type": "string"
            },
            "subnet": {
              "description": "The subnet in which to house the VPC Access Connector.",
              "type": "object",
              "properties": {
                "nameRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "Subnet name (relative, not fully qualified). E.g. if the full subnet selfLink is https://compute.googleapis.com/compute/v1/projects/{project}/regions/{region}/subnetworks/{subnetName} the correct input for this field would be: {subnetName}",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                },
                "projectRef": {
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "Project in which the subnet exists. If not set, this project is assumed to be the project for which the connector create request was issued.",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions represent the latest available observation of the resource's current state.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "type": "string"
                  },
                  "message": {
                    "description": "Human-readable message indicating details about last transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status is the status of the condition. Can be True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              }
            },
            "connectedProjects": {
              "description": "Output only. List of projects using the connector.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "observedGeneration": {
              "description": "ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.",
              "type": "integer"
            },
            "state": {
              "description": "Output only. State of the VPC access connector. Possible values: STATE_UNSPECIFIED, READY, CREATING, DELETING, ERROR, UPDATING",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "vpcaccess.cnrm.cloud.google.com",
          "kind": "VPCAccessConnector",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.cnrm.vpcaccess.v1beta1.VPCAccessConnectorList": {
      "description": "VPCAccessConnectorList is a list of VPCAccessConnector",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["vpcaccess.cnrm.cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of vpcaccessconnectors. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.cnrm.vpcaccess.v1beta1.VPCAccessConnector"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["VPCAccessConnectorList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "vpcaccess.cnrm.cloud.google.com",
          "kind": "VPCAccessConnectorList",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.v1.BackendConfig": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["cloud.google.com/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BackendConfig"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "BackendConfigSpec is the spec for a BackendConfig resource",
          "type": "object",
          "properties": {
            "cdn": {
              "description": "CDNConfig contains configuration for CDN-enabled backends.",
              "type": "object",
              "required": ["enabled"],
              "properties": {
                "cachePolicy": {
                  "description": "CacheKeyPolicy contains configuration for how requests to a CDN-enabled backend are cached.",
                  "type": "object",
                  "properties": {
                    "includeHost": {
                      "description": "If true, requests to different hosts will be cached separately.",
                      "type": "boolean"
                    },
                    "includeProtocol": {
                      "description": "If true, http and https requests will be cached separately.",
                      "type": "boolean"
                    },
                    "includeQueryString": {
                      "description": "If true, query string parameters are included in the cache key according to QueryStringBlacklist and QueryStringWhitelist. If neither is set, the entire query string is included and if false the entire query string is excluded.",
                      "type": "boolean"
                    },
                    "queryStringBlacklist": {
                      "description": "Names of query strint parameters to exclude from cache keys. All other parameters are included. Either specify QueryStringBlacklist or QueryStringWhitelist, but not both.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "queryStringWhitelist": {
                      "description": "Names of query string parameters to include in cache keys. All other parameters are excluded. Either specify QueryStringBlacklist or QueryStringWhitelist, but not both.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                },
                "enabled": {
                  "type": "boolean"
                }
              }
            },
            "connectionDraining": {
              "description": "ConnectionDrainingConfig contains configuration for connection draining. For now the draining timeout. May manage more settings in the future.",
              "type": "object",
              "properties": {
                "drainingTimeoutSec": {
                  "description": "Draining timeout in seconds.",
                  "type": "integer",
                  "format": "int64"
                }
              }
            },
            "customRequestHeaders": {
              "description": "CustomRequestHeadersConfig contains configuration for custom request headers",
              "type": "object",
              "properties": {
                "headers": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "healthCheck": {
              "description": "HealthCheckConfig contains configuration for the health check.",
              "type": "object",
              "properties": {
                "checkIntervalSec": {
                  "description": "CheckIntervalSec is a health check parameter. See https://cloud.google.com/compute/docs/reference/rest/v1/healthChecks.",
                  "type": "integer",
                  "format": "int64"
                },
                "healthyThreshold": {
                  "description": "HealthyThreshold is a health check parameter. See https://cloud.google.com/compute/docs/reference/rest/v1/healthChecks.",
                  "type": "integer",
                  "format": "int64"
                },
                "port": {
                  "description": "Port is a health check parameter. See https://cloud.google.com/compute/docs/reference/rest/v1/healthChecks. If Port is used, the controller updates portSpecification as well",
                  "type": "integer",
                  "format": "int64"
                },
                "requestPath": {
                  "description": "RequestPath is a health check parameter. See https://cloud.google.com/compute/docs/reference/rest/v1/healthChecks.",
                  "type": "string"
                },
                "timeoutSec": {
                  "description": "TimeoutSec is a health check parameter. See https://cloud.google.com/compute/docs/reference/rest/v1/healthChecks.",
                  "type": "integer",
                  "format": "int64"
                },
                "type": {
                  "description": "Type is a health check parameter. See https://cloud.google.com/compute/docs/reference/rest/v1/healthChecks.",
                  "type": "string"
                },
                "unhealthyThreshold": {
                  "description": "UnhealthyThreshold is a health check parameter. See https://cloud.google.com/compute/docs/reference/rest/v1/healthChecks.",
                  "type": "integer",
                  "format": "int64"
                }
              }
            },
            "iap": {
              "description": "IAPConfig contains configuration for IAP-enabled backends.",
              "type": "object",
              "required": ["enabled", "oauthclientCredentials"],
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "oauthclientCredentials": {
                  "description": "OAuthClientCredentials contains credentials for a single IAP-enabled backend.",
                  "type": "object",
                  "required": ["secretName"],
                  "properties": {
                    "clientID": {
                      "description": "Direct reference to OAuth client id.",
                      "type": "string"
                    },
                    "clientSecret": {
                      "description": "Direct reference to OAuth client secret.",
                      "type": "string"
                    },
                    "secretName": {
                      "description": "The name of a k8s secret which stores the OAuth client id & secret.",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "logging": {
              "description": "LogConfig contains configuration for logging.",
              "type": "object",
              "properties": {
                "enable": {
                  "description": "This field denotes whether to enable logging for the load balancer traffic served by this backend service.",
                  "type": "boolean"
                },
                "sampleRate": {
                  "description": "This field can only be specified if logging is enabled for this backend service. The value of the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported. The default value is 1.0.",
                  "type": "number",
                  "format": "double"
                }
              }
            },
            "securityPolicy": {
              "description": "SecurityPolicyConfig contains configuration for CloudArmor-enabled backends. If not specified, the controller will not reconcile the security policy configuration. In other words, users can make changes in GCE without the controller overwriting them.",
              "type": "object",
              "required": ["name"],
              "properties": {
                "name": {
                  "description": "Name of the security policy that should be associated. If set to empty, the existing security policy on the backend will be removed.",
                  "type": "string"
                }
              }
            },
            "sessionAffinity": {
              "description": "SessionAffinityConfig contains configuration for stickyness parameters.",
              "type": "object",
              "properties": {
                "affinityCookieTtlSec": {
                  "type": "integer",
                  "format": "int64"
                },
                "affinityType": {
                  "type": "string"
                }
              }
            },
            "timeoutSec": {
              "type": "integer",
              "format": "int64"
            }
          }
        },
        "status": {
          "type": "object"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "cloud.google.com",
          "kind": "BackendConfig",
          "version": "v1"
        }
      ]
    },
    "com.google.cloud.v1.BackendConfigList": {
      "description": "BackendConfigList is a list of BackendConfig",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["cloud.google.com/v1"]
        },
        "items": {
          "description": "List of backendconfigs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.v1.BackendConfig"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BackendConfigList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "cloud.google.com",
          "kind": "BackendConfigList",
          "version": "v1"
        }
      ]
    },
    "com.google.cloud.v1beta1.BackendConfig": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["cloud.google.com/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BackendConfig"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "BackendConfigSpec is the spec for a BackendConfig resource",
          "type": "object",
          "properties": {
            "cdn": {
              "description": "CDNConfig contains configuration for CDN-enabled backends.",
              "type": "object",
              "required": ["enabled"],
              "properties": {
                "cachePolicy": {
                  "description": "CacheKeyPolicy contains configuration for how requests to a CDN-enabled backend are cached.",
                  "type": "object",
                  "properties": {
                    "includeHost": {
                      "description": "If true, requests to different hosts will be cached separately.",
                      "type": "boolean"
                    },
                    "includeProtocol": {
                      "description": "If true, http and https requests will be cached separately.",
                      "type": "boolean"
                    },
                    "includeQueryString": {
                      "description": "If true, query string parameters are included in the cache key according to QueryStringBlacklist and QueryStringWhitelist. If neither is set, the entire query string is included and if false the entire query string is excluded.",
                      "type": "boolean"
                    },
                    "queryStringBlacklist": {
                      "description": "Names of query strint parameters to exclude from cache keys. All other parameters are included. Either specify QueryStringBlacklist or QueryStringWhitelist, but not both.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "queryStringWhitelist": {
                      "description": "Names of query string parameters to include in cache keys. All other parameters are excluded. Either specify QueryStringBlacklist or QueryStringWhitelist, but not both.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                },
                "enabled": {
                  "type": "boolean"
                }
              }
            },
            "connectionDraining": {
              "description": "ConnectionDrainingConfig contains configuration for connection draining. For now the draining timeout. May manage more settings in the future.",
              "type": "object",
              "properties": {
                "drainingTimeoutSec": {
                  "description": "Draining timeout in seconds.",
                  "type": "integer",
                  "format": "int64"
                }
              }
            },
            "customRequestHeaders": {
              "description": "CustomRequestHeadersConfig contains configuration for custom request headers",
              "type": "object",
              "properties": {
                "headers": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            "healthCheck": {
              "description": "HealthCheckConfig contains configuration for the health check.",
              "type": "object",
              "properties": {
                "checkIntervalSec": {
                  "description": "CheckIntervalSec is a health check parameter. See https://cloud.google.com/compute/docs/reference/rest/v1/healthChecks.",
                  "type": "integer",
                  "format": "int64"
                },
                "healthyThreshold": {
                  "description": "HealthyThreshold is a health check parameter. See https://cloud.google.com/compute/docs/reference/rest/v1/healthChecks.",
                  "type": "integer",
                  "format": "int64"
                },
                "port": {
                  "type": "integer",
                  "format": "int64"
                },
                "requestPath": {
                  "description": "RequestPath is a health check parameter. See https://cloud.google.com/compute/docs/reference/rest/v1/healthChecks.",
                  "type": "string"
                },
                "timeoutSec": {
                  "description": "TimeoutSec is a health check parameter. See https://cloud.google.com/compute/docs/reference/rest/v1/healthChecks.",
                  "type": "integer",
                  "format": "int64"
                },
                "type": {
                  "description": "Type is a health check parameter. See https://cloud.google.com/compute/docs/reference/rest/v1/healthChecks.",
                  "type": "string"
                },
                "unhealthyThreshold": {
                  "description": "UnhealthyThreshold is a health check parameter. See https://cloud.google.com/compute/docs/reference/rest/v1/healthChecks.",
                  "type": "integer",
                  "format": "int64"
                }
              }
            },
            "iap": {
              "description": "IAPConfig contains configuration for IAP-enabled backends.",
              "type": "object",
              "required": ["enabled", "oauthclientCredentials"],
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "oauthclientCredentials": {
                  "description": "OAuthClientCredentials contains credentials for a single IAP-enabled backend.",
                  "type": "object",
                  "required": ["secretName"],
                  "properties": {
                    "clientID": {
                      "description": "Direct reference to OAuth client id.",
                      "type": "string"
                    },
                    "clientSecret": {
                      "description": "Direct reference to OAuth client secret.",
                      "type": "string"
                    },
                    "secretName": {
                      "description": "The name of a k8s secret which stores the OAuth client id & secret.",
                      "type": "string"
                    }
                  }
                }
              }
            },
            "securityPolicy": {
              "description": "SecurityPolicyConfig contains configuration for CloudArmor-enabled backends. If not specified, the controller will not reconcile the security policy configuration. In other words, users can make changes in GCE without the controller overwriting them.",
              "type": "object",
              "required": ["name"],
              "properties": {
                "name": {
                  "description": "Name of the security policy that should be associated. If set to empty, the existing security policy on the backend will be removed.",
                  "type": "string"
                }
              }
            },
            "sessionAffinity": {
              "description": "SessionAffinityConfig contains configuration for stickyness parameters.",
              "type": "object",
              "properties": {
                "affinityCookieTtlSec": {
                  "type": "integer",
                  "format": "int64"
                },
                "affinityType": {
                  "type": "string"
                }
              }
            },
            "timeoutSec": {
              "type": "integer",
              "format": "int64"
            }
          }
        },
        "status": {
          "type": "object"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "cloud.google.com",
          "kind": "BackendConfig",
          "version": "v1beta1"
        }
      ]
    },
    "com.google.cloud.v1beta1.BackendConfigList": {
      "description": "BackendConfigList is a list of BackendConfig",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["cloud.google.com/v1beta1"]
        },
        "items": {
          "description": "List of backendconfigs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/com.google.cloud.v1beta1.BackendConfig"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["BackendConfigList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "cloud.google.com",
          "kind": "BackendConfigList",
          "version": "v1beta1"
        }
      ]
    },
    "io.gke.autoscaling.internal.v1alpha1.CapacityRequest": {
      "description": "CapacityRequest is a way to express additional capacity that we would like to reserve in the cluster. Cluster Autoscaler can use this information in its calculations and signal if the additional capacity is available in the cluster or proactively add capacity if needed.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["internal.autoscaling.gke.io/v1alpha1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CapacityRequest"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Specification of the CapacityRequest object. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status.",
          "type": "object",
          "required": ["capacity"],
          "properties": {
            "capacity": {
              "description": "Capacity specifies additional capacity to reserve in the cluster as a specification of the pod that should be scheduled in the cluster.",
              "type": "object",
              "required": ["containers"],
              "properties": {
                "activeDeadlineSeconds": {
                  "description": "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
                  "type": "integer",
                  "format": "int64"
                },
                "affinity": {
                  "description": "If specified, the pod's scheduling constraints",
                  "type": "object",
                  "properties": {
                    "nodeAffinity": {
                      "description": "Describes node affinity scheduling rules for the pod.",
                      "type": "object",
                      "properties": {
                        "preferredDuringSchedulingIgnoredDuringExecution": {
                          "description": "The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.",
                          "type": "array",
                          "items": {
                            "description": "An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).",
                            "type": "object",
                            "required": ["preference", "weight"],
                            "properties": {
                              "preference": {
                                "description": "A node selector term, associated with the corresponding weight.",
                                "type": "object",
                                "properties": {
                                  "matchExpressions": {
                                    "description": "A list of node selector requirements by node's labels.",
                                    "type": "array",
                                    "items": {
                                      "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                      "type": "object",
                                      "required": ["key", "operator"],
                                      "properties": {
                                        "key": {
                                          "description": "The label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                          "type": "string"
                                        },
                                        "values": {
                                          "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "matchFields": {
                                    "description": "A list of node selector requirements by node's fields.",
                                    "type": "array",
                                    "items": {
                                      "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                      "type": "object",
                                      "required": ["key", "operator"],
                                      "properties": {
                                        "key": {
                                          "description": "The label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                          "type": "string"
                                        },
                                        "values": {
                                          "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "weight": {
                                "description": "Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.",
                                "type": "integer",
                                "format": "int32"
                              }
                            }
                          }
                        },
                        "requiredDuringSchedulingIgnoredDuringExecution": {
                          "description": "If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.",
                          "type": "object",
                          "required": ["nodeSelectorTerms"],
                          "properties": {
                            "nodeSelectorTerms": {
                              "description": "Required. A list of node selector terms. The terms are ORed.",
                              "type": "array",
                              "items": {
                                "description": "A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.",
                                "type": "object",
                                "properties": {
                                  "matchExpressions": {
                                    "description": "A list of node selector requirements by node's labels.",
                                    "type": "array",
                                    "items": {
                                      "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                      "type": "object",
                                      "required": ["key", "operator"],
                                      "properties": {
                                        "key": {
                                          "description": "The label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                          "type": "string"
                                        },
                                        "values": {
                                          "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "matchFields": {
                                    "description": "A list of node selector requirements by node's fields.",
                                    "type": "array",
                                    "items": {
                                      "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                      "type": "object",
                                      "required": ["key", "operator"],
                                      "properties": {
                                        "key": {
                                          "description": "The label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                          "type": "string"
                                        },
                                        "values": {
                                          "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "podAffinity": {
                      "description": "Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).",
                      "type": "object",
                      "properties": {
                        "preferredDuringSchedulingIgnoredDuringExecution": {
                          "description": "The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.",
                          "type": "array",
                          "items": {
                            "description": "The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)",
                            "type": "object",
                            "required": ["podAffinityTerm", "weight"],
                            "properties": {
                              "podAffinityTerm": {
                                "description": "Required. A pod affinity term, associated with the corresponding weight.",
                                "type": "object",
                                "required": ["topologyKey"],
                                "properties": {
                                  "labelSelector": {
                                    "description": "A label query over a set of resources, in this case pods.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": ["key", "operator"],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string"
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      }
                                    }
                                  },
                                  "namespaces": {
                                    "description": "namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \"this pod's namespace\"",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  },
                                  "topologyKey": {
                                    "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.",
                                    "type": "string"
                                  }
                                }
                              },
                              "weight": {
                                "description": "weight associated with matching the corresponding podAffinityTerm, in the range 1-100.",
                                "type": "integer",
                                "format": "int32"
                              }
                            }
                          }
                        },
                        "requiredDuringSchedulingIgnoredDuringExecution": {
                          "description": "If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.",
                          "type": "array",
                          "items": {
                            "description": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running",
                            "type": "object",
                            "required": ["topologyKey"],
                            "properties": {
                              "labelSelector": {
                                "description": "A label query over a set of resources, in this case pods.",
                                "type": "object",
                                "properties": {
                                  "matchExpressions": {
                                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                    "type": "array",
                                    "items": {
                                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                      "type": "object",
                                      "required": ["key", "operator"],
                                      "properties": {
                                        "key": {
                                          "description": "key is the label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                          "type": "string"
                                        },
                                        "values": {
                                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "matchLabels": {
                                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                    "type": "object",
                                    "additionalProperties": {
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "namespaces": {
                                "description": "namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \"this pod's namespace\"",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "topologyKey": {
                                "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.",
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    },
                    "podAntiAffinity": {
                      "description": "Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).",
                      "type": "object",
                      "properties": {
                        "preferredDuringSchedulingIgnoredDuringExecution": {
                          "description": "The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.",
                          "type": "array",
                          "items": {
                            "description": "The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)",
                            "type": "object",
                            "required": ["podAffinityTerm", "weight"],
                            "properties": {
                              "podAffinityTerm": {
                                "description": "Required. A pod affinity term, associated with the corresponding weight.",
                                "type": "object",
                                "required": ["topologyKey"],
                                "properties": {
                                  "labelSelector": {
                                    "description": "A label query over a set of resources, in this case pods.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": ["key", "operator"],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string"
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      }
                                    }
                                  },
                                  "namespaces": {
                                    "description": "namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \"this pod's namespace\"",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  },
                                  "topologyKey": {
                                    "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.",
                                    "type": "string"
                                  }
                                }
                              },
                              "weight": {
                                "description": "weight associated with matching the corresponding podAffinityTerm, in the range 1-100.",
                                "type": "integer",
                                "format": "int32"
                              }
                            }
                          }
                        },
                        "requiredDuringSchedulingIgnoredDuringExecution": {
                          "description": "If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.",
                          "type": "array",
                          "items": {
                            "description": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running",
                            "type": "object",
                            "required": ["topologyKey"],
                            "properties": {
                              "labelSelector": {
                                "description": "A label query over a set of resources, in this case pods.",
                                "type": "object",
                                "properties": {
                                  "matchExpressions": {
                                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                    "type": "array",
                                    "items": {
                                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                      "type": "object",
                                      "required": ["key", "operator"],
                                      "properties": {
                                        "key": {
                                          "description": "key is the label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                          "type": "string"
                                        },
                                        "values": {
                                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "matchLabels": {
                                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                    "type": "object",
                                    "additionalProperties": {
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "namespaces": {
                                "description": "namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \"this pod's namespace\"",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "topologyKey": {
                                "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.",
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "automountServiceAccountToken": {
                  "description": "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
                  "type": "boolean"
                },
                "containers": {
                  "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
                  "type": "array",
                  "items": {
                    "description": "A single application container that you want to run within a pod.",
                    "type": "object",
                    "required": ["name"],
                    "properties": {
                      "args": {
                        "description": "Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "command": {
                        "description": "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "env": {
                        "description": "List of environment variables to set in the container. Cannot be updated.",
                        "type": "array",
                        "items": {
                          "description": "EnvVar represents an environment variable present in a Container.",
                          "type": "object",
                          "required": ["name"],
                          "properties": {
                            "name": {
                              "description": "Name of the environment variable. Must be a C_IDENTIFIER.",
                              "type": "string"
                            },
                            "value": {
                              "description": "Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to \"\".",
                              "type": "string"
                            },
                            "valueFrom": {
                              "description": "Source for the environment variable's value. Cannot be used if value is not empty.",
                              "type": "object",
                              "properties": {
                                "configMapKeyRef": {
                                  "description": "Selects a key of a ConfigMap.",
                                  "type": "object",
                                  "required": ["key"],
                                  "properties": {
                                    "key": {
                                      "description": "The key to select.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                      "type": "string"
                                    },
                                    "optional": {
                                      "description": "Specify whether the ConfigMap or it's key must be defined",
                                      "type": "boolean"
                                    }
                                  }
                                },
                                "fieldRef": {
                                  "description": "Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP.",
                                  "type": "object",
                                  "required": ["fieldPath"],
                                  "properties": {
                                    "apiVersion": {
                                      "description": "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".",
                                      "type": "string"
                                    },
                                    "fieldPath": {
                                      "description": "Path of the field to select in the specified API version.",
                                      "type": "string"
                                    }
                                  }
                                },
                                "resourceFieldRef": {
                                  "description": "Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.",
                                  "type": "object",
                                  "required": ["resource"],
                                  "properties": {
                                    "containerName": {
                                      "description": "Container name: required for volumes, optional for env vars",
                                      "type": "string"
                                    },
                                    "divisor": {
                                      "description": "Specifies the output format of the exposed resources, defaults to \"1\"",
                                      "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                                      "x-kubernetes-int-or-string": true
                                    },
                                    "resource": {
                                      "description": "Required: resource to select",
                                      "type": "string"
                                    }
                                  }
                                },
                                "secretKeyRef": {
                                  "description": "Selects a key of a secret in the pod's namespace",
                                  "type": "object",
                                  "required": ["key"],
                                  "properties": {
                                    "key": {
                                      "description": "The key of the secret to select from.  Must be a valid secret key.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                      "type": "string"
                                    },
                                    "optional": {
                                      "description": "Specify whether the Secret or it's key must be defined",
                                      "type": "boolean"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "envFrom": {
                        "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
                        "type": "array",
                        "items": {
                          "description": "EnvFromSource represents the source of a set of ConfigMaps",
                          "type": "object",
                          "properties": {
                            "configMapRef": {
                              "description": "The ConfigMap to select from",
                              "type": "object",
                              "properties": {
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                  "type": "string"
                                },
                                "optional": {
                                  "description": "Specify whether the ConfigMap must be defined",
                                  "type": "boolean"
                                }
                              }
                            },
                            "prefix": {
                              "description": "An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.",
                              "type": "string"
                            },
                            "secretRef": {
                              "description": "The Secret to select from",
                              "type": "object",
                              "properties": {
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                  "type": "string"
                                },
                                "optional": {
                                  "description": "Specify whether the Secret must be defined",
                                  "type": "boolean"
                                }
                              }
                            }
                          }
                        }
                      },
                      "image": {
                        "description": "Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
                        "type": "string"
                      },
                      "imagePullPolicy": {
                        "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
                        "type": "string"
                      },
                      "lifecycle": {
                        "description": "Actions that the management system should take in response to container lifecycle events. Cannot be updated.",
                        "type": "object",
                        "properties": {
                          "postStart": {
                            "description": "PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks",
                            "type": "object",
                            "properties": {
                              "exec": {
                                "description": "One and only one of the following should be specified. Exec specifies the action to take.",
                                "type": "object",
                                "properties": {
                                  "command": {
                                    "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "httpGet": {
                                "description": "HTTPGet specifies the http request to perform.",
                                "type": "object",
                                "required": ["port"],
                                "properties": {
                                  "host": {
                                    "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                    "type": "string"
                                  },
                                  "httpHeaders": {
                                    "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                    "type": "array",
                                    "items": {
                                      "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                      "type": "object",
                                      "required": ["name", "value"],
                                      "properties": {
                                        "name": {
                                          "description": "The header field name",
                                          "type": "string"
                                        },
                                        "value": {
                                          "description": "The header field value",
                                          "type": "string"
                                        }
                                      }
                                    }
                                  },
                                  "path": {
                                    "description": "Path to access on the HTTP server.",
                                    "type": "string"
                                  },
                                  "port": {
                                    "description": "Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                    "x-kubernetes-int-or-string": true
                                  },
                                  "scheme": {
                                    "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                    "type": "string"
                                  }
                                }
                              },
                              "tcpSocket": {
                                "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook",
                                "type": "object",
                                "required": ["port"],
                                "properties": {
                                  "host": {
                                    "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                    "type": "string"
                                  },
                                  "port": {
                                    "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                    "x-kubernetes-int-or-string": true
                                  }
                                }
                              }
                            }
                          },
                          "preStop": {
                            "description": "PreStop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks",
                            "type": "object",
                            "properties": {
                              "exec": {
                                "description": "One and only one of the following should be specified. Exec specifies the action to take.",
                                "type": "object",
                                "properties": {
                                  "command": {
                                    "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "httpGet": {
                                "description": "HTTPGet specifies the http request to perform.",
                                "type": "object",
                                "required": ["port"],
                                "properties": {
                                  "host": {
                                    "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                    "type": "string"
                                  },
                                  "httpHeaders": {
                                    "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                    "type": "array",
                                    "items": {
                                      "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                      "type": "object",
                                      "required": ["name", "value"],
                                      "properties": {
                                        "name": {
                                          "description": "The header field name",
                                          "type": "string"
                                        },
                                        "value": {
                                          "description": "The header field value",
                                          "type": "string"
                                        }
                                      }
                                    }
                                  },
                                  "path": {
                                    "description": "Path to access on the HTTP server.",
                                    "type": "string"
                                  },
                                  "port": {
                                    "description": "Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                    "x-kubernetes-int-or-string": true
                                  },
                                  "scheme": {
                                    "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                    "type": "string"
                                  }
                                }
                              },
                              "tcpSocket": {
                                "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook",
                                "type": "object",
                                "required": ["port"],
                                "properties": {
                                  "host": {
                                    "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                    "type": "string"
                                  },
                                  "port": {
                                    "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                    "x-kubernetes-int-or-string": true
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "livenessProbe": {
                        "description": "Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                        "type": "object",
                        "properties": {
                          "exec": {
                            "description": "One and only one of the following should be specified. Exec specifies the action to take.",
                            "type": "object",
                            "properties": {
                              "command": {
                                "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "failureThreshold": {
                            "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "httpGet": {
                            "description": "HTTPGet specifies the http request to perform.",
                            "type": "object",
                            "required": ["port"],
                            "properties": {
                              "host": {
                                "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                "type": "string"
                              },
                              "httpHeaders": {
                                "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                "type": "array",
                                "items": {
                                  "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                  "type": "object",
                                  "required": ["name", "value"],
                                  "properties": {
                                    "name": {
                                      "description": "The header field name",
                                      "type": "string"
                                    },
                                    "value": {
                                      "description": "The header field value",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "path": {
                                "description": "Path to access on the HTTP server.",
                                "type": "string"
                              },
                              "port": {
                                "description": "Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                "x-kubernetes-int-or-string": true
                              },
                              "scheme": {
                                "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                "type": "string"
                              }
                            }
                          },
                          "initialDelaySeconds": {
                            "description": "Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                            "type": "integer",
                            "format": "int32"
                          },
                          "periodSeconds": {
                            "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "successThreshold": {
                            "description": "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "tcpSocket": {
                            "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook",
                            "type": "object",
                            "required": ["port"],
                            "properties": {
                              "host": {
                                "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                "type": "string"
                              },
                              "port": {
                                "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                "x-kubernetes-int-or-string": true
                              }
                            }
                          },
                          "timeoutSeconds": {
                            "description": "Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                            "type": "integer",
                            "format": "int32"
                          }
                        }
                      },
                      "name": {
                        "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
                        "type": "string"
                      },
                      "ports": {
                        "description": "List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"0.0.0.0\" address inside a container will be accessible from the network. Cannot be updated.",
                        "type": "array",
                        "items": {
                          "description": "ContainerPort represents a network port in a single container.",
                          "type": "object",
                          "required": ["containerPort"],
                          "properties": {
                            "containerPort": {
                              "description": "Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.",
                              "type": "integer",
                              "format": "int32"
                            },
                            "hostIP": {
                              "description": "What host IP to bind the external port to.",
                              "type": "string"
                            },
                            "hostPort": {
                              "description": "Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.",
                              "type": "integer",
                              "format": "int32"
                            },
                            "name": {
                              "description": "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.",
                              "type": "string"
                            },
                            "protocol": {
                              "description": "Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \"TCP\".",
                              "type": "string"
                            }
                          }
                        },
                        "x-kubernetes-list-map-keys": [
                          "containerPort",
                          "protocol"
                        ],
                        "x-kubernetes-list-type": "map"
                      },
                      "readinessProbe": {
                        "description": "Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                        "type": "object",
                        "properties": {
                          "exec": {
                            "description": "One and only one of the following should be specified. Exec specifies the action to take.",
                            "type": "object",
                            "properties": {
                              "command": {
                                "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "failureThreshold": {
                            "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "httpGet": {
                            "description": "HTTPGet specifies the http request to perform.",
                            "type": "object",
                            "required": ["port"],
                            "properties": {
                              "host": {
                                "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                "type": "string"
                              },
                              "httpHeaders": {
                                "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                "type": "array",
                                "items": {
                                  "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                  "type": "object",
                                  "required": ["name", "value"],
                                  "properties": {
                                    "name": {
                                      "description": "The header field name",
                                      "type": "string"
                                    },
                                    "value": {
                                      "description": "The header field value",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "path": {
                                "description": "Path to access on the HTTP server.",
                                "type": "string"
                              },
                              "port": {
                                "description": "Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                "x-kubernetes-int-or-string": true
                              },
                              "scheme": {
                                "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                "type": "string"
                              }
                            }
                          },
                          "initialDelaySeconds": {
                            "description": "Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                            "type": "integer",
                            "format": "int32"
                          },
                          "periodSeconds": {
                            "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "successThreshold": {
                            "description": "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "tcpSocket": {
                            "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook",
                            "type": "object",
                            "required": ["port"],
                            "properties": {
                              "host": {
                                "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                "type": "string"
                              },
                              "port": {
                                "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                "x-kubernetes-int-or-string": true
                              }
                            }
                          },
                          "timeoutSeconds": {
                            "description": "Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                            "type": "integer",
                            "format": "int32"
                          }
                        }
                      },
                      "resources": {
                        "description": "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                        "type": "object",
                        "properties": {
                          "limits": {
                            "description": "Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                            "type": "object",
                            "additionalProperties": {
                              "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                              "x-kubernetes-int-or-string": true
                            }
                          },
                          "requests": {
                            "description": "Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                            "type": "object",
                            "additionalProperties": {
                              "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                              "x-kubernetes-int-or-string": true
                            }
                          }
                        }
                      },
                      "securityContext": {
                        "description": "Security options the pod should run with. More info: https://kubernetes.io/docs/concepts/policy/security-context/ More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
                        "type": "object",
                        "properties": {
                          "allowPrivilegeEscalation": {
                            "description": "AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN",
                            "type": "boolean"
                          },
                          "capabilities": {
                            "description": "The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.",
                            "type": "object",
                            "properties": {
                              "add": {
                                "description": "Added capabilities",
                                "type": "array",
                                "items": {
                                  "description": "Capability represent POSIX capabilities type",
                                  "type": "string"
                                }
                              },
                              "drop": {
                                "description": "Removed capabilities",
                                "type": "array",
                                "items": {
                                  "description": "Capability represent POSIX capabilities type",
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "privileged": {
                            "description": "Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.",
                            "type": "boolean"
                          },
                          "procMount": {
                            "description": "procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled.",
                            "type": "string"
                          },
                          "readOnlyRootFilesystem": {
                            "description": "Whether this container has a read-only root filesystem. Default is false.",
                            "type": "boolean"
                          },
                          "runAsGroup": {
                            "description": "The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "runAsNonRoot": {
                            "description": "Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                            "type": "boolean"
                          },
                          "runAsUser": {
                            "description": "The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "seLinuxOptions": {
                            "description": "The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                            "type": "object",
                            "properties": {
                              "level": {
                                "description": "Level is SELinux level label that applies to the container.",
                                "type": "string"
                              },
                              "role": {
                                "description": "Role is a SELinux role label that applies to the container.",
                                "type": "string"
                              },
                              "type": {
                                "description": "Type is a SELinux type label that applies to the container.",
                                "type": "string"
                              },
                              "user": {
                                "description": "User is a SELinux user label that applies to the container.",
                                "type": "string"
                              }
                            }
                          }
                        }
                      },
                      "stdin": {
                        "description": "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
                        "type": "boolean"
                      },
                      "stdinOnce": {
                        "description": "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
                        "type": "boolean"
                      },
                      "terminationMessagePath": {
                        "description": "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
                        "type": "string"
                      },
                      "terminationMessagePolicy": {
                        "description": "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
                        "type": "string"
                      },
                      "tty": {
                        "description": "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
                        "type": "boolean"
                      },
                      "volumeDevices": {
                        "description": "volumeDevices is the list of block devices to be used by the container. This is an alpha feature and may change in the future.",
                        "type": "array",
                        "items": {
                          "description": "volumeDevice describes a mapping of a raw block device within a container.",
                          "type": "object",
                          "required": ["devicePath", "name"],
                          "properties": {
                            "devicePath": {
                              "description": "devicePath is the path inside of the container that the device will be mapped to.",
                              "type": "string"
                            },
                            "name": {
                              "description": "name must match the name of a persistentVolumeClaim in the pod",
                              "type": "string"
                            }
                          }
                        }
                      },
                      "volumeMounts": {
                        "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
                        "type": "array",
                        "items": {
                          "description": "VolumeMount describes a mounting of a Volume within a container.",
                          "type": "object",
                          "required": ["mountPath", "name"],
                          "properties": {
                            "mountPath": {
                              "description": "Path within the container at which the volume should be mounted.  Must not contain ':'.",
                              "type": "string"
                            },
                            "mountPropagation": {
                              "description": "mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.",
                              "type": "string"
                            },
                            "name": {
                              "description": "This must match the Name of a Volume.",
                              "type": "string"
                            },
                            "readOnly": {
                              "description": "Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.",
                              "type": "boolean"
                            },
                            "subPath": {
                              "description": "Path within the volume from which the container's volume should be mounted. Defaults to \"\" (volume's root).",
                              "type": "string"
                            }
                          }
                        }
                      },
                      "workingDir": {
                        "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
                        "type": "string"
                      }
                    }
                  }
                },
                "dnsConfig": {
                  "description": "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
                  "type": "object",
                  "properties": {
                    "nameservers": {
                      "description": "A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "options": {
                      "description": "A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.",
                      "type": "array",
                      "items": {
                        "description": "PodDNSConfigOption defines DNS resolver options of a pod.",
                        "type": "object",
                        "properties": {
                          "name": {
                            "description": "Required.",
                            "type": "string"
                          },
                          "value": {
                            "type": "string"
                          }
                        }
                      }
                    },
                    "searches": {
                      "description": "A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                },
                "dnsPolicy": {
                  "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
                  "type": "string"
                },
                "enableServiceLinks": {
                  "description": "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links.",
                  "type": "boolean"
                },
                "hostAliases": {
                  "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.",
                  "type": "array",
                  "items": {
                    "description": "HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.",
                    "type": "object",
                    "properties": {
                      "hostnames": {
                        "description": "Hostnames for the above IP address.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "ip": {
                        "description": "IP address of the host file entry.",
                        "type": "string"
                      }
                    }
                  }
                },
                "hostIPC": {
                  "description": "Use the host's ipc namespace. Optional: Default to false.",
                  "type": "boolean"
                },
                "hostNetwork": {
                  "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
                  "type": "boolean"
                },
                "hostPID": {
                  "description": "Use the host's pid namespace. Optional: Default to false.",
                  "type": "boolean"
                },
                "hostname": {
                  "description": "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
                  "type": "string"
                },
                "imagePullSecrets": {
                  "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
                  "type": "array",
                  "items": {
                    "description": "LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.",
                    "type": "object",
                    "properties": {
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                        "type": "string"
                      }
                    }
                  }
                },
                "initContainers": {
                  "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
                  "type": "array",
                  "items": {
                    "description": "A single application container that you want to run within a pod.",
                    "type": "object",
                    "required": ["name"],
                    "properties": {
                      "args": {
                        "description": "Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "command": {
                        "description": "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "env": {
                        "description": "List of environment variables to set in the container. Cannot be updated.",
                        "type": "array",
                        "items": {
                          "description": "EnvVar represents an environment variable present in a Container.",
                          "type": "object",
                          "required": ["name"],
                          "properties": {
                            "name": {
                              "description": "Name of the environment variable. Must be a C_IDENTIFIER.",
                              "type": "string"
                            },
                            "value": {
                              "description": "Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to \"\".",
                              "type": "string"
                            },
                            "valueFrom": {
                              "description": "Source for the environment variable's value. Cannot be used if value is not empty.",
                              "type": "object",
                              "properties": {
                                "configMapKeyRef": {
                                  "description": "Selects a key of a ConfigMap.",
                                  "type": "object",
                                  "required": ["key"],
                                  "properties": {
                                    "key": {
                                      "description": "The key to select.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                      "type": "string"
                                    },
                                    "optional": {
                                      "description": "Specify whether the ConfigMap or it's key must be defined",
                                      "type": "boolean"
                                    }
                                  }
                                },
                                "fieldRef": {
                                  "description": "Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP.",
                                  "type": "object",
                                  "required": ["fieldPath"],
                                  "properties": {
                                    "apiVersion": {
                                      "description": "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".",
                                      "type": "string"
                                    },
                                    "fieldPath": {
                                      "description": "Path of the field to select in the specified API version.",
                                      "type": "string"
                                    }
                                  }
                                },
                                "resourceFieldRef": {
                                  "description": "Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.",
                                  "type": "object",
                                  "required": ["resource"],
                                  "properties": {
                                    "containerName": {
                                      "description": "Container name: required for volumes, optional for env vars",
                                      "type": "string"
                                    },
                                    "divisor": {
                                      "description": "Specifies the output format of the exposed resources, defaults to \"1\"",
                                      "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                                      "x-kubernetes-int-or-string": true
                                    },
                                    "resource": {
                                      "description": "Required: resource to select",
                                      "type": "string"
                                    }
                                  }
                                },
                                "secretKeyRef": {
                                  "description": "Selects a key of a secret in the pod's namespace",
                                  "type": "object",
                                  "required": ["key"],
                                  "properties": {
                                    "key": {
                                      "description": "The key of the secret to select from.  Must be a valid secret key.",
                                      "type": "string"
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                      "type": "string"
                                    },
                                    "optional": {
                                      "description": "Specify whether the Secret or it's key must be defined",
                                      "type": "boolean"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "envFrom": {
                        "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
                        "type": "array",
                        "items": {
                          "description": "EnvFromSource represents the source of a set of ConfigMaps",
                          "type": "object",
                          "properties": {
                            "configMapRef": {
                              "description": "The ConfigMap to select from",
                              "type": "object",
                              "properties": {
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                  "type": "string"
                                },
                                "optional": {
                                  "description": "Specify whether the ConfigMap must be defined",
                                  "type": "boolean"
                                }
                              }
                            },
                            "prefix": {
                              "description": "An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.",
                              "type": "string"
                            },
                            "secretRef": {
                              "description": "The Secret to select from",
                              "type": "object",
                              "properties": {
                                "name": {
                                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                  "type": "string"
                                },
                                "optional": {
                                  "description": "Specify whether the Secret must be defined",
                                  "type": "boolean"
                                }
                              }
                            }
                          }
                        }
                      },
                      "image": {
                        "description": "Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
                        "type": "string"
                      },
                      "imagePullPolicy": {
                        "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
                        "type": "string"
                      },
                      "lifecycle": {
                        "description": "Actions that the management system should take in response to container lifecycle events. Cannot be updated.",
                        "type": "object",
                        "properties": {
                          "postStart": {
                            "description": "PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks",
                            "type": "object",
                            "properties": {
                              "exec": {
                                "description": "One and only one of the following should be specified. Exec specifies the action to take.",
                                "type": "object",
                                "properties": {
                                  "command": {
                                    "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "httpGet": {
                                "description": "HTTPGet specifies the http request to perform.",
                                "type": "object",
                                "required": ["port"],
                                "properties": {
                                  "host": {
                                    "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                    "type": "string"
                                  },
                                  "httpHeaders": {
                                    "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                    "type": "array",
                                    "items": {
                                      "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                      "type": "object",
                                      "required": ["name", "value"],
                                      "properties": {
                                        "name": {
                                          "description": "The header field name",
                                          "type": "string"
                                        },
                                        "value": {
                                          "description": "The header field value",
                                          "type": "string"
                                        }
                                      }
                                    }
                                  },
                                  "path": {
                                    "description": "Path to access on the HTTP server.",
                                    "type": "string"
                                  },
                                  "port": {
                                    "description": "Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                    "x-kubernetes-int-or-string": true
                                  },
                                  "scheme": {
                                    "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                    "type": "string"
                                  }
                                }
                              },
                              "tcpSocket": {
                                "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook",
                                "type": "object",
                                "required": ["port"],
                                "properties": {
                                  "host": {
                                    "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                    "type": "string"
                                  },
                                  "port": {
                                    "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                    "x-kubernetes-int-or-string": true
                                  }
                                }
                              }
                            }
                          },
                          "preStop": {
                            "description": "PreStop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks",
                            "type": "object",
                            "properties": {
                              "exec": {
                                "description": "One and only one of the following should be specified. Exec specifies the action to take.",
                                "type": "object",
                                "properties": {
                                  "command": {
                                    "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "httpGet": {
                                "description": "HTTPGet specifies the http request to perform.",
                                "type": "object",
                                "required": ["port"],
                                "properties": {
                                  "host": {
                                    "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                    "type": "string"
                                  },
                                  "httpHeaders": {
                                    "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                    "type": "array",
                                    "items": {
                                      "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                      "type": "object",
                                      "required": ["name", "value"],
                                      "properties": {
                                        "name": {
                                          "description": "The header field name",
                                          "type": "string"
                                        },
                                        "value": {
                                          "description": "The header field value",
                                          "type": "string"
                                        }
                                      }
                                    }
                                  },
                                  "path": {
                                    "description": "Path to access on the HTTP server.",
                                    "type": "string"
                                  },
                                  "port": {
                                    "description": "Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                    "x-kubernetes-int-or-string": true
                                  },
                                  "scheme": {
                                    "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                    "type": "string"
                                  }
                                }
                              },
                              "tcpSocket": {
                                "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook",
                                "type": "object",
                                "required": ["port"],
                                "properties": {
                                  "host": {
                                    "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                    "type": "string"
                                  },
                                  "port": {
                                    "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                    "x-kubernetes-int-or-string": true
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "livenessProbe": {
                        "description": "Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                        "type": "object",
                        "properties": {
                          "exec": {
                            "description": "One and only one of the following should be specified. Exec specifies the action to take.",
                            "type": "object",
                            "properties": {
                              "command": {
                                "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "failureThreshold": {
                            "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "httpGet": {
                            "description": "HTTPGet specifies the http request to perform.",
                            "type": "object",
                            "required": ["port"],
                            "properties": {
                              "host": {
                                "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                "type": "string"
                              },
                              "httpHeaders": {
                                "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                "type": "array",
                                "items": {
                                  "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                  "type": "object",
                                  "required": ["name", "value"],
                                  "properties": {
                                    "name": {
                                      "description": "The header field name",
                                      "type": "string"
                                    },
                                    "value": {
                                      "description": "The header field value",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "path": {
                                "description": "Path to access on the HTTP server.",
                                "type": "string"
                              },
                              "port": {
                                "description": "Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                "x-kubernetes-int-or-string": true
                              },
                              "scheme": {
                                "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                "type": "string"
                              }
                            }
                          },
                          "initialDelaySeconds": {
                            "description": "Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                            "type": "integer",
                            "format": "int32"
                          },
                          "periodSeconds": {
                            "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "successThreshold": {
                            "description": "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "tcpSocket": {
                            "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook",
                            "type": "object",
                            "required": ["port"],
                            "properties": {
                              "host": {
                                "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                "type": "string"
                              },
                              "port": {
                                "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                "x-kubernetes-int-or-string": true
                              }
                            }
                          },
                          "timeoutSeconds": {
                            "description": "Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                            "type": "integer",
                            "format": "int32"
                          }
                        }
                      },
                      "name": {
                        "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
                        "type": "string"
                      },
                      "ports": {
                        "description": "List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"0.0.0.0\" address inside a container will be accessible from the network. Cannot be updated.",
                        "type": "array",
                        "items": {
                          "description": "ContainerPort represents a network port in a single container.",
                          "type": "object",
                          "required": ["containerPort"],
                          "properties": {
                            "containerPort": {
                              "description": "Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.",
                              "type": "integer",
                              "format": "int32"
                            },
                            "hostIP": {
                              "description": "What host IP to bind the external port to.",
                              "type": "string"
                            },
                            "hostPort": {
                              "description": "Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.",
                              "type": "integer",
                              "format": "int32"
                            },
                            "name": {
                              "description": "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.",
                              "type": "string"
                            },
                            "protocol": {
                              "description": "Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \"TCP\".",
                              "type": "string"
                            }
                          }
                        },
                        "x-kubernetes-list-map-keys": [
                          "containerPort",
                          "protocol"
                        ],
                        "x-kubernetes-list-type": "map"
                      },
                      "readinessProbe": {
                        "description": "Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                        "type": "object",
                        "properties": {
                          "exec": {
                            "description": "One and only one of the following should be specified. Exec specifies the action to take.",
                            "type": "object",
                            "properties": {
                              "command": {
                                "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "failureThreshold": {
                            "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "httpGet": {
                            "description": "HTTPGet specifies the http request to perform.",
                            "type": "object",
                            "required": ["port"],
                            "properties": {
                              "host": {
                                "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                "type": "string"
                              },
                              "httpHeaders": {
                                "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                "type": "array",
                                "items": {
                                  "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                  "type": "object",
                                  "required": ["name", "value"],
                                  "properties": {
                                    "name": {
                                      "description": "The header field name",
                                      "type": "string"
                                    },
                                    "value": {
                                      "description": "The header field value",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "path": {
                                "description": "Path to access on the HTTP server.",
                                "type": "string"
                              },
                              "port": {
                                "description": "Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                "x-kubernetes-int-or-string": true
                              },
                              "scheme": {
                                "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                "type": "string"
                              }
                            }
                          },
                          "initialDelaySeconds": {
                            "description": "Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                            "type": "integer",
                            "format": "int32"
                          },
                          "periodSeconds": {
                            "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "successThreshold": {
                            "description": "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "tcpSocket": {
                            "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook",
                            "type": "object",
                            "required": ["port"],
                            "properties": {
                              "host": {
                                "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                "type": "string"
                              },
                              "port": {
                                "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
                                "x-kubernetes-int-or-string": true
                              }
                            }
                          },
                          "timeoutSeconds": {
                            "description": "Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                            "type": "integer",
                            "format": "int32"
                          }
                        }
                      },
                      "resources": {
                        "description": "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                        "type": "object",
                        "properties": {
                          "limits": {
                            "description": "Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                            "type": "object",
                            "additionalProperties": {
                              "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                              "x-kubernetes-int-or-string": true
                            }
                          },
                          "requests": {
                            "description": "Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                            "type": "object",
                            "additionalProperties": {
                              "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                              "x-kubernetes-int-or-string": true
                            }
                          }
                        }
                      },
                      "securityContext": {
                        "description": "Security options the pod should run with. More info: https://kubernetes.io/docs/concepts/policy/security-context/ More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
                        "type": "object",
                        "properties": {
                          "allowPrivilegeEscalation": {
                            "description": "AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN",
                            "type": "boolean"
                          },
                          "capabilities": {
                            "description": "The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.",
                            "type": "object",
                            "properties": {
                              "add": {
                                "description": "Added capabilities",
                                "type": "array",
                                "items": {
                                  "description": "Capability represent POSIX capabilities type",
                                  "type": "string"
                                }
                              },
                              "drop": {
                                "description": "Removed capabilities",
                                "type": "array",
                                "items": {
                                  "description": "Capability represent POSIX capabilities type",
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "privileged": {
                            "description": "Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.",
                            "type": "boolean"
                          },
                          "procMount": {
                            "description": "procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled.",
                            "type": "string"
                          },
                          "readOnlyRootFilesystem": {
                            "description": "Whether this container has a read-only root filesystem. Default is false.",
                            "type": "boolean"
                          },
                          "runAsGroup": {
                            "description": "The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "runAsNonRoot": {
                            "description": "Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                            "type": "boolean"
                          },
                          "runAsUser": {
                            "description": "The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "seLinuxOptions": {
                            "description": "The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                            "type": "object",
                            "properties": {
                              "level": {
                                "description": "Level is SELinux level label that applies to the container.",
                                "type": "string"
                              },
                              "role": {
                                "description": "Role is a SELinux role label that applies to the container.",
                                "type": "string"
                              },
                              "type": {
                                "description": "Type is a SELinux type label that applies to the container.",
                                "type": "string"
                              },
                              "user": {
                                "description": "User is a SELinux user label that applies to the container.",
                                "type": "string"
                              }
                            }
                          }
                        }
                      },
                      "stdin": {
                        "description": "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
                        "type": "boolean"
                      },
                      "stdinOnce": {
                        "description": "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
                        "type": "boolean"
                      },
                      "terminationMessagePath": {
                        "description": "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
                        "type": "string"
                      },
                      "terminationMessagePolicy": {
                        "description": "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
                        "type": "string"
                      },
                      "tty": {
                        "description": "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
                        "type": "boolean"
                      },
                      "volumeDevices": {
                        "description": "volumeDevices is the list of block devices to be used by the container. This is an alpha feature and may change in the future.",
                        "type": "array",
                        "items": {
                          "description": "volumeDevice describes a mapping of a raw block device within a container.",
                          "type": "object",
                          "required": ["devicePath", "name"],
                          "properties": {
                            "devicePath": {
                              "description": "devicePath is the path inside of the container that the device will be mapped to.",
                              "type": "string"
                            },
                            "name": {
                              "description": "name must match the name of a persistentVolumeClaim in the pod",
                              "type": "string"
                            }
                          }
                        }
                      },
                      "volumeMounts": {
                        "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
                        "type": "array",
                        "items": {
                          "description": "VolumeMount describes a mounting of a Volume within a container.",
                          "type": "object",
                          "required": ["mountPath", "name"],
                          "properties": {
                            "mountPath": {
                              "description": "Path within the container at which the volume should be mounted.  Must not contain ':'.",
                              "type": "string"
                            },
                            "mountPropagation": {
                              "description": "mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.",
                              "type": "string"
                            },
                            "name": {
                              "description": "This must match the Name of a Volume.",
                              "type": "string"
                            },
                            "readOnly": {
                              "description": "Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.",
                              "type": "boolean"
                            },
                            "subPath": {
                              "description": "Path within the volume from which the container's volume should be mounted. Defaults to \"\" (volume's root).",
                              "type": "string"
                            }
                          }
                        }
                      },
                      "workingDir": {
                        "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
                        "type": "string"
                      }
                    }
                  }
                },
                "nodeName": {
                  "description": "NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.",
                  "type": "string"
                },
                "nodeSelector": {
                  "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "priority": {
                  "description": "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
                  "type": "integer",
                  "format": "int32"
                },
                "priorityClassName": {
                  "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
                  "type": "string"
                },
                "readinessGates": {
                  "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://github.com/kubernetes/community/blob/master/keps/sig-network/0007-pod-ready%2B%2B.md",
                  "type": "array",
                  "items": {
                    "description": "PodReadinessGate contains the reference to a pod condition",
                    "type": "object",
                    "required": ["conditionType"],
                    "properties": {
                      "conditionType": {
                        "description": "ConditionType refers to a condition in the pod's condition list with matching type.",
                        "type": "string"
                      }
                    }
                  }
                },
                "restartPolicy": {
                  "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
                  "type": "string"
                },
                "runtimeClassName": {
                  "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://github.com/kubernetes/community/blob/master/keps/sig-node/0014-runtime-class.md This is an alpha feature and may change in the future.",
                  "type": "string"
                },
                "schedulerName": {
                  "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
                  "type": "string"
                },
                "securityContext": {
                  "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
                  "type": "object",
                  "properties": {
                    "fsGroup": {
                      "description": "A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: \n 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- \n If unset, the Kubelet will not modify the ownership and permissions of any volume.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "runAsGroup": {
                      "description": "The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "runAsNonRoot": {
                      "description": "Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                      "type": "boolean"
                    },
                    "runAsUser": {
                      "description": "The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "seLinuxOptions": {
                      "description": "The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.",
                      "type": "object",
                      "properties": {
                        "level": {
                          "description": "Level is SELinux level label that applies to the container.",
                          "type": "string"
                        },
                        "role": {
                          "description": "Role is a SELinux role label that applies to the container.",
                          "type": "string"
                        },
                        "type": {
                          "description": "Type is a SELinux type label that applies to the container.",
                          "type": "string"
                        },
                        "user": {
                          "description": "User is a SELinux user label that applies to the container.",
                          "type": "string"
                        }
                      }
                    },
                    "supplementalGroups": {
                      "description": "A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.",
                      "type": "array",
                      "items": {
                        "type": "integer",
                        "format": "int64"
                      }
                    },
                    "sysctls": {
                      "description": "Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch.",
                      "type": "array",
                      "items": {
                        "description": "Sysctl defines a kernel parameter to be set",
                        "type": "object",
                        "required": ["name", "value"],
                        "properties": {
                          "name": {
                            "description": "Name of a property to set",
                            "type": "string"
                          },
                          "value": {
                            "description": "Value of a property to set",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                },
                "serviceAccount": {
                  "description": "DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
                  "type": "string"
                },
                "serviceAccountName": {
                  "description": "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
                  "type": "string"
                },
                "shareProcessNamespace": {
                  "description": "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false. This field is beta-level and may be disabled with the PodShareProcessNamespace feature.",
                  "type": "boolean"
                },
                "subdomain": {
                  "description": "If specified, the fully qualified Pod hostname will be \"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\". If not specified, the pod will not have a domainname at all.",
                  "type": "string"
                },
                "terminationGracePeriodSeconds": {
                  "description": "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
                  "type": "integer",
                  "format": "int64"
                },
                "tolerations": {
                  "description": "If specified, the pod's tolerations.",
                  "type": "array",
                  "items": {
                    "description": "The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.",
                    "type": "object",
                    "properties": {
                      "effect": {
                        "description": "Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.",
                        "type": "string"
                      },
                      "key": {
                        "description": "Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.",
                        "type": "string"
                      },
                      "operator": {
                        "description": "Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.",
                        "type": "string"
                      },
                      "tolerationSeconds": {
                        "description": "TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.",
                        "type": "integer",
                        "format": "int64"
                      },
                      "value": {
                        "description": "Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.",
                        "type": "string"
                      }
                    }
                  }
                },
                "volumes": {
                  "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
                  "type": "array",
                  "items": {
                    "description": "Volume represents a named volume in a pod that may be accessed by any container in the pod.",
                    "type": "object",
                    "required": ["name"],
                    "properties": {
                      "awsElasticBlockStore": {
                        "description": "AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore",
                        "type": "object",
                        "required": ["volumeID"],
                        "properties": {
                          "fsType": {
                            "description": "Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine",
                            "type": "string"
                          },
                          "partition": {
                            "description": "The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or you can leave the property empty).",
                            "type": "integer",
                            "format": "int32"
                          },
                          "readOnly": {
                            "description": "Specify \"true\" to force and set the ReadOnly property in VolumeMounts to \"true\". If omitted, the default is \"false\". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore",
                            "type": "boolean"
                          },
                          "volumeID": {
                            "description": "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore",
                            "type": "string"
                          }
                        }
                      },
                      "azureDisk": {
                        "description": "AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.",
                        "type": "object",
                        "required": ["diskName", "diskURI"],
                        "properties": {
                          "cachingMode": {
                            "description": "Host Caching mode: None, Read Only, Read Write.",
                            "type": "string"
                          },
                          "diskName": {
                            "description": "The Name of the data disk in the blob storage",
                            "type": "string"
                          },
                          "diskURI": {
                            "description": "The URI the data disk in the blob storage",
                            "type": "string"
                          },
                          "fsType": {
                            "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
                            "type": "string"
                          },
                          "kind": {
                            "description": "Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
                            "type": "boolean"
                          }
                        }
                      },
                      "azureFile": {
                        "description": "AzureFile represents an Azure File Service mount on the host and bind mount to the pod.",
                        "type": "object",
                        "required": ["secretName", "shareName"],
                        "properties": {
                          "readOnly": {
                            "description": "Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
                            "type": "boolean"
                          },
                          "secretName": {
                            "description": "the name of secret that contains Azure Storage Account Name and Key",
                            "type": "string"
                          },
                          "shareName": {
                            "description": "Share Name",
                            "type": "string"
                          }
                        }
                      },
                      "cephfs": {
                        "description": "CephFS represents a Ceph FS mount on the host that shares a pod's lifetime",
                        "type": "object",
                        "required": ["monitors"],
                        "properties": {
                          "monitors": {
                            "description": "Required: Monitors is a collection of Ceph monitors More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "path": {
                            "description": "Optional: Used as the mounted root, rather than the full Ceph tree, default is /",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it",
                            "type": "boolean"
                          },
                          "secretFile": {
                            "description": "Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it",
                            "type": "string"
                          },
                          "secretRef": {
                            "description": "Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it",
                            "type": "object",
                            "properties": {
                              "name": {
                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                "type": "string"
                              }
                            }
                          },
                          "user": {
                            "description": "Optional: User is the rados user name, default is admin More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it",
                            "type": "string"
                          }
                        }
                      },
                      "cinder": {
                        "description": "Cinder represents a cinder volume attached and mounted on kubelets host machine More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md",
                        "type": "object",
                        "required": ["volumeID"],
                        "properties": {
                          "fsType": {
                            "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md",
                            "type": "boolean"
                          },
                          "secretRef": {
                            "description": "Optional: points to a secret object containing parameters used to connect to OpenStack.",
                            "type": "object",
                            "properties": {
                              "name": {
                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                "type": "string"
                              }
                            }
                          },
                          "volumeID": {
                            "description": "volume id used to identify the volume in cinder More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md",
                            "type": "string"
                          }
                        }
                      },
                      "configMap": {
                        "description": "ConfigMap represents a configMap that should populate this volume",
                        "type": "object",
                        "properties": {
                          "defaultMode": {
                            "description": "Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "items": {
                            "description": "If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.",
                            "type": "array",
                            "items": {
                              "description": "Maps a string key to a path within a volume.",
                              "type": "object",
                              "required": ["key", "path"],
                              "properties": {
                                "key": {
                                  "description": "The key to project.",
                                  "type": "string"
                                },
                                "mode": {
                                  "description": "Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "path": {
                                  "description": "The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.",
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                            "type": "string"
                          },
                          "optional": {
                            "description": "Specify whether the ConfigMap or it's keys must be defined",
                            "type": "boolean"
                          }
                        }
                      },
                      "downwardAPI": {
                        "description": "DownwardAPI represents downward API about the pod that should populate this volume",
                        "type": "object",
                        "properties": {
                          "defaultMode": {
                            "description": "Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "items": {
                            "description": "Items is a list of downward API volume file",
                            "type": "array",
                            "items": {
                              "description": "DownwardAPIVolumeFile represents information to create the file containing the pod field",
                              "type": "object",
                              "required": ["path"],
                              "properties": {
                                "fieldRef": {
                                  "description": "Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.",
                                  "type": "object",
                                  "required": ["fieldPath"],
                                  "properties": {
                                    "apiVersion": {
                                      "description": "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".",
                                      "type": "string"
                                    },
                                    "fieldPath": {
                                      "description": "Path of the field to select in the specified API version.",
                                      "type": "string"
                                    }
                                  }
                                },
                                "mode": {
                                  "description": "Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "path": {
                                  "description": "Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'",
                                  "type": "string"
                                },
                                "resourceFieldRef": {
                                  "description": "Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.",
                                  "type": "object",
                                  "required": ["resource"],
                                  "properties": {
                                    "containerName": {
                                      "description": "Container name: required for volumes, optional for env vars",
                                      "type": "string"
                                    },
                                    "divisor": {
                                      "description": "Specifies the output format of the exposed resources, defaults to \"1\"",
                                      "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                                      "x-kubernetes-int-or-string": true
                                    },
                                    "resource": {
                                      "description": "Required: resource to select",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "emptyDir": {
                        "description": "EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir",
                        "type": "object",
                        "properties": {
                          "medium": {
                            "description": "What type of storage medium should back this directory. The default is \"\" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir",
                            "type": "string"
                          },
                          "sizeLimit": {
                            "description": "Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir",
                            "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                            "x-kubernetes-int-or-string": true
                          }
                        }
                      },
                      "fc": {
                        "description": "FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.",
                        "type": "object",
                        "properties": {
                          "fsType": {
                            "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine",
                            "type": "string"
                          },
                          "lun": {
                            "description": "Optional: FC target lun number",
                            "type": "integer",
                            "format": "int32"
                          },
                          "readOnly": {
                            "description": "Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
                            "type": "boolean"
                          },
                          "targetWWNs": {
                            "description": "Optional: FC target worldwide names (WWNs)",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "wwids": {
                            "description": "Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "flexVolume": {
                        "description": "FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.",
                        "type": "object",
                        "required": ["driver"],
                        "properties": {
                          "driver": {
                            "description": "Driver is the name of the driver to use for this volume.",
                            "type": "string"
                          },
                          "fsType": {
                            "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". The default filesystem depends on FlexVolume script.",
                            "type": "string"
                          },
                          "options": {
                            "description": "Optional: Extra command options if any.",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          },
                          "readOnly": {
                            "description": "Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
                            "type": "boolean"
                          },
                          "secretRef": {
                            "description": "Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.",
                            "type": "object",
                            "properties": {
                              "name": {
                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                "type": "string"
                              }
                            }
                          }
                        }
                      },
                      "flocker": {
                        "description": "Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running",
                        "type": "object",
                        "properties": {
                          "datasetName": {
                            "description": "Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated",
                            "type": "string"
                          },
                          "datasetUUID": {
                            "description": "UUID of the dataset. This is unique identifier of a Flocker dataset",
                            "type": "string"
                          }
                        }
                      },
                      "gcePersistentDisk": {
                        "description": "GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk",
                        "type": "object",
                        "required": ["pdName"],
                        "properties": {
                          "fsType": {
                            "description": "Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine",
                            "type": "string"
                          },
                          "partition": {
                            "description": "The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk",
                            "type": "integer",
                            "format": "int32"
                          },
                          "pdName": {
                            "description": "Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk",
                            "type": "boolean"
                          }
                        }
                      },
                      "gitRepo": {
                        "description": "GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.",
                        "type": "object",
                        "required": ["repository"],
                        "properties": {
                          "directory": {
                            "description": "Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.",
                            "type": "string"
                          },
                          "repository": {
                            "description": "Repository URL",
                            "type": "string"
                          },
                          "revision": {
                            "description": "Commit hash for the specified revision.",
                            "type": "string"
                          }
                        }
                      },
                      "glusterfs": {
                        "description": "Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md",
                        "type": "object",
                        "required": ["endpoints", "path"],
                        "properties": {
                          "endpoints": {
                            "description": "EndpointsName is the endpoint name that details Glusterfs topology. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod",
                            "type": "string"
                          },
                          "path": {
                            "description": "Path is the Glusterfs volume path. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod",
                            "type": "boolean"
                          }
                        }
                      },
                      "hostPath": {
                        "description": "HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.",
                        "type": "object",
                        "required": ["path"],
                        "properties": {
                          "path": {
                            "description": "Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath",
                            "type": "string"
                          },
                          "type": {
                            "description": "Type for HostPath Volume Defaults to \"\" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath",
                            "type": "string"
                          }
                        }
                      },
                      "iscsi": {
                        "description": "ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://releases.k8s.io/HEAD/examples/volumes/iscsi/README.md",
                        "type": "object",
                        "required": ["iqn", "lun", "targetPortal"],
                        "properties": {
                          "chapAuthDiscovery": {
                            "description": "whether support iSCSI Discovery CHAP authentication",
                            "type": "boolean"
                          },
                          "chapAuthSession": {
                            "description": "whether support iSCSI Session CHAP authentication",
                            "type": "boolean"
                          },
                          "fsType": {
                            "description": "Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine",
                            "type": "string"
                          },
                          "initiatorName": {
                            "description": "Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.",
                            "type": "string"
                          },
                          "iqn": {
                            "description": "Target iSCSI Qualified Name.",
                            "type": "string"
                          },
                          "iscsiInterface": {
                            "description": "iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).",
                            "type": "string"
                          },
                          "lun": {
                            "description": "iSCSI Target Lun number.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "portals": {
                            "description": "iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "readOnly": {
                            "description": "ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.",
                            "type": "boolean"
                          },
                          "secretRef": {
                            "description": "CHAP Secret for iSCSI target and initiator authentication",
                            "type": "object",
                            "properties": {
                              "name": {
                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                "type": "string"
                              }
                            }
                          },
                          "targetPortal": {
                            "description": "iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).",
                            "type": "string"
                          }
                        }
                      },
                      "name": {
                        "description": "Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "nfs": {
                        "description": "NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs",
                        "type": "object",
                        "required": ["path", "server"],
                        "properties": {
                          "path": {
                            "description": "Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs",
                            "type": "boolean"
                          },
                          "server": {
                            "description": "Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs",
                            "type": "string"
                          }
                        }
                      },
                      "persistentVolumeClaim": {
                        "description": "PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims",
                        "type": "object",
                        "required": ["claimName"],
                        "properties": {
                          "claimName": {
                            "description": "ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "Will force the ReadOnly setting in VolumeMounts. Default false.",
                            "type": "boolean"
                          }
                        }
                      },
                      "photonPersistentDisk": {
                        "description": "PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine",
                        "type": "object",
                        "required": ["pdID"],
                        "properties": {
                          "fsType": {
                            "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
                            "type": "string"
                          },
                          "pdID": {
                            "description": "ID that identifies Photon Controller persistent disk",
                            "type": "string"
                          }
                        }
                      },
                      "portworxVolume": {
                        "description": "PortworxVolume represents a portworx volume attached and mounted on kubelets host machine",
                        "type": "object",
                        "required": ["volumeID"],
                        "properties": {
                          "fsType": {
                            "description": "FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\". Implicitly inferred to be \"ext4\" if unspecified.",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
                            "type": "boolean"
                          },
                          "volumeID": {
                            "description": "VolumeID uniquely identifies a Portworx volume",
                            "type": "string"
                          }
                        }
                      },
                      "projected": {
                        "description": "Items for all in one resources secrets, configmaps, and downward API",
                        "type": "object",
                        "required": ["sources"],
                        "properties": {
                          "defaultMode": {
                            "description": "Mode bits to use on created files by default. Must be a value between 0 and 0777. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "sources": {
                            "description": "list of volume projections",
                            "type": "array",
                            "items": {
                              "description": "Projection that may be projected along with other supported volume types",
                              "type": "object",
                              "properties": {
                                "configMap": {
                                  "description": "information about the configMap data to project",
                                  "type": "object",
                                  "properties": {
                                    "items": {
                                      "description": "If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.",
                                      "type": "array",
                                      "items": {
                                        "description": "Maps a string key to a path within a volume.",
                                        "type": "object",
                                        "required": ["key", "path"],
                                        "properties": {
                                          "key": {
                                            "description": "The key to project.",
                                            "type": "string"
                                          },
                                          "mode": {
                                            "description": "Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "path": {
                                            "description": "The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                      "type": "string"
                                    },
                                    "optional": {
                                      "description": "Specify whether the ConfigMap or it's keys must be defined",
                                      "type": "boolean"
                                    }
                                  }
                                },
                                "downwardAPI": {
                                  "description": "information about the downwardAPI data to project",
                                  "type": "object",
                                  "properties": {
                                    "items": {
                                      "description": "Items is a list of DownwardAPIVolume file",
                                      "type": "array",
                                      "items": {
                                        "description": "DownwardAPIVolumeFile represents information to create the file containing the pod field",
                                        "type": "object",
                                        "required": ["path"],
                                        "properties": {
                                          "fieldRef": {
                                            "description": "Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.",
                                            "type": "object",
                                            "required": ["fieldPath"],
                                            "properties": {
                                              "apiVersion": {
                                                "description": "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".",
                                                "type": "string"
                                              },
                                              "fieldPath": {
                                                "description": "Path of the field to select in the specified API version.",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "mode": {
                                            "description": "Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "path": {
                                            "description": "Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'",
                                            "type": "string"
                                          },
                                          "resourceFieldRef": {
                                            "description": "Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.",
                                            "type": "object",
                                            "required": ["resource"],
                                            "properties": {
                                              "containerName": {
                                                "description": "Container name: required for volumes, optional for env vars",
                                                "type": "string"
                                              },
                                              "divisor": {
                                                "description": "Specifies the output format of the exposed resources, defaults to \"1\"",
                                                "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                                                "x-kubernetes-int-or-string": true
                                              },
                                              "resource": {
                                                "description": "Required: resource to select",
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "secret": {
                                  "description": "information about the secret data to project",
                                  "type": "object",
                                  "properties": {
                                    "items": {
                                      "description": "If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.",
                                      "type": "array",
                                      "items": {
                                        "description": "Maps a string key to a path within a volume.",
                                        "type": "object",
                                        "required": ["key", "path"],
                                        "properties": {
                                          "key": {
                                            "description": "The key to project.",
                                            "type": "string"
                                          },
                                          "mode": {
                                            "description": "Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "path": {
                                            "description": "The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    },
                                    "name": {
                                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                      "type": "string"
                                    },
                                    "optional": {
                                      "description": "Specify whether the Secret or its key must be defined",
                                      "type": "boolean"
                                    }
                                  }
                                },
                                "serviceAccountToken": {
                                  "description": "information about the serviceAccountToken data to project",
                                  "type": "object",
                                  "required": ["path"],
                                  "properties": {
                                    "audience": {
                                      "description": "Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.",
                                      "type": "string"
                                    },
                                    "expirationSeconds": {
                                      "description": "ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.",
                                      "type": "integer",
                                      "format": "int64"
                                    },
                                    "path": {
                                      "description": "Path is the path relative to the mount point of the file to project the token into.",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "quobyte": {
                        "description": "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime",
                        "type": "object",
                        "required": ["registry", "volume"],
                        "properties": {
                          "group": {
                            "description": "Group to map volume access to Default is no group",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.",
                            "type": "boolean"
                          },
                          "registry": {
                            "description": "Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes",
                            "type": "string"
                          },
                          "user": {
                            "description": "User to map volume access to Defaults to serivceaccount user",
                            "type": "string"
                          },
                          "volume": {
                            "description": "Volume is a string that references an already created Quobyte volume by name.",
                            "type": "string"
                          }
                        }
                      },
                      "rbd": {
                        "description": "RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md",
                        "type": "object",
                        "required": ["image", "monitors"],
                        "properties": {
                          "fsType": {
                            "description": "Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine",
                            "type": "string"
                          },
                          "image": {
                            "description": "The rados image name. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it",
                            "type": "string"
                          },
                          "keyring": {
                            "description": "Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it",
                            "type": "string"
                          },
                          "monitors": {
                            "description": "A collection of Ceph monitors. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "pool": {
                            "description": "The rados pool name. Default is rbd. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it",
                            "type": "boolean"
                          },
                          "secretRef": {
                            "description": "SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it",
                            "type": "object",
                            "properties": {
                              "name": {
                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                "type": "string"
                              }
                            }
                          },
                          "user": {
                            "description": "The rados user name. Default is admin. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it",
                            "type": "string"
                          }
                        }
                      },
                      "scaleIO": {
                        "description": "ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.",
                        "type": "object",
                        "required": ["gateway", "secretRef", "system"],
                        "properties": {
                          "fsType": {
                            "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Default is \"xfs\".",
                            "type": "string"
                          },
                          "gateway": {
                            "description": "The host address of the ScaleIO API Gateway.",
                            "type": "string"
                          },
                          "protectionDomain": {
                            "description": "The name of the ScaleIO Protection Domain for the configured storage.",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
                            "type": "boolean"
                          },
                          "secretRef": {
                            "description": "SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.",
                            "type": "object",
                            "properties": {
                              "name": {
                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                "type": "string"
                              }
                            }
                          },
                          "sslEnabled": {
                            "description": "Flag to enable/disable SSL communication with Gateway, default false",
                            "type": "boolean"
                          },
                          "storageMode": {
                            "description": "Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.",
                            "type": "string"
                          },
                          "storagePool": {
                            "description": "The ScaleIO Storage Pool associated with the protection domain.",
                            "type": "string"
                          },
                          "system": {
                            "description": "The name of the storage system as configured in ScaleIO.",
                            "type": "string"
                          },
                          "volumeName": {
                            "description": "The name of a volume already created in the ScaleIO system that is associated with this volume source.",
                            "type": "string"
                          }
                        }
                      },
                      "secret": {
                        "description": "Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret",
                        "type": "object",
                        "properties": {
                          "defaultMode": {
                            "description": "Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "items": {
                            "description": "If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.",
                            "type": "array",
                            "items": {
                              "description": "Maps a string key to a path within a volume.",
                              "type": "object",
                              "required": ["key", "path"],
                              "properties": {
                                "key": {
                                  "description": "The key to project.",
                                  "type": "string"
                                },
                                "mode": {
                                  "description": "Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "path": {
                                  "description": "The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.",
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "optional": {
                            "description": "Specify whether the Secret or it's keys must be defined",
                            "type": "boolean"
                          },
                          "secretName": {
                            "description": "Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret",
                            "type": "string"
                          }
                        }
                      },
                      "storageos": {
                        "description": "StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.",
                        "type": "object",
                        "properties": {
                          "fsType": {
                            "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
                            "type": "boolean"
                          },
                          "secretRef": {
                            "description": "SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.",
                            "type": "object",
                            "properties": {
                              "name": {
                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                                "type": "string"
                              }
                            }
                          },
                          "volumeName": {
                            "description": "VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.",
                            "type": "string"
                          },
                          "volumeNamespace": {
                            "description": "VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to \"default\" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.",
                            "type": "string"
                          }
                        }
                      },
                      "vsphereVolume": {
                        "description": "VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine",
                        "type": "object",
                        "required": ["volumePath"],
                        "properties": {
                          "fsType": {
                            "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
                            "type": "string"
                          },
                          "storagePolicyID": {
                            "description": "Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.",
                            "type": "string"
                          },
                          "storagePolicyName": {
                            "description": "Storage Policy Based Management (SPBM) profile name.",
                            "type": "string"
                          },
                          "volumePath": {
                            "description": "Path that identifies vSphere volume vmdk",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "provisionPolicy": {
              "description": "ProvisionPolicy describes how to provision the additional capacity.",
              "type": "object",
              "required": ["podsToReplace"],
              "properties": {
                "podsToReplace": {
                  "description": "PodsToReplace is a list of pods that can be excluded from simulation when reserving additional capacity. The semantics is that the pod for which this capacity request reserves capacity will replace the pods in this list.",
                  "type": "array",
                  "items": {
                    "description": "LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.",
                    "type": "object",
                    "properties": {
                      "name": {
                        "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "provisionedCapacitySelector": {
              "description": "ProvisionedCapacitySelector identifies pods that this Capacity Request is related to by. This signifies that creation of a pod matching ProvisionedCapacitySelector may mean that this Capacity Request is no longer needed. Note that this field is ignored by Cluster Autoscaler and it is the responsibility of the client to delete the Capacity Request when it becomes obsolete. If the client consumes the capacity without deleting the request, the Cluster Autoscaler will attempt to fulfill the request again.",
              "type": "object",
              "properties": {
                "matchExpressions": {
                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                  "type": "array",
                  "items": {
                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                    "type": "object",
                    "required": ["key", "operator"],
                    "properties": {
                      "key": {
                        "description": "key is the label key that the selector applies to.",
                        "type": "string"
                      },
                      "operator": {
                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                        "type": "string"
                      },
                      "values": {
                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "matchLabels": {
                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "status": {
          "description": "Current status of the CapacityRequest.",
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Conditions is a set of conditions indicating the state in which the CapacityRequest is currently in.",
              "type": "array",
              "items": {
                "description": "CapacityRequestCondition indicates the state in which the CapacityRequest is currently in.",
                "type": "object",
                "required": ["status", "type"],
                "properties": {
                  "lastTransitionTime": {
                    "description": "LastTransitionTime is the last time the condition transitioned from one status to another.",
                    "type": "string",
                    "format": "date-time"
                  },
                  "message": {
                    "description": "Message is a human-readable explanation containing details about the transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "Reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status of the condition (True, False, Unknown).",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type describes the current condition.",
                    "type": "string"
                  }
                }
              }
            },
            "lastUpdateTime": {
              "description": "LastUpdateTime is the time when the status was last refreshed.",
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "internal.autoscaling.gke.io",
          "kind": "CapacityRequest",
          "version": "v1alpha1"
        }
      ]
    },
    "io.gke.autoscaling.internal.v1alpha1.CapacityRequestList": {
      "description": "CapacityRequestList is a list of CapacityRequest",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["internal.autoscaling.gke.io/v1alpha1"]
        },
        "items": {
          "description": "List of capacityrequests. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.gke.autoscaling.internal.v1alpha1.CapacityRequest"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CapacityRequestList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "internal.autoscaling.gke.io",
          "kind": "CapacityRequestList",
          "version": "v1alpha1"
        }
      ]
    },
    "io.gke.networking.v1.ManagedCertificate": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.gke.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ManagedCertificate"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "domains": {
              "type": "array",
              "maxItems": 100,
              "items": {
                "type": "string",
                "maxLength": 63,
                "pattern": "^(([a-z0-9]+|[a-z0-9][-a-z0-9]*[a-z0-9])\\.)+[a-z][-a-z0-9]*[a-z0-9]$"
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "certificateName": {
              "type": "string"
            },
            "certificateStatus": {
              "type": "string"
            },
            "domainStatus": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["domain", "status"],
                "properties": {
                  "domain": {
                    "type": "string"
                  },
                  "status": {
                    "type": "string"
                  }
                }
              }
            },
            "expireTime": {
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.gke.io",
          "kind": "ManagedCertificate",
          "version": "v1"
        }
      ]
    },
    "io.gke.networking.v1.ManagedCertificateList": {
      "description": "ManagedCertificateList is a list of ManagedCertificate",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.gke.io/v1"]
        },
        "items": {
          "description": "List of managedcertificates. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.gke.networking.v1.ManagedCertificate"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ManagedCertificateList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.gke.io",
          "kind": "ManagedCertificateList",
          "version": "v1"
        }
      ]
    },
    "io.gke.networking.v1beta1.FrontendConfig": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.gke.io/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["FrontendConfig"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "FrontendConfigSpec is the spec for a FrontendConfig resource",
          "type": "object",
          "properties": {
            "redirectToHttps": {
              "description": "HttpsRedirectConfig representing the configuration of Https redirects",
              "type": "object",
              "required": ["enabled"],
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "responseCodeName": {
                  "description": "String representing the HTTP response code Options are MOVED_PERMANENTLY_DEFAULT, FOUND, TEMPORARY_REDIRECT, or PERMANENT_REDIRECT",
                  "type": "string"
                }
              }
            },
            "sslPolicy": {
              "type": "string"
            }
          }
        },
        "status": {
          "type": "object"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.gke.io",
          "kind": "FrontendConfig",
          "version": "v1beta1"
        }
      ]
    },
    "io.gke.networking.v1beta1.FrontendConfigList": {
      "description": "FrontendConfigList is a list of FrontendConfig",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.gke.io/v1beta1"]
        },
        "items": {
          "description": "List of frontendconfigs. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.gke.networking.v1beta1.FrontendConfig"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["FrontendConfigList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.gke.io",
          "kind": "FrontendConfigList",
          "version": "v1beta1"
        }
      ]
    },
    "io.gke.networking.v1beta1.ManagedCertificate": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.gke.io/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ManagedCertificate"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "domains": {
              "type": "array",
              "maxItems": 1,
              "items": {
                "type": "string",
                "maxLength": 63,
                "pattern": "^(([a-z0-9]+|[a-z0-9][-a-z0-9]*[a-z0-9])\\.)+[a-z][-a-z0-9]*[a-z0-9]$"
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "certificateName": {
              "type": "string"
            },
            "certificateStatus": {
              "type": "string"
            },
            "domainStatus": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["domain", "status"],
                "properties": {
                  "domain": {
                    "type": "string"
                  },
                  "status": {
                    "type": "string"
                  }
                }
              }
            },
            "expireTime": {
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.gke.io",
          "kind": "ManagedCertificate",
          "version": "v1beta1"
        }
      ]
    },
    "io.gke.networking.v1beta1.ManagedCertificateList": {
      "description": "ManagedCertificateList is a list of ManagedCertificate",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.gke.io/v1beta1"]
        },
        "items": {
          "description": "List of managedcertificates. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.gke.networking.v1beta1.ManagedCertificate"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ManagedCertificateList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.gke.io",
          "kind": "ManagedCertificateList",
          "version": "v1beta1"
        }
      ]
    },
    "io.gke.networking.v1beta1.ServiceAttachment": {
      "description": "ServiceAttachment represents a Service Attachment associated with a service/ingress/gateway class",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.gke.io/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ServiceAttachment"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "ServiceAttachmentSpec is the spec for a ServiceAttachment resource",
          "type": "object",
          "properties": {
            "connectionPreference": {
              "description": "ConnectionPreference determines how consumers are accepted.",
              "type": "string"
            },
            "consumerAllowList": {
              "description": "ConsumerAllowList is list of consumer projects that should be allow listed for this ServiceAttachment",
              "type": "array",
              "items": {
                "description": "ConsumerProject is the consumer project and project level configuration",
                "type": "object",
                "properties": {
                  "connectionLimit": {
                    "description": "ConnectionLimit is the connection limit for this Consumer project",
                    "type": "integer",
                    "format": "int64"
                  },
                  "forceSendFields": {
                    "description": "ForceSendFields is a list of field names (e.g. \"ConnectionLimit\") to unconditionally include in API requests. By default, fields with empty values are omitted from API requests. However, any non-pointer, non-interface field appearing in ForceSendFields will be sent to the server regardless of whether the field is empty or not. This may be used to include empty fields in Patch requests.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "x-kubernetes-list-type": "atomic"
                  },
                  "nullFields": {
                    "description": "NullFields is a list of field names (e.g. \"ConnectionLimit\") to include in API requests with the JSON null value. By default, fields with empty values are omitted from API requests. However, any field with an empty value appearing in NullFields will be sent to the server as null. It is an error if a field in this list has a non-empty value. This may be used to include null fields in Patch requests.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "x-kubernetes-list-type": "atomic"
                  },
                  "project": {
                    "description": "Project is the project id or number for the project to set the limit for.",
                    "type": "string"
                  }
                }
              },
              "x-kubernetes-list-type": "atomic"
            },
            "consumerRejectList": {
              "description": "ConsumerRejectList is the list of Consumer Project IDs or Numbers that should be rejected for this ServiceAttachment",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "atomic"
            },
            "natSubnets": {
              "description": "NATSubnets contains the list of subnet names for PSC",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "atomic"
            },
            "proxyProtocol": {
              "description": "ProxyProtocol when set will expose client information TCP/IP information",
              "type": "boolean"
            },
            "resourceRef": {
              "description": "ResourceRef is the reference to the K8s resource that created the forwarding rule Only Services can be used as a reference",
              "type": "object",
              "required": ["kind", "name"],
              "properties": {
                "apiGroup": {
                  "description": "APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.",
                  "type": "string"
                },
                "kind": {
                  "description": "Kind is the type of resource being referenced",
                  "type": "string"
                },
                "name": {
                  "description": "Name is the name of resource being referenced",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "description": "ServiceAttachmentStatus is the status for a ServiceAttachment resource",
          "type": "object",
          "properties": {
            "consumerForwardingRules": {
              "description": "Consumer Forwarding Rules using ts Service Attachment",
              "type": "array",
              "items": {
                "description": "ConsumerForwardingRule is a reference to the PSC consumer forwarding rule",
                "type": "object",
                "properties": {
                  "forwardingRuleURL": {
                    "description": "Forwarding rule consumer created to use ServiceAttachment",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status of consumer forwarding rule",
                    "type": "string"
                  }
                }
              },
              "x-kubernetes-list-type": "atomic"
            },
            "forwardingRuleURL": {
              "description": "ForwardingRuleURL is the URL to the GCE Forwarding Rule resource the Service Attachment points to",
              "type": "string"
            },
            "lastModifiedTimestamp": {
              "description": "LastModifiedTimestamp tracks last time Status was updated",
              "format": "date-time"
            },
            "serviceAttachmentURL": {
              "description": "ServiceAttachmentURL is the URL for the GCE Service Attachment resource",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.gke.io",
          "kind": "ServiceAttachment",
          "version": "v1beta1"
        }
      ]
    },
    "io.gke.networking.v1beta1.ServiceAttachmentList": {
      "description": "ServiceAttachmentList is a list of ServiceAttachment",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.gke.io/v1beta1"]
        },
        "items": {
          "description": "List of serviceattachments. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.gke.networking.v1beta1.ServiceAttachment"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ServiceAttachmentList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.gke.io",
          "kind": "ServiceAttachmentList",
          "version": "v1beta1"
        }
      ]
    },
    "io.gke.networking.v1beta1.ServiceNetworkEndpointGroup": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.gke.io/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ServiceNetworkEndpointGroup"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object"
        },
        "status": {
          "description": "ServiceNetworkEndpointGroupStatus is the status for a ServiceNetworkEndpointGroup resource",
          "type": "object",
          "properties": {
            "conditions": {
              "description": "Last time the NEG syncer syncs associated NEGs.",
              "type": "array",
              "items": {
                "description": "NegCondition contains details for the current condition of this NEG.",
                "type": "object",
                "required": ["type", "status", "reason", "message"],
                "properties": {
                  "lastTransitionTime": {
                    "description": "Last time the condition transitioned from one status to another.",
                    "format": "date-time"
                  },
                  "message": {
                    "description": "A human readable message indicating details about the transition. This field may be empty.",
                    "type": "string"
                  },
                  "observedGeneration": {
                    "description": "ObservedGeneration will not be set for ServiceNetworkEndpointGroup as the spec is empty.",
                    "type": "integer",
                    "format": "int64"
                  },
                  "reason": {
                    "description": "The reason for the condition's last transition",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status of the condition, one of True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of the condition.",
                    "type": "string"
                  }
                }
              },
              "x-kubernetes-list-map-keys": ["type"],
              "x-kubernetes-list-type": "map"
            },
            "lastSyncTime": {
              "description": "Last time the NEG syncer syncs associated NEGs.",
              "format": "date-time"
            },
            "networkEndpointGroups": {
              "type": "array",
              "items": {
                "description": "NegObjectReference is the object reference to the NEG resource in GCE",
                "type": "object",
                "required": ["id"],
                "properties": {
                  "id": {
                    "description": "The unique identifier for the NEG resource in GCE API.",
                    "type": "string"
                  },
                  "networkEndpointType": {
                    "description": "NetworkEndpointType: Type of network endpoints in this network endpoint group.",
                    "type": "string"
                  },
                  "selfLink": {
                    "description": "SelfLink is the GCE Server-defined fully-qualified URL for the GCE NEG resource",
                    "type": "string"
                  }
                }
              },
              "x-kubernetes-list-map-keys": ["id"],
              "x-kubernetes-list-type": "map"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.gke.io",
          "kind": "ServiceNetworkEndpointGroup",
          "version": "v1beta1"
        }
      ]
    },
    "io.gke.networking.v1beta1.ServiceNetworkEndpointGroupList": {
      "description": "ServiceNetworkEndpointGroupList is a list of ServiceNetworkEndpointGroup",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.gke.io/v1beta1"]
        },
        "items": {
          "description": "List of servicenetworkendpointgroups. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.gke.networking.v1beta1.ServiceNetworkEndpointGroup"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ServiceNetworkEndpointGroupList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.gke.io",
          "kind": "ServiceNetworkEndpointGroupList",
          "version": "v1beta1"
        }
      ]
    },
    "io.gke.networking.v1beta2.ManagedCertificate": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.gke.io/v1beta2"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ManagedCertificate"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "domains": {
              "type": "array",
              "maxItems": 100,
              "items": {
                "type": "string",
                "maxLength": 63,
                "pattern": "^(([a-z0-9]+|[a-z0-9][-a-z0-9]*[a-z0-9])\\.)+[a-z][-a-z0-9]*[a-z0-9]$"
              }
            }
          }
        },
        "status": {
          "type": "object",
          "properties": {
            "certificateName": {
              "type": "string"
            },
            "certificateStatus": {
              "type": "string"
            },
            "domainStatus": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["domain", "status"],
                "properties": {
                  "domain": {
                    "type": "string"
                  },
                  "status": {
                    "type": "string"
                  }
                }
              }
            },
            "expireTime": {
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.gke.io",
          "kind": "ManagedCertificate",
          "version": "v1beta2"
        }
      ]
    },
    "io.gke.networking.v1beta2.ManagedCertificateList": {
      "description": "ManagedCertificateList is a list of ManagedCertificate",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.gke.io/v1beta2"]
        },
        "items": {
          "description": "List of managedcertificates. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.gke.networking.v1beta2.ManagedCertificate"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ManagedCertificateList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.gke.io",
          "kind": "ManagedCertificateList",
          "version": "v1beta2"
        }
      ]
    },
    "io.gke.nodemanagement.v1alpha1.UpdateInfo": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["nodemanagement.gke.io/v1alpha1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["UpdateInfo"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "type": "object",
          "properties": {
            "Type": {
              "type": "string"
            },
            "instanceGroupUrl": {
              "type": "string"
            },
            "surgeNode": {
              "type": "string"
            },
            "targetNode": {
              "type": "string"
            },
            "validUntil": {
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "nodemanagement.gke.io",
          "kind": "UpdateInfo",
          "version": "v1alpha1"
        }
      ]
    },
    "io.gke.nodemanagement.v1alpha1.UpdateInfoList": {
      "description": "UpdateInfoList is a list of UpdateInfo",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["nodemanagement.gke.io/v1alpha1"]
        },
        "items": {
          "description": "List of updateinfos. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.gke.nodemanagement.v1alpha1.UpdateInfo"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["UpdateInfoList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "nodemanagement.gke.io",
          "kind": "UpdateInfoList",
          "version": "v1alpha1"
        }
      ]
    },
    "io.k8s.api.admissionregistration.v1.MutatingWebhook": {
      "description": "MutatingWebhook describes an admission webhook and the resources and operations it applies to.",
      "type": "object",
      "required": [
        "name",
        "clientConfig",
        "sideEffects",
        "admissionReviewVersions"
      ],
      "properties": {
        "admissionReviewVersions": {
          "description": "AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the Webhook expects. API server will try to use first version in the list which it supports. If none of the versions specified in this list supported by API server, validation will fail for this object. If a persisted webhook configuration specifies allowed versions and does not include any versions known to the API Server, calls to the webhook will fail and be subject to the failure policy.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "clientConfig": {
          "description": "ClientConfig defines how to communicate with the hook. Required",
          "$ref": "#/definitions/io.k8s.api.admissionregistration.v1.WebhookClientConfig"
        },
        "failurePolicy": {
          "description": "FailurePolicy defines how unrecognized errors from the admission endpoint are handled - allowed values are Ignore or Fail. Defaults to Fail.",
          "type": "string"
        },
        "matchPolicy": {
          "description": "matchPolicy defines how the \"rules\" list is used to match incoming requests. Allowed values are \"Exact\" or \"Equivalent\".\n\n- Exact: match a request only if it exactly matches a specified rule. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but \"rules\" only included `apiGroups:[\"apps\"], apiVersions:[\"v1\"], resources: [\"deployments\"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.\n\n- Equivalent: match a request if modifies a resource listed in rules, even via another API group or version. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, and \"rules\" only included `apiGroups:[\"apps\"], apiVersions:[\"v1\"], resources: [\"deployments\"]`, a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.\n\nDefaults to \"Equivalent\"",
          "type": "string"
        },
        "name": {
          "description": "The name of the admission webhook. Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where \"imagepolicy\" is the name of the webhook, and kubernetes.io is the name of the organization. Required.",
          "type": "string"
        },
        "namespaceSelector": {
          "description": "NamespaceSelector decides whether to run the webhook on an object based on whether the namespace for that object matches the selector. If the object itself is a namespace, the matching is performed on object.metadata.labels. If the object is another cluster scoped resource, it never skips the webhook.\n\nFor example, to run the webhook on any objects whose namespace is not associated with \"runlevel\" of \"0\" or \"1\";  you will set the selector as follows: \"namespaceSelector\": {\n  \"matchExpressions\": [\n    {\n      \"key\": \"runlevel\",\n      \"operator\": \"NotIn\",\n      \"values\": [\n        \"0\",\n        \"1\"\n      ]\n    }\n  ]\n}\n\nIf instead you want to only run the webhook on any objects whose namespace is associated with the \"environment\" of \"prod\" or \"staging\"; you will set the selector as follows: \"namespaceSelector\": {\n  \"matchExpressions\": [\n    {\n      \"key\": \"environment\",\n      \"operator\": \"In\",\n      \"values\": [\n        \"prod\",\n        \"staging\"\n      ]\n    }\n  ]\n}\n\nSee https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more examples of label selectors.\n\nDefault to the empty LabelSelector, which matches everything.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "objectSelector": {
          "description": "ObjectSelector decides whether to run the webhook based on if the object has matching labels. objectSelector is evaluated against both the oldObject and newObject that would be sent to the webhook, and is considered to match if either object matches the selector. A null object (oldObject in the case of create, or newObject in the case of delete) or an object that cannot have labels (like a DeploymentRollback or a PodProxyOptions object) is not considered to match. Use the object selector only if the webhook is opt-in, because end users may skip the admission webhook by setting the labels. Default to the empty LabelSelector, which matches everything.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "reinvocationPolicy": {
          "description": "reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation. Allowed values are \"Never\" and \"IfNeeded\".\n\nNever: the webhook will not be called more than once in a single admission evaluation.\n\nIfNeeded: the webhook will be called at least one additional time as part of the admission evaluation if the object being admitted is modified by other admission plugins after the initial webhook call. Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted. Note: * the number of additional invocations is not guaranteed to be exactly one. * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again. * webhooks that use this option may be reordered to minimize the number of additional invocations. * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.\n\nDefaults to \"Never\".",
          "type": "string"
        },
        "rules": {
          "description": "Rules describes what operations on what resources/subresources the webhook cares about. The webhook cares about an operation if it matches _any_ Rule. However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the cluster in a state which cannot be recovered from without completely disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.admissionregistration.v1.RuleWithOperations"
          }
        },
        "sideEffects": {
          "description": "SideEffects states whether this webhook has side effects. Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown). Webhooks with side effects MUST implement a reconciliation system, since a request may be rejected by a future step in the admission chain and the side effects therefore need to be undone. Requests with the dryRun attribute will be auto-rejected if they match a webhook with sideEffects == Unknown or Some.",
          "type": "string"
        },
        "timeoutSeconds": {
          "description": "TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the webhook call will be ignored or the API call will fail based on the failure policy. The timeout value must be between 1 and 30 seconds. Default to 10 seconds.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.admissionregistration.v1.MutatingWebhookConfiguration": {
      "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["admissionregistration.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MutatingWebhookConfiguration"]
        },
        "metadata": {
          "description": "Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "webhooks": {
          "description": "Webhooks is a list of webhooks and the affected resources and operations.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.admissionregistration.v1.MutatingWebhook"
          },
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "admissionregistration.k8s.io",
          "kind": "MutatingWebhookConfiguration",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.admissionregistration.v1.MutatingWebhookConfigurationList": {
      "description": "MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["admissionregistration.k8s.io/v1"]
        },
        "items": {
          "description": "List of MutatingWebhookConfiguration.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.admissionregistration.v1.MutatingWebhookConfiguration"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["MutatingWebhookConfigurationList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "admissionregistration.k8s.io",
          "kind": "MutatingWebhookConfigurationList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.admissionregistration.v1.RuleWithOperations": {
      "description": "RuleWithOperations is a tuple of Operations and Resources. It is recommended to make sure that all the tuple expansions are valid.",
      "type": "object",
      "properties": {
        "apiGroups": {
          "description": "APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is present, the length of the slice must be one. Required.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "apiVersions": {
          "description": "APIVersions is the API versions the resources belong to. '*' is all versions. If '*' is present, the length of the slice must be one. Required.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "operations": {
          "description": "Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or * for all of those operations and any future admission operations that are added. If '*' is present, the length of the slice must be one. Required.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "resources": {
          "description": "Resources is a list of resources this rule applies to.\n\nFor example: 'pods' means pods. 'pods/log' means the log subresource of pods. '*' means all resources, but not subresources. 'pods/*' means all subresources of pods. '*/scale' means all scale subresources. '*/*' means all resources and their subresources.\n\nIf wildcard is present, the validation rule will ensure resources do not overlap with each other.\n\nDepending on the enclosing object, subresources might not be allowed. Required.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "scope": {
          "description": "scope specifies the scope of this rule. Valid values are \"Cluster\", \"Namespaced\", and \"*\" \"Cluster\" means that only cluster-scoped resources will match this rule. Namespace API objects are cluster-scoped. \"Namespaced\" means that only namespaced resources will match this rule. \"*\" means that there are no scope restrictions. Subresources match the scope of their parent resource. Default is \"*\".",
          "type": "string"
        }
      }
    },
    "io.k8s.api.admissionregistration.v1.ServiceReference": {
      "description": "ServiceReference holds a reference to Service.legacy.k8s.io",
      "type": "object",
      "required": ["namespace", "name"],
      "properties": {
        "name": {
          "description": "`name` is the name of the service. Required",
          "type": "string"
        },
        "namespace": {
          "description": "`namespace` is the namespace of the service. Required",
          "type": "string"
        },
        "path": {
          "description": "`path` is an optional URL path which will be sent in any request to this service.",
          "type": "string"
        },
        "port": {
          "description": "If specified, the port on the service that hosting webhook. Default to 443 for backward compatibility. `port` should be a valid port number (1-65535, inclusive).",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.admissionregistration.v1.ValidatingWebhook": {
      "description": "ValidatingWebhook describes an admission webhook and the resources and operations it applies to.",
      "type": "object",
      "required": [
        "name",
        "clientConfig",
        "sideEffects",
        "admissionReviewVersions"
      ],
      "properties": {
        "admissionReviewVersions": {
          "description": "AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the Webhook expects. API server will try to use first version in the list which it supports. If none of the versions specified in this list supported by API server, validation will fail for this object. If a persisted webhook configuration specifies allowed versions and does not include any versions known to the API Server, calls to the webhook will fail and be subject to the failure policy.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "clientConfig": {
          "description": "ClientConfig defines how to communicate with the hook. Required",
          "$ref": "#/definitions/io.k8s.api.admissionregistration.v1.WebhookClientConfig"
        },
        "failurePolicy": {
          "description": "FailurePolicy defines how unrecognized errors from the admission endpoint are handled - allowed values are Ignore or Fail. Defaults to Fail.",
          "type": "string"
        },
        "matchPolicy": {
          "description": "matchPolicy defines how the \"rules\" list is used to match incoming requests. Allowed values are \"Exact\" or \"Equivalent\".\n\n- Exact: match a request only if it exactly matches a specified rule. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but \"rules\" only included `apiGroups:[\"apps\"], apiVersions:[\"v1\"], resources: [\"deployments\"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.\n\n- Equivalent: match a request if modifies a resource listed in rules, even via another API group or version. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, and \"rules\" only included `apiGroups:[\"apps\"], apiVersions:[\"v1\"], resources: [\"deployments\"]`, a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.\n\nDefaults to \"Equivalent\"",
          "type": "string"
        },
        "name": {
          "description": "The name of the admission webhook. Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where \"imagepolicy\" is the name of the webhook, and kubernetes.io is the name of the organization. Required.",
          "type": "string"
        },
        "namespaceSelector": {
          "description": "NamespaceSelector decides whether to run the webhook on an object based on whether the namespace for that object matches the selector. If the object itself is a namespace, the matching is performed on object.metadata.labels. If the object is another cluster scoped resource, it never skips the webhook.\n\nFor example, to run the webhook on any objects whose namespace is not associated with \"runlevel\" of \"0\" or \"1\";  you will set the selector as follows: \"namespaceSelector\": {\n  \"matchExpressions\": [\n    {\n      \"key\": \"runlevel\",\n      \"operator\": \"NotIn\",\n      \"values\": [\n        \"0\",\n        \"1\"\n      ]\n    }\n  ]\n}\n\nIf instead you want to only run the webhook on any objects whose namespace is associated with the \"environment\" of \"prod\" or \"staging\"; you will set the selector as follows: \"namespaceSelector\": {\n  \"matchExpressions\": [\n    {\n      \"key\": \"environment\",\n      \"operator\": \"In\",\n      \"values\": [\n        \"prod\",\n        \"staging\"\n      ]\n    }\n  ]\n}\n\nSee https://kubernetes.io/docs/concepts/overview/working-with-objects/labels for more examples of label selectors.\n\nDefault to the empty LabelSelector, which matches everything.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "objectSelector": {
          "description": "ObjectSelector decides whether to run the webhook based on if the object has matching labels. objectSelector is evaluated against both the oldObject and newObject that would be sent to the webhook, and is considered to match if either object matches the selector. A null object (oldObject in the case of create, or newObject in the case of delete) or an object that cannot have labels (like a DeploymentRollback or a PodProxyOptions object) is not considered to match. Use the object selector only if the webhook is opt-in, because end users may skip the admission webhook by setting the labels. Default to the empty LabelSelector, which matches everything.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "rules": {
          "description": "Rules describes what operations on what resources/subresources the webhook cares about. The webhook cares about an operation if it matches _any_ Rule. However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the cluster in a state which cannot be recovered from without completely disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.admissionregistration.v1.RuleWithOperations"
          }
        },
        "sideEffects": {
          "description": "SideEffects states whether this webhook has side effects. Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown). Webhooks with side effects MUST implement a reconciliation system, since a request may be rejected by a future step in the admission chain and the side effects therefore need to be undone. Requests with the dryRun attribute will be auto-rejected if they match a webhook with sideEffects == Unknown or Some.",
          "type": "string"
        },
        "timeoutSeconds": {
          "description": "TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the webhook call will be ignored or the API call will fail based on the failure policy. The timeout value must be between 1 and 30 seconds. Default to 10 seconds.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.admissionregistration.v1.ValidatingWebhookConfiguration": {
      "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["admissionregistration.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ValidatingWebhookConfiguration"]
        },
        "metadata": {
          "description": "Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "webhooks": {
          "description": "Webhooks is a list of webhooks and the affected resources and operations.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.admissionregistration.v1.ValidatingWebhook"
          },
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "admissionregistration.k8s.io",
          "kind": "ValidatingWebhookConfiguration",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.admissionregistration.v1.ValidatingWebhookConfigurationList": {
      "description": "ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["admissionregistration.k8s.io/v1"]
        },
        "items": {
          "description": "List of ValidatingWebhookConfiguration.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.admissionregistration.v1.ValidatingWebhookConfiguration"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ValidatingWebhookConfigurationList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "admissionregistration.k8s.io",
          "kind": "ValidatingWebhookConfigurationList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.admissionregistration.v1.WebhookClientConfig": {
      "description": "WebhookClientConfig contains the information to make a TLS connection with the webhook",
      "type": "object",
      "properties": {
        "caBundle": {
          "description": "`caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate. If unspecified, system trust roots on the apiserver are used.",
          "type": "string",
          "format": "byte"
        },
        "service": {
          "description": "`service` is a reference to the service for this webhook. Either `service` or `url` must be specified.\n\nIf the webhook is running within the cluster, then you should use `service`.",
          "$ref": "#/definitions/io.k8s.api.admissionregistration.v1.ServiceReference"
        },
        "url": {
          "description": "`url` gives the location of the webhook, in standard URL form (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.\n\nThe `host` should not refer to a service running in the cluster; use the `service` field instead. The host might be resolved via external DNS in some apiservers (e.g., `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation). `host` may also be an IP address.\n\nPlease note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take great care to run this webhook on all hosts which run an apiserver which might need to make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy to turn up in a new cluster.\n\nThe scheme must be \"https\"; the URL must begin with \"https://\".\n\nA path is optional, and if present may be any string permissible in a URL. You may use the path to pass an arbitrary string to the webhook, for example, a cluster identifier.\n\nAttempting to use a user or basic auth e.g. \"user:password@\" is not allowed. Fragments (\"#...\") and query parameters (\"?...\") are not allowed, either.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.apps.v1.ControllerRevision": {
      "description": "ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers.",
      "type": "object",
      "required": ["revision"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["apps/v1"]
        },
        "data": {
          "description": "Data is the serialized representation of the state.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.runtime.RawExtension"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ControllerRevision"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "revision": {
          "description": "Revision indicates the revision of the state represented by Data.",
          "type": "integer",
          "format": "int64"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps",
          "kind": "ControllerRevision",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.apps.v1.ControllerRevisionList": {
      "description": "ControllerRevisionList is a resource containing a list of ControllerRevision objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["apps/v1"]
        },
        "items": {
          "description": "Items is the list of ControllerRevisions",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.apps.v1.ControllerRevision"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ControllerRevisionList"]
        },
        "metadata": {
          "description": "More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps",
          "kind": "ControllerRevisionList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.apps.v1.DaemonSet": {
      "description": "DaemonSet represents the configuration of a daemon set.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["apps/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DaemonSet"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "The desired behavior of this daemon set. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.apps.v1.DaemonSetSpec"
        },
        "status": {
          "description": "The current status of this daemon set. This data may be out of date by some window of time. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.apps.v1.DaemonSetStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps",
          "kind": "DaemonSet",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.apps.v1.DaemonSetCondition": {
      "description": "DaemonSetCondition describes the state of a DaemonSet at a certain point.",
      "type": "object",
      "required": ["type", "status"],
      "properties": {
        "lastTransitionTime": {
          "description": "Last time the condition transitioned from one status to another.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "A human readable message indicating details about the transition.",
          "type": "string"
        },
        "reason": {
          "description": "The reason for the condition's last transition.",
          "type": "string"
        },
        "status": {
          "description": "Status of the condition, one of True, False, Unknown.",
          "type": "string"
        },
        "type": {
          "description": "Type of DaemonSet condition.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.apps.v1.DaemonSetList": {
      "description": "DaemonSetList is a collection of daemon sets.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["apps/v1"]
        },
        "items": {
          "description": "A list of daemon sets.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.apps.v1.DaemonSet"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DaemonSetList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps",
          "kind": "DaemonSetList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.apps.v1.DaemonSetSpec": {
      "description": "DaemonSetSpec is the specification of a daemon set.",
      "type": "object",
      "required": ["selector", "template"],
      "properties": {
        "minReadySeconds": {
          "description": "The minimum number of seconds for which a newly created DaemonSet pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready).",
          "type": "integer",
          "format": "int32"
        },
        "revisionHistoryLimit": {
          "description": "The number of old history to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.",
          "type": "integer",
          "format": "int32"
        },
        "selector": {
          "description": "A label query over pods that are managed by the daemon set. Must match in order to be controlled. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "template": {
          "description": "An object that describes the pod that will be created. The DaemonSet will create exactly one copy of this pod on every node that matches the template's node selector (or on every node if no node selector is specified). More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodTemplateSpec"
        },
        "updateStrategy": {
          "description": "An update strategy to replace existing DaemonSet pods with new pods.",
          "$ref": "#/definitions/io.k8s.api.apps.v1.DaemonSetUpdateStrategy"
        }
      }
    },
    "io.k8s.api.apps.v1.DaemonSetStatus": {
      "description": "DaemonSetStatus represents the current status of a daemon set.",
      "type": "object",
      "required": [
        "currentNumberScheduled",
        "numberMisscheduled",
        "desiredNumberScheduled",
        "numberReady"
      ],
      "properties": {
        "collisionCount": {
          "description": "Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.",
          "type": "integer",
          "format": "int32"
        },
        "conditions": {
          "description": "Represents the latest available observations of a DaemonSet's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.apps.v1.DaemonSetCondition"
          },
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        },
        "currentNumberScheduled": {
          "description": "The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/",
          "type": "integer",
          "format": "int32"
        },
        "desiredNumberScheduled": {
          "description": "The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/",
          "type": "integer",
          "format": "int32"
        },
        "numberAvailable": {
          "description": "The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)",
          "type": "integer",
          "format": "int32"
        },
        "numberMisscheduled": {
          "description": "The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/",
          "type": "integer",
          "format": "int32"
        },
        "numberReady": {
          "description": "The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and ready.",
          "type": "integer",
          "format": "int32"
        },
        "numberUnavailable": {
          "description": "The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)",
          "type": "integer",
          "format": "int32"
        },
        "observedGeneration": {
          "description": "The most recent generation observed by the daemon set controller.",
          "type": "integer",
          "format": "int64"
        },
        "updatedNumberScheduled": {
          "description": "The total number of nodes that are running updated daemon pod",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.apps.v1.DaemonSetUpdateStrategy": {
      "description": "DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.",
      "type": "object",
      "properties": {
        "rollingUpdate": {
          "description": "Rolling update config params. Present only if type = \"RollingUpdate\".",
          "$ref": "#/definitions/io.k8s.api.apps.v1.RollingUpdateDaemonSet"
        },
        "type": {
          "description": "Type of daemon set update. Can be \"RollingUpdate\" or \"OnDelete\". Default is RollingUpdate.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.apps.v1.Deployment": {
      "description": "Deployment enables declarative updates for Pods and ReplicaSets.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["apps/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Deployment"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Specification of the desired behavior of the Deployment.",
          "$ref": "#/definitions/io.k8s.api.apps.v1.DeploymentSpec"
        },
        "status": {
          "description": "Most recently observed status of the Deployment.",
          "$ref": "#/definitions/io.k8s.api.apps.v1.DeploymentStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps",
          "kind": "Deployment",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.apps.v1.DeploymentCondition": {
      "description": "DeploymentCondition describes the state of a deployment at a certain point.",
      "type": "object",
      "required": ["type", "status"],
      "properties": {
        "lastTransitionTime": {
          "description": "Last time the condition transitioned from one status to another.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "lastUpdateTime": {
          "description": "The last time this condition was updated.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "A human readable message indicating details about the transition.",
          "type": "string"
        },
        "reason": {
          "description": "The reason for the condition's last transition.",
          "type": "string"
        },
        "status": {
          "description": "Status of the condition, one of True, False, Unknown.",
          "type": "string"
        },
        "type": {
          "description": "Type of deployment condition.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.apps.v1.DeploymentList": {
      "description": "DeploymentList is a list of Deployments.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["apps/v1"]
        },
        "items": {
          "description": "Items is the list of Deployments.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.apps.v1.Deployment"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DeploymentList"]
        },
        "metadata": {
          "description": "Standard list metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps",
          "kind": "DeploymentList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.apps.v1.DeploymentSpec": {
      "description": "DeploymentSpec is the specification of the desired behavior of the Deployment.",
      "type": "object",
      "required": ["selector", "template"],
      "properties": {
        "minReadySeconds": {
          "description": "Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)",
          "type": "integer",
          "format": "int32"
        },
        "paused": {
          "description": "Indicates that the deployment is paused.",
          "type": "boolean"
        },
        "progressDeadlineSeconds": {
          "description": "The maximum time in seconds for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. Defaults to 600s.",
          "type": "integer",
          "format": "int32"
        },
        "replicas": {
          "description": "Number of desired pods. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.",
          "type": "integer",
          "format": "int32"
        },
        "revisionHistoryLimit": {
          "description": "The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.",
          "type": "integer",
          "format": "int32"
        },
        "selector": {
          "description": "Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment. It must match the pod template's labels.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "strategy": {
          "description": "The deployment strategy to use to replace existing pods with new ones.",
          "x-kubernetes-patch-strategy": "retainKeys",
          "$ref": "#/definitions/io.k8s.api.apps.v1.DeploymentStrategy"
        },
        "template": {
          "description": "Template describes the pods that will be created.",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodTemplateSpec"
        }
      }
    },
    "io.k8s.api.apps.v1.DeploymentStatus": {
      "description": "DeploymentStatus is the most recently observed status of the Deployment.",
      "type": "object",
      "properties": {
        "availableReplicas": {
          "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.",
          "type": "integer",
          "format": "int32"
        },
        "collisionCount": {
          "description": "Count of hash collisions for the Deployment. The Deployment controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ReplicaSet.",
          "type": "integer",
          "format": "int32"
        },
        "conditions": {
          "description": "Represents the latest available observations of a deployment's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.apps.v1.DeploymentCondition"
          },
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        },
        "observedGeneration": {
          "description": "The generation observed by the deployment controller.",
          "type": "integer",
          "format": "int64"
        },
        "readyReplicas": {
          "description": "Total number of ready pods targeted by this deployment.",
          "type": "integer",
          "format": "int32"
        },
        "replicas": {
          "description": "Total number of non-terminated pods targeted by this deployment (their labels match the selector).",
          "type": "integer",
          "format": "int32"
        },
        "unavailableReplicas": {
          "description": "Total number of unavailable pods targeted by this deployment. This is the total number of pods that are still required for the deployment to have 100% available capacity. They may either be pods that are running but not yet available or pods that still have not been created.",
          "type": "integer",
          "format": "int32"
        },
        "updatedReplicas": {
          "description": "Total number of non-terminated pods targeted by this deployment that have the desired template spec.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.apps.v1.DeploymentStrategy": {
      "description": "DeploymentStrategy describes how to replace existing pods with new ones.",
      "type": "object",
      "properties": {
        "rollingUpdate": {
          "description": "Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.",
          "$ref": "#/definitions/io.k8s.api.apps.v1.RollingUpdateDeployment"
        },
        "type": {
          "description": "Type of deployment. Can be \"Recreate\" or \"RollingUpdate\". Default is RollingUpdate.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.apps.v1.ReplicaSet": {
      "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["apps/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ReplicaSet"]
        },
        "metadata": {
          "description": "If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s) that the ReplicaSet manages. Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the specification of the desired behavior of the ReplicaSet. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.apps.v1.ReplicaSetSpec"
        },
        "status": {
          "description": "Status is the most recently observed status of the ReplicaSet. This data may be out of date by some window of time. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.apps.v1.ReplicaSetStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps",
          "kind": "ReplicaSet",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.apps.v1.ReplicaSetCondition": {
      "description": "ReplicaSetCondition describes the state of a replica set at a certain point.",
      "type": "object",
      "required": ["type", "status"],
      "properties": {
        "lastTransitionTime": {
          "description": "The last time the condition transitioned from one status to another.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "A human readable message indicating details about the transition.",
          "type": "string"
        },
        "reason": {
          "description": "The reason for the condition's last transition.",
          "type": "string"
        },
        "status": {
          "description": "Status of the condition, one of True, False, Unknown.",
          "type": "string"
        },
        "type": {
          "description": "Type of replica set condition.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.apps.v1.ReplicaSetList": {
      "description": "ReplicaSetList is a collection of ReplicaSets.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["apps/v1"]
        },
        "items": {
          "description": "List of ReplicaSets. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.apps.v1.ReplicaSet"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ReplicaSetList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps",
          "kind": "ReplicaSetList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.apps.v1.ReplicaSetSpec": {
      "description": "ReplicaSetSpec is the specification of a ReplicaSet.",
      "type": "object",
      "required": ["selector"],
      "properties": {
        "minReadySeconds": {
          "description": "Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)",
          "type": "integer",
          "format": "int32"
        },
        "replicas": {
          "description": "Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller",
          "type": "integer",
          "format": "int32"
        },
        "selector": {
          "description": "Selector is a label query over pods that should match the replica count. Label keys and values that must match in order to be controlled by this replica set. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "template": {
          "description": "Template is the object that describes the pod that will be created if insufficient replicas are detected. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodTemplateSpec"
        }
      }
    },
    "io.k8s.api.apps.v1.ReplicaSetStatus": {
      "description": "ReplicaSetStatus represents the current status of a ReplicaSet.",
      "type": "object",
      "required": ["replicas"],
      "properties": {
        "availableReplicas": {
          "description": "The number of available replicas (ready for at least minReadySeconds) for this replica set.",
          "type": "integer",
          "format": "int32"
        },
        "conditions": {
          "description": "Represents the latest available observations of a replica set's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.apps.v1.ReplicaSetCondition"
          },
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        },
        "fullyLabeledReplicas": {
          "description": "The number of pods that have labels matching the labels of the pod template of the replicaset.",
          "type": "integer",
          "format": "int32"
        },
        "observedGeneration": {
          "description": "ObservedGeneration reflects the generation of the most recently observed ReplicaSet.",
          "type": "integer",
          "format": "int64"
        },
        "readyReplicas": {
          "description": "The number of ready replicas for this replica set.",
          "type": "integer",
          "format": "int32"
        },
        "replicas": {
          "description": "Replicas is the most recently oberved number of replicas. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.apps.v1.RollingUpdateDaemonSet": {
      "description": "Spec to control the desired behavior of daemon set rolling update.",
      "type": "object",
      "properties": {
        "maxSurge": {
          "description": "The maximum number of nodes with an existing available DaemonSet pod that can have an updated DaemonSet pod during during an update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up to a minimum of 1. Default value is 0. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their a new pod created before the old pod is marked as deleted. The update starts by launching new pods on 30% of nodes. Once an updated pod is available (Ready for at least minReadySeconds) the old DaemonSet pod on that node is marked deleted. If the old pod becomes unavailable for any reason (Ready transitions to false, is evicted, or is drained) an updated pod is immediatedly created on that node without considering surge limits. Allowing surge implies the possibility that the resources consumed by the daemonset on any given node can double if the readiness check fails, and so resource intensive daemonsets should take into account that they may cause evictions during disruption. This is beta field and enabled/disabled by DaemonSetUpdateSurge feature gate.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
        },
        "maxUnavailable": {
          "description": "The maximum number of DaemonSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0 if MaxSurge is 0 Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those DaemonSet pods and then brings up new DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are available at all times during the update.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
        }
      }
    },
    "io.k8s.api.apps.v1.RollingUpdateDeployment": {
      "description": "Spec to control the desired behavior of rolling update.",
      "type": "object",
      "properties": {
        "maxSurge": {
          "description": "The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
        },
        "maxUnavailable": {
          "description": "The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
        }
      }
    },
    "io.k8s.api.apps.v1.RollingUpdateStatefulSetStrategy": {
      "description": "RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.",
      "type": "object",
      "properties": {
        "partition": {
          "description": "Partition indicates the ordinal at which the StatefulSet should be partitioned. Default value is 0.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.apps.v1.StatefulSet": {
      "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["apps/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StatefulSet"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the desired identities of pods in this set.",
          "$ref": "#/definitions/io.k8s.api.apps.v1.StatefulSetSpec"
        },
        "status": {
          "description": "Status is the current status of Pods in this StatefulSet. This data may be out of date by some window of time.",
          "$ref": "#/definitions/io.k8s.api.apps.v1.StatefulSetStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps",
          "kind": "StatefulSet",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.apps.v1.StatefulSetCondition": {
      "description": "StatefulSetCondition describes the state of a statefulset at a certain point.",
      "type": "object",
      "required": ["type", "status"],
      "properties": {
        "lastTransitionTime": {
          "description": "Last time the condition transitioned from one status to another.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "A human readable message indicating details about the transition.",
          "type": "string"
        },
        "reason": {
          "description": "The reason for the condition's last transition.",
          "type": "string"
        },
        "status": {
          "description": "Status of the condition, one of True, False, Unknown.",
          "type": "string"
        },
        "type": {
          "description": "Type of statefulset condition.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.apps.v1.StatefulSetList": {
      "description": "StatefulSetList is a collection of StatefulSets.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["apps/v1"]
        },
        "items": {
          "description": "Items is the list of stateful sets.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.apps.v1.StatefulSet"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StatefulSetList"]
        },
        "metadata": {
          "description": "Standard list's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apps",
          "kind": "StatefulSetList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.apps.v1.StatefulSetSpec": {
      "description": "A StatefulSetSpec is the specification of a StatefulSet.",
      "type": "object",
      "required": ["selector", "template", "serviceName"],
      "properties": {
        "minReadySeconds": {
          "description": "Minimum number of seconds for which a newly created pod should be ready without any of its container crashing for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready) This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate.",
          "type": "integer",
          "format": "int32"
        },
        "podManagementPolicy": {
          "description": "podManagementPolicy controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`, where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is `Parallel` which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.",
          "type": "string"
        },
        "replicas": {
          "description": "replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template, but individual replicas also have a consistent identity. If unspecified, defaults to 1.",
          "type": "integer",
          "format": "int32"
        },
        "revisionHistoryLimit": {
          "description": "revisionHistoryLimit is the maximum number of revisions that will be maintained in the StatefulSet's revision history. The revision history consists of all revisions not represented by a currently applied StatefulSetSpec version. The default value is 10.",
          "type": "integer",
          "format": "int32"
        },
        "selector": {
          "description": "selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "serviceName": {
          "description": "serviceName is the name of the service that governs this StatefulSet. This service must exist before the StatefulSet, and is responsible for the network identity of the set. Pods get DNS/hostnames that follow the pattern: pod-specific-string.serviceName.default.svc.cluster.local where \"pod-specific-string\" is managed by the StatefulSet controller.",
          "type": "string"
        },
        "template": {
          "description": "template is the object that describes the pod that will be created if insufficient replicas are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have a unique identity from the rest of the StatefulSet.",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodTemplateSpec"
        },
        "updateStrategy": {
          "description": "updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template.",
          "$ref": "#/definitions/io.k8s.api.apps.v1.StatefulSetUpdateStrategy"
        },
        "volumeClaimTemplates": {
          "description": "volumeClaimTemplates is a list of claims that pods are allowed to reference. The StatefulSet controller is responsible for mapping network identities to claims in a way that maintains the identity of a pod. Every claim in this list must have at least one matching (by name) volumeMount in one container in the template. A claim in this list takes precedence over any volumes in the template, with the same name.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.PersistentVolumeClaim"
          }
        }
      }
    },
    "io.k8s.api.apps.v1.StatefulSetStatus": {
      "description": "StatefulSetStatus represents the current state of a StatefulSet.",
      "type": "object",
      "required": ["replicas"],
      "properties": {
        "availableReplicas": {
          "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this statefulset. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. Remove omitempty when graduating to beta",
          "type": "integer",
          "format": "int32"
        },
        "collisionCount": {
          "description": "collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.",
          "type": "integer",
          "format": "int32"
        },
        "conditions": {
          "description": "Represents the latest available observations of a statefulset's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.apps.v1.StatefulSetCondition"
          },
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        },
        "currentReplicas": {
          "description": "currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by currentRevision.",
          "type": "integer",
          "format": "int32"
        },
        "currentRevision": {
          "description": "currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [0,currentReplicas).",
          "type": "string"
        },
        "observedGeneration": {
          "description": "observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the StatefulSet's generation, which is updated on mutation by the API Server.",
          "type": "integer",
          "format": "int64"
        },
        "readyReplicas": {
          "description": "readyReplicas is the number of Pods created by the StatefulSet controller that have a Ready Condition.",
          "type": "integer",
          "format": "int32"
        },
        "replicas": {
          "description": "replicas is the number of Pods created by the StatefulSet controller.",
          "type": "integer",
          "format": "int32"
        },
        "updateRevision": {
          "description": "updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [replicas-updatedReplicas,replicas)",
          "type": "string"
        },
        "updatedReplicas": {
          "description": "updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by updateRevision.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.apps.v1.StatefulSetUpdateStrategy": {
      "description": "StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy.",
      "type": "object",
      "properties": {
        "rollingUpdate": {
          "description": "RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.",
          "$ref": "#/definitions/io.k8s.api.apps.v1.RollingUpdateStatefulSetStrategy"
        },
        "type": {
          "description": "Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.authentication.v1.BoundObjectReference": {
      "description": "BoundObjectReference is a reference to an object that a token is bound to.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "API version of the referent.",
          "type": "string"
        },
        "kind": {
          "description": "Kind of the referent. Valid kinds are 'Pod' and 'Secret'.",
          "type": "string"
        },
        "name": {
          "description": "Name of the referent.",
          "type": "string"
        },
        "uid": {
          "description": "UID of the referent.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.authentication.v1.TokenRequest": {
      "description": "TokenRequest requests a token for a given service account.",
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["authentication.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["TokenRequest"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec holds information about the request being evaluated",
          "$ref": "#/definitions/io.k8s.api.authentication.v1.TokenRequestSpec"
        },
        "status": {
          "description": "Status is filled in by the server and indicates whether the token can be authenticated.",
          "$ref": "#/definitions/io.k8s.api.authentication.v1.TokenRequestStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "authentication.k8s.io",
          "kind": "TokenRequest",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.authentication.v1.TokenRequestSpec": {
      "description": "TokenRequestSpec contains client provided parameters of a token request.",
      "type": "object",
      "required": ["audiences"],
      "properties": {
        "audiences": {
          "description": "Audiences are the intendend audiences of the token. A recipient of a token must identitfy themself with an identifier in the list of audiences of the token, and otherwise should reject the token. A token issued for multiple audiences may be used to authenticate against any of the audiences listed but implies a high degree of trust between the target audiences.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "boundObjectRef": {
          "description": "BoundObjectRef is a reference to an object that the token will be bound to. The token will only be valid for as long as the bound object exists. NOTE: The API server's TokenReview endpoint will validate the BoundObjectRef, but other audiences may not. Keep ExpirationSeconds small if you want prompt revocation.",
          "$ref": "#/definitions/io.k8s.api.authentication.v1.BoundObjectReference"
        },
        "expirationSeconds": {
          "description": "ExpirationSeconds is the requested duration of validity of the request. The token issuer may return a token with a different validity duration so a client needs to check the 'expiration' field in a response.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "io.k8s.api.authentication.v1.TokenRequestStatus": {
      "description": "TokenRequestStatus is the result of a token request.",
      "type": "object",
      "required": ["token", "expirationTimestamp"],
      "properties": {
        "expirationTimestamp": {
          "description": "ExpirationTimestamp is the time of expiration of the returned token.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "token": {
          "description": "Token is the opaque bearer token.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.authentication.v1.TokenReview": {
      "description": "TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver.",
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["authentication.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["TokenReview"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec holds information about the request being evaluated",
          "$ref": "#/definitions/io.k8s.api.authentication.v1.TokenReviewSpec"
        },
        "status": {
          "description": "Status is filled in by the server and indicates whether the request can be authenticated.",
          "$ref": "#/definitions/io.k8s.api.authentication.v1.TokenReviewStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "authentication.k8s.io",
          "kind": "TokenReview",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.authentication.v1.TokenReviewSpec": {
      "description": "TokenReviewSpec is a description of the token authentication request.",
      "type": "object",
      "properties": {
        "audiences": {
          "description": "Audiences is a list of the identifiers that the resource server presented with the token identifies as. Audience-aware token authenticators will verify that the token was intended for at least one of the audiences in this list. If no audiences are provided, the audience will default to the audience of the Kubernetes apiserver.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "token": {
          "description": "Token is the opaque bearer token.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.authentication.v1.TokenReviewStatus": {
      "description": "TokenReviewStatus is the result of the token authentication request.",
      "type": "object",
      "properties": {
        "audiences": {
          "description": "Audiences are audience identifiers chosen by the authenticator that are compatible with both the TokenReview and token. An identifier is any identifier in the intersection of the TokenReviewSpec audiences and the token's audiences. A client of the TokenReview API that sets the spec.audiences field should validate that a compatible audience identifier is returned in the status.audiences field to ensure that the TokenReview server is audience aware. If a TokenReview returns an empty status.audience field where status.authenticated is \"true\", the token is valid against the audience of the Kubernetes API server.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "authenticated": {
          "description": "Authenticated indicates that the token was associated with a known user.",
          "type": "boolean"
        },
        "error": {
          "description": "Error indicates that the token couldn't be checked",
          "type": "string"
        },
        "user": {
          "description": "User is the UserInfo associated with the provided token.",
          "$ref": "#/definitions/io.k8s.api.authentication.v1.UserInfo"
        }
      }
    },
    "io.k8s.api.authentication.v1.UserInfo": {
      "description": "UserInfo holds the information about the user needed to implement the user.Info interface.",
      "type": "object",
      "properties": {
        "extra": {
          "description": "Any additional information provided by the authenticator.",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "groups": {
          "description": "The names of groups this user is a part of.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "uid": {
          "description": "A unique value that identifies this user across time. If this user is deleted and another user by the same name is added, they will have different UIDs.",
          "type": "string"
        },
        "username": {
          "description": "The name that uniquely identifies this user among all active users.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.authorization.v1.LocalSubjectAccessReview": {
      "description": "LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking.",
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["authorization.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["LocalSubjectAccessReview"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec holds information about the request being evaluated.  spec.namespace must be equal to the namespace you made the request against.  If empty, it is defaulted.",
          "$ref": "#/definitions/io.k8s.api.authorization.v1.SubjectAccessReviewSpec"
        },
        "status": {
          "description": "Status is filled in by the server and indicates whether the request is allowed or not",
          "$ref": "#/definitions/io.k8s.api.authorization.v1.SubjectAccessReviewStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "authorization.k8s.io",
          "kind": "LocalSubjectAccessReview",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.authorization.v1.NonResourceAttributes": {
      "description": "NonResourceAttributes includes the authorization attributes available for non-resource requests to the Authorizer interface",
      "type": "object",
      "properties": {
        "path": {
          "description": "Path is the URL path of the request",
          "type": "string"
        },
        "verb": {
          "description": "Verb is the standard HTTP verb",
          "type": "string"
        }
      }
    },
    "io.k8s.api.authorization.v1.NonResourceRule": {
      "description": "NonResourceRule holds information that describes a rule for the non-resource",
      "type": "object",
      "required": ["verbs"],
      "properties": {
        "nonResourceURLs": {
          "description": "NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path.  \"*\" means all.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "verbs": {
          "description": "Verb is a list of kubernetes non-resource API verbs, like: get, post, put, delete, patch, head, options.  \"*\" means all.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.authorization.v1.ResourceAttributes": {
      "description": "ResourceAttributes includes the authorization attributes available for resource requests to the Authorizer interface",
      "type": "object",
      "properties": {
        "group": {
          "description": "Group is the API Group of the Resource.  \"*\" means all.",
          "type": "string"
        },
        "name": {
          "description": "Name is the name of the resource being requested for a \"get\" or deleted for a \"delete\". \"\" (empty) means all.",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace is the namespace of the action being requested.  Currently, there is no distinction between no namespace and all namespaces \"\" (empty) is defaulted for LocalSubjectAccessReviews \"\" (empty) is empty for cluster-scoped resources \"\" (empty) means \"all\" for namespace scoped resources from a SubjectAccessReview or SelfSubjectAccessReview",
          "type": "string"
        },
        "resource": {
          "description": "Resource is one of the existing resource types.  \"*\" means all.",
          "type": "string"
        },
        "subresource": {
          "description": "Subresource is one of the existing resource types.  \"\" means none.",
          "type": "string"
        },
        "verb": {
          "description": "Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete, proxy.  \"*\" means all.",
          "type": "string"
        },
        "version": {
          "description": "Version is the API Version of the Resource.  \"*\" means all.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.authorization.v1.ResourceRule": {
      "description": "ResourceRule is the list of actions the subject is allowed to perform on resources. The list ordering isn't significant, may contain duplicates, and possibly be incomplete.",
      "type": "object",
      "required": ["verbs"],
      "properties": {
        "apiGroups": {
          "description": "APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be allowed.  \"*\" means all.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "resourceNames": {
          "description": "ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.  \"*\" means all.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "resources": {
          "description": "Resources is a list of resources this rule applies to.  \"*\" means all in the specified apiGroups.\n \"*/foo\" represents the subresource 'foo' for all resources in the specified apiGroups.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "verbs": {
          "description": "Verb is a list of kubernetes resource API verbs, like: get, list, watch, create, update, delete, proxy.  \"*\" means all.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.authorization.v1.SelfSubjectAccessReview": {
      "description": "SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able to check whether they can perform an action",
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["authorization.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SelfSubjectAccessReview"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec holds information about the request being evaluated.  user and groups must be empty",
          "$ref": "#/definitions/io.k8s.api.authorization.v1.SelfSubjectAccessReviewSpec"
        },
        "status": {
          "description": "Status is filled in by the server and indicates whether the request is allowed or not",
          "$ref": "#/definitions/io.k8s.api.authorization.v1.SubjectAccessReviewStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "authorization.k8s.io",
          "kind": "SelfSubjectAccessReview",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.authorization.v1.SelfSubjectAccessReviewSpec": {
      "description": "SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set",
      "type": "object",
      "properties": {
        "nonResourceAttributes": {
          "description": "NonResourceAttributes describes information for a non-resource access request",
          "$ref": "#/definitions/io.k8s.api.authorization.v1.NonResourceAttributes"
        },
        "resourceAttributes": {
          "description": "ResourceAuthorizationAttributes describes information for a resource access request",
          "$ref": "#/definitions/io.k8s.api.authorization.v1.ResourceAttributes"
        }
      }
    },
    "io.k8s.api.authorization.v1.SelfSubjectRulesReview": {
      "description": "SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server.",
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["authorization.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SelfSubjectRulesReview"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec holds information about the request being evaluated.",
          "$ref": "#/definitions/io.k8s.api.authorization.v1.SelfSubjectRulesReviewSpec"
        },
        "status": {
          "description": "Status is filled in by the server and indicates the set of actions a user can perform.",
          "$ref": "#/definitions/io.k8s.api.authorization.v1.SubjectRulesReviewStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "authorization.k8s.io",
          "kind": "SelfSubjectRulesReview",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.authorization.v1.SelfSubjectRulesReviewSpec": {
      "description": "SelfSubjectRulesReviewSpec defines the specification for SelfSubjectRulesReview.",
      "type": "object",
      "properties": {
        "namespace": {
          "description": "Namespace to evaluate rules for. Required.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.authorization.v1.SubjectAccessReview": {
      "description": "SubjectAccessReview checks whether or not a user or group can perform an action.",
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["authorization.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SubjectAccessReview"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec holds information about the request being evaluated",
          "$ref": "#/definitions/io.k8s.api.authorization.v1.SubjectAccessReviewSpec"
        },
        "status": {
          "description": "Status is filled in by the server and indicates whether the request is allowed or not",
          "$ref": "#/definitions/io.k8s.api.authorization.v1.SubjectAccessReviewStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "authorization.k8s.io",
          "kind": "SubjectAccessReview",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.authorization.v1.SubjectAccessReviewSpec": {
      "description": "SubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set",
      "type": "object",
      "properties": {
        "extra": {
          "description": "Extra corresponds to the user.Info.GetExtra() method from the authenticator.  Since that is input to the authorizer it needs a reflection here.",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "groups": {
          "description": "Groups is the groups you're testing for.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "nonResourceAttributes": {
          "description": "NonResourceAttributes describes information for a non-resource access request",
          "$ref": "#/definitions/io.k8s.api.authorization.v1.NonResourceAttributes"
        },
        "resourceAttributes": {
          "description": "ResourceAuthorizationAttributes describes information for a resource access request",
          "$ref": "#/definitions/io.k8s.api.authorization.v1.ResourceAttributes"
        },
        "uid": {
          "description": "UID information about the requesting user.",
          "type": "string"
        },
        "user": {
          "description": "User is the user you're testing for. If you specify \"User\" but not \"Groups\", then is it interpreted as \"What if User were not a member of any groups",
          "type": "string"
        }
      }
    },
    "io.k8s.api.authorization.v1.SubjectAccessReviewStatus": {
      "description": "SubjectAccessReviewStatus",
      "type": "object",
      "required": ["allowed"],
      "properties": {
        "allowed": {
          "description": "Allowed is required. True if the action would be allowed, false otherwise.",
          "type": "boolean"
        },
        "denied": {
          "description": "Denied is optional. True if the action would be denied, otherwise false. If both allowed is false and denied is false, then the authorizer has no opinion on whether to authorize the action. Denied may not be true if Allowed is true.",
          "type": "boolean"
        },
        "evaluationError": {
          "description": "EvaluationError is an indication that some error occurred during the authorization check. It is entirely possible to get an error and be able to continue determine authorization status in spite of it. For instance, RBAC can be missing a role, but enough roles are still present and bound to reason about the request.",
          "type": "string"
        },
        "reason": {
          "description": "Reason is optional.  It indicates why a request was allowed or denied.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.authorization.v1.SubjectRulesReviewStatus": {
      "description": "SubjectRulesReviewStatus contains the result of a rules check. This check can be incomplete depending on the set of authorizers the server is configured with and any errors experienced during evaluation. Because authorization rules are additive, if a rule appears in a list it's safe to assume the subject has that permission, even if that list is incomplete.",
      "type": "object",
      "required": ["resourceRules", "nonResourceRules", "incomplete"],
      "properties": {
        "evaluationError": {
          "description": "EvaluationError can appear in combination with Rules. It indicates an error occurred during rule evaluation, such as an authorizer that doesn't support rule evaluation, and that ResourceRules and/or NonResourceRules may be incomplete.",
          "type": "string"
        },
        "incomplete": {
          "description": "Incomplete is true when the rules returned by this call are incomplete. This is most commonly encountered when an authorizer, such as an external authorizer, doesn't support rules evaluation.",
          "type": "boolean"
        },
        "nonResourceRules": {
          "description": "NonResourceRules is the list of actions the subject is allowed to perform on non-resources. The list ordering isn't significant, may contain duplicates, and possibly be incomplete.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.authorization.v1.NonResourceRule"
          }
        },
        "resourceRules": {
          "description": "ResourceRules is the list of actions the subject is allowed to perform on resources. The list ordering isn't significant, may contain duplicates, and possibly be incomplete.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.authorization.v1.ResourceRule"
          }
        }
      }
    },
    "io.k8s.api.autoscaling.v1.CrossVersionObjectReference": {
      "description": "CrossVersionObjectReference contains enough information to let you identify the referred resource.",
      "type": "object",
      "required": ["kind", "name"],
      "properties": {
        "apiVersion": {
          "description": "API version of the referent",
          "type": "string"
        },
        "kind": {
          "description": "Kind of the referent; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\"",
          "type": "string"
        },
        "name": {
          "description": "Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names",
          "type": "string"
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.autoscaling.v1.HorizontalPodAutoscaler": {
      "description": "configuration of a horizontal pod autoscaler.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["autoscaling/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["HorizontalPodAutoscaler"]
        },
        "metadata": {
          "description": "Standard object metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "behaviour of autoscaler. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerSpec"
        },
        "status": {
          "description": "current information about the autoscaler.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "autoscaling",
          "kind": "HorizontalPodAutoscaler",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerList": {
      "description": "list of horizontal pod autoscaler objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["autoscaling/v1"]
        },
        "items": {
          "description": "list of horizontal pod autoscaler objects.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.autoscaling.v1.HorizontalPodAutoscaler"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["HorizontalPodAutoscalerList"]
        },
        "metadata": {
          "description": "Standard list metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "autoscaling",
          "kind": "HorizontalPodAutoscalerList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerSpec": {
      "description": "specification of a horizontal pod autoscaler.",
      "type": "object",
      "required": ["scaleTargetRef", "maxReplicas"],
      "properties": {
        "maxReplicas": {
          "description": "upper limit for the number of pods that can be set by the autoscaler; cannot be smaller than MinReplicas.",
          "type": "integer",
          "format": "int32"
        },
        "minReplicas": {
          "description": "minReplicas is the lower limit for the number of replicas to which the autoscaler can scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the alpha feature gate HPAScaleToZero is enabled and at least one Object or External metric is configured.  Scaling is active as long as at least one metric value is available.",
          "type": "integer",
          "format": "int32"
        },
        "scaleTargetRef": {
          "description": "reference to scaled resource; horizontal pod autoscaler will learn the current resource consumption and will set the desired number of pods by using its Scale subresource.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v1.CrossVersionObjectReference"
        },
        "targetCPUUtilizationPercentage": {
          "description": "target average CPU utilization (represented as a percentage of requested CPU) over all the pods; if not specified the default autoscaling policy will be used.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerStatus": {
      "description": "current status of a horizontal pod autoscaler",
      "type": "object",
      "required": ["currentReplicas", "desiredReplicas"],
      "properties": {
        "currentCPUUtilizationPercentage": {
          "description": "current average CPU utilization over all pods, represented as a percentage of requested CPU, e.g. 70 means that an average pod is using now 70% of its requested CPU.",
          "type": "integer",
          "format": "int32"
        },
        "currentReplicas": {
          "description": "current number of replicas of pods managed by this autoscaler.",
          "type": "integer",
          "format": "int32"
        },
        "desiredReplicas": {
          "description": "desired number of replicas of pods managed by this autoscaler.",
          "type": "integer",
          "format": "int32"
        },
        "lastScaleTime": {
          "description": "last time the HorizontalPodAutoscaler scaled the number of pods; used by the autoscaler to control how often the number of pods is changed.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "observedGeneration": {
          "description": "most recent generation observed by this autoscaler.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "io.k8s.api.autoscaling.v1.Scale": {
      "description": "Scale represents a scaling request for a resource.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["autoscaling/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Scale"]
        },
        "metadata": {
          "description": "Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v1.ScaleSpec"
        },
        "status": {
          "description": "current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v1.ScaleStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "autoscaling",
          "kind": "Scale",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.autoscaling.v1.ScaleSpec": {
      "description": "ScaleSpec describes the attributes of a scale subresource.",
      "type": "object",
      "properties": {
        "replicas": {
          "description": "desired number of instances for the scaled object.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.autoscaling.v1.ScaleStatus": {
      "description": "ScaleStatus represents the current status of a scale subresource.",
      "type": "object",
      "required": ["replicas"],
      "properties": {
        "replicas": {
          "description": "actual number of observed instances of the scaled object.",
          "type": "integer",
          "format": "int32"
        },
        "selector": {
          "description": "label query over pods that should match the replicas count. This is same as the label selector but in the string format to avoid introspection by clients. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors",
          "type": "string"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta1.ContainerResourceMetricSource": {
      "description": "ContainerResourceMetricSource indicates how to scale on a resource metric known to Kubernetes, as specified in requests and limits, describing each pod in the current scale target (e.g. CPU or memory).  The values will be averaged together before being compared to the target.  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.  Only one \"target\" type should be set.",
      "type": "object",
      "required": ["name", "container"],
      "properties": {
        "container": {
          "description": "container is the name of the container in the pods of the scaling target",
          "type": "string"
        },
        "name": {
          "description": "name is the name of the resource in question.",
          "type": "string"
        },
        "targetAverageUtilization": {
          "description": "targetAverageUtilization is the target value of the average of the resource metric across all relevant pods, represented as a percentage of the requested value of the resource for the pods.",
          "type": "integer",
          "format": "int32"
        },
        "targetAverageValue": {
          "description": "targetAverageValue is the target value of the average of the resource metric across all relevant pods, as a raw value (instead of as a percentage of the request), similar to the \"pods\" metric source type.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta1.ContainerResourceMetricStatus": {
      "description": "ContainerResourceMetricStatus indicates the current value of a resource metric known to Kubernetes, as specified in requests and limits, describing a single container in each pod in the current scale target (e.g. CPU or memory).  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.",
      "type": "object",
      "required": ["name", "currentAverageValue", "container"],
      "properties": {
        "container": {
          "description": "container is the name of the container in the pods of the scaling target",
          "type": "string"
        },
        "currentAverageUtilization": {
          "description": "currentAverageUtilization is the current value of the average of the resource metric across all relevant pods, represented as a percentage of the requested value of the resource for the pods.  It will only be present if `targetAverageValue` was set in the corresponding metric specification.",
          "type": "integer",
          "format": "int32"
        },
        "currentAverageValue": {
          "description": "currentAverageValue is the current value of the average of the resource metric across all relevant pods, as a raw value (instead of as a percentage of the request), similar to the \"pods\" metric source type. It will always be set, regardless of the corresponding metric specification.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        },
        "name": {
          "description": "name is the name of the resource in question.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta1.CrossVersionObjectReference": {
      "description": "CrossVersionObjectReference contains enough information to let you identify the referred resource.",
      "type": "object",
      "required": ["kind", "name"],
      "properties": {
        "apiVersion": {
          "description": "API version of the referent",
          "type": "string"
        },
        "kind": {
          "description": "Kind of the referent; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\"",
          "type": "string"
        },
        "name": {
          "description": "Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names",
          "type": "string"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta1.ExternalMetricSource": {
      "description": "ExternalMetricSource indicates how to scale on a metric not associated with any Kubernetes object (for example length of queue in cloud messaging service, or QPS from loadbalancer running outside of cluster). Exactly one \"target\" type should be set.",
      "type": "object",
      "required": ["metricName"],
      "properties": {
        "metricName": {
          "description": "metricName is the name of the metric in question.",
          "type": "string"
        },
        "metricSelector": {
          "description": "metricSelector is used to identify a specific time series within a given metric.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "targetAverageValue": {
          "description": "targetAverageValue is the target per-pod value of global metric (as a quantity). Mutually exclusive with TargetValue.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        },
        "targetValue": {
          "description": "targetValue is the target value of the metric (as a quantity). Mutually exclusive with TargetAverageValue.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta1.ExternalMetricStatus": {
      "description": "ExternalMetricStatus indicates the current value of a global metric not associated with any Kubernetes object.",
      "type": "object",
      "required": ["metricName", "currentValue"],
      "properties": {
        "currentAverageValue": {
          "description": "currentAverageValue is the current value of metric averaged over autoscaled pods.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        },
        "currentValue": {
          "description": "currentValue is the current value of the metric (as a quantity)",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        },
        "metricName": {
          "description": "metricName is the name of a metric used for autoscaling in metric system.",
          "type": "string"
        },
        "metricSelector": {
          "description": "metricSelector is used to identify a specific time series within a given metric.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscaler": {
      "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["autoscaling/v2beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["HorizontalPodAutoscaler"]
        },
        "metadata": {
          "description": "metadata is the standard object metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "spec is the specification for the behaviour of the autoscaler. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscalerSpec"
        },
        "status": {
          "description": "status is the current information about the autoscaler.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscalerStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "autoscaling",
          "kind": "HorizontalPodAutoscaler",
          "version": "v2beta1"
        }
      ]
    },
    "io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscalerCondition": {
      "description": "HorizontalPodAutoscalerCondition describes the state of a HorizontalPodAutoscaler at a certain point.",
      "type": "object",
      "required": ["type", "status"],
      "properties": {
        "lastTransitionTime": {
          "description": "lastTransitionTime is the last time the condition transitioned from one status to another",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "message is a human-readable explanation containing details about the transition",
          "type": "string"
        },
        "reason": {
          "description": "reason is the reason for the condition's last transition.",
          "type": "string"
        },
        "status": {
          "description": "status is the status of the condition (True, False, Unknown)",
          "type": "string"
        },
        "type": {
          "description": "type describes the current condition",
          "type": "string"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscalerList": {
      "description": "HorizontalPodAutoscaler is a list of horizontal pod autoscaler objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["autoscaling/v2beta1"]
        },
        "items": {
          "description": "items is the list of horizontal pod autoscaler objects.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscaler"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["HorizontalPodAutoscalerList"]
        },
        "metadata": {
          "description": "metadata is the standard list metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "autoscaling",
          "kind": "HorizontalPodAutoscalerList",
          "version": "v2beta1"
        }
      ]
    },
    "io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscalerSpec": {
      "description": "HorizontalPodAutoscalerSpec describes the desired functionality of the HorizontalPodAutoscaler.",
      "type": "object",
      "required": ["scaleTargetRef", "maxReplicas"],
      "properties": {
        "maxReplicas": {
          "description": "maxReplicas is the upper limit for the number of replicas to which the autoscaler can scale up. It cannot be less that minReplicas.",
          "type": "integer",
          "format": "int32"
        },
        "metrics": {
          "description": "metrics contains the specifications for which to use to calculate the desired replica count (the maximum replica count across all metrics will be used).  The desired replica count is calculated multiplying the ratio between the target value and the current value by the current number of pods.  Ergo, metrics used must decrease as the pod count is increased, and vice-versa.  See the individual metric source types for more information about how each type of metric must respond.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.MetricSpec"
          }
        },
        "minReplicas": {
          "description": "minReplicas is the lower limit for the number of replicas to which the autoscaler can scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the alpha feature gate HPAScaleToZero is enabled and at least one Object or External metric is configured.  Scaling is active as long as at least one metric value is available.",
          "type": "integer",
          "format": "int32"
        },
        "scaleTargetRef": {
          "description": "scaleTargetRef points to the target resource to scale, and is used to the pods for which metrics should be collected, as well as to actually change the replica count.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.CrossVersionObjectReference"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscalerStatus": {
      "description": "HorizontalPodAutoscalerStatus describes the current status of a horizontal pod autoscaler.",
      "type": "object",
      "required": ["currentReplicas", "desiredReplicas", "conditions"],
      "properties": {
        "conditions": {
          "description": "conditions is the set of conditions required for this autoscaler to scale its target, and indicates whether or not those conditions are met.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscalerCondition"
          }
        },
        "currentMetrics": {
          "description": "currentMetrics is the last read state of the metrics used by this autoscaler.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.MetricStatus"
          }
        },
        "currentReplicas": {
          "description": "currentReplicas is current number of replicas of pods managed by this autoscaler, as last seen by the autoscaler.",
          "type": "integer",
          "format": "int32"
        },
        "desiredReplicas": {
          "description": "desiredReplicas is the desired number of replicas of pods managed by this autoscaler, as last calculated by the autoscaler.",
          "type": "integer",
          "format": "int32"
        },
        "lastScaleTime": {
          "description": "lastScaleTime is the last time the HorizontalPodAutoscaler scaled the number of pods, used by the autoscaler to control how often the number of pods is changed.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "observedGeneration": {
          "description": "observedGeneration is the most recent generation observed by this autoscaler.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta1.MetricSpec": {
      "description": "MetricSpec specifies how to scale based on a single metric (only `type` and one other matching field should be set at once).",
      "type": "object",
      "required": ["type"],
      "properties": {
        "containerResource": {
          "description": "container resource refers to a resource metric (such as those specified in requests and limits) known to Kubernetes describing a single container in each pod of the current scale target (e.g. CPU or memory). Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source. This is an alpha feature and can be enabled by the HPAContainerMetrics feature flag.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.ContainerResourceMetricSource"
        },
        "external": {
          "description": "external refers to a global metric that is not associated with any Kubernetes object. It allows autoscaling based on information coming from components running outside of cluster (for example length of queue in cloud messaging service, or QPS from loadbalancer running outside of cluster).",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.ExternalMetricSource"
        },
        "object": {
          "description": "object refers to a metric describing a single kubernetes object (for example, hits-per-second on an Ingress object).",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.ObjectMetricSource"
        },
        "pods": {
          "description": "pods refers to a metric describing each pod in the current scale target (for example, transactions-processed-per-second).  The values will be averaged together before being compared to the target value.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.PodsMetricSource"
        },
        "resource": {
          "description": "resource refers to a resource metric (such as those specified in requests and limits) known to Kubernetes describing each pod in the current scale target (e.g. CPU or memory). Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.ResourceMetricSource"
        },
        "type": {
          "description": "type is the type of metric source.  It should be one of \"ContainerResource\", \"External\", \"Object\", \"Pods\" or \"Resource\", each mapping to a matching field in the object. Note: \"ContainerResource\" type is available on when the feature-gate HPAContainerMetrics is enabled",
          "type": "string"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta1.MetricStatus": {
      "description": "MetricStatus describes the last-read state of a single metric.",
      "type": "object",
      "required": ["type"],
      "properties": {
        "containerResource": {
          "description": "container resource refers to a resource metric (such as those specified in requests and limits) known to Kubernetes describing a single container in each pod in the current scale target (e.g. CPU or memory). Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.ContainerResourceMetricStatus"
        },
        "external": {
          "description": "external refers to a global metric that is not associated with any Kubernetes object. It allows autoscaling based on information coming from components running outside of cluster (for example length of queue in cloud messaging service, or QPS from loadbalancer running outside of cluster).",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.ExternalMetricStatus"
        },
        "object": {
          "description": "object refers to a metric describing a single kubernetes object (for example, hits-per-second on an Ingress object).",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.ObjectMetricStatus"
        },
        "pods": {
          "description": "pods refers to a metric describing each pod in the current scale target (for example, transactions-processed-per-second).  The values will be averaged together before being compared to the target value.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.PodsMetricStatus"
        },
        "resource": {
          "description": "resource refers to a resource metric (such as those specified in requests and limits) known to Kubernetes describing each pod in the current scale target (e.g. CPU or memory). Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.ResourceMetricStatus"
        },
        "type": {
          "description": "type is the type of metric source.  It will be one of \"ContainerResource\", \"External\", \"Object\", \"Pods\" or \"Resource\", each corresponds to a matching field in the object. Note: \"ContainerResource\" type is available on when the feature-gate HPAContainerMetrics is enabled",
          "type": "string"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta1.ObjectMetricSource": {
      "description": "ObjectMetricSource indicates how to scale on a metric describing a kubernetes object (for example, hits-per-second on an Ingress object).",
      "type": "object",
      "required": ["target", "metricName", "targetValue"],
      "properties": {
        "averageValue": {
          "description": "averageValue is the target value of the average of the metric across all relevant pods (as a quantity)",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        },
        "metricName": {
          "description": "metricName is the name of the metric in question.",
          "type": "string"
        },
        "selector": {
          "description": "selector is the string-encoded form of a standard kubernetes label selector for the given metric When set, it is passed as an additional parameter to the metrics server for more specific metrics scoping When unset, just the metricName will be used to gather metrics.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "target": {
          "description": "target is the described Kubernetes object.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.CrossVersionObjectReference"
        },
        "targetValue": {
          "description": "targetValue is the target value of the metric (as a quantity).",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta1.ObjectMetricStatus": {
      "description": "ObjectMetricStatus indicates the current value of a metric describing a kubernetes object (for example, hits-per-second on an Ingress object).",
      "type": "object",
      "required": ["target", "metricName", "currentValue"],
      "properties": {
        "averageValue": {
          "description": "averageValue is the current value of the average of the metric across all relevant pods (as a quantity)",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        },
        "currentValue": {
          "description": "currentValue is the current value of the metric (as a quantity).",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        },
        "metricName": {
          "description": "metricName is the name of the metric in question.",
          "type": "string"
        },
        "selector": {
          "description": "selector is the string-encoded form of a standard kubernetes label selector for the given metric When set in the ObjectMetricSource, it is passed as an additional parameter to the metrics server for more specific metrics scoping. When unset, just the metricName will be used to gather metrics.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "target": {
          "description": "target is the described Kubernetes object.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta1.CrossVersionObjectReference"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta1.PodsMetricSource": {
      "description": "PodsMetricSource indicates how to scale on a metric describing each pod in the current scale target (for example, transactions-processed-per-second). The values will be averaged together before being compared to the target value.",
      "type": "object",
      "required": ["metricName", "targetAverageValue"],
      "properties": {
        "metricName": {
          "description": "metricName is the name of the metric in question",
          "type": "string"
        },
        "selector": {
          "description": "selector is the string-encoded form of a standard kubernetes label selector for the given metric When set, it is passed as an additional parameter to the metrics server for more specific metrics scoping When unset, just the metricName will be used to gather metrics.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "targetAverageValue": {
          "description": "targetAverageValue is the target value of the average of the metric across all relevant pods (as a quantity)",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta1.PodsMetricStatus": {
      "description": "PodsMetricStatus indicates the current value of a metric describing each pod in the current scale target (for example, transactions-processed-per-second).",
      "type": "object",
      "required": ["metricName", "currentAverageValue"],
      "properties": {
        "currentAverageValue": {
          "description": "currentAverageValue is the current value of the average of the metric across all relevant pods (as a quantity)",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        },
        "metricName": {
          "description": "metricName is the name of the metric in question",
          "type": "string"
        },
        "selector": {
          "description": "selector is the string-encoded form of a standard kubernetes label selector for the given metric When set in the PodsMetricSource, it is passed as an additional parameter to the metrics server for more specific metrics scoping. When unset, just the metricName will be used to gather metrics.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta1.ResourceMetricSource": {
      "description": "ResourceMetricSource indicates how to scale on a resource metric known to Kubernetes, as specified in requests and limits, describing each pod in the current scale target (e.g. CPU or memory).  The values will be averaged together before being compared to the target.  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.  Only one \"target\" type should be set.",
      "type": "object",
      "required": ["name"],
      "properties": {
        "name": {
          "description": "name is the name of the resource in question.",
          "type": "string"
        },
        "targetAverageUtilization": {
          "description": "targetAverageUtilization is the target value of the average of the resource metric across all relevant pods, represented as a percentage of the requested value of the resource for the pods.",
          "type": "integer",
          "format": "int32"
        },
        "targetAverageValue": {
          "description": "targetAverageValue is the target value of the average of the resource metric across all relevant pods, as a raw value (instead of as a percentage of the request), similar to the \"pods\" metric source type.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta1.ResourceMetricStatus": {
      "description": "ResourceMetricStatus indicates the current value of a resource metric known to Kubernetes, as specified in requests and limits, describing each pod in the current scale target (e.g. CPU or memory).  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.",
      "type": "object",
      "required": ["name", "currentAverageValue"],
      "properties": {
        "currentAverageUtilization": {
          "description": "currentAverageUtilization is the current value of the average of the resource metric across all relevant pods, represented as a percentage of the requested value of the resource for the pods.  It will only be present if `targetAverageValue` was set in the corresponding metric specification.",
          "type": "integer",
          "format": "int32"
        },
        "currentAverageValue": {
          "description": "currentAverageValue is the current value of the average of the resource metric across all relevant pods, as a raw value (instead of as a percentage of the request), similar to the \"pods\" metric source type. It will always be set, regardless of the corresponding metric specification.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        },
        "name": {
          "description": "name is the name of the resource in question.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.ContainerResourceMetricSource": {
      "description": "ContainerResourceMetricSource indicates how to scale on a resource metric known to Kubernetes, as specified in requests and limits, describing each pod in the current scale target (e.g. CPU or memory).  The values will be averaged together before being compared to the target.  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.  Only one \"target\" type should be set.",
      "type": "object",
      "required": ["name", "target", "container"],
      "properties": {
        "container": {
          "description": "container is the name of the container in the pods of the scaling target",
          "type": "string"
        },
        "name": {
          "description": "name is the name of the resource in question.",
          "type": "string"
        },
        "target": {
          "description": "target specifies the target value for the given metric",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricTarget"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.ContainerResourceMetricStatus": {
      "description": "ContainerResourceMetricStatus indicates the current value of a resource metric known to Kubernetes, as specified in requests and limits, describing a single container in each pod in the current scale target (e.g. CPU or memory).  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.",
      "type": "object",
      "required": ["name", "current", "container"],
      "properties": {
        "container": {
          "description": "Container is the name of the container in the pods of the scaling target",
          "type": "string"
        },
        "current": {
          "description": "current contains the current value for the given metric",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricValueStatus"
        },
        "name": {
          "description": "Name is the name of the resource in question.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.CrossVersionObjectReference": {
      "description": "CrossVersionObjectReference contains enough information to let you identify the referred resource.",
      "type": "object",
      "required": ["kind", "name"],
      "properties": {
        "apiVersion": {
          "description": "API version of the referent",
          "type": "string"
        },
        "kind": {
          "description": "Kind of the referent; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\"",
          "type": "string"
        },
        "name": {
          "description": "Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names",
          "type": "string"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.ExternalMetricSource": {
      "description": "ExternalMetricSource indicates how to scale on a metric not associated with any Kubernetes object (for example length of queue in cloud messaging service, or QPS from loadbalancer running outside of cluster).",
      "type": "object",
      "required": ["metric", "target"],
      "properties": {
        "metric": {
          "description": "metric identifies the target metric by name and selector",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricIdentifier"
        },
        "target": {
          "description": "target specifies the target value for the given metric",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricTarget"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.ExternalMetricStatus": {
      "description": "ExternalMetricStatus indicates the current value of a global metric not associated with any Kubernetes object.",
      "type": "object",
      "required": ["metric", "current"],
      "properties": {
        "current": {
          "description": "current contains the current value for the given metric",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricValueStatus"
        },
        "metric": {
          "description": "metric identifies the target metric by name and selector",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricIdentifier"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.HPAScalingPolicy": {
      "description": "HPAScalingPolicy is a single policy which must hold true for a specified past interval.",
      "type": "object",
      "required": ["type", "value", "periodSeconds"],
      "properties": {
        "periodSeconds": {
          "description": "PeriodSeconds specifies the window of time for which the policy should hold true. PeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).",
          "type": "integer",
          "format": "int32"
        },
        "type": {
          "description": "Type is used to specify the scaling policy.",
          "type": "string"
        },
        "value": {
          "description": "Value contains the amount of change which is permitted by the policy. It must be greater than zero",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.HPAScalingRules": {
      "description": "HPAScalingRules configures the scaling behavior for one direction. These Rules are applied after calculating DesiredReplicas from metrics for the HPA. They can limit the scaling velocity by specifying scaling policies. They can prevent flapping by specifying the stabilization window, so that the number of replicas is not set instantly, instead, the safest value from the stabilization window is chosen.",
      "type": "object",
      "properties": {
        "policies": {
          "description": "policies is a list of potential scaling polices which can be used during scaling. At least one policy must be specified, otherwise the HPAScalingRules will be discarded as invalid",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.HPAScalingPolicy"
          }
        },
        "selectPolicy": {
          "description": "selectPolicy is used to specify which policy should be used. If not set, the default value MaxPolicySelect is used.",
          "type": "string"
        },
        "stabilizationWindowSeconds": {
          "description": "StabilizationWindowSeconds is the number of seconds for which past recommendations should be considered while scaling up or scaling down. StabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour). If not set, use the default values: - For scale up: 0 (i.e. no stabilization is done). - For scale down: 300 (i.e. the stabilization window is 300 seconds long).",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscaler": {
      "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["autoscaling/v2beta2"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["HorizontalPodAutoscaler"]
        },
        "metadata": {
          "description": "metadata is the standard object metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "spec is the specification for the behaviour of the autoscaler. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscalerSpec"
        },
        "status": {
          "description": "status is the current information about the autoscaler.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscalerStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "autoscaling",
          "kind": "HorizontalPodAutoscaler",
          "version": "v2beta2"
        }
      ]
    },
    "io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscalerBehavior": {
      "description": "HorizontalPodAutoscalerBehavior configures the scaling behavior of the target in both Up and Down directions (scaleUp and scaleDown fields respectively).",
      "type": "object",
      "properties": {
        "scaleDown": {
          "description": "scaleDown is scaling policy for scaling Down. If not set, the default value is to allow to scale down to minReplicas pods, with a 300 second stabilization window (i.e., the highest recommendation for the last 300sec is used).",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.HPAScalingRules"
        },
        "scaleUp": {
          "description": "scaleUp is scaling policy for scaling Up. If not set, the default value is the higher of:\n  * increase no more than 4 pods per 60 seconds\n  * double the number of pods per 60 seconds\nNo stabilization is used.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.HPAScalingRules"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscalerCondition": {
      "description": "HorizontalPodAutoscalerCondition describes the state of a HorizontalPodAutoscaler at a certain point.",
      "type": "object",
      "required": ["type", "status"],
      "properties": {
        "lastTransitionTime": {
          "description": "lastTransitionTime is the last time the condition transitioned from one status to another",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "message is a human-readable explanation containing details about the transition",
          "type": "string"
        },
        "reason": {
          "description": "reason is the reason for the condition's last transition.",
          "type": "string"
        },
        "status": {
          "description": "status is the status of the condition (True, False, Unknown)",
          "type": "string"
        },
        "type": {
          "description": "type describes the current condition",
          "type": "string"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscalerList": {
      "description": "HorizontalPodAutoscalerList is a list of horizontal pod autoscaler objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["autoscaling/v2beta2"]
        },
        "items": {
          "description": "items is the list of horizontal pod autoscaler objects.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscaler"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["HorizontalPodAutoscalerList"]
        },
        "metadata": {
          "description": "metadata is the standard list metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "autoscaling",
          "kind": "HorizontalPodAutoscalerList",
          "version": "v2beta2"
        }
      ]
    },
    "io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscalerSpec": {
      "description": "HorizontalPodAutoscalerSpec describes the desired functionality of the HorizontalPodAutoscaler.",
      "type": "object",
      "required": ["scaleTargetRef", "maxReplicas"],
      "properties": {
        "behavior": {
          "description": "behavior configures the scaling behavior of the target in both Up and Down directions (scaleUp and scaleDown fields respectively). If not set, the default HPAScalingRules for scale up and scale down are used.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscalerBehavior"
        },
        "maxReplicas": {
          "description": "maxReplicas is the upper limit for the number of replicas to which the autoscaler can scale up. It cannot be less that minReplicas.",
          "type": "integer",
          "format": "int32"
        },
        "metrics": {
          "description": "metrics contains the specifications for which to use to calculate the desired replica count (the maximum replica count across all metrics will be used).  The desired replica count is calculated multiplying the ratio between the target value and the current value by the current number of pods.  Ergo, metrics used must decrease as the pod count is increased, and vice-versa.  See the individual metric source types for more information about how each type of metric must respond. If not set, the default metric will be set to 80% average CPU utilization.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricSpec"
          }
        },
        "minReplicas": {
          "description": "minReplicas is the lower limit for the number of replicas to which the autoscaler can scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the alpha feature gate HPAScaleToZero is enabled and at least one Object or External metric is configured.  Scaling is active as long as at least one metric value is available.",
          "type": "integer",
          "format": "int32"
        },
        "scaleTargetRef": {
          "description": "scaleTargetRef points to the target resource to scale, and is used to the pods for which metrics should be collected, as well as to actually change the replica count.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.CrossVersionObjectReference"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscalerStatus": {
      "description": "HorizontalPodAutoscalerStatus describes the current status of a horizontal pod autoscaler.",
      "type": "object",
      "required": ["currentReplicas", "desiredReplicas", "conditions"],
      "properties": {
        "conditions": {
          "description": "conditions is the set of conditions required for this autoscaler to scale its target, and indicates whether or not those conditions are met.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscalerCondition"
          }
        },
        "currentMetrics": {
          "description": "currentMetrics is the last read state of the metrics used by this autoscaler.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricStatus"
          }
        },
        "currentReplicas": {
          "description": "currentReplicas is current number of replicas of pods managed by this autoscaler, as last seen by the autoscaler.",
          "type": "integer",
          "format": "int32"
        },
        "desiredReplicas": {
          "description": "desiredReplicas is the desired number of replicas of pods managed by this autoscaler, as last calculated by the autoscaler.",
          "type": "integer",
          "format": "int32"
        },
        "lastScaleTime": {
          "description": "lastScaleTime is the last time the HorizontalPodAutoscaler scaled the number of pods, used by the autoscaler to control how often the number of pods is changed.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "observedGeneration": {
          "description": "observedGeneration is the most recent generation observed by this autoscaler.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.MetricIdentifier": {
      "description": "MetricIdentifier defines the name and optionally selector for a metric",
      "type": "object",
      "required": ["name"],
      "properties": {
        "name": {
          "description": "name is the name of the given metric",
          "type": "string"
        },
        "selector": {
          "description": "selector is the string-encoded form of a standard kubernetes label selector for the given metric When set, it is passed as an additional parameter to the metrics server for more specific metrics scoping. When unset, just the metricName will be used to gather metrics.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.MetricSpec": {
      "description": "MetricSpec specifies how to scale based on a single metric (only `type` and one other matching field should be set at once).",
      "type": "object",
      "required": ["type"],
      "properties": {
        "containerResource": {
          "description": "container resource refers to a resource metric (such as those specified in requests and limits) known to Kubernetes describing a single container in each pod of the current scale target (e.g. CPU or memory). Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source. This is an alpha feature and can be enabled by the HPAContainerMetrics feature flag.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.ContainerResourceMetricSource"
        },
        "external": {
          "description": "external refers to a global metric that is not associated with any Kubernetes object. It allows autoscaling based on information coming from components running outside of cluster (for example length of queue in cloud messaging service, or QPS from loadbalancer running outside of cluster).",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.ExternalMetricSource"
        },
        "object": {
          "description": "object refers to a metric describing a single kubernetes object (for example, hits-per-second on an Ingress object).",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.ObjectMetricSource"
        },
        "pods": {
          "description": "pods refers to a metric describing each pod in the current scale target (for example, transactions-processed-per-second).  The values will be averaged together before being compared to the target value.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.PodsMetricSource"
        },
        "resource": {
          "description": "resource refers to a resource metric (such as those specified in requests and limits) known to Kubernetes describing each pod in the current scale target (e.g. CPU or memory). Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.ResourceMetricSource"
        },
        "type": {
          "description": "type is the type of metric source.  It should be one of \"ContainerResource\", \"External\", \"Object\", \"Pods\" or \"Resource\", each mapping to a matching field in the object. Note: \"ContainerResource\" type is available on when the feature-gate HPAContainerMetrics is enabled",
          "type": "string"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.MetricStatus": {
      "description": "MetricStatus describes the last-read state of a single metric.",
      "type": "object",
      "required": ["type"],
      "properties": {
        "containerResource": {
          "description": "container resource refers to a resource metric (such as those specified in requests and limits) known to Kubernetes describing a single container in each pod in the current scale target (e.g. CPU or memory). Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.ContainerResourceMetricStatus"
        },
        "external": {
          "description": "external refers to a global metric that is not associated with any Kubernetes object. It allows autoscaling based on information coming from components running outside of cluster (for example length of queue in cloud messaging service, or QPS from loadbalancer running outside of cluster).",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.ExternalMetricStatus"
        },
        "object": {
          "description": "object refers to a metric describing a single kubernetes object (for example, hits-per-second on an Ingress object).",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.ObjectMetricStatus"
        },
        "pods": {
          "description": "pods refers to a metric describing each pod in the current scale target (for example, transactions-processed-per-second).  The values will be averaged together before being compared to the target value.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.PodsMetricStatus"
        },
        "resource": {
          "description": "resource refers to a resource metric (such as those specified in requests and limits) known to Kubernetes describing each pod in the current scale target (e.g. CPU or memory). Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.ResourceMetricStatus"
        },
        "type": {
          "description": "type is the type of metric source.  It will be one of \"ContainerResource\", \"External\", \"Object\", \"Pods\" or \"Resource\", each corresponds to a matching field in the object. Note: \"ContainerResource\" type is available on when the feature-gate HPAContainerMetrics is enabled",
          "type": "string"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.MetricTarget": {
      "description": "MetricTarget defines the target value, average value, or average utilization of a specific metric",
      "type": "object",
      "required": ["type"],
      "properties": {
        "averageUtilization": {
          "description": "averageUtilization is the target value of the average of the resource metric across all relevant pods, represented as a percentage of the requested value of the resource for the pods. Currently only valid for Resource metric source type",
          "type": "integer",
          "format": "int32"
        },
        "averageValue": {
          "description": "averageValue is the target value of the average of the metric across all relevant pods (as a quantity)",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        },
        "type": {
          "description": "type represents whether the metric type is Utilization, Value, or AverageValue",
          "type": "string"
        },
        "value": {
          "description": "value is the target value of the metric (as a quantity).",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.MetricValueStatus": {
      "description": "MetricValueStatus holds the current value for a metric",
      "type": "object",
      "properties": {
        "averageUtilization": {
          "description": "currentAverageUtilization is the current value of the average of the resource metric across all relevant pods, represented as a percentage of the requested value of the resource for the pods.",
          "type": "integer",
          "format": "int32"
        },
        "averageValue": {
          "description": "averageValue is the current value of the average of the metric across all relevant pods (as a quantity)",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        },
        "value": {
          "description": "value is the current value of the metric (as a quantity).",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.ObjectMetricSource": {
      "description": "ObjectMetricSource indicates how to scale on a metric describing a kubernetes object (for example, hits-per-second on an Ingress object).",
      "type": "object",
      "required": ["describedObject", "target", "metric"],
      "properties": {
        "describedObject": {
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.CrossVersionObjectReference"
        },
        "metric": {
          "description": "metric identifies the target metric by name and selector",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricIdentifier"
        },
        "target": {
          "description": "target specifies the target value for the given metric",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricTarget"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.ObjectMetricStatus": {
      "description": "ObjectMetricStatus indicates the current value of a metric describing a kubernetes object (for example, hits-per-second on an Ingress object).",
      "type": "object",
      "required": ["metric", "current", "describedObject"],
      "properties": {
        "current": {
          "description": "current contains the current value for the given metric",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricValueStatus"
        },
        "describedObject": {
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.CrossVersionObjectReference"
        },
        "metric": {
          "description": "metric identifies the target metric by name and selector",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricIdentifier"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.PodsMetricSource": {
      "description": "PodsMetricSource indicates how to scale on a metric describing each pod in the current scale target (for example, transactions-processed-per-second). The values will be averaged together before being compared to the target value.",
      "type": "object",
      "required": ["metric", "target"],
      "properties": {
        "metric": {
          "description": "metric identifies the target metric by name and selector",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricIdentifier"
        },
        "target": {
          "description": "target specifies the target value for the given metric",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricTarget"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.PodsMetricStatus": {
      "description": "PodsMetricStatus indicates the current value of a metric describing each pod in the current scale target (for example, transactions-processed-per-second).",
      "type": "object",
      "required": ["metric", "current"],
      "properties": {
        "current": {
          "description": "current contains the current value for the given metric",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricValueStatus"
        },
        "metric": {
          "description": "metric identifies the target metric by name and selector",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricIdentifier"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.ResourceMetricSource": {
      "description": "ResourceMetricSource indicates how to scale on a resource metric known to Kubernetes, as specified in requests and limits, describing each pod in the current scale target (e.g. CPU or memory).  The values will be averaged together before being compared to the target.  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.  Only one \"target\" type should be set.",
      "type": "object",
      "required": ["name", "target"],
      "properties": {
        "name": {
          "description": "name is the name of the resource in question.",
          "type": "string"
        },
        "target": {
          "description": "target specifies the target value for the given metric",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricTarget"
        }
      }
    },
    "io.k8s.api.autoscaling.v2beta2.ResourceMetricStatus": {
      "description": "ResourceMetricStatus indicates the current value of a resource metric known to Kubernetes, as specified in requests and limits, describing each pod in the current scale target (e.g. CPU or memory).  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.",
      "type": "object",
      "required": ["name", "current"],
      "properties": {
        "current": {
          "description": "current contains the current value for the given metric",
          "$ref": "#/definitions/io.k8s.api.autoscaling.v2beta2.MetricValueStatus"
        },
        "name": {
          "description": "Name is the name of the resource in question.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.batch.v1.CronJob": {
      "description": "CronJob represents the configuration of a single cron job.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["batch/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CronJob"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Specification of the desired behavior of a cron job, including the schedule. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.batch.v1.CronJobSpec"
        },
        "status": {
          "description": "Current status of a cron job. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.batch.v1.CronJobStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "batch",
          "kind": "CronJob",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.batch.v1.CronJobList": {
      "description": "CronJobList is a collection of cron jobs.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["batch/v1"]
        },
        "items": {
          "description": "items is the list of CronJobs.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.batch.v1.CronJob"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CronJobList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "batch",
          "kind": "CronJobList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.batch.v1.CronJobSpec": {
      "description": "CronJobSpec describes how the job execution will look like and when it will actually run.",
      "type": "object",
      "required": ["schedule", "jobTemplate"],
      "properties": {
        "concurrencyPolicy": {
          "description": "Specifies how to treat concurrent executions of a Job. Valid values are: - \"Allow\" (default): allows CronJobs to run concurrently; - \"Forbid\": forbids concurrent runs, skipping next run if previous run hasn't finished yet; - \"Replace\": cancels currently running job and replaces it with a new one",
          "type": "string"
        },
        "failedJobsHistoryLimit": {
          "description": "The number of failed finished jobs to retain. Value must be non-negative integer. Defaults to 1.",
          "type": "integer",
          "format": "int32"
        },
        "jobTemplate": {
          "description": "Specifies the job that will be created when executing a CronJob.",
          "$ref": "#/definitions/io.k8s.api.batch.v1.JobTemplateSpec"
        },
        "schedule": {
          "description": "The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.",
          "type": "string"
        },
        "startingDeadlineSeconds": {
          "description": "Optional deadline in seconds for starting the job if it misses scheduled time for any reason.  Missed jobs executions will be counted as failed ones.",
          "type": "integer",
          "format": "int64"
        },
        "successfulJobsHistoryLimit": {
          "description": "The number of successful finished jobs to retain. Value must be non-negative integer. Defaults to 3.",
          "type": "integer",
          "format": "int32"
        },
        "suspend": {
          "description": "This flag tells the controller to suspend subsequent executions, it does not apply to already started executions.  Defaults to false.",
          "type": "boolean"
        }
      }
    },
    "io.k8s.api.batch.v1.CronJobStatus": {
      "description": "CronJobStatus represents the current state of a cron job.",
      "type": "object",
      "properties": {
        "active": {
          "description": "A list of pointers to currently running jobs.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "lastScheduleTime": {
          "description": "Information when was the last time the job was successfully scheduled.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "lastSuccessfulTime": {
          "description": "Information when was the last time the job successfully completed.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        }
      }
    },
    "io.k8s.api.batch.v1.Job": {
      "description": "Job represents the configuration of a single job.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["batch/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Job"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Specification of the desired behavior of a job. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.batch.v1.JobSpec"
        },
        "status": {
          "description": "Current status of a job. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.batch.v1.JobStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "batch",
          "kind": "Job",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.batch.v1.JobCondition": {
      "description": "JobCondition describes current state of a job.",
      "type": "object",
      "required": ["type", "status"],
      "properties": {
        "lastProbeTime": {
          "description": "Last time the condition was checked.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "lastTransitionTime": {
          "description": "Last time the condition transit from one status to another.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "Human readable message indicating details about last transition.",
          "type": "string"
        },
        "reason": {
          "description": "(brief) reason for the condition's last transition.",
          "type": "string"
        },
        "status": {
          "description": "Status of the condition, one of True, False, Unknown.",
          "type": "string"
        },
        "type": {
          "description": "Type of job condition, Complete or Failed.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.batch.v1.JobList": {
      "description": "JobList is a collection of jobs.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["batch/v1"]
        },
        "items": {
          "description": "items is the list of Jobs.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.batch.v1.Job"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["JobList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "batch",
          "kind": "JobList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.batch.v1.JobSpec": {
      "description": "JobSpec describes how the job execution will look like.",
      "type": "object",
      "required": ["template"],
      "properties": {
        "activeDeadlineSeconds": {
          "description": "Specifies the duration in seconds relative to the startTime that the job may be continuously active before the system tries to terminate it; value must be positive integer. If a Job is suspended (at creation or through an update), this timer will effectively be stopped and reset when the Job is resumed again.",
          "type": "integer",
          "format": "int64"
        },
        "backoffLimit": {
          "description": "Specifies the number of retries before marking this job failed. Defaults to 6",
          "type": "integer",
          "format": "int32"
        },
        "completionMode": {
          "description": "CompletionMode specifies how Pod completions are tracked. It can be `NonIndexed` (default) or `Indexed`.\n\n`NonIndexed` means that the Job is considered complete when there have been .spec.completions successfully completed Pods. Each Pod completion is homologous to each other.\n\n`Indexed` means that the Pods of a Job get an associated completion index from 0 to (.spec.completions - 1), available in the annotation batch.kubernetes.io/job-completion-index. The Job is considered complete when there is one successfully completed Pod for each index. When value is `Indexed`, .spec.completions must be specified and `.spec.parallelism` must be less than or equal to 10^5. In addition, The Pod name takes the form `$(job-name)-$(index)-$(random-string)`, the Pod hostname takes the form `$(job-name)-$(index)`.\n\nThis field is beta-level. More completion modes can be added in the future. If the Job controller observes a mode that it doesn't recognize, the controller skips updates for the Job.",
          "type": "string"
        },
        "completions": {
          "description": "Specifies the desired number of successfully finished pods the job should be run with.  Setting to nil means that the success of any pod signals the success of all pods, and allows parallelism to have any positive value.  Setting to 1 means that parallelism is limited to 1 and the success of that pod signals the success of the job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/",
          "type": "integer",
          "format": "int32"
        },
        "manualSelector": {
          "description": "manualSelector controls generation of pod labels and pod selectors. Leave `manualSelector` unset unless you are certain what you are doing. When false or unset, the system pick labels unique to this job and appends those labels to the pod template.  When true, the user is responsible for picking unique labels and specifying the selector.  Failure to pick a unique label may cause this and other jobs to not function correctly.  However, You may see `manualSelector=true` in jobs that were created with the old `extensions/v1beta1` API. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector",
          "type": "boolean"
        },
        "parallelism": {
          "description": "Specifies the maximum desired number of pods the job should run at any given time. The actual number of pods running in steady state will be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism), i.e. when the work left to do is less than max parallelism. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/",
          "type": "integer",
          "format": "int32"
        },
        "selector": {
          "description": "A label query over pods that should match the pod count. Normally, the system sets this field for you. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "suspend": {
          "description": "Suspend specifies whether the Job controller should create Pods or not. If a Job is created with suspend set to true, no Pods are created by the Job controller. If a Job is suspended after creation (i.e. the flag goes from false to true), the Job controller will delete all active Pods associated with this Job. Users must design their workload to gracefully handle this. Suspending a Job will reset the StartTime field of the Job, effectively resetting the ActiveDeadlineSeconds timer too. Defaults to false.\n\nThis field is beta-level, gated by SuspendJob feature flag (enabled by default).",
          "type": "boolean"
        },
        "template": {
          "description": "Describes the pod that will be created when executing a job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodTemplateSpec"
        },
        "ttlSecondsAfterFinished": {
          "description": "ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job won't be automatically deleted. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.batch.v1.JobStatus": {
      "description": "JobStatus represents the current state of a Job.",
      "type": "object",
      "properties": {
        "active": {
          "description": "The number of actively running pods.",
          "type": "integer",
          "format": "int32"
        },
        "completedIndexes": {
          "description": "CompletedIndexes holds the completed indexes when .spec.completionMode = \"Indexed\" in a text format. The indexes are represented as decimal integers separated by commas. The numbers are listed in increasing order. Three or more consecutive numbers are compressed and represented by the first and last element of the series, separated by a hyphen. For example, if the completed indexes are 1, 3, 4, 5 and 7, they are represented as \"1,3-5,7\".",
          "type": "string"
        },
        "completionTime": {
          "description": "Represents time when the job was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. The completion time is only set when the job finishes successfully.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "conditions": {
          "description": "The latest available observations of an object's current state. When a Job fails, one of the conditions will have type \"Failed\" and status true. When a Job is suspended, one of the conditions will have type \"Suspended\" and status true; when the Job is resumed, the status of this condition will become false. When a Job is completed, one of the conditions will have type \"Complete\" and status true. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.batch.v1.JobCondition"
          },
          "x-kubernetes-list-type": "atomic",
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        },
        "failed": {
          "description": "The number of pods which reached phase Failed.",
          "type": "integer",
          "format": "int32"
        },
        "startTime": {
          "description": "Represents time when the job controller started processing a job. When a Job is created in the suspended state, this field is not set until the first time it is resumed. This field is reset every time a Job is resumed from suspension. It is represented in RFC3339 form and is in UTC.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "succeeded": {
          "description": "The number of pods which reached phase Succeeded.",
          "type": "integer",
          "format": "int32"
        },
        "uncountedTerminatedPods": {
          "description": "UncountedTerminatedPods holds the UIDs of Pods that have terminated but the job controller hasn't yet accounted for in the status counters.\n\nThe job controller creates pods with a finalizer. When a pod terminates (succeeded or failed), the controller does three steps to account for it in the job status: (1) Add the pod UID to the arrays in this field. (2) Remove the pod finalizer. (3) Remove the pod UID from the arrays while increasing the corresponding\n    counter.\n\nThis field is alpha-level. The job controller only makes use of this field when the feature gate PodTrackingWithFinalizers is enabled. Old jobs might not be tracked using this field, in which case the field remains null.",
          "$ref": "#/definitions/io.k8s.api.batch.v1.UncountedTerminatedPods"
        }
      }
    },
    "io.k8s.api.batch.v1.JobTemplateSpec": {
      "description": "JobTemplateSpec describes the data a Job should have when created from a template",
      "type": "object",
      "properties": {
        "metadata": {
          "description": "Standard object's metadata of the jobs created from this template. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Specification of the desired behavior of the job. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.batch.v1.JobSpec"
        }
      }
    },
    "io.k8s.api.batch.v1.UncountedTerminatedPods": {
      "description": "UncountedTerminatedPods holds UIDs of Pods that have terminated but haven't been accounted in Job status counters.",
      "type": "object",
      "properties": {
        "failed": {
          "description": "Failed holds UIDs of failed Pods.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-list-type": "set"
        },
        "succeeded": {
          "description": "Succeeded holds UIDs of succeeded Pods.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-list-type": "set"
        }
      }
    },
    "io.k8s.api.batch.v1beta1.CronJob": {
      "description": "CronJob represents the configuration of a single cron job.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["batch/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CronJob"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Specification of the desired behavior of a cron job, including the schedule. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.batch.v1beta1.CronJobSpec"
        },
        "status": {
          "description": "Current status of a cron job. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.batch.v1beta1.CronJobStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "batch",
          "kind": "CronJob",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.api.batch.v1beta1.CronJobList": {
      "description": "CronJobList is a collection of cron jobs.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["batch/v1beta1"]
        },
        "items": {
          "description": "items is the list of CronJobs.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.batch.v1beta1.CronJob"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CronJobList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "batch",
          "kind": "CronJobList",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.api.batch.v1beta1.CronJobSpec": {
      "description": "CronJobSpec describes how the job execution will look like and when it will actually run.",
      "type": "object",
      "required": ["schedule", "jobTemplate"],
      "properties": {
        "concurrencyPolicy": {
          "description": "Specifies how to treat concurrent executions of a Job. Valid values are: - \"Allow\" (default): allows CronJobs to run concurrently; - \"Forbid\": forbids concurrent runs, skipping next run if previous run hasn't finished yet; - \"Replace\": cancels currently running job and replaces it with a new one",
          "type": "string"
        },
        "failedJobsHistoryLimit": {
          "description": "The number of failed finished jobs to retain. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.",
          "type": "integer",
          "format": "int32"
        },
        "jobTemplate": {
          "description": "Specifies the job that will be created when executing a CronJob.",
          "$ref": "#/definitions/io.k8s.api.batch.v1beta1.JobTemplateSpec"
        },
        "schedule": {
          "description": "The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.",
          "type": "string"
        },
        "startingDeadlineSeconds": {
          "description": "Optional deadline in seconds for starting the job if it misses scheduled time for any reason.  Missed jobs executions will be counted as failed ones.",
          "type": "integer",
          "format": "int64"
        },
        "successfulJobsHistoryLimit": {
          "description": "The number of successful finished jobs to retain. This is a pointer to distinguish between explicit zero and not specified. Defaults to 3.",
          "type": "integer",
          "format": "int32"
        },
        "suspend": {
          "description": "This flag tells the controller to suspend subsequent executions, it does not apply to already started executions.  Defaults to false.",
          "type": "boolean"
        }
      }
    },
    "io.k8s.api.batch.v1beta1.CronJobStatus": {
      "description": "CronJobStatus represents the current state of a cron job.",
      "type": "object",
      "properties": {
        "active": {
          "description": "A list of pointers to currently running jobs.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "lastScheduleTime": {
          "description": "Information when was the last time the job was successfully scheduled.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "lastSuccessfulTime": {
          "description": "Information when was the last time the job successfully completed.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        }
      }
    },
    "io.k8s.api.batch.v1beta1.JobTemplateSpec": {
      "description": "JobTemplateSpec describes the data a Job should have when created from a template",
      "type": "object",
      "properties": {
        "metadata": {
          "description": "Standard object's metadata of the jobs created from this template. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Specification of the desired behavior of the job. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.batch.v1.JobSpec"
        }
      }
    },
    "io.k8s.api.certificates.v1.CertificateSigningRequest": {
      "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers.",
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["certificates.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CertificateSigningRequest"]
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "spec contains the certificate request, and is immutable after creation. Only the request, signerName, expirationSeconds, and usages fields can be set on creation. Other fields are derived by Kubernetes and cannot be modified by users.",
          "$ref": "#/definitions/io.k8s.api.certificates.v1.CertificateSigningRequestSpec"
        },
        "status": {
          "description": "status contains information about whether the request is approved or denied, and the certificate issued by the signer, or the failure condition indicating signer failure.",
          "$ref": "#/definitions/io.k8s.api.certificates.v1.CertificateSigningRequestStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "certificates.k8s.io",
          "kind": "CertificateSigningRequest",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.certificates.v1.CertificateSigningRequestCondition": {
      "description": "CertificateSigningRequestCondition describes a condition of a CertificateSigningRequest object",
      "type": "object",
      "required": ["type", "status"],
      "properties": {
        "lastTransitionTime": {
          "description": "lastTransitionTime is the time the condition last transitioned from one status to another. If unset, when a new condition type is added or an existing condition's status is changed, the server defaults this to the current time.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "lastUpdateTime": {
          "description": "lastUpdateTime is the time of the last update to this condition",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "message contains a human readable message with details about the request state",
          "type": "string"
        },
        "reason": {
          "description": "reason indicates a brief reason for the request state",
          "type": "string"
        },
        "status": {
          "description": "status of the condition, one of True, False, Unknown. Approved, Denied, and Failed conditions may not be \"False\" or \"Unknown\".",
          "type": "string"
        },
        "type": {
          "description": "type of the condition. Known conditions are \"Approved\", \"Denied\", and \"Failed\".\n\nAn \"Approved\" condition is added via the /approval subresource, indicating the request was approved and should be issued by the signer.\n\nA \"Denied\" condition is added via the /approval subresource, indicating the request was denied and should not be issued by the signer.\n\nA \"Failed\" condition is added via the /status subresource, indicating the signer failed to issue the certificate.\n\nApproved and Denied conditions are mutually exclusive. Approved, Denied, and Failed conditions cannot be removed once added.\n\nOnly one condition of a given type is allowed.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.certificates.v1.CertificateSigningRequestList": {
      "description": "CertificateSigningRequestList is a collection of CertificateSigningRequest objects",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["certificates.k8s.io/v1"]
        },
        "items": {
          "description": "items is a collection of CertificateSigningRequest objects",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.certificates.v1.CertificateSigningRequest"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CertificateSigningRequestList"]
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "certificates.k8s.io",
          "kind": "CertificateSigningRequestList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.certificates.v1.CertificateSigningRequestSpec": {
      "description": "CertificateSigningRequestSpec contains the certificate request.",
      "type": "object",
      "required": ["request", "signerName"],
      "properties": {
        "expirationSeconds": {
          "description": "expirationSeconds is the requested duration of validity of the issued certificate. The certificate signer may issue a certificate with a different validity duration so a client must check the delta between the notBefore and and notAfter fields in the issued certificate to determine the actual duration.\n\nThe v1.22+ in-tree implementations of the well-known Kubernetes signers will honor this field as long as the requested duration is not greater than the maximum duration they will honor per the --cluster-signing-duration CLI flag to the Kubernetes controller manager.\n\nCertificate signers may not honor this field for various reasons:\n\n  1. Old signer that is unaware of the field (such as the in-tree\n     implementations prior to v1.22)\n  2. Signer whose configured maximum is shorter than the requested duration\n  3. Signer whose configured minimum is longer than the requested duration\n\nThe minimum valid value for expirationSeconds is 600, i.e. 10 minutes.\n\nAs of v1.22, this field is beta and is controlled via the CSRDuration feature gate.",
          "type": "integer",
          "format": "int32"
        },
        "extra": {
          "description": "extra contains extra attributes of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "groups": {
          "description": "groups contains group membership of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "request": {
          "description": "request contains an x509 certificate signing request encoded in a \"CERTIFICATE REQUEST\" PEM block. When serialized as JSON or YAML, the data is additionally base64-encoded.",
          "type": "string",
          "format": "byte",
          "x-kubernetes-list-type": "atomic"
        },
        "signerName": {
          "description": "signerName indicates the requested signer, and is a qualified name.\n\nList/watch requests for CertificateSigningRequests can filter on this field using a \"spec.signerName=NAME\" fieldSelector.\n\nWell-known Kubernetes signers are:\n 1. \"kubernetes.io/kube-apiserver-client\": issues client certificates that can be used to authenticate to kube-apiserver.\n  Requests for this signer are never auto-approved by kube-controller-manager, can be issued by the \"csrsigning\" controller in kube-controller-manager.\n 2. \"kubernetes.io/kube-apiserver-client-kubelet\": issues client certificates that kubelets use to authenticate to kube-apiserver.\n  Requests for this signer can be auto-approved by the \"csrapproving\" controller in kube-controller-manager, and can be issued by the \"csrsigning\" controller in kube-controller-manager.\n 3. \"kubernetes.io/kubelet-serving\" issues serving certificates that kubelets use to serve TLS endpoints, which kube-apiserver can connect to securely.\n  Requests for this signer are never auto-approved by kube-controller-manager, and can be issued by the \"csrsigning\" controller in kube-controller-manager.\n\nMore details are available at https://k8s.io/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers\n\nCustom signerNames can also be specified. The signer defines:\n 1. Trust distribution: how trust (CA bundles) are distributed.\n 2. Permitted subjects: and behavior when a disallowed subject is requested.\n 3. Required, permitted, or forbidden x509 extensions in the request (including whether subjectAltNames are allowed, which types, restrictions on allowed values) and behavior when a disallowed extension is requested.\n 4. Required, permitted, or forbidden key usages / extended key usages.\n 5. Expiration/certificate lifetime: whether it is fixed by the signer, configurable by the admin.\n 6. Whether or not requests for CA certificates are allowed.",
          "type": "string"
        },
        "uid": {
          "description": "uid contains the uid of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.",
          "type": "string"
        },
        "usages": {
          "description": "usages specifies a set of key usages requested in the issued certificate.\n\nRequests for TLS client certificates typically request: \"digital signature\", \"key encipherment\", \"client auth\".\n\nRequests for TLS serving certificates typically request: \"key encipherment\", \"digital signature\", \"server auth\".\n\nValid values are:\n \"signing\", \"digital signature\", \"content commitment\",\n \"key encipherment\", \"key agreement\", \"data encipherment\",\n \"cert sign\", \"crl sign\", \"encipher only\", \"decipher only\", \"any\",\n \"server auth\", \"client auth\",\n \"code signing\", \"email protection\", \"s/mime\",\n \"ipsec end system\", \"ipsec tunnel\", \"ipsec user\",\n \"timestamping\", \"ocsp signing\", \"microsoft sgc\", \"netscape sgc\"",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "username": {
          "description": "username contains the name of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.certificates.v1.CertificateSigningRequestStatus": {
      "description": "CertificateSigningRequestStatus contains conditions used to indicate approved/denied/failed status of the request, and the issued certificate.",
      "type": "object",
      "properties": {
        "certificate": {
          "description": "certificate is populated with an issued certificate by the signer after an Approved condition is present. This field is set via the /status subresource. Once populated, this field is immutable.\n\nIf the certificate signing request is denied, a condition of type \"Denied\" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type \"Failed\" is added and this field remains empty.\n\nValidation requirements:\n 1. certificate must contain one or more PEM blocks.\n 2. All PEM blocks must have the \"CERTIFICATE\" label, contain no headers, and the encoded data\n  must be a BER-encoded ASN.1 Certificate structure as described in section 4 of RFC5280.\n 3. Non-PEM content may appear before or after the \"CERTIFICATE\" PEM blocks and is unvalidated,\n  to allow for explanatory text as described in section 5.2 of RFC7468.\n\nIf more than one PEM block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.\n\nThe certificate is encoded in PEM format.\n\nWhen serialized as JSON or YAML, the data is additionally base64-encoded, so it consists of:\n\n    base64(\n    -----BEGIN CERTIFICATE-----\n    ...\n    -----END CERTIFICATE-----\n    )",
          "type": "string",
          "format": "byte",
          "x-kubernetes-list-type": "atomic"
        },
        "conditions": {
          "description": "conditions applied to the request. Known conditions are \"Approved\", \"Denied\", and \"Failed\".",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.certificates.v1.CertificateSigningRequestCondition"
          },
          "x-kubernetes-list-map-keys": ["type"],
          "x-kubernetes-list-type": "map"
        }
      }
    },
    "io.k8s.api.coordination.v1.Lease": {
      "description": "Lease defines a lease concept.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["coordination.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Lease"]
        },
        "metadata": {
          "description": "More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Specification of the Lease. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.coordination.v1.LeaseSpec"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "coordination.k8s.io",
          "kind": "Lease",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.coordination.v1.LeaseList": {
      "description": "LeaseList is a list of Lease objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["coordination.k8s.io/v1"]
        },
        "items": {
          "description": "Items is a list of schema objects.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.coordination.v1.Lease"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["LeaseList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "coordination.k8s.io",
          "kind": "LeaseList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.coordination.v1.LeaseSpec": {
      "description": "LeaseSpec is a specification of a Lease.",
      "type": "object",
      "properties": {
        "acquireTime": {
          "description": "acquireTime is a time when the current lease was acquired.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime"
        },
        "holderIdentity": {
          "description": "holderIdentity contains the identity of the holder of a current lease.",
          "type": "string"
        },
        "leaseDurationSeconds": {
          "description": "leaseDurationSeconds is a duration that candidates for a lease need to wait to force acquire it. This is measure against time of last observed RenewTime.",
          "type": "integer",
          "format": "int32"
        },
        "leaseTransitions": {
          "description": "leaseTransitions is the number of transitions of a lease between holders.",
          "type": "integer",
          "format": "int32"
        },
        "renewTime": {
          "description": "renewTime is a time when the current holder of a lease has last updated the lease.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime"
        }
      }
    },
    "io.k8s.api.core.v1.AWSElasticBlockStoreVolumeSource": {
      "description": "Represents a Persistent Disk resource in AWS.\n\nAn AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.",
      "type": "object",
      "required": ["volumeID"],
      "properties": {
        "fsType": {
          "description": "Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore",
          "type": "string"
        },
        "partition": {
          "description": "The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or you can leave the property empty).",
          "type": "integer",
          "format": "int32"
        },
        "readOnly": {
          "description": "Specify \"true\" to force and set the ReadOnly property in VolumeMounts to \"true\". If omitted, the default is \"false\". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore",
          "type": "boolean"
        },
        "volumeID": {
          "description": "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.Affinity": {
      "description": "Affinity is a group of affinity scheduling rules.",
      "type": "object",
      "properties": {
        "nodeAffinity": {
          "description": "Describes node affinity scheduling rules for the pod.",
          "$ref": "#/definitions/io.k8s.api.core.v1.NodeAffinity"
        },
        "podAffinity": {
          "description": "Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodAffinity"
        },
        "podAntiAffinity": {
          "description": "Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodAntiAffinity"
        }
      }
    },
    "io.k8s.api.core.v1.AttachedVolume": {
      "description": "AttachedVolume describes a volume attached to a node",
      "type": "object",
      "required": ["name", "devicePath"],
      "properties": {
        "devicePath": {
          "description": "DevicePath represents the device path where the volume should be available",
          "type": "string"
        },
        "name": {
          "description": "Name of the attached volume",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.AzureDiskVolumeSource": {
      "description": "AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.",
      "type": "object",
      "required": ["diskName", "diskURI"],
      "properties": {
        "cachingMode": {
          "description": "Host Caching mode: None, Read Only, Read Write.",
          "type": "string"
        },
        "diskName": {
          "description": "The Name of the data disk in the blob storage",
          "type": "string"
        },
        "diskURI": {
          "description": "The URI the data disk in the blob storage",
          "type": "string"
        },
        "fsType": {
          "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
          "type": "string"
        },
        "kind": {
          "description": "Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared",
          "type": "string"
        },
        "readOnly": {
          "description": "Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
          "type": "boolean"
        }
      }
    },
    "io.k8s.api.core.v1.AzureFilePersistentVolumeSource": {
      "description": "AzureFile represents an Azure File Service mount on the host and bind mount to the pod.",
      "type": "object",
      "required": ["secretName", "shareName"],
      "properties": {
        "readOnly": {
          "description": "Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
          "type": "boolean"
        },
        "secretName": {
          "description": "the name of secret that contains Azure Storage Account Name and Key",
          "type": "string"
        },
        "secretNamespace": {
          "description": "the namespace of the secret that contains Azure Storage Account Name and Key default is the same as the Pod",
          "type": "string"
        },
        "shareName": {
          "description": "Share Name",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.AzureFileVolumeSource": {
      "description": "AzureFile represents an Azure File Service mount on the host and bind mount to the pod.",
      "type": "object",
      "required": ["secretName", "shareName"],
      "properties": {
        "readOnly": {
          "description": "Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
          "type": "boolean"
        },
        "secretName": {
          "description": "the name of secret that contains Azure Storage Account Name and Key",
          "type": "string"
        },
        "shareName": {
          "description": "Share Name",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.Binding": {
      "description": "Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead.",
      "type": "object",
      "required": ["target"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Binding"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "target": {
          "description": "The target object that you want to bind to the standard object.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "Binding",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.CSIPersistentVolumeSource": {
      "description": "Represents storage that is managed by an external CSI volume driver (Beta feature)",
      "type": "object",
      "required": ["driver", "volumeHandle"],
      "properties": {
        "controllerExpandSecretRef": {
          "description": "ControllerExpandSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI ControllerExpandVolume call. This is an alpha field and requires enabling ExpandCSIVolumes feature gate. This field is optional, and may be empty if no secret is required. If the secret object contains more than one secret, all secrets are passed.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretReference"
        },
        "controllerPublishSecretRef": {
          "description": "ControllerPublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI ControllerPublishVolume and ControllerUnpublishVolume calls. This field is optional, and may be empty if no secret is required. If the secret object contains more than one secret, all secrets are passed.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretReference"
        },
        "driver": {
          "description": "Driver is the name of the driver to use for this volume. Required.",
          "type": "string"
        },
        "fsType": {
          "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\".",
          "type": "string"
        },
        "nodePublishSecretRef": {
          "description": "NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and may be empty if no secret is required. If the secret object contains more than one secret, all secrets are passed.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretReference"
        },
        "nodeStageSecretRef": {
          "description": "NodeStageSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodeStageVolume and NodeStageVolume and NodeUnstageVolume calls. This field is optional, and may be empty if no secret is required. If the secret object contains more than one secret, all secrets are passed.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretReference"
        },
        "readOnly": {
          "description": "Optional: The value to pass to ControllerPublishVolumeRequest. Defaults to false (read/write).",
          "type": "boolean"
        },
        "volumeAttributes": {
          "description": "Attributes of the volume to publish.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "volumeHandle": {
          "description": "VolumeHandle is the unique volume name returned by the CSI volume plugin\u2019s CreateVolume to refer to the volume on all subsequent calls. Required.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.CSIVolumeSource": {
      "description": "Represents a source location of a volume to mount, managed by an external CSI driver",
      "type": "object",
      "required": ["driver"],
      "properties": {
        "driver": {
          "description": "Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.",
          "type": "string"
        },
        "fsType": {
          "description": "Filesystem type to mount. Ex. \"ext4\", \"xfs\", \"ntfs\". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.",
          "type": "string"
        },
        "nodePublishSecretRef": {
          "description": "NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.",
          "$ref": "#/definitions/io.k8s.api.core.v1.LocalObjectReference"
        },
        "readOnly": {
          "description": "Specifies a read-only configuration for the volume. Defaults to false (read/write).",
          "type": "boolean"
        },
        "volumeAttributes": {
          "description": "VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.core.v1.Capabilities": {
      "description": "Adds and removes POSIX capabilities from running containers.",
      "type": "object",
      "properties": {
        "add": {
          "description": "Added capabilities",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "drop": {
          "description": "Removed capabilities",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.core.v1.CephFSPersistentVolumeSource": {
      "description": "Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.",
      "type": "object",
      "required": ["monitors"],
      "properties": {
        "monitors": {
          "description": "Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "path": {
          "description": "Optional: Used as the mounted root, rather than the full Ceph tree, default is /",
          "type": "string"
        },
        "readOnly": {
          "description": "Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it",
          "type": "boolean"
        },
        "secretFile": {
          "description": "Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it",
          "type": "string"
        },
        "secretRef": {
          "description": "Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretReference"
        },
        "user": {
          "description": "Optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.CephFSVolumeSource": {
      "description": "Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.",
      "type": "object",
      "required": ["monitors"],
      "properties": {
        "monitors": {
          "description": "Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "path": {
          "description": "Optional: Used as the mounted root, rather than the full Ceph tree, default is /",
          "type": "string"
        },
        "readOnly": {
          "description": "Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it",
          "type": "boolean"
        },
        "secretFile": {
          "description": "Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it",
          "type": "string"
        },
        "secretRef": {
          "description": "Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it",
          "$ref": "#/definitions/io.k8s.api.core.v1.LocalObjectReference"
        },
        "user": {
          "description": "Optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.CinderPersistentVolumeSource": {
      "description": "Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.",
      "type": "object",
      "required": ["volumeID"],
      "properties": {
        "fsType": {
          "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md",
          "type": "string"
        },
        "readOnly": {
          "description": "Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md",
          "type": "boolean"
        },
        "secretRef": {
          "description": "Optional: points to a secret object containing parameters used to connect to OpenStack.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretReference"
        },
        "volumeID": {
          "description": "volume id used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.CinderVolumeSource": {
      "description": "Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.",
      "type": "object",
      "required": ["volumeID"],
      "properties": {
        "fsType": {
          "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md",
          "type": "string"
        },
        "readOnly": {
          "description": "Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md",
          "type": "boolean"
        },
        "secretRef": {
          "description": "Optional: points to a secret object containing parameters used to connect to OpenStack.",
          "$ref": "#/definitions/io.k8s.api.core.v1.LocalObjectReference"
        },
        "volumeID": {
          "description": "volume id used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.ClientIPConfig": {
      "description": "ClientIPConfig represents the configurations of Client IP based session affinity.",
      "type": "object",
      "properties": {
        "timeoutSeconds": {
          "description": "timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == \"ClientIP\". Default value is 10800(for 3 hours).",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.core.v1.ComponentCondition": {
      "description": "Information about the condition of a component.",
      "type": "object",
      "required": ["type", "status"],
      "properties": {
        "error": {
          "description": "Condition error code for a component. For example, a health check error code.",
          "type": "string"
        },
        "message": {
          "description": "Message about the condition for a component. For example, information about a health check.",
          "type": "string"
        },
        "status": {
          "description": "Status of the condition for a component. Valid values for \"Healthy\": \"True\", \"False\", or \"Unknown\".",
          "type": "string"
        },
        "type": {
          "description": "Type of condition for a component. Valid value: \"Healthy\"",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.ComponentStatus": {
      "description": "ComponentStatus (and ComponentStatusList) holds the cluster validation info. Deprecated: This API is deprecated in v1.19+",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "conditions": {
          "description": "List of component conditions observed",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ComponentCondition"
          },
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComponentStatus"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "ComponentStatus",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.ComponentStatusList": {
      "description": "Status of all the conditions for the component as a list of ComponentStatus objects. Deprecated: This API is deprecated in v1.19+",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "items": {
          "description": "List of ComponentStatus objects.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ComponentStatus"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ComponentStatusList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "ComponentStatusList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.ConfigMap": {
      "description": "ConfigMap holds configuration data for pods to consume.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "binaryData": {
          "description": "BinaryData contains the binary data. Each key must consist of alphanumeric characters, '-', '_' or '.'. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet.",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          }
        },
        "data": {
          "description": "Data contains the configuration data. Each key must consist of alphanumeric characters, '-', '_' or '.'. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "immutable": {
          "description": "Immutable, if set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Defaulted to nil.",
          "type": "boolean"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ConfigMap"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "ConfigMap",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.ConfigMapEnvSource": {
      "description": "ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.\n\nThe contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.",
      "type": "object",
      "properties": {
        "name": {
          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
          "type": "string"
        },
        "optional": {
          "description": "Specify whether the ConfigMap must be defined",
          "type": "boolean"
        }
      }
    },
    "io.k8s.api.core.v1.ConfigMapKeySelector": {
      "description": "Selects a key from a ConfigMap.",
      "type": "object",
      "required": ["key"],
      "properties": {
        "key": {
          "description": "The key to select.",
          "type": "string"
        },
        "name": {
          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
          "type": "string"
        },
        "optional": {
          "description": "Specify whether the ConfigMap or its key must be defined",
          "type": "boolean"
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.core.v1.ConfigMapList": {
      "description": "ConfigMapList is a resource containing a list of ConfigMap objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "items": {
          "description": "Items is the list of ConfigMaps.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ConfigMap"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ConfigMapList"]
        },
        "metadata": {
          "description": "More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "ConfigMapList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.ConfigMapNodeConfigSource": {
      "description": "ConfigMapNodeConfigSource contains the information to reference a ConfigMap as a config source for the Node. This API is deprecated since 1.22: https://git.k8s.io/enhancements/keps/sig-node/281-dynamic-kubelet-configuration",
      "type": "object",
      "required": ["namespace", "name", "kubeletConfigKey"],
      "properties": {
        "kubeletConfigKey": {
          "description": "KubeletConfigKey declares which key of the referenced ConfigMap corresponds to the KubeletConfiguration structure This field is required in all cases.",
          "type": "string"
        },
        "name": {
          "description": "Name is the metadata.name of the referenced ConfigMap. This field is required in all cases.",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace is the metadata.namespace of the referenced ConfigMap. This field is required in all cases.",
          "type": "string"
        },
        "resourceVersion": {
          "description": "ResourceVersion is the metadata.ResourceVersion of the referenced ConfigMap. This field is forbidden in Node.Spec, and required in Node.Status.",
          "type": "string"
        },
        "uid": {
          "description": "UID is the metadata.UID of the referenced ConfigMap. This field is forbidden in Node.Spec, and required in Node.Status.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.ConfigMapProjection": {
      "description": "Adapts a ConfigMap into a projected volume.\n\nThe contents of the target ConfigMap's Data field will be presented in a projected volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. Note that this is identical to a configmap volume source without the default mode.",
      "type": "object",
      "properties": {
        "items": {
          "description": "If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.KeyToPath"
          }
        },
        "name": {
          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
          "type": "string"
        },
        "optional": {
          "description": "Specify whether the ConfigMap or its keys must be defined",
          "type": "boolean"
        }
      }
    },
    "io.k8s.api.core.v1.ConfigMapVolumeSource": {
      "description": "Adapts a ConfigMap into a volume.\n\nThe contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.",
      "type": "object",
      "properties": {
        "defaultMode": {
          "description": "Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
          "type": "integer",
          "format": "int32"
        },
        "items": {
          "description": "If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.KeyToPath"
          }
        },
        "name": {
          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
          "type": "string"
        },
        "optional": {
          "description": "Specify whether the ConfigMap or its keys must be defined",
          "type": "boolean"
        }
      }
    },
    "io.k8s.api.core.v1.Container": {
      "description": "A single application container that you want to run within a pod.",
      "type": "object",
      "required": ["name"],
      "properties": {
        "args": {
          "description": "Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "command": {
          "description": "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "env": {
          "description": "List of environment variables to set in the container. Cannot be updated.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.EnvVar"
          },
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "envFrom": {
          "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.EnvFromSource"
          }
        },
        "image": {
          "description": "Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
          "type": "string"
        },
        "imagePullPolicy": {
          "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
          "type": "string"
        },
        "lifecycle": {
          "description": "Actions that the management system should take in response to container lifecycle events. Cannot be updated.",
          "$ref": "#/definitions/io.k8s.api.core.v1.Lifecycle"
        },
        "livenessProbe": {
          "description": "Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/io.k8s.api.core.v1.Probe"
        },
        "name": {
          "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
          "type": "string"
        },
        "ports": {
          "description": "List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"0.0.0.0\" address inside a container will be accessible from the network. Cannot be updated.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ContainerPort"
          },
          "x-kubernetes-list-map-keys": ["containerPort", "protocol"],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "containerPort",
          "x-kubernetes-patch-strategy": "merge"
        },
        "readinessProbe": {
          "description": "Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/io.k8s.api.core.v1.Probe"
        },
        "resources": {
          "description": "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
          "$ref": "#/definitions/io.k8s.api.core.v1.ResourceRequirements"
        },
        "securityContext": {
          "description": "SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecurityContext"
        },
        "startupProbe": {
          "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/io.k8s.api.core.v1.Probe"
        },
        "stdin": {
          "description": "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
          "type": "boolean"
        },
        "stdinOnce": {
          "description": "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
          "type": "boolean"
        },
        "terminationMessagePath": {
          "description": "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
          "type": "string"
        },
        "terminationMessagePolicy": {
          "description": "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
          "type": "string"
        },
        "tty": {
          "description": "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
          "type": "boolean"
        },
        "volumeDevices": {
          "description": "volumeDevices is the list of block devices to be used by the container.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.VolumeDevice"
          },
          "x-kubernetes-patch-merge-key": "devicePath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumeMounts": {
          "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.VolumeMount"
          },
          "x-kubernetes-patch-merge-key": "mountPath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "workingDir": {
          "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.ContainerImage": {
      "description": "Describe a container image",
      "type": "object",
      "properties": {
        "names": {
          "description": "Names by which this image is known. e.g. [\"k8s.gcr.io/hyperkube:v1.0.7\", \"dockerhub.io/google_containers/hyperkube:v1.0.7\"]",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "sizeBytes": {
          "description": "The size of the image in bytes.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "io.k8s.api.core.v1.ContainerPort": {
      "description": "ContainerPort represents a network port in a single container.",
      "type": "object",
      "required": ["containerPort"],
      "properties": {
        "containerPort": {
          "description": "Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.",
          "type": "integer",
          "format": "int32"
        },
        "hostIP": {
          "description": "What host IP to bind the external port to.",
          "type": "string"
        },
        "hostPort": {
          "description": "Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.",
          "type": "integer",
          "format": "int32"
        },
        "name": {
          "description": "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.",
          "type": "string"
        },
        "protocol": {
          "description": "Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \"TCP\".",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.ContainerState": {
      "description": "ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting.",
      "type": "object",
      "properties": {
        "running": {
          "description": "Details about a running container",
          "$ref": "#/definitions/io.k8s.api.core.v1.ContainerStateRunning"
        },
        "terminated": {
          "description": "Details about a terminated container",
          "$ref": "#/definitions/io.k8s.api.core.v1.ContainerStateTerminated"
        },
        "waiting": {
          "description": "Details about a waiting container",
          "$ref": "#/definitions/io.k8s.api.core.v1.ContainerStateWaiting"
        }
      }
    },
    "io.k8s.api.core.v1.ContainerStateRunning": {
      "description": "ContainerStateRunning is a running state of a container.",
      "type": "object",
      "properties": {
        "startedAt": {
          "description": "Time at which the container was last (re-)started",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        }
      }
    },
    "io.k8s.api.core.v1.ContainerStateTerminated": {
      "description": "ContainerStateTerminated is a terminated state of a container.",
      "type": "object",
      "required": ["exitCode"],
      "properties": {
        "containerID": {
          "description": "Container's ID in the format 'docker://<container_id>'",
          "type": "string"
        },
        "exitCode": {
          "description": "Exit status from the last termination of the container",
          "type": "integer",
          "format": "int32"
        },
        "finishedAt": {
          "description": "Time at which the container last terminated",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "Message regarding the last termination of the container",
          "type": "string"
        },
        "reason": {
          "description": "(brief) reason from the last termination of the container",
          "type": "string"
        },
        "signal": {
          "description": "Signal from the last termination of the container",
          "type": "integer",
          "format": "int32"
        },
        "startedAt": {
          "description": "Time at which previous execution of the container started",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        }
      }
    },
    "io.k8s.api.core.v1.ContainerStateWaiting": {
      "description": "ContainerStateWaiting is a waiting state of a container.",
      "type": "object",
      "properties": {
        "message": {
          "description": "Message regarding why the container is not yet running.",
          "type": "string"
        },
        "reason": {
          "description": "(brief) reason the container is not yet running.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.ContainerStatus": {
      "description": "ContainerStatus contains details for the current status of this container.",
      "type": "object",
      "required": ["name", "ready", "restartCount", "image", "imageID"],
      "properties": {
        "containerID": {
          "description": "Container's ID in the format 'docker://<container_id>'.",
          "type": "string"
        },
        "image": {
          "description": "The image the container is running. More info: https://kubernetes.io/docs/concepts/containers/images",
          "type": "string"
        },
        "imageID": {
          "description": "ImageID of the container's image.",
          "type": "string"
        },
        "lastState": {
          "description": "Details about the container's last termination condition.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ContainerState"
        },
        "name": {
          "description": "This must be a DNS_LABEL. Each container in a pod must have a unique name. Cannot be updated.",
          "type": "string"
        },
        "ready": {
          "description": "Specifies whether the container has passed its readiness probe.",
          "type": "boolean"
        },
        "restartCount": {
          "description": "The number of times the container has been restarted, currently based on the number of dead containers that have not yet been removed. Note that this is calculated from dead containers. But those containers are subject to garbage collection. This value will get capped at 5 by GC.",
          "type": "integer",
          "format": "int32"
        },
        "started": {
          "description": "Specifies whether the container has passed its startup probe. Initialized as false, becomes true after startupProbe is considered successful. Resets to false when the container is restarted, or if kubelet loses state temporarily. Is always true when no startupProbe is defined.",
          "type": "boolean"
        },
        "state": {
          "description": "Details about the container's current condition.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ContainerState"
        }
      }
    },
    "io.k8s.api.core.v1.DaemonEndpoint": {
      "description": "DaemonEndpoint contains information about a single Daemon endpoint.",
      "type": "object",
      "required": ["Port"],
      "properties": {
        "Port": {
          "description": "Port number of the given endpoint.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.core.v1.DownwardAPIProjection": {
      "description": "Represents downward API info for projecting into a projected volume. Note that this is identical to a downwardAPI volume source without the default mode.",
      "type": "object",
      "properties": {
        "items": {
          "description": "Items is a list of DownwardAPIVolume file",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.DownwardAPIVolumeFile"
          }
        }
      }
    },
    "io.k8s.api.core.v1.DownwardAPIVolumeFile": {
      "description": "DownwardAPIVolumeFile represents information to create the file containing the pod field",
      "type": "object",
      "required": ["path"],
      "properties": {
        "fieldRef": {
          "description": "Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectFieldSelector"
        },
        "mode": {
          "description": "Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
          "type": "integer",
          "format": "int32"
        },
        "path": {
          "description": "Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'",
          "type": "string"
        },
        "resourceFieldRef": {
          "description": "Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ResourceFieldSelector"
        }
      }
    },
    "io.k8s.api.core.v1.DownwardAPIVolumeSource": {
      "description": "DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.",
      "type": "object",
      "properties": {
        "defaultMode": {
          "description": "Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
          "type": "integer",
          "format": "int32"
        },
        "items": {
          "description": "Items is a list of downward API volume file",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.DownwardAPIVolumeFile"
          }
        }
      }
    },
    "io.k8s.api.core.v1.EmptyDirVolumeSource": {
      "description": "Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.",
      "type": "object",
      "properties": {
        "medium": {
          "description": "What type of storage medium should back this directory. The default is \"\" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir",
          "type": "string"
        },
        "sizeLimit": {
          "description": "Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        }
      }
    },
    "io.k8s.api.core.v1.EndpointAddress": {
      "description": "EndpointAddress is a tuple that describes single IP address.",
      "type": "object",
      "required": ["ip"],
      "properties": {
        "hostname": {
          "description": "The Hostname of this endpoint",
          "type": "string"
        },
        "ip": {
          "description": "The IP of this endpoint. May not be loopback (127.0.0.0/8), link-local (169.254.0.0/16), or link-local multicast ((224.0.0.0/24). IPv6 is also accepted but not fully supported on all platforms. Also, certain kubernetes components, like kube-proxy, are not IPv6 ready.",
          "type": "string"
        },
        "nodeName": {
          "description": "Optional: Node hosting this endpoint. This can be used to determine endpoints local to a node.",
          "type": "string"
        },
        "targetRef": {
          "description": "Reference to object providing the endpoint.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.core.v1.EndpointPort": {
      "description": "EndpointPort is a tuple that describes a single port.",
      "type": "object",
      "required": ["port"],
      "properties": {
        "appProtocol": {
          "description": "The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and http://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol.",
          "type": "string"
        },
        "name": {
          "description": "The name of this port.  This must match the 'name' field in the corresponding ServicePort. Must be a DNS_LABEL. Optional only if one port is defined.",
          "type": "string"
        },
        "port": {
          "description": "The port number of the endpoint.",
          "type": "integer",
          "format": "int32"
        },
        "protocol": {
          "description": "The IP protocol for this port. Must be UDP, TCP, or SCTP. Default is TCP.",
          "type": "string"
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.core.v1.EndpointSubset": {
      "description": "EndpointSubset is a group of addresses with a common set of ports. The expanded set of endpoints is the Cartesian product of Addresses x Ports. For example, given:\n  {\n    Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n    Ports:     [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n  }\nThe resulting set of endpoints can be viewed as:\n    a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],\n    b: [ 10.10.1.1:309, 10.10.2.2:309 ]",
      "type": "object",
      "properties": {
        "addresses": {
          "description": "IP addresses which offer the related ports that are marked as ready. These endpoints should be considered safe for load balancers and clients to utilize.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.EndpointAddress"
          }
        },
        "notReadyAddresses": {
          "description": "IP addresses which offer the related ports but are not currently marked as ready because they have not yet finished starting, have recently failed a readiness check, or have recently failed a liveness check.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.EndpointAddress"
          }
        },
        "ports": {
          "description": "Port numbers available on the related IP addresses.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.EndpointPort"
          }
        }
      }
    },
    "io.k8s.api.core.v1.Endpoints": {
      "description": "Endpoints is a collection of endpoints that implement the actual service. Example:\n  Name: \"mysvc\",\n  Subsets: [\n    {\n      Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n      Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n    },\n    {\n      Addresses: [{\"ip\": \"10.10.3.3\"}],\n      Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n    },\n ]",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Endpoints"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "subsets": {
          "description": "The set of all endpoints is the union of all subsets. Addresses are placed into subsets according to the IPs they share. A single address with multiple ports, some of which are ready and some of which are not (because they come from different containers) will result in the address being displayed in different subsets for the different ports. No address will appear in both Addresses and NotReadyAddresses in the same subset. Sets of addresses and ports that comprise a service.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.EndpointSubset"
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "Endpoints",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.EndpointsList": {
      "description": "EndpointsList is a list of endpoints.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "items": {
          "description": "List of endpoints.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.Endpoints"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["EndpointsList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "EndpointsList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.EnvFromSource": {
      "description": "EnvFromSource represents the source of a set of ConfigMaps",
      "type": "object",
      "properties": {
        "configMapRef": {
          "description": "The ConfigMap to select from",
          "$ref": "#/definitions/io.k8s.api.core.v1.ConfigMapEnvSource"
        },
        "prefix": {
          "description": "An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.",
          "type": "string"
        },
        "secretRef": {
          "description": "The Secret to select from",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretEnvSource"
        }
      }
    },
    "io.k8s.api.core.v1.EnvVar": {
      "description": "EnvVar represents an environment variable present in a Container.",
      "type": "object",
      "required": ["name"],
      "properties": {
        "name": {
          "description": "Name of the environment variable. Must be a C_IDENTIFIER.",
          "type": "string"
        },
        "value": {
          "description": "Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to \"\".",
          "type": "string"
        },
        "valueFrom": {
          "description": "Source for the environment variable's value. Cannot be used if value is not empty.",
          "$ref": "#/definitions/io.k8s.api.core.v1.EnvVarSource"
        }
      }
    },
    "io.k8s.api.core.v1.EnvVarSource": {
      "description": "EnvVarSource represents a source for the value of an EnvVar.",
      "type": "object",
      "properties": {
        "configMapKeyRef": {
          "description": "Selects a key of a ConfigMap.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ConfigMapKeySelector"
        },
        "fieldRef": {
          "description": "Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectFieldSelector"
        },
        "resourceFieldRef": {
          "description": "Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ResourceFieldSelector"
        },
        "secretKeyRef": {
          "description": "Selects a key of a secret in the pod's namespace",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        }
      }
    },
    "io.k8s.api.core.v1.EphemeralContainer": {
      "description": "An EphemeralContainer is a container that may be added temporarily to an existing pod for user-initiated activities such as debugging. Ephemeral containers have no resource or scheduling guarantees, and they will not be restarted when they exit or when a pod is removed or restarted. If an ephemeral container causes a pod to exceed its resource allocation, the pod may be evicted. Ephemeral containers may not be added by directly updating the pod spec. They must be added via the pod's ephemeralcontainers subresource, and they will appear in the pod spec once added. This is an alpha feature enabled by the EphemeralContainers feature flag.",
      "type": "object",
      "required": ["name"],
      "properties": {
        "args": {
          "description": "Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "command": {
          "description": "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "env": {
          "description": "List of environment variables to set in the container. Cannot be updated.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.EnvVar"
          },
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "envFrom": {
          "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.EnvFromSource"
          }
        },
        "image": {
          "description": "Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images",
          "type": "string"
        },
        "imagePullPolicy": {
          "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
          "type": "string"
        },
        "lifecycle": {
          "description": "Lifecycle is not allowed for ephemeral containers.",
          "$ref": "#/definitions/io.k8s.api.core.v1.Lifecycle"
        },
        "livenessProbe": {
          "description": "Probes are not allowed for ephemeral containers.",
          "$ref": "#/definitions/io.k8s.api.core.v1.Probe"
        },
        "name": {
          "description": "Name of the ephemeral container specified as a DNS_LABEL. This name must be unique among all containers, init containers and ephemeral containers.",
          "type": "string"
        },
        "ports": {
          "description": "Ports are not allowed for ephemeral containers.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ContainerPort"
          }
        },
        "readinessProbe": {
          "description": "Probes are not allowed for ephemeral containers.",
          "$ref": "#/definitions/io.k8s.api.core.v1.Probe"
        },
        "resources": {
          "description": "Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources already allocated to the pod.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ResourceRequirements"
        },
        "securityContext": {
          "description": "Optional: SecurityContext defines the security options the ephemeral container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecurityContext"
        },
        "startupProbe": {
          "description": "Probes are not allowed for ephemeral containers.",
          "$ref": "#/definitions/io.k8s.api.core.v1.Probe"
        },
        "stdin": {
          "description": "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
          "type": "boolean"
        },
        "stdinOnce": {
          "description": "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
          "type": "boolean"
        },
        "targetContainerName": {
          "description": "If set, the name of the container from PodSpec that this ephemeral container targets. The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container. If not set then the ephemeral container is run in whatever namespaces are shared for the pod. Note that the container runtime must support this feature.",
          "type": "string"
        },
        "terminationMessagePath": {
          "description": "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
          "type": "string"
        },
        "terminationMessagePolicy": {
          "description": "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
          "type": "string"
        },
        "tty": {
          "description": "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
          "type": "boolean"
        },
        "volumeDevices": {
          "description": "volumeDevices is the list of block devices to be used by the container.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.VolumeDevice"
          },
          "x-kubernetes-patch-merge-key": "devicePath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumeMounts": {
          "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.VolumeMount"
          },
          "x-kubernetes-patch-merge-key": "mountPath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "workingDir": {
          "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.EphemeralVolumeSource": {
      "description": "Represents an ephemeral volume that is handled by a normal storage driver.",
      "type": "object",
      "properties": {
        "volumeClaimTemplate": {
          "description": "Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).\n\nAn existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.\n\nThis field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.\n\nRequired, must not be nil.",
          "$ref": "#/definitions/io.k8s.api.core.v1.PersistentVolumeClaimTemplate"
        }
      }
    },
    "io.k8s.api.core.v1.Event": {
      "description": "Event is a report of an event somewhere in the cluster.  Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data.",
      "type": "object",
      "required": ["metadata", "involvedObject"],
      "properties": {
        "action": {
          "description": "What action was taken/failed regarding to the Regarding object.",
          "type": "string"
        },
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "count": {
          "description": "The number of times this event has occurred.",
          "type": "integer",
          "format": "int32"
        },
        "eventTime": {
          "description": "Time when this Event was first observed.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime"
        },
        "firstTimestamp": {
          "description": "The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "involvedObject": {
          "description": "The object that this event is about.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Event"]
        },
        "lastTimestamp": {
          "description": "The time at which the most recent occurrence of this event was recorded.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "A human-readable description of the status of this operation.",
          "type": "string"
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "reason": {
          "description": "This should be a short, machine understandable string that gives the reason for the transition into the object's current status.",
          "type": "string"
        },
        "related": {
          "description": "Optional secondary object for more complex actions.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        },
        "reportingComponent": {
          "description": "Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.",
          "type": "string"
        },
        "reportingInstance": {
          "description": "ID of the controller instance, e.g. `kubelet-xyzf`.",
          "type": "string"
        },
        "series": {
          "description": "Data about the Event series this event represents or nil if it's a singleton Event.",
          "$ref": "#/definitions/io.k8s.api.core.v1.EventSeries"
        },
        "source": {
          "description": "The component reporting this event. Should be a short machine understandable string.",
          "$ref": "#/definitions/io.k8s.api.core.v1.EventSource"
        },
        "type": {
          "description": "Type of this event (Normal, Warning), new types could be added in the future",
          "type": "string"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "Event",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.EventList": {
      "description": "EventList is a list of events.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "items": {
          "description": "List of events",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.Event"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["EventList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "EventList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.EventSeries": {
      "description": "EventSeries contain information on series of events, i.e. thing that was/is happening continuously for some time.",
      "type": "object",
      "properties": {
        "count": {
          "description": "Number of occurrences in this series up to the last heartbeat time",
          "type": "integer",
          "format": "int32"
        },
        "lastObservedTime": {
          "description": "Time of the last occurrence observed",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime"
        }
      }
    },
    "io.k8s.api.core.v1.EventSource": {
      "description": "EventSource contains information for an event.",
      "type": "object",
      "properties": {
        "component": {
          "description": "Component from which the event is generated.",
          "type": "string"
        },
        "host": {
          "description": "Node name on which the event is generated.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.ExecAction": {
      "description": "ExecAction describes a \"run in container\" action.",
      "type": "object",
      "properties": {
        "command": {
          "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.core.v1.FCVolumeSource": {
      "description": "Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling.",
      "type": "object",
      "properties": {
        "fsType": {
          "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
          "type": "string"
        },
        "lun": {
          "description": "Optional: FC target lun number",
          "type": "integer",
          "format": "int32"
        },
        "readOnly": {
          "description": "Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
          "type": "boolean"
        },
        "targetWWNs": {
          "description": "Optional: FC target worldwide names (WWNs)",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "wwids": {
          "description": "Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.core.v1.FlexPersistentVolumeSource": {
      "description": "FlexPersistentVolumeSource represents a generic persistent volume resource that is provisioned/attached using an exec based plugin.",
      "type": "object",
      "required": ["driver"],
      "properties": {
        "driver": {
          "description": "Driver is the name of the driver to use for this volume.",
          "type": "string"
        },
        "fsType": {
          "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". The default filesystem depends on FlexVolume script.",
          "type": "string"
        },
        "options": {
          "description": "Optional: Extra command options if any.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "readOnly": {
          "description": "Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
          "type": "boolean"
        },
        "secretRef": {
          "description": "Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretReference"
        }
      }
    },
    "io.k8s.api.core.v1.FlexVolumeSource": {
      "description": "FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.",
      "type": "object",
      "required": ["driver"],
      "properties": {
        "driver": {
          "description": "Driver is the name of the driver to use for this volume.",
          "type": "string"
        },
        "fsType": {
          "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". The default filesystem depends on FlexVolume script.",
          "type": "string"
        },
        "options": {
          "description": "Optional: Extra command options if any.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "readOnly": {
          "description": "Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
          "type": "boolean"
        },
        "secretRef": {
          "description": "Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.",
          "$ref": "#/definitions/io.k8s.api.core.v1.LocalObjectReference"
        }
      }
    },
    "io.k8s.api.core.v1.FlockerVolumeSource": {
      "description": "Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.",
      "type": "object",
      "properties": {
        "datasetName": {
          "description": "Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated",
          "type": "string"
        },
        "datasetUUID": {
          "description": "UUID of the dataset. This is unique identifier of a Flocker dataset",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.GCEPersistentDiskVolumeSource": {
      "description": "Represents a Persistent Disk resource in Google Compute Engine.\n\nA GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.",
      "type": "object",
      "required": ["pdName"],
      "properties": {
        "fsType": {
          "description": "Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk",
          "type": "string"
        },
        "partition": {
          "description": "The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk",
          "type": "integer",
          "format": "int32"
        },
        "pdName": {
          "description": "Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk",
          "type": "string"
        },
        "readOnly": {
          "description": "ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk",
          "type": "boolean"
        }
      }
    },
    "io.k8s.api.core.v1.GitRepoVolumeSource": {
      "description": "Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.\n\nDEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.",
      "type": "object",
      "required": ["repository"],
      "properties": {
        "directory": {
          "description": "Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.",
          "type": "string"
        },
        "repository": {
          "description": "Repository URL",
          "type": "string"
        },
        "revision": {
          "description": "Commit hash for the specified revision.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.GlusterfsPersistentVolumeSource": {
      "description": "Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling.",
      "type": "object",
      "required": ["endpoints", "path"],
      "properties": {
        "endpoints": {
          "description": "EndpointsName is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod",
          "type": "string"
        },
        "endpointsNamespace": {
          "description": "EndpointsNamespace is the namespace that contains Glusterfs endpoint. If this field is empty, the EndpointNamespace defaults to the same namespace as the bound PVC. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod",
          "type": "string"
        },
        "path": {
          "description": "Path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod",
          "type": "string"
        },
        "readOnly": {
          "description": "ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod",
          "type": "boolean"
        }
      }
    },
    "io.k8s.api.core.v1.GlusterfsVolumeSource": {
      "description": "Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling.",
      "type": "object",
      "required": ["endpoints", "path"],
      "properties": {
        "endpoints": {
          "description": "EndpointsName is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod",
          "type": "string"
        },
        "path": {
          "description": "Path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod",
          "type": "string"
        },
        "readOnly": {
          "description": "ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod",
          "type": "boolean"
        }
      }
    },
    "io.k8s.api.core.v1.HTTPGetAction": {
      "description": "HTTPGetAction describes an action based on HTTP Get requests.",
      "type": "object",
      "required": ["port"],
      "properties": {
        "host": {
          "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
          "type": "string"
        },
        "httpHeaders": {
          "description": "Custom headers to set in the request. HTTP allows repeated headers.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.HTTPHeader"
          }
        },
        "path": {
          "description": "Path to access on the HTTP server.",
          "type": "string"
        },
        "port": {
          "description": "Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
        },
        "scheme": {
          "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.HTTPHeader": {
      "description": "HTTPHeader describes a custom header to be used in HTTP probes",
      "type": "object",
      "required": ["name", "value"],
      "properties": {
        "name": {
          "description": "The header field name",
          "type": "string"
        },
        "value": {
          "description": "The header field value",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.Handler": {
      "description": "Handler defines a specific action that should be taken",
      "type": "object",
      "properties": {
        "exec": {
          "description": "One and only one of the following should be specified. Exec specifies the action to take.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ExecAction"
        },
        "httpGet": {
          "description": "HTTPGet specifies the http request to perform.",
          "$ref": "#/definitions/io.k8s.api.core.v1.HTTPGetAction"
        },
        "tcpSocket": {
          "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported",
          "$ref": "#/definitions/io.k8s.api.core.v1.TCPSocketAction"
        }
      }
    },
    "io.k8s.api.core.v1.HostAlias": {
      "description": "HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.",
      "type": "object",
      "properties": {
        "hostnames": {
          "description": "Hostnames for the above IP address.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "ip": {
          "description": "IP address of the host file entry.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.HostPathVolumeSource": {
      "description": "Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling.",
      "type": "object",
      "required": ["path"],
      "properties": {
        "path": {
          "description": "Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath",
          "type": "string"
        },
        "type": {
          "description": "Type for HostPath Volume Defaults to \"\" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.ISCSIPersistentVolumeSource": {
      "description": "ISCSIPersistentVolumeSource represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.",
      "type": "object",
      "required": ["targetPortal", "iqn", "lun"],
      "properties": {
        "chapAuthDiscovery": {
          "description": "whether support iSCSI Discovery CHAP authentication",
          "type": "boolean"
        },
        "chapAuthSession": {
          "description": "whether support iSCSI Session CHAP authentication",
          "type": "boolean"
        },
        "fsType": {
          "description": "Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi",
          "type": "string"
        },
        "initiatorName": {
          "description": "Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.",
          "type": "string"
        },
        "iqn": {
          "description": "Target iSCSI Qualified Name.",
          "type": "string"
        },
        "iscsiInterface": {
          "description": "iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).",
          "type": "string"
        },
        "lun": {
          "description": "iSCSI Target Lun number.",
          "type": "integer",
          "format": "int32"
        },
        "portals": {
          "description": "iSCSI Target Portal List. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "readOnly": {
          "description": "ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.",
          "type": "boolean"
        },
        "secretRef": {
          "description": "CHAP Secret for iSCSI target and initiator authentication",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretReference"
        },
        "targetPortal": {
          "description": "iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.ISCSIVolumeSource": {
      "description": "Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.",
      "type": "object",
      "required": ["targetPortal", "iqn", "lun"],
      "properties": {
        "chapAuthDiscovery": {
          "description": "whether support iSCSI Discovery CHAP authentication",
          "type": "boolean"
        },
        "chapAuthSession": {
          "description": "whether support iSCSI Session CHAP authentication",
          "type": "boolean"
        },
        "fsType": {
          "description": "Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi",
          "type": "string"
        },
        "initiatorName": {
          "description": "Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.",
          "type": "string"
        },
        "iqn": {
          "description": "Target iSCSI Qualified Name.",
          "type": "string"
        },
        "iscsiInterface": {
          "description": "iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).",
          "type": "string"
        },
        "lun": {
          "description": "iSCSI Target Lun number.",
          "type": "integer",
          "format": "int32"
        },
        "portals": {
          "description": "iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "readOnly": {
          "description": "ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.",
          "type": "boolean"
        },
        "secretRef": {
          "description": "CHAP Secret for iSCSI target and initiator authentication",
          "$ref": "#/definitions/io.k8s.api.core.v1.LocalObjectReference"
        },
        "targetPortal": {
          "description": "iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.KeyToPath": {
      "description": "Maps a string key to a path within a volume.",
      "type": "object",
      "required": ["key", "path"],
      "properties": {
        "key": {
          "description": "The key to project.",
          "type": "string"
        },
        "mode": {
          "description": "Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
          "type": "integer",
          "format": "int32"
        },
        "path": {
          "description": "The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.Lifecycle": {
      "description": "Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.",
      "type": "object",
      "properties": {
        "postStart": {
          "description": "PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks",
          "$ref": "#/definitions/io.k8s.api.core.v1.Handler"
        },
        "preStop": {
          "description": "PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The reason for termination is passed to the handler. The Pod's termination grace period countdown begins before the PreStop hooked is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period. Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks",
          "$ref": "#/definitions/io.k8s.api.core.v1.Handler"
        }
      }
    },
    "io.k8s.api.core.v1.LimitRange": {
      "description": "LimitRange sets resource usage limits for each kind of resource in a Namespace.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["LimitRange"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the limits enforced. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.core.v1.LimitRangeSpec"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "LimitRange",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.LimitRangeItem": {
      "description": "LimitRangeItem defines a min/max usage limit for any resource that matches on kind.",
      "type": "object",
      "required": ["type"],
      "properties": {
        "default": {
          "description": "Default resource requirement limit value by resource name if resource limit is omitted.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          }
        },
        "defaultRequest": {
          "description": "DefaultRequest is the default resource requirement request value by resource name if resource request is omitted.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          }
        },
        "max": {
          "description": "Max usage constraints on this kind by resource name.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          }
        },
        "maxLimitRequestRatio": {
          "description": "MaxLimitRequestRatio if specified, the named resource must have a request and limit that are both non-zero where limit divided by request is less than or equal to the enumerated value; this represents the max burst for the named resource.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          }
        },
        "min": {
          "description": "Min usage constraints on this kind by resource name.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          }
        },
        "type": {
          "description": "Type of resource that this limit applies to.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.LimitRangeList": {
      "description": "LimitRangeList is a list of LimitRange items.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "items": {
          "description": "Items is a list of LimitRange objects. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.LimitRange"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["LimitRangeList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "LimitRangeList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.LimitRangeSpec": {
      "description": "LimitRangeSpec defines a min/max usage limit for resources that match on kind.",
      "type": "object",
      "required": ["limits"],
      "properties": {
        "limits": {
          "description": "Limits is the list of LimitRangeItem objects that are enforced.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.LimitRangeItem"
          }
        }
      }
    },
    "io.k8s.api.core.v1.LoadBalancerIngress": {
      "description": "LoadBalancerIngress represents the status of a load-balancer ingress point: traffic intended for the service should be sent to an ingress point.",
      "type": "object",
      "properties": {
        "hostname": {
          "description": "Hostname is set for load-balancer ingress points that are DNS based (typically AWS load-balancers)",
          "type": "string"
        },
        "ip": {
          "description": "IP is set for load-balancer ingress points that are IP based (typically GCE or OpenStack load-balancers)",
          "type": "string"
        },
        "ports": {
          "description": "Ports is a list of records of service ports If used, every port defined in the service should have an entry in it",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.PortStatus"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "io.k8s.api.core.v1.LoadBalancerStatus": {
      "description": "LoadBalancerStatus represents the status of a load-balancer.",
      "type": "object",
      "properties": {
        "ingress": {
          "description": "Ingress is a list containing ingress points for the load-balancer. Traffic intended for the service should be sent to these ingress points.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.LoadBalancerIngress"
          }
        }
      }
    },
    "io.k8s.api.core.v1.LocalObjectReference": {
      "description": "LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.",
      "type": "object",
      "properties": {
        "name": {
          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
          "type": "string"
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.core.v1.LocalVolumeSource": {
      "description": "Local represents directly-attached storage with node affinity (Beta feature)",
      "type": "object",
      "required": ["path"],
      "properties": {
        "fsType": {
          "description": "Filesystem type to mount. It applies only when the Path is a block device. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". The default value is to auto-select a fileystem if unspecified.",
          "type": "string"
        },
        "path": {
          "description": "The full path to the volume on the node. It can be either a directory or block device (disk, partition, ...).",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.NFSVolumeSource": {
      "description": "Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling.",
      "type": "object",
      "required": ["server", "path"],
      "properties": {
        "path": {
          "description": "Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs",
          "type": "string"
        },
        "readOnly": {
          "description": "ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs",
          "type": "boolean"
        },
        "server": {
          "description": "Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.Namespace": {
      "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Namespace"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the behavior of the Namespace. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.core.v1.NamespaceSpec"
        },
        "status": {
          "description": "Status describes the current status of a Namespace. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.core.v1.NamespaceStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "Namespace",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.NamespaceCondition": {
      "description": "NamespaceCondition contains details about state of namespace.",
      "type": "object",
      "required": ["type", "status"],
      "properties": {
        "lastTransitionTime": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "type": "string"
        },
        "reason": {
          "type": "string"
        },
        "status": {
          "description": "Status of the condition, one of True, False, Unknown.",
          "type": "string"
        },
        "type": {
          "description": "Type of namespace controller condition.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.NamespaceList": {
      "description": "NamespaceList is a list of Namespaces.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "items": {
          "description": "Items is the list of Namespace objects in the list. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.Namespace"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NamespaceList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "NamespaceList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.NamespaceSpec": {
      "description": "NamespaceSpec describes the attributes on a Namespace.",
      "type": "object",
      "properties": {
        "finalizers": {
          "description": "Finalizers is an opaque list of values that must be empty to permanently remove object from storage. More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.core.v1.NamespaceStatus": {
      "description": "NamespaceStatus is information about the current status of a Namespace.",
      "type": "object",
      "properties": {
        "conditions": {
          "description": "Represents the latest available observations of a namespace's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.NamespaceCondition"
          },
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        },
        "phase": {
          "description": "Phase is the current lifecycle phase of the namespace. More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.Node": {
      "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd).",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Node"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the behavior of a node. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.core.v1.NodeSpec"
        },
        "status": {
          "description": "Most recently observed status of the node. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.core.v1.NodeStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "Node",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.NodeAddress": {
      "description": "NodeAddress contains information for the node's address.",
      "type": "object",
      "required": ["type", "address"],
      "properties": {
        "address": {
          "description": "The node address.",
          "type": "string"
        },
        "type": {
          "description": "Node address type, one of Hostname, ExternalIP or InternalIP.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.NodeAffinity": {
      "description": "Node affinity is a group of node affinity scheduling rules.",
      "type": "object",
      "properties": {
        "preferredDuringSchedulingIgnoredDuringExecution": {
          "description": "The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.PreferredSchedulingTerm"
          }
        },
        "requiredDuringSchedulingIgnoredDuringExecution": {
          "description": "If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.",
          "$ref": "#/definitions/io.k8s.api.core.v1.NodeSelector"
        }
      }
    },
    "io.k8s.api.core.v1.NodeCondition": {
      "description": "NodeCondition contains condition information for a node.",
      "type": "object",
      "required": ["type", "status"],
      "properties": {
        "lastHeartbeatTime": {
          "description": "Last time we got an update on a given condition.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "lastTransitionTime": {
          "description": "Last time the condition transit from one status to another.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "Human readable message indicating details about last transition.",
          "type": "string"
        },
        "reason": {
          "description": "(brief) reason for the condition's last transition.",
          "type": "string"
        },
        "status": {
          "description": "Status of the condition, one of True, False, Unknown.",
          "type": "string"
        },
        "type": {
          "description": "Type of node condition.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.NodeConfigSource": {
      "description": "NodeConfigSource specifies a source of node configuration. Exactly one subfield (excluding metadata) must be non-nil. This API is deprecated since 1.22",
      "type": "object",
      "properties": {
        "configMap": {
          "description": "ConfigMap is a reference to a Node's ConfigMap",
          "$ref": "#/definitions/io.k8s.api.core.v1.ConfigMapNodeConfigSource"
        }
      }
    },
    "io.k8s.api.core.v1.NodeConfigStatus": {
      "description": "NodeConfigStatus describes the status of the config assigned by Node.Spec.ConfigSource.",
      "type": "object",
      "properties": {
        "active": {
          "description": "Active reports the checkpointed config the node is actively using. Active will represent either the current version of the Assigned config, or the current LastKnownGood config, depending on whether attempting to use the Assigned config results in an error.",
          "$ref": "#/definitions/io.k8s.api.core.v1.NodeConfigSource"
        },
        "assigned": {
          "description": "Assigned reports the checkpointed config the node will try to use. When Node.Spec.ConfigSource is updated, the node checkpoints the associated config payload to local disk, along with a record indicating intended config. The node refers to this record to choose its config checkpoint, and reports this record in Assigned. Assigned only updates in the status after the record has been checkpointed to disk. When the Kubelet is restarted, it tries to make the Assigned config the Active config by loading and validating the checkpointed payload identified by Assigned.",
          "$ref": "#/definitions/io.k8s.api.core.v1.NodeConfigSource"
        },
        "error": {
          "description": "Error describes any problems reconciling the Spec.ConfigSource to the Active config. Errors may occur, for example, attempting to checkpoint Spec.ConfigSource to the local Assigned record, attempting to checkpoint the payload associated with Spec.ConfigSource, attempting to load or validate the Assigned config, etc. Errors may occur at different points while syncing config. Earlier errors (e.g. download or checkpointing errors) will not result in a rollback to LastKnownGood, and may resolve across Kubelet retries. Later errors (e.g. loading or validating a checkpointed config) will result in a rollback to LastKnownGood. In the latter case, it is usually possible to resolve the error by fixing the config assigned in Spec.ConfigSource. You can find additional information for debugging by searching the error message in the Kubelet log. Error is a human-readable description of the error state; machines can check whether or not Error is empty, but should not rely on the stability of the Error text across Kubelet versions.",
          "type": "string"
        },
        "lastKnownGood": {
          "description": "LastKnownGood reports the checkpointed config the node will fall back to when it encounters an error attempting to use the Assigned config. The Assigned config becomes the LastKnownGood config when the node determines that the Assigned config is stable and correct. This is currently implemented as a 10-minute soak period starting when the local record of Assigned config is updated. If the Assigned config is Active at the end of this period, it becomes the LastKnownGood. Note that if Spec.ConfigSource is reset to nil (use local defaults), the LastKnownGood is also immediately reset to nil, because the local default config is always assumed good. You should not make assumptions about the node's method of determining config stability and correctness, as this may change or become configurable in the future.",
          "$ref": "#/definitions/io.k8s.api.core.v1.NodeConfigSource"
        }
      }
    },
    "io.k8s.api.core.v1.NodeDaemonEndpoints": {
      "description": "NodeDaemonEndpoints lists ports opened by daemons running on the Node.",
      "type": "object",
      "properties": {
        "kubeletEndpoint": {
          "description": "Endpoint on which Kubelet is listening.",
          "$ref": "#/definitions/io.k8s.api.core.v1.DaemonEndpoint"
        }
      }
    },
    "io.k8s.api.core.v1.NodeList": {
      "description": "NodeList is the whole list of all Nodes which have been registered with master.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "items": {
          "description": "List of nodes",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.Node"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NodeList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "NodeList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.NodeSelector": {
      "description": "A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.",
      "type": "object",
      "required": ["nodeSelectorTerms"],
      "properties": {
        "nodeSelectorTerms": {
          "description": "Required. A list of node selector terms. The terms are ORed.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.NodeSelectorTerm"
          }
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.core.v1.NodeSelectorRequirement": {
      "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      "type": "object",
      "required": ["key", "operator"],
      "properties": {
        "key": {
          "description": "The label key that the selector applies to.",
          "type": "string"
        },
        "operator": {
          "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
          "type": "string"
        },
        "values": {
          "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.core.v1.NodeSelectorTerm": {
      "description": "A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.",
      "type": "object",
      "properties": {
        "matchExpressions": {
          "description": "A list of node selector requirements by node's labels.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.NodeSelectorRequirement"
          }
        },
        "matchFields": {
          "description": "A list of node selector requirements by node's fields.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.NodeSelectorRequirement"
          }
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.core.v1.NodeSpec": {
      "description": "NodeSpec describes the attributes that a node is created with.",
      "type": "object",
      "properties": {
        "configSource": {
          "description": "Deprecated. If specified, the source of the node's configuration. The DynamicKubeletConfig feature gate must be enabled for the Kubelet to use this field. This field is deprecated as of 1.22: https://git.k8s.io/enhancements/keps/sig-node/281-dynamic-kubelet-configuration",
          "$ref": "#/definitions/io.k8s.api.core.v1.NodeConfigSource"
        },
        "externalID": {
          "description": "Deprecated. Not all kubelets will set this field. Remove field after 1.13. see: https://issues.k8s.io/61966",
          "type": "string"
        },
        "podCIDR": {
          "description": "PodCIDR represents the pod IP range assigned to the node.",
          "type": "string"
        },
        "podCIDRs": {
          "description": "podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node. If this field is specified, the 0th entry must match the podCIDR field. It may contain at most 1 value for each of IPv4 and IPv6.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-patch-strategy": "merge"
        },
        "providerID": {
          "description": "ID of the node assigned by the cloud provider in the format: <ProviderName>://<ProviderSpecificNodeID>",
          "type": "string"
        },
        "taints": {
          "description": "If specified, the node's taints.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.Taint"
          }
        },
        "unschedulable": {
          "description": "Unschedulable controls node schedulability of new pods. By default, node is schedulable. More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration",
          "type": "boolean"
        }
      }
    },
    "io.k8s.api.core.v1.NodeStatus": {
      "description": "NodeStatus is information about the current status of a node.",
      "type": "object",
      "properties": {
        "addresses": {
          "description": "List of addresses reachable to the node. Queried from cloud provider, if available. More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses Note: This field is declared as mergeable, but the merge key is not sufficiently unique, which can cause data corruption when it is merged. Callers should instead use a full-replacement patch. See http://pr.k8s.io/79391 for an example.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.NodeAddress"
          },
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        },
        "allocatable": {
          "description": "Allocatable represents the resources of a node that are available for scheduling. Defaults to Capacity.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          }
        },
        "capacity": {
          "description": "Capacity represents the total resources of a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          }
        },
        "conditions": {
          "description": "Conditions is an array of current observed node conditions. More info: https://kubernetes.io/docs/concepts/nodes/node/#condition",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.NodeCondition"
          },
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        },
        "config": {
          "description": "Status of the config assigned to the node via the dynamic Kubelet config feature.",
          "$ref": "#/definitions/io.k8s.api.core.v1.NodeConfigStatus"
        },
        "daemonEndpoints": {
          "description": "Endpoints of daemons running on the Node.",
          "$ref": "#/definitions/io.k8s.api.core.v1.NodeDaemonEndpoints"
        },
        "images": {
          "description": "List of container images on this node",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ContainerImage"
          }
        },
        "nodeInfo": {
          "description": "Set of ids/uuids to uniquely identify the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#info",
          "$ref": "#/definitions/io.k8s.api.core.v1.NodeSystemInfo"
        },
        "phase": {
          "description": "NodePhase is the recently observed lifecycle phase of the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#phase The field is never populated, and now is deprecated.",
          "type": "string"
        },
        "volumesAttached": {
          "description": "List of volumes that are attached to the node.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.AttachedVolume"
          }
        },
        "volumesInUse": {
          "description": "List of attachable volumes in use (mounted) by the node.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.core.v1.NodeSystemInfo": {
      "description": "NodeSystemInfo is a set of ids/uuids to uniquely identify the node.",
      "type": "object",
      "required": [
        "machineID",
        "systemUUID",
        "bootID",
        "kernelVersion",
        "osImage",
        "containerRuntimeVersion",
        "kubeletVersion",
        "kubeProxyVersion",
        "operatingSystem",
        "architecture"
      ],
      "properties": {
        "architecture": {
          "description": "The Architecture reported by the node",
          "type": "string"
        },
        "bootID": {
          "description": "Boot ID reported by the node.",
          "type": "string"
        },
        "containerRuntimeVersion": {
          "description": "ContainerRuntime Version reported by the node through runtime remote API (e.g. docker://1.5.0).",
          "type": "string"
        },
        "kernelVersion": {
          "description": "Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).",
          "type": "string"
        },
        "kubeProxyVersion": {
          "description": "KubeProxy Version reported by the node.",
          "type": "string"
        },
        "kubeletVersion": {
          "description": "Kubelet Version reported by the node.",
          "type": "string"
        },
        "machineID": {
          "description": "MachineID reported by the node. For unique machine identification in the cluster this field is preferred. Learn more from man(5) machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html",
          "type": "string"
        },
        "operatingSystem": {
          "description": "The Operating System reported by the node",
          "type": "string"
        },
        "osImage": {
          "description": "OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).",
          "type": "string"
        },
        "systemUUID": {
          "description": "SystemUUID reported by the node. For unique machine identification MachineID is preferred. This field is specific to Red Hat hosts https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.ObjectFieldSelector": {
      "description": "ObjectFieldSelector selects an APIVersioned field of an object.",
      "type": "object",
      "required": ["fieldPath"],
      "properties": {
        "apiVersion": {
          "description": "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".",
          "type": "string"
        },
        "fieldPath": {
          "description": "Path of the field to select in the specified API version.",
          "type": "string"
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.core.v1.ObjectReference": {
      "description": "ObjectReference contains enough information to let you inspect or modify the referred object.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "API version of the referent.",
          "type": "string"
        },
        "fieldPath": {
          "description": "If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \"spec.containers{name}\" (where \"name\" refers to the name of the container that triggered the event) or if no container name is specified \"spec.containers[2]\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.",
          "type": "string"
        },
        "kind": {
          "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "name": {
          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
          "type": "string"
        },
        "resourceVersion": {
          "description": "Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
          "type": "string"
        },
        "uid": {
          "description": "UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids",
          "type": "string"
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.core.v1.PersistentVolume": {
      "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PersistentVolume"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines a specification of a persistent volume owned by the cluster. Provisioned by an administrator. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes",
          "$ref": "#/definitions/io.k8s.api.core.v1.PersistentVolumeSpec"
        },
        "status": {
          "description": "Status represents the current information/status for the persistent volume. Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes",
          "$ref": "#/definitions/io.k8s.api.core.v1.PersistentVolumeStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "PersistentVolume",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.PersistentVolumeClaim": {
      "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PersistentVolumeClaim"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims",
          "$ref": "#/definitions/io.k8s.api.core.v1.PersistentVolumeClaimSpec"
        },
        "status": {
          "description": "Status represents the current information/status of a persistent volume claim. Read-only. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims",
          "$ref": "#/definitions/io.k8s.api.core.v1.PersistentVolumeClaimStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "PersistentVolumeClaim",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.PersistentVolumeClaimCondition": {
      "description": "PersistentVolumeClaimCondition contails details about state of pvc",
      "type": "object",
      "required": ["type", "status"],
      "properties": {
        "lastProbeTime": {
          "description": "Last time we probed the condition.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "lastTransitionTime": {
          "description": "Last time the condition transitioned from one status to another.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "Human-readable message indicating details about last transition.",
          "type": "string"
        },
        "reason": {
          "description": "Unique, this should be a short, machine understandable string that gives the reason for condition's last transition. If it reports \"ResizeStarted\" that means the underlying persistent volume is being resized.",
          "type": "string"
        },
        "status": {
          "type": "string"
        },
        "type": {
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.PersistentVolumeClaimList": {
      "description": "PersistentVolumeClaimList is a list of PersistentVolumeClaim items.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "items": {
          "description": "A list of persistent volume claims. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.PersistentVolumeClaim"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PersistentVolumeClaimList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "PersistentVolumeClaimList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.PersistentVolumeClaimSpec": {
      "description": "PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes",
      "type": "object",
      "properties": {
        "accessModes": {
          "description": "AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "dataSource": {
          "description": "This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.",
          "$ref": "#/definitions/io.k8s.api.core.v1.TypedLocalObjectReference"
        },
        "dataSourceRef": {
          "description": "Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While DataSource ignores disallowed values (dropping them), DataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n(Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.",
          "$ref": "#/definitions/io.k8s.api.core.v1.TypedLocalObjectReference"
        },
        "resources": {
          "description": "Resources represents the minimum resources the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources",
          "$ref": "#/definitions/io.k8s.api.core.v1.ResourceRequirements"
        },
        "selector": {
          "description": "A label query over volumes to consider for binding.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "storageClassName": {
          "description": "Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1",
          "type": "string"
        },
        "volumeMode": {
          "description": "volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.",
          "type": "string"
        },
        "volumeName": {
          "description": "VolumeName is the binding reference to the PersistentVolume backing this claim.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.PersistentVolumeClaimStatus": {
      "description": "PersistentVolumeClaimStatus is the current status of a persistent volume claim.",
      "type": "object",
      "properties": {
        "accessModes": {
          "description": "AccessModes contains the actual access modes the volume backing the PVC has. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "capacity": {
          "description": "Represents the actual resources of the underlying volume.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          }
        },
        "conditions": {
          "description": "Current Condition of persistent volume claim. If underlying persistent volume is being resized then the Condition will be set to 'ResizeStarted'.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.PersistentVolumeClaimCondition"
          },
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        },
        "phase": {
          "description": "Phase represents the current phase of PersistentVolumeClaim.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.PersistentVolumeClaimTemplate": {
      "description": "PersistentVolumeClaimTemplate is used to produce PersistentVolumeClaim objects as part of an EphemeralVolumeSource.",
      "type": "object",
      "required": ["spec"],
      "properties": {
        "metadata": {
          "description": "May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.",
          "$ref": "#/definitions/io.k8s.api.core.v1.PersistentVolumeClaimSpec"
        }
      }
    },
    "io.k8s.api.core.v1.PersistentVolumeClaimVolumeSource": {
      "description": "PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).",
      "type": "object",
      "required": ["claimName"],
      "properties": {
        "claimName": {
          "description": "ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims",
          "type": "string"
        },
        "readOnly": {
          "description": "Will force the ReadOnly setting in VolumeMounts. Default false.",
          "type": "boolean"
        }
      }
    },
    "io.k8s.api.core.v1.PersistentVolumeList": {
      "description": "PersistentVolumeList is a list of PersistentVolume items.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "items": {
          "description": "List of persistent volumes. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.PersistentVolume"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PersistentVolumeList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "PersistentVolumeList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.PersistentVolumeSpec": {
      "description": "PersistentVolumeSpec is the specification of a persistent volume.",
      "type": "object",
      "properties": {
        "accessModes": {
          "description": "AccessModes contains all ways the volume can be mounted. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "awsElasticBlockStore": {
          "description": "AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore",
          "$ref": "#/definitions/io.k8s.api.core.v1.AWSElasticBlockStoreVolumeSource"
        },
        "azureDisk": {
          "description": "AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.",
          "$ref": "#/definitions/io.k8s.api.core.v1.AzureDiskVolumeSource"
        },
        "azureFile": {
          "description": "AzureFile represents an Azure File Service mount on the host and bind mount to the pod.",
          "$ref": "#/definitions/io.k8s.api.core.v1.AzureFilePersistentVolumeSource"
        },
        "capacity": {
          "description": "A description of the persistent volume's resources and capacity. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          }
        },
        "cephfs": {
          "description": "CephFS represents a Ceph FS mount on the host that shares a pod's lifetime",
          "$ref": "#/definitions/io.k8s.api.core.v1.CephFSPersistentVolumeSource"
        },
        "cinder": {
          "description": "Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md",
          "$ref": "#/definitions/io.k8s.api.core.v1.CinderPersistentVolumeSource"
        },
        "claimRef": {
          "description": "ClaimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. claim.VolumeName is the authoritative bind between PV and PVC. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        },
        "csi": {
          "description": "CSI represents storage that is handled by an external CSI driver (Beta feature).",
          "$ref": "#/definitions/io.k8s.api.core.v1.CSIPersistentVolumeSource"
        },
        "fc": {
          "description": "FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.",
          "$ref": "#/definitions/io.k8s.api.core.v1.FCVolumeSource"
        },
        "flexVolume": {
          "description": "FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.",
          "$ref": "#/definitions/io.k8s.api.core.v1.FlexPersistentVolumeSource"
        },
        "flocker": {
          "description": "Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running",
          "$ref": "#/definitions/io.k8s.api.core.v1.FlockerVolumeSource"
        },
        "gcePersistentDisk": {
          "description": "GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk",
          "$ref": "#/definitions/io.k8s.api.core.v1.GCEPersistentDiskVolumeSource"
        },
        "glusterfs": {
          "description": "Glusterfs represents a Glusterfs volume that is attached to a host and exposed to the pod. Provisioned by an admin. More info: https://examples.k8s.io/volumes/glusterfs/README.md",
          "$ref": "#/definitions/io.k8s.api.core.v1.GlusterfsPersistentVolumeSource"
        },
        "hostPath": {
          "description": "HostPath represents a directory on the host. Provisioned by a developer or tester. This is useful for single-node development and testing only! On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath",
          "$ref": "#/definitions/io.k8s.api.core.v1.HostPathVolumeSource"
        },
        "iscsi": {
          "description": "ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ISCSIPersistentVolumeSource"
        },
        "local": {
          "description": "Local represents directly-attached storage with node affinity",
          "$ref": "#/definitions/io.k8s.api.core.v1.LocalVolumeSource"
        },
        "mountOptions": {
          "description": "A list of mount options, e.g. [\"ro\", \"soft\"]. Not validated - mount will simply fail if one is invalid. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "nfs": {
          "description": "NFS represents an NFS mount on the host. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs",
          "$ref": "#/definitions/io.k8s.api.core.v1.NFSVolumeSource"
        },
        "nodeAffinity": {
          "description": "NodeAffinity defines constraints that limit what nodes this volume can be accessed from. This field influences the scheduling of pods that use this volume.",
          "$ref": "#/definitions/io.k8s.api.core.v1.VolumeNodeAffinity"
        },
        "persistentVolumeReclaimPolicy": {
          "description": "What happens to a persistent volume when released from its claim. Valid options are Retain (default for manually created PersistentVolumes), Delete (default for dynamically provisioned PersistentVolumes), and Recycle (deprecated). Recycle must be supported by the volume plugin underlying this PersistentVolume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming",
          "type": "string"
        },
        "photonPersistentDisk": {
          "description": "PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine",
          "$ref": "#/definitions/io.k8s.api.core.v1.PhotonPersistentDiskVolumeSource"
        },
        "portworxVolume": {
          "description": "PortworxVolume represents a portworx volume attached and mounted on kubelets host machine",
          "$ref": "#/definitions/io.k8s.api.core.v1.PortworxVolumeSource"
        },
        "quobyte": {
          "description": "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime",
          "$ref": "#/definitions/io.k8s.api.core.v1.QuobyteVolumeSource"
        },
        "rbd": {
          "description": "RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md",
          "$ref": "#/definitions/io.k8s.api.core.v1.RBDPersistentVolumeSource"
        },
        "scaleIO": {
          "description": "ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ScaleIOPersistentVolumeSource"
        },
        "storageClassName": {
          "description": "Name of StorageClass to which this persistent volume belongs. Empty value means that this volume does not belong to any StorageClass.",
          "type": "string"
        },
        "storageos": {
          "description": "StorageOS represents a StorageOS volume that is attached to the kubelet's host machine and mounted into the pod More info: https://examples.k8s.io/volumes/storageos/README.md",
          "$ref": "#/definitions/io.k8s.api.core.v1.StorageOSPersistentVolumeSource"
        },
        "volumeMode": {
          "description": "volumeMode defines if a volume is intended to be used with a formatted filesystem or to remain in raw block state. Value of Filesystem is implied when not included in spec.",
          "type": "string"
        },
        "vsphereVolume": {
          "description": "VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine",
          "$ref": "#/definitions/io.k8s.api.core.v1.VsphereVirtualDiskVolumeSource"
        }
      }
    },
    "io.k8s.api.core.v1.PersistentVolumeStatus": {
      "description": "PersistentVolumeStatus is the current status of a persistent volume.",
      "type": "object",
      "properties": {
        "message": {
          "description": "A human-readable message indicating details about why the volume is in this state.",
          "type": "string"
        },
        "phase": {
          "description": "Phase indicates if a volume is available, bound to a claim, or released by a claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#phase",
          "type": "string"
        },
        "reason": {
          "description": "Reason is a brief CamelCase string that describes any failure and is meant for machine parsing and tidy display in the CLI.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.PhotonPersistentDiskVolumeSource": {
      "description": "Represents a Photon Controller persistent disk resource.",
      "type": "object",
      "required": ["pdID"],
      "properties": {
        "fsType": {
          "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
          "type": "string"
        },
        "pdID": {
          "description": "ID that identifies Photon Controller persistent disk",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.Pod": {
      "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Pod"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Specification of the desired behavior of the pod. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodSpec"
        },
        "status": {
          "description": "Most recently observed status of the pod. This data may not be up to date. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "Pod",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.PodAffinity": {
      "description": "Pod affinity is a group of inter pod affinity scheduling rules.",
      "type": "object",
      "properties": {
        "preferredDuringSchedulingIgnoredDuringExecution": {
          "description": "The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.WeightedPodAffinityTerm"
          }
        },
        "requiredDuringSchedulingIgnoredDuringExecution": {
          "description": "If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.PodAffinityTerm"
          }
        }
      }
    },
    "io.k8s.api.core.v1.PodAffinityTerm": {
      "description": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running",
      "type": "object",
      "required": ["topologyKey"],
      "properties": {
        "labelSelector": {
          "description": "A label query over a set of resources, in this case pods.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "namespaceSelector": {
          "description": "A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means \"this pod's namespace\". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "namespaces": {
          "description": "namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \"this pod's namespace\"",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "topologyKey": {
          "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.PodAntiAffinity": {
      "description": "Pod anti affinity is a group of inter pod anti affinity scheduling rules.",
      "type": "object",
      "properties": {
        "preferredDuringSchedulingIgnoredDuringExecution": {
          "description": "The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.WeightedPodAffinityTerm"
          }
        },
        "requiredDuringSchedulingIgnoredDuringExecution": {
          "description": "If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.PodAffinityTerm"
          }
        }
      }
    },
    "io.k8s.api.core.v1.PodCondition": {
      "description": "PodCondition contains details for the current condition of this pod.",
      "type": "object",
      "required": ["type", "status"],
      "properties": {
        "lastProbeTime": {
          "description": "Last time we probed the condition.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "lastTransitionTime": {
          "description": "Last time the condition transitioned from one status to another.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "Human-readable message indicating details about last transition.",
          "type": "string"
        },
        "reason": {
          "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
          "type": "string"
        },
        "status": {
          "description": "Status is the status of the condition. Can be True, False, Unknown. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions",
          "type": "string"
        },
        "type": {
          "description": "Type is the type of the condition. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.PodDNSConfig": {
      "description": "PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.",
      "type": "object",
      "properties": {
        "nameservers": {
          "description": "A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "options": {
          "description": "A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.PodDNSConfigOption"
          }
        },
        "searches": {
          "description": "A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.core.v1.PodDNSConfigOption": {
      "description": "PodDNSConfigOption defines DNS resolver options of a pod.",
      "type": "object",
      "properties": {
        "name": {
          "description": "Required.",
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.PodIP": {
      "description": "IP address information for entries in the (plural) PodIPs field. Each entry includes:\n   IP: An IP address allocated to the pod. Routable at least within the cluster.",
      "type": "object",
      "properties": {
        "ip": {
          "description": "ip is an IP address (IPv4 or IPv6) assigned to the pod",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.PodList": {
      "description": "PodList is a list of Pods.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "items": {
          "description": "List of pods. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.Pod"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PodList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "PodList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.PodReadinessGate": {
      "description": "PodReadinessGate contains the reference to a pod condition",
      "type": "object",
      "required": ["conditionType"],
      "properties": {
        "conditionType": {
          "description": "ConditionType refers to a condition in the pod's condition list with matching type.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.PodSecurityContext": {
      "description": "PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.",
      "type": "object",
      "properties": {
        "fsGroup": {
          "description": "A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:\n\n1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----\n\nIf unset, the Kubelet will not modify the ownership and permissions of any volume.",
          "type": "integer",
          "format": "int64"
        },
        "fsGroupChangePolicy": {
          "description": "fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are \"OnRootMismatch\" and \"Always\". If not specified, \"Always\" is used.",
          "type": "string"
        },
        "runAsGroup": {
          "description": "The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.",
          "type": "integer",
          "format": "int64"
        },
        "runAsNonRoot": {
          "description": "Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
          "type": "boolean"
        },
        "runAsUser": {
          "description": "The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.",
          "type": "integer",
          "format": "int64"
        },
        "seLinuxOptions": {
          "description": "The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SELinuxOptions"
        },
        "seccompProfile": {
          "description": "The seccomp options to use by the containers in this pod.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SeccompProfile"
        },
        "supplementalGroups": {
          "description": "A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int64"
          }
        },
        "sysctls": {
          "description": "Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.Sysctl"
          }
        },
        "windowsOptions": {
          "description": "The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
          "$ref": "#/definitions/io.k8s.api.core.v1.WindowsSecurityContextOptions"
        }
      }
    },
    "io.k8s.api.core.v1.PodSpec": {
      "description": "PodSpec is a description of a pod.",
      "type": "object",
      "required": ["containers"],
      "properties": {
        "activeDeadlineSeconds": {
          "description": "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
          "type": "integer",
          "format": "int64"
        },
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/io.k8s.api.core.v1.Affinity"
        },
        "automountServiceAccountToken": {
          "description": "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
          "type": "boolean"
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.Container"
          },
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "dnsConfig": {
          "description": "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodDNSConfig"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "enableServiceLinks": {
          "description": "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
          "type": "boolean"
        },
        "ephemeralContainers": {
          "description": "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource. This field is alpha-level and is only honored by servers that enable the EphemeralContainers feature.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.EphemeralContainer"
          },
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostAliases": {
          "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.HostAlias"
          },
          "x-kubernetes-patch-merge-key": "ip",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "hostPID": {
          "description": "Use the host's pid namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostname": {
          "description": "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
          "type": "string"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.LocalObjectReference"
          },
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "initContainers": {
          "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.Container"
          },
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "nodeName": {
          "description": "NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.",
          "type": "string"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "x-kubernetes-map-type": "atomic"
        },
        "overhead": {
          "description": "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md This field is beta-level as of Kubernetes v1.18, and is only honored by servers that enable the PodOverhead feature.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          }
        },
        "preemptionPolicy": {
          "description": "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is beta-level, gated by the NonPreemptingPriority feature-gate.",
          "type": "string"
        },
        "priority": {
          "description": "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
          "type": "integer",
          "format": "int32"
        },
        "priorityClassName": {
          "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
          "type": "string"
        },
        "readinessGates": {
          "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.PodReadinessGate"
          }
        },
        "restartPolicy": {
          "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
          "type": "string"
        },
        "runtimeClassName": {
          "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class This is a beta feature as of Kubernetes v1.14.",
          "type": "string"
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "securityContext": {
          "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodSecurityContext"
        },
        "serviceAccount": {
          "description": "DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
          "type": "string"
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
          "type": "string"
        },
        "setHostnameAsFQDN": {
          "description": "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
          "type": "boolean"
        },
        "shareProcessNamespace": {
          "description": "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
          "type": "boolean"
        },
        "subdomain": {
          "description": "If specified, the fully qualified Pod hostname will be \"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\". If not specified, the pod will not have a domainname at all.",
          "type": "string"
        },
        "terminationGracePeriodSeconds": {
          "description": "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
          "type": "integer",
          "format": "int64"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.Toleration"
          }
        },
        "topologySpreadConstraints": {
          "description": "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.TopologySpreadConstraint"
          },
          "x-kubernetes-list-map-keys": ["topologyKey", "whenUnsatisfiable"],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "topologyKey",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.Volume"
          },
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        }
      }
    },
    "io.k8s.api.core.v1.PodStatus": {
      "description": "PodStatus represents information about the status of a pod. Status may trail the actual state of a system, especially if the node that hosts the pod cannot contact the control plane.",
      "type": "object",
      "properties": {
        "conditions": {
          "description": "Current service state of pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.PodCondition"
          },
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        },
        "containerStatuses": {
          "description": "The list has one entry per container in the manifest. Each entry is currently the output of `docker inspect`. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ContainerStatus"
          }
        },
        "ephemeralContainerStatuses": {
          "description": "Status for any ephemeral containers that have run in this pod. This field is alpha-level and is only populated by servers that enable the EphemeralContainers feature.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ContainerStatus"
          }
        },
        "hostIP": {
          "description": "IP address of the host to which the pod is assigned. Empty if not yet scheduled.",
          "type": "string"
        },
        "initContainerStatuses": {
          "description": "The list has one entry per init container in the manifest. The most recent successful init container will have ready = true, the most recently started container will have startTime set. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ContainerStatus"
          }
        },
        "message": {
          "description": "A human readable message indicating details about why the pod is in this condition.",
          "type": "string"
        },
        "nominatedNodeName": {
          "description": "nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be scheduled right away as preemption victims receive their graceful termination periods. This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to give the resources on this node to a higher priority pod that is created after preemption. As a result, this field may be different than PodSpec.nodeName when the pod is scheduled.",
          "type": "string"
        },
        "phase": {
          "description": "The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle. The conditions array, the reason and message fields, and the individual container status arrays contain more detail about the pod's status. There are five possible phase values:\n\nPending: The pod has been accepted by the Kubernetes system, but one or more of the container images has not been created. This includes time before being scheduled as well as time spent downloading images over the network, which could take a while. Running: The pod has been bound to a node, and all of the containers have been created. At least one container is still running, or is in the process of starting or restarting. Succeeded: All containers in the pod have terminated in success, and will not be restarted. Failed: All containers in the pod have terminated, and at least one container has terminated in failure. The container either exited with non-zero status or was terminated by the system. Unknown: For some reason the state of the pod could not be obtained, typically due to an error in communicating with the host of the pod.\n\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase",
          "type": "string"
        },
        "podIP": {
          "description": "IP address allocated to the pod. Routable at least within the cluster. Empty if not yet allocated.",
          "type": "string"
        },
        "podIPs": {
          "description": "podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th entry must match the podIP field. Pods may be allocated at most 1 value for each of IPv4 and IPv6. This list is empty if no IPs have been allocated yet.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.PodIP"
          },
          "x-kubernetes-patch-merge-key": "ip",
          "x-kubernetes-patch-strategy": "merge"
        },
        "qosClass": {
          "description": "The Quality of Service (QOS) classification assigned to the pod based on resource requirements See PodQOSClass type for available QOS classes More info: https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md",
          "type": "string"
        },
        "reason": {
          "description": "A brief CamelCase message indicating details about why the pod is in this state. e.g. 'Evicted'",
          "type": "string"
        },
        "startTime": {
          "description": "RFC 3339 date and time at which the object was acknowledged by the Kubelet. This is before the Kubelet pulled the container image(s) for the pod.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        }
      }
    },
    "io.k8s.api.core.v1.PodTemplate": {
      "description": "PodTemplate describes a template for creating copies of a predefined pod.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PodTemplate"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "template": {
          "description": "Template defines the pods that will be created from this pod template. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodTemplateSpec"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "PodTemplate",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.PodTemplateList": {
      "description": "PodTemplateList is a list of PodTemplates.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "items": {
          "description": "List of pod templates",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.PodTemplate"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PodTemplateList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "PodTemplateList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.PodTemplateSpec": {
      "description": "PodTemplateSpec describes the data a pod should have when created from a template",
      "type": "object",
      "properties": {
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Specification of the desired behavior of the pod. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodSpec"
        }
      }
    },
    "io.k8s.api.core.v1.PortStatus": {
      "type": "object",
      "required": ["port", "protocol"],
      "properties": {
        "error": {
          "description": "Error is to record the problem with the service port The format of the error shall comply with the following rules: - built-in error values shall be specified in this file and those shall use\n  CamelCase names\n- cloud provider specific error values must have names that comply with the\n  format foo.example.com/CamelCase.",
          "type": "string"
        },
        "port": {
          "description": "Port is the port number of the service port of which status is recorded here",
          "type": "integer",
          "format": "int32"
        },
        "protocol": {
          "description": "Protocol is the protocol of the service port of which status is recorded here The supported values are: \"TCP\", \"UDP\", \"SCTP\"",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.PortworxVolumeSource": {
      "description": "PortworxVolumeSource represents a Portworx volume resource.",
      "type": "object",
      "required": ["volumeID"],
      "properties": {
        "fsType": {
          "description": "FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\". Implicitly inferred to be \"ext4\" if unspecified.",
          "type": "string"
        },
        "readOnly": {
          "description": "Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
          "type": "boolean"
        },
        "volumeID": {
          "description": "VolumeID uniquely identifies a Portworx volume",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.PreferredSchedulingTerm": {
      "description": "An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).",
      "type": "object",
      "required": ["weight", "preference"],
      "properties": {
        "preference": {
          "description": "A node selector term, associated with the corresponding weight.",
          "$ref": "#/definitions/io.k8s.api.core.v1.NodeSelectorTerm"
        },
        "weight": {
          "description": "Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.core.v1.Probe": {
      "description": "Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.",
      "type": "object",
      "properties": {
        "exec": {
          "description": "One and only one of the following should be specified. Exec specifies the action to take.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ExecAction"
        },
        "failureThreshold": {
          "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.",
          "type": "integer",
          "format": "int32"
        },
        "httpGet": {
          "description": "HTTPGet specifies the http request to perform.",
          "$ref": "#/definitions/io.k8s.api.core.v1.HTTPGetAction"
        },
        "initialDelaySeconds": {
          "description": "Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "type": "integer",
          "format": "int32"
        },
        "periodSeconds": {
          "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
          "type": "integer",
          "format": "int32"
        },
        "successThreshold": {
          "description": "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.",
          "type": "integer",
          "format": "int32"
        },
        "tcpSocket": {
          "description": "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported",
          "$ref": "#/definitions/io.k8s.api.core.v1.TCPSocketAction"
        },
        "terminationGracePeriodSeconds": {
          "description": "Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.",
          "type": "integer",
          "format": "int64"
        },
        "timeoutSeconds": {
          "description": "Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.core.v1.ProjectedVolumeSource": {
      "description": "Represents a projected volume source",
      "type": "object",
      "properties": {
        "defaultMode": {
          "description": "Mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
          "type": "integer",
          "format": "int32"
        },
        "sources": {
          "description": "list of volume projections",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.VolumeProjection"
          }
        }
      }
    },
    "io.k8s.api.core.v1.QuobyteVolumeSource": {
      "description": "Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling.",
      "type": "object",
      "required": ["registry", "volume"],
      "properties": {
        "group": {
          "description": "Group to map volume access to Default is no group",
          "type": "string"
        },
        "readOnly": {
          "description": "ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.",
          "type": "boolean"
        },
        "registry": {
          "description": "Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes",
          "type": "string"
        },
        "tenant": {
          "description": "Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin",
          "type": "string"
        },
        "user": {
          "description": "User to map volume access to Defaults to serivceaccount user",
          "type": "string"
        },
        "volume": {
          "description": "Volume is a string that references an already created Quobyte volume by name.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.RBDPersistentVolumeSource": {
      "description": "Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.",
      "type": "object",
      "required": ["monitors", "image"],
      "properties": {
        "fsType": {
          "description": "Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd",
          "type": "string"
        },
        "image": {
          "description": "The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
          "type": "string"
        },
        "keyring": {
          "description": "Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
          "type": "string"
        },
        "monitors": {
          "description": "A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "pool": {
          "description": "The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
          "type": "string"
        },
        "readOnly": {
          "description": "ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
          "type": "boolean"
        },
        "secretRef": {
          "description": "SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretReference"
        },
        "user": {
          "description": "The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.RBDVolumeSource": {
      "description": "Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.",
      "type": "object",
      "required": ["monitors", "image"],
      "properties": {
        "fsType": {
          "description": "Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd",
          "type": "string"
        },
        "image": {
          "description": "The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
          "type": "string"
        },
        "keyring": {
          "description": "Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
          "type": "string"
        },
        "monitors": {
          "description": "A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "pool": {
          "description": "The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
          "type": "string"
        },
        "readOnly": {
          "description": "ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
          "type": "boolean"
        },
        "secretRef": {
          "description": "SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
          "$ref": "#/definitions/io.k8s.api.core.v1.LocalObjectReference"
        },
        "user": {
          "description": "The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.ReplicationController": {
      "description": "ReplicationController represents the configuration of a replication controller.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ReplicationController"]
        },
        "metadata": {
          "description": "If the Labels of a ReplicationController are empty, they are defaulted to be the same as the Pod(s) that the replication controller manages. Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the specification of the desired behavior of the replication controller. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.core.v1.ReplicationControllerSpec"
        },
        "status": {
          "description": "Status is the most recently observed status of the replication controller. This data may be out of date by some window of time. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.core.v1.ReplicationControllerStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "ReplicationController",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.ReplicationControllerCondition": {
      "description": "ReplicationControllerCondition describes the state of a replication controller at a certain point.",
      "type": "object",
      "required": ["type", "status"],
      "properties": {
        "lastTransitionTime": {
          "description": "The last time the condition transitioned from one status to another.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "A human readable message indicating details about the transition.",
          "type": "string"
        },
        "reason": {
          "description": "The reason for the condition's last transition.",
          "type": "string"
        },
        "status": {
          "description": "Status of the condition, one of True, False, Unknown.",
          "type": "string"
        },
        "type": {
          "description": "Type of replication controller condition.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.ReplicationControllerList": {
      "description": "ReplicationControllerList is a collection of replication controllers.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "items": {
          "description": "List of replication controllers. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ReplicationController"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ReplicationControllerList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "ReplicationControllerList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.ReplicationControllerSpec": {
      "description": "ReplicationControllerSpec is the specification of a replication controller.",
      "type": "object",
      "properties": {
        "minReadySeconds": {
          "description": "Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)",
          "type": "integer",
          "format": "int32"
        },
        "replicas": {
          "description": "Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller",
          "type": "integer",
          "format": "int32"
        },
        "selector": {
          "description": "Selector is a label query over pods that should match the Replicas count. If Selector is empty, it is defaulted to the labels present on the Pod template. Label keys and values that must match in order to be controlled by this replication controller, if empty defaulted to labels on Pod template. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "x-kubernetes-map-type": "atomic"
        },
        "template": {
          "description": "Template is the object that describes the pod that will be created if insufficient replicas are detected. This takes precedence over a TemplateRef. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodTemplateSpec"
        }
      }
    },
    "io.k8s.api.core.v1.ReplicationControllerStatus": {
      "description": "ReplicationControllerStatus represents the current status of a replication controller.",
      "type": "object",
      "required": ["replicas"],
      "properties": {
        "availableReplicas": {
          "description": "The number of available replicas (ready for at least minReadySeconds) for this replication controller.",
          "type": "integer",
          "format": "int32"
        },
        "conditions": {
          "description": "Represents the latest available observations of a replication controller's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ReplicationControllerCondition"
          },
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        },
        "fullyLabeledReplicas": {
          "description": "The number of pods that have labels matching the labels of the pod template of the replication controller.",
          "type": "integer",
          "format": "int32"
        },
        "observedGeneration": {
          "description": "ObservedGeneration reflects the generation of the most recently observed replication controller.",
          "type": "integer",
          "format": "int64"
        },
        "readyReplicas": {
          "description": "The number of ready replicas for this replication controller.",
          "type": "integer",
          "format": "int32"
        },
        "replicas": {
          "description": "Replicas is the most recently oberved number of replicas. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.core.v1.ResourceFieldSelector": {
      "description": "ResourceFieldSelector represents container resources (cpu, memory) and their output format",
      "type": "object",
      "required": ["resource"],
      "properties": {
        "containerName": {
          "description": "Container name: required for volumes, optional for env vars",
          "type": "string"
        },
        "divisor": {
          "description": "Specifies the output format of the exposed resources, defaults to \"1\"",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        },
        "resource": {
          "description": "Required: resource to select",
          "type": "string"
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.core.v1.ResourceQuota": {
      "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ResourceQuota"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the desired quota. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.core.v1.ResourceQuotaSpec"
        },
        "status": {
          "description": "Status defines the actual enforced quota and its current usage. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.core.v1.ResourceQuotaStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "ResourceQuota",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.ResourceQuotaList": {
      "description": "ResourceQuotaList is a list of ResourceQuota items.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "items": {
          "description": "Items is a list of ResourceQuota objects. More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ResourceQuota"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ResourceQuotaList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "ResourceQuotaList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.ResourceQuotaSpec": {
      "description": "ResourceQuotaSpec defines the desired hard limits to enforce for Quota.",
      "type": "object",
      "properties": {
        "hard": {
          "description": "hard is the set of desired hard limits for each named resource. More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          }
        },
        "scopeSelector": {
          "description": "scopeSelector is also a collection of filters like scopes that must match each object tracked by a quota but expressed using ScopeSelectorOperator in combination with possible values. For a resource to match, both scopes AND scopeSelector (if specified in spec), must be matched.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ScopeSelector"
        },
        "scopes": {
          "description": "A collection of filters that must match each object tracked by a quota. If not specified, the quota matches all objects.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.core.v1.ResourceQuotaStatus": {
      "description": "ResourceQuotaStatus defines the enforced hard limits and observed use.",
      "type": "object",
      "properties": {
        "hard": {
          "description": "Hard is the set of enforced hard limits for each named resource. More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          }
        },
        "used": {
          "description": "Used is the current observed total usage of the resource in the namespace.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          }
        }
      }
    },
    "io.k8s.api.core.v1.ResourceRequirements": {
      "description": "ResourceRequirements describes the compute resource requirements.",
      "type": "object",
      "properties": {
        "limits": {
          "description": "Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          }
        },
        "requests": {
          "description": "Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          }
        }
      }
    },
    "io.k8s.api.core.v1.SELinuxOptions": {
      "description": "SELinuxOptions are the labels to be applied to the container",
      "type": "object",
      "properties": {
        "level": {
          "description": "Level is SELinux level label that applies to the container.",
          "type": "string"
        },
        "role": {
          "description": "Role is a SELinux role label that applies to the container.",
          "type": "string"
        },
        "type": {
          "description": "Type is a SELinux type label that applies to the container.",
          "type": "string"
        },
        "user": {
          "description": "User is a SELinux user label that applies to the container.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.ScaleIOPersistentVolumeSource": {
      "description": "ScaleIOPersistentVolumeSource represents a persistent ScaleIO volume",
      "type": "object",
      "required": ["gateway", "system", "secretRef"],
      "properties": {
        "fsType": {
          "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Default is \"xfs\"",
          "type": "string"
        },
        "gateway": {
          "description": "The host address of the ScaleIO API Gateway.",
          "type": "string"
        },
        "protectionDomain": {
          "description": "The name of the ScaleIO Protection Domain for the configured storage.",
          "type": "string"
        },
        "readOnly": {
          "description": "Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
          "type": "boolean"
        },
        "secretRef": {
          "description": "SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretReference"
        },
        "sslEnabled": {
          "description": "Flag to enable/disable SSL communication with Gateway, default false",
          "type": "boolean"
        },
        "storageMode": {
          "description": "Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.",
          "type": "string"
        },
        "storagePool": {
          "description": "The ScaleIO Storage Pool associated with the protection domain.",
          "type": "string"
        },
        "system": {
          "description": "The name of the storage system as configured in ScaleIO.",
          "type": "string"
        },
        "volumeName": {
          "description": "The name of a volume already created in the ScaleIO system that is associated with this volume source.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.ScaleIOVolumeSource": {
      "description": "ScaleIOVolumeSource represents a persistent ScaleIO volume",
      "type": "object",
      "required": ["gateway", "system", "secretRef"],
      "properties": {
        "fsType": {
          "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Default is \"xfs\".",
          "type": "string"
        },
        "gateway": {
          "description": "The host address of the ScaleIO API Gateway.",
          "type": "string"
        },
        "protectionDomain": {
          "description": "The name of the ScaleIO Protection Domain for the configured storage.",
          "type": "string"
        },
        "readOnly": {
          "description": "Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
          "type": "boolean"
        },
        "secretRef": {
          "description": "SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.",
          "$ref": "#/definitions/io.k8s.api.core.v1.LocalObjectReference"
        },
        "sslEnabled": {
          "description": "Flag to enable/disable SSL communication with Gateway, default false",
          "type": "boolean"
        },
        "storageMode": {
          "description": "Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.",
          "type": "string"
        },
        "storagePool": {
          "description": "The ScaleIO Storage Pool associated with the protection domain.",
          "type": "string"
        },
        "system": {
          "description": "The name of the storage system as configured in ScaleIO.",
          "type": "string"
        },
        "volumeName": {
          "description": "The name of a volume already created in the ScaleIO system that is associated with this volume source.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.ScopeSelector": {
      "description": "A scope selector represents the AND of the selectors represented by the scoped-resource selector requirements.",
      "type": "object",
      "properties": {
        "matchExpressions": {
          "description": "A list of scope selector requirements by scope of the resources.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ScopedResourceSelectorRequirement"
          }
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.core.v1.ScopedResourceSelectorRequirement": {
      "description": "A scoped-resource selector requirement is a selector that contains values, a scope name, and an operator that relates the scope name and values.",
      "type": "object",
      "required": ["scopeName", "operator"],
      "properties": {
        "operator": {
          "description": "Represents a scope's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist.",
          "type": "string"
        },
        "scopeName": {
          "description": "The name of the scope that the selector applies to.",
          "type": "string"
        },
        "values": {
          "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.core.v1.SeccompProfile": {
      "description": "SeccompProfile defines a pod/container's seccomp profile settings. Only one profile source may be set.",
      "type": "object",
      "required": ["type"],
      "properties": {
        "localhostProfile": {
          "description": "localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is \"Localhost\".",
          "type": "string"
        },
        "type": {
          "description": "type indicates which kind of seccomp profile will be applied. Valid options are:\n\nLocalhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.",
          "type": "string"
        }
      },
      "x-kubernetes-unions": [
        {
          "discriminator": "type",
          "fields-to-discriminateBy": {
            "localhostProfile": "LocalhostProfile"
          }
        }
      ]
    },
    "io.k8s.api.core.v1.Secret": {
      "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "data": {
          "description": "Data contains the secret data. Each key must consist of alphanumeric characters, '-', '_' or '.'. The serialized form of the secret data is a base64 encoded string, representing the arbitrary (possibly non-string) data value here. Described in https://tools.ietf.org/html/rfc4648#section-4",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          }
        },
        "immutable": {
          "description": "Immutable, if set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Defaulted to nil.",
          "type": "boolean"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Secret"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "stringData": {
          "description": "stringData allows specifying non-binary secret data in string form. It is provided as a write-only input field for convenience. All keys and values are merged into the data field on write, overwriting any existing values. The stringData field is never output when reading from the API.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "type": {
          "description": "Used to facilitate programmatic handling of secret data.",
          "type": "string"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "Secret",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.SecretEnvSource": {
      "description": "SecretEnvSource selects a Secret to populate the environment variables with.\n\nThe contents of the target Secret's Data field will represent the key-value pairs as environment variables.",
      "type": "object",
      "properties": {
        "name": {
          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
          "type": "string"
        },
        "optional": {
          "description": "Specify whether the Secret must be defined",
          "type": "boolean"
        }
      }
    },
    "io.k8s.api.core.v1.SecretKeySelector": {
      "description": "SecretKeySelector selects a key of a Secret.",
      "type": "object",
      "required": ["key"],
      "properties": {
        "key": {
          "description": "The key of the secret to select from.  Must be a valid secret key.",
          "type": "string"
        },
        "name": {
          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
          "type": "string"
        },
        "optional": {
          "description": "Specify whether the Secret or its key must be defined",
          "type": "boolean"
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.core.v1.SecretList": {
      "description": "SecretList is a list of Secret.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "items": {
          "description": "Items is a list of secret objects. More info: https://kubernetes.io/docs/concepts/configuration/secret",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.Secret"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["SecretList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "SecretList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.SecretProjection": {
      "description": "Adapts a secret into a projected volume.\n\nThe contents of the target Secret's Data field will be presented in a projected volume as files using the keys in the Data field as the file names. Note that this is identical to a secret volume source without the default mode.",
      "type": "object",
      "properties": {
        "items": {
          "description": "If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.KeyToPath"
          }
        },
        "name": {
          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
          "type": "string"
        },
        "optional": {
          "description": "Specify whether the Secret or its key must be defined",
          "type": "boolean"
        }
      }
    },
    "io.k8s.api.core.v1.SecretReference": {
      "description": "SecretReference represents a Secret Reference. It has enough information to retrieve secret in any namespace",
      "type": "object",
      "properties": {
        "name": {
          "description": "Name is unique within a namespace to reference a secret resource.",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace defines the space within which the secret name must be unique.",
          "type": "string"
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.core.v1.SecretVolumeSource": {
      "description": "Adapts a Secret into a volume.\n\nThe contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.",
      "type": "object",
      "properties": {
        "defaultMode": {
          "description": "Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
          "type": "integer",
          "format": "int32"
        },
        "items": {
          "description": "If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.KeyToPath"
          }
        },
        "optional": {
          "description": "Specify whether the Secret or its keys must be defined",
          "type": "boolean"
        },
        "secretName": {
          "description": "Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.SecurityContext": {
      "description": "SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.",
      "type": "object",
      "properties": {
        "allowPrivilegeEscalation": {
          "description": "AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN",
          "type": "boolean"
        },
        "capabilities": {
          "description": "The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.",
          "$ref": "#/definitions/io.k8s.api.core.v1.Capabilities"
        },
        "privileged": {
          "description": "Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.",
          "type": "boolean"
        },
        "procMount": {
          "description": "procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled.",
          "type": "string"
        },
        "readOnlyRootFilesystem": {
          "description": "Whether this container has a read-only root filesystem. Default is false.",
          "type": "boolean"
        },
        "runAsGroup": {
          "description": "The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
          "type": "integer",
          "format": "int64"
        },
        "runAsNonRoot": {
          "description": "Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
          "type": "boolean"
        },
        "runAsUser": {
          "description": "The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
          "type": "integer",
          "format": "int64"
        },
        "seLinuxOptions": {
          "description": "The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SELinuxOptions"
        },
        "seccompProfile": {
          "description": "The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SeccompProfile"
        },
        "windowsOptions": {
          "description": "The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
          "$ref": "#/definitions/io.k8s.api.core.v1.WindowsSecurityContextOptions"
        }
      }
    },
    "io.k8s.api.core.v1.Service": {
      "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Service"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the behavior of a service. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.core.v1.ServiceSpec"
        },
        "status": {
          "description": "Most recently observed status of the service. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.core.v1.ServiceStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "Service",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.ServiceAccount": {
      "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "automountServiceAccountToken": {
          "description": "AutomountServiceAccountToken indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level.",
          "type": "boolean"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.LocalObjectReference"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ServiceAccount"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "secrets": {
          "description": "Secrets is the list of secrets allowed to be used by pods running using this ServiceAccount. More info: https://kubernetes.io/docs/concepts/configuration/secret",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
          },
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "ServiceAccount",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.ServiceAccountList": {
      "description": "ServiceAccountList is a list of ServiceAccount objects",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "items": {
          "description": "List of ServiceAccounts. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ServiceAccount"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ServiceAccountList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "ServiceAccountList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.ServiceAccountTokenProjection": {
      "description": "ServiceAccountTokenProjection represents a projected service account token volume. This projection can be used to insert a service account token into the pods runtime filesystem for use against APIs (Kubernetes API Server or otherwise).",
      "type": "object",
      "required": ["path"],
      "properties": {
        "audience": {
          "description": "Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.",
          "type": "string"
        },
        "expirationSeconds": {
          "description": "ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.",
          "type": "integer",
          "format": "int64"
        },
        "path": {
          "description": "Path is the path relative to the mount point of the file to project the token into.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.ServiceList": {
      "description": "ServiceList holds a list of services.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "items": {
          "description": "List of services",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.Service"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ServiceList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "ServiceList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.core.v1.ServicePort": {
      "description": "ServicePort contains information on service's port.",
      "type": "object",
      "required": ["port"],
      "properties": {
        "appProtocol": {
          "description": "The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and http://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol.",
          "type": "string"
        },
        "name": {
          "description": "The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.",
          "type": "string"
        },
        "nodePort": {
          "description": "The port on each node on which this service is exposed when type is NodePort or LoadBalancer.  Usually assigned by the system. If a value is specified, in-range, and not in use it will be used, otherwise the operation will fail.  If not specified, a port will be allocated if this Service requires one.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport",
          "type": "integer",
          "format": "int32"
        },
        "port": {
          "description": "The port that will be exposed by this service.",
          "type": "integer",
          "format": "int32"
        },
        "protocol": {
          "description": "The IP protocol for this port. Supports \"TCP\", \"UDP\", and \"SCTP\". Default is TCP.",
          "type": "string"
        },
        "targetPort": {
          "description": "Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod's container ports. If this is not specified, the value of the 'port' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the 'port' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
        }
      }
    },
    "io.k8s.api.core.v1.ServiceSpec": {
      "description": "ServiceSpec describes the attributes that a user creates on a service.",
      "type": "object",
      "properties": {
        "allocateLoadBalancerNodePorts": {
          "description": "allocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for services with type LoadBalancer.  Default is \"true\". It may be set to \"false\" if the cluster load-balancer does not rely on NodePorts.  If the caller requests specific NodePorts (by specifying a value), those requests will be respected, regardless of this field. This field may only be set for services with type LoadBalancer and will be cleared if the type is changed to any other type. This field is beta-level and is only honored by servers that enable the ServiceLBNodePortControl feature.",
          "type": "boolean"
        },
        "clusterIP": {
          "description": "clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are \"None\", empty string (\"\"), or a valid IP address. Setting this to \"None\" makes a \"headless service\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies",
          "type": "string"
        },
        "clusterIPs": {
          "description": "ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly.  If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are \"None\", empty string (\"\"), or a valid IP address.  Setting this to \"None\" makes a \"headless service\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName.  If this field is not specified, it will be initialized from the clusterIP field.  If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value.\n\nUnless the \"IPv6DualStack\" feature gate is enabled, this field is limited to one value, which must be the same as the clusterIP field.  If the feature gate is enabled, this field may hold a maximum of two entries (dual-stack IPs, in either order).  These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "externalIPs": {
          "description": "externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "externalName": {
          "description": "externalName is the external reference that discovery mechanisms will return as an alias for this service (e.g. a DNS CNAME record). No proxying will be involved.  Must be a lowercase RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires `type` to be \"ExternalName\".",
          "type": "string"
        },
        "externalTrafficPolicy": {
          "description": "externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. \"Local\" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. \"Cluster\" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.",
          "type": "string"
        },
        "healthCheckNodePort": {
          "description": "healthCheckNodePort specifies the healthcheck nodePort for the service. This only applies when type is set to LoadBalancer and externalTrafficPolicy is set to Local. If a value is specified, is in-range, and is not in use, it will be used.  If not specified, a value will be automatically allocated.  External systems (e.g. load-balancers) can use this port to determine if a given node holds endpoints for this service or not.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type).",
          "type": "integer",
          "format": "int32"
        },
        "internalTrafficPolicy": {
          "description": "InternalTrafficPolicy specifies if the cluster internal traffic should be routed to all endpoints or node-local endpoints only. \"Cluster\" routes internal traffic to a Service to all endpoints. \"Local\" routes traffic to node-local endpoints only, traffic is dropped if no node-local endpoints are ready. The default value is \"Cluster\".",
          "type": "string"
        },
        "ipFamilies": {
          "description": "IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service, and is gated by the \"IPv6DualStack\" feature gate.  This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail.  This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service.  Valid values are \"IPv4\" and \"IPv6\".  This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to \"headless\" services.  This field will be wiped when updating a Service to type ExternalName.\n\nThis field may hold a maximum of two entries (dual-stack families, in either order).  These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "ipFamilyPolicy": {
          "description": "IPFamilyPolicy represents the dual-stack-ness requested or required by this Service, and is gated by the \"IPv6DualStack\" feature gate.  If there is no value provided, then this field will be set to SingleStack. Services can be \"SingleStack\" (a single IP family), \"PreferDualStack\" (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or \"RequireDualStack\" (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field.  This field will be wiped when updating a service to type ExternalName.",
          "type": "string"
        },
        "loadBalancerClass": {
          "description": "loadBalancerClass is the class of the load balancer implementation this Service belongs to. If specified, the value of this field must be a label-style identifier, with an optional prefix, e.g. \"internal-vip\" or \"example.com/internal-vip\". Unprefixed names are reserved for end-users. This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load balancer implementation is used, today this is typically done through the cloud provider integration, but should apply for any default implementation. If set, it is assumed that a load balancer implementation is watching for Services with a matching class. Any default load balancer implementation (e.g. cloud providers) should ignore Services that set this field. This field can only be set when creating or updating a Service to type 'LoadBalancer'. Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.",
          "type": "string"
        },
        "loadBalancerIP": {
          "description": "Only applies to Service Type: LoadBalancer LoadBalancer will get created with the IP specified in this field. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature.",
          "type": "string"
        },
        "loadBalancerSourceRanges": {
          "description": "If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature.\" More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "ports": {
          "description": "The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.ServicePort"
          },
          "x-kubernetes-list-map-keys": ["port", "protocol"],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "port",
          "x-kubernetes-patch-strategy": "merge"
        },
        "publishNotReadyAddresses": {
          "description": "publishNotReadyAddresses indicates that any agent which deals with endpoints for this Service should disregard any indications of ready/not-ready. The primary use case for setting this field is for a StatefulSet's Headless Service to propagate SRV DNS records for its Pods for the purpose of peer discovery. The Kubernetes controllers that generate Endpoints and EndpointSlice resources for Services interpret this to mean that all endpoints are considered \"ready\" even if the Pods themselves are not. Agents which consume only Kubernetes generated endpoints through the Endpoints or EndpointSlice resources can safely assume this behavior.",
          "type": "boolean"
        },
        "selector": {
          "description": "Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "x-kubernetes-map-type": "atomic"
        },
        "sessionAffinity": {
          "description": "Supports \"ClientIP\" and \"None\". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies",
          "type": "string"
        },
        "sessionAffinityConfig": {
          "description": "sessionAffinityConfig contains the configurations of session affinity.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SessionAffinityConfig"
        },
        "type": {
          "description": "type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. \"ClusterIP\" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is \"None\", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. \"NodePort\" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. \"LoadBalancer\" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. \"ExternalName\" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.ServiceStatus": {
      "description": "ServiceStatus represents the current status of a service.",
      "type": "object",
      "properties": {
        "conditions": {
          "description": "Current service state",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Condition"
          },
          "x-kubernetes-list-map-keys": ["type"],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        },
        "loadBalancer": {
          "description": "LoadBalancer contains the current status of the load-balancer, if one is present.",
          "$ref": "#/definitions/io.k8s.api.core.v1.LoadBalancerStatus"
        }
      }
    },
    "io.k8s.api.core.v1.SessionAffinityConfig": {
      "description": "SessionAffinityConfig represents the configurations of session affinity.",
      "type": "object",
      "properties": {
        "clientIP": {
          "description": "clientIP contains the configurations of Client IP based session affinity.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ClientIPConfig"
        }
      }
    },
    "io.k8s.api.core.v1.StorageOSPersistentVolumeSource": {
      "description": "Represents a StorageOS persistent volume resource.",
      "type": "object",
      "properties": {
        "fsType": {
          "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
          "type": "string"
        },
        "readOnly": {
          "description": "Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
          "type": "boolean"
        },
        "secretRef": {
          "description": "SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        },
        "volumeName": {
          "description": "VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.",
          "type": "string"
        },
        "volumeNamespace": {
          "description": "VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to \"default\" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.StorageOSVolumeSource": {
      "description": "Represents a StorageOS persistent volume resource.",
      "type": "object",
      "properties": {
        "fsType": {
          "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
          "type": "string"
        },
        "readOnly": {
          "description": "Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
          "type": "boolean"
        },
        "secretRef": {
          "description": "SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.",
          "$ref": "#/definitions/io.k8s.api.core.v1.LocalObjectReference"
        },
        "volumeName": {
          "description": "VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.",
          "type": "string"
        },
        "volumeNamespace": {
          "description": "VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to \"default\" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.Sysctl": {
      "description": "Sysctl defines a kernel parameter to be set",
      "type": "object",
      "required": ["name", "value"],
      "properties": {
        "name": {
          "description": "Name of a property to set",
          "type": "string"
        },
        "value": {
          "description": "Value of a property to set",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.TCPSocketAction": {
      "description": "TCPSocketAction describes an action based on opening a socket",
      "type": "object",
      "required": ["port"],
      "properties": {
        "host": {
          "description": "Optional: Host name to connect to, defaults to the pod IP.",
          "type": "string"
        },
        "port": {
          "description": "Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
        }
      }
    },
    "io.k8s.api.core.v1.Taint": {
      "description": "The node this Taint is attached to has the \"effect\" on any pod that does not tolerate the Taint.",
      "type": "object",
      "required": ["key", "effect"],
      "properties": {
        "effect": {
          "description": "Required. The effect of the taint on pods that do not tolerate the taint. Valid effects are NoSchedule, PreferNoSchedule and NoExecute.",
          "type": "string"
        },
        "key": {
          "description": "Required. The taint key to be applied to a node.",
          "type": "string"
        },
        "timeAdded": {
          "description": "TimeAdded represents the time at which the taint was added. It is only written for NoExecute taints.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "value": {
          "description": "The taint value corresponding to the taint key.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.Toleration": {
      "description": "The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.",
      "type": "object",
      "properties": {
        "effect": {
          "description": "Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.",
          "type": "string"
        },
        "key": {
          "description": "Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.",
          "type": "string"
        },
        "operator": {
          "description": "Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.",
          "type": "string"
        },
        "tolerationSeconds": {
          "description": "TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.",
          "type": "integer",
          "format": "int64"
        },
        "value": {
          "description": "Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.TopologySelectorLabelRequirement": {
      "description": "A topology selector requirement is a selector that matches given label. This is an alpha feature and may change in the future.",
      "type": "object",
      "required": ["key", "values"],
      "properties": {
        "key": {
          "description": "The label key that the selector applies to.",
          "type": "string"
        },
        "values": {
          "description": "An array of string values. One value must match the label to be selected. Each entry in Values is ORed.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.core.v1.TopologySelectorTerm": {
      "description": "A topology selector term represents the result of label queries. A null or empty topology selector term matches no objects. The requirements of them are ANDed. It provides a subset of functionality as NodeSelectorTerm. This is an alpha feature and may change in the future.",
      "type": "object",
      "properties": {
        "matchLabelExpressions": {
          "description": "A list of topology selector requirements by labels.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.TopologySelectorLabelRequirement"
          }
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.core.v1.TopologySpreadConstraint": {
      "description": "TopologySpreadConstraint specifies how to spread matching pods among the given topology.",
      "type": "object",
      "required": ["maxSkew", "topologyKey", "whenUnsatisfiable"],
      "properties": {
        "labelSelector": {
          "description": "LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "maxSkew": {
          "description": "MaxSkew describes the degree to which pods may be unevenly distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | |   P   |   P   |       | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1; scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.",
          "type": "integer",
          "format": "int32"
        },
        "topologyKey": {
          "description": "TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a \"bucket\", and try to put balanced number of pods into each bucket. It's a required field.",
          "type": "string"
        },
        "whenUnsatisfiable": {
          "description": "WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location,\n  but giving higher precedence to topologies that would help reduce the\n  skew.\nA constraint is considered \"Unsatisfiable\" for an incoming pod if and only if every possible node assigment for that pod would violate \"MaxSkew\" on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P |   P   |   P   | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.TypedLocalObjectReference": {
      "description": "TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace.",
      "type": "object",
      "required": ["kind", "name"],
      "properties": {
        "apiGroup": {
          "description": "APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.",
          "type": "string"
        },
        "kind": {
          "description": "Kind is the type of resource being referenced",
          "type": "string"
        },
        "name": {
          "description": "Name is the name of resource being referenced",
          "type": "string"
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.core.v1.Volume": {
      "description": "Volume represents a named volume in a pod that may be accessed by any container in the pod.",
      "type": "object",
      "required": ["name"],
      "properties": {
        "awsElasticBlockStore": {
          "description": "AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore",
          "$ref": "#/definitions/io.k8s.api.core.v1.AWSElasticBlockStoreVolumeSource"
        },
        "azureDisk": {
          "description": "AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.",
          "$ref": "#/definitions/io.k8s.api.core.v1.AzureDiskVolumeSource"
        },
        "azureFile": {
          "description": "AzureFile represents an Azure File Service mount on the host and bind mount to the pod.",
          "$ref": "#/definitions/io.k8s.api.core.v1.AzureFileVolumeSource"
        },
        "cephfs": {
          "description": "CephFS represents a Ceph FS mount on the host that shares a pod's lifetime",
          "$ref": "#/definitions/io.k8s.api.core.v1.CephFSVolumeSource"
        },
        "cinder": {
          "description": "Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md",
          "$ref": "#/definitions/io.k8s.api.core.v1.CinderVolumeSource"
        },
        "configMap": {
          "description": "ConfigMap represents a configMap that should populate this volume",
          "$ref": "#/definitions/io.k8s.api.core.v1.ConfigMapVolumeSource"
        },
        "csi": {
          "description": "CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).",
          "$ref": "#/definitions/io.k8s.api.core.v1.CSIVolumeSource"
        },
        "downwardAPI": {
          "description": "DownwardAPI represents downward API about the pod that should populate this volume",
          "$ref": "#/definitions/io.k8s.api.core.v1.DownwardAPIVolumeSource"
        },
        "emptyDir": {
          "description": "EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir",
          "$ref": "#/definitions/io.k8s.api.core.v1.EmptyDirVolumeSource"
        },
        "ephemeral": {
          "description": "Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.\n\nUse this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity\n   tracking are needed,\nc) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through\n   a PersistentVolumeClaim (see EphemeralVolumeSource for more\n   information on the connection between this volume type\n   and PersistentVolumeClaim).\n\nUse PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.\n\nUse CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.\n\nA pod can use both types of ephemeral volumes and persistent volumes at the same time.\n\nThis is a beta feature and only available when the GenericEphemeralVolume feature gate is enabled.",
          "$ref": "#/definitions/io.k8s.api.core.v1.EphemeralVolumeSource"
        },
        "fc": {
          "description": "FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.",
          "$ref": "#/definitions/io.k8s.api.core.v1.FCVolumeSource"
        },
        "flexVolume": {
          "description": "FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.",
          "$ref": "#/definitions/io.k8s.api.core.v1.FlexVolumeSource"
        },
        "flocker": {
          "description": "Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running",
          "$ref": "#/definitions/io.k8s.api.core.v1.FlockerVolumeSource"
        },
        "gcePersistentDisk": {
          "description": "GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk",
          "$ref": "#/definitions/io.k8s.api.core.v1.GCEPersistentDiskVolumeSource"
        },
        "gitRepo": {
          "description": "GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.",
          "$ref": "#/definitions/io.k8s.api.core.v1.GitRepoVolumeSource"
        },
        "glusterfs": {
          "description": "Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md",
          "$ref": "#/definitions/io.k8s.api.core.v1.GlusterfsVolumeSource"
        },
        "hostPath": {
          "description": "HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath",
          "$ref": "#/definitions/io.k8s.api.core.v1.HostPathVolumeSource"
        },
        "iscsi": {
          "description": "ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md",
          "$ref": "#/definitions/io.k8s.api.core.v1.ISCSIVolumeSource"
        },
        "name": {
          "description": "Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
          "type": "string"
        },
        "nfs": {
          "description": "NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs",
          "$ref": "#/definitions/io.k8s.api.core.v1.NFSVolumeSource"
        },
        "persistentVolumeClaim": {
          "description": "PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims",
          "$ref": "#/definitions/io.k8s.api.core.v1.PersistentVolumeClaimVolumeSource"
        },
        "photonPersistentDisk": {
          "description": "PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine",
          "$ref": "#/definitions/io.k8s.api.core.v1.PhotonPersistentDiskVolumeSource"
        },
        "portworxVolume": {
          "description": "PortworxVolume represents a portworx volume attached and mounted on kubelets host machine",
          "$ref": "#/definitions/io.k8s.api.core.v1.PortworxVolumeSource"
        },
        "projected": {
          "description": "Items for all in one resources secrets, configmaps, and downward API",
          "$ref": "#/definitions/io.k8s.api.core.v1.ProjectedVolumeSource"
        },
        "quobyte": {
          "description": "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime",
          "$ref": "#/definitions/io.k8s.api.core.v1.QuobyteVolumeSource"
        },
        "rbd": {
          "description": "RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md",
          "$ref": "#/definitions/io.k8s.api.core.v1.RBDVolumeSource"
        },
        "scaleIO": {
          "description": "ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ScaleIOVolumeSource"
        },
        "secret": {
          "description": "Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretVolumeSource"
        },
        "storageos": {
          "description": "StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.",
          "$ref": "#/definitions/io.k8s.api.core.v1.StorageOSVolumeSource"
        },
        "vsphereVolume": {
          "description": "VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine",
          "$ref": "#/definitions/io.k8s.api.core.v1.VsphereVirtualDiskVolumeSource"
        }
      }
    },
    "io.k8s.api.core.v1.VolumeDevice": {
      "description": "volumeDevice describes a mapping of a raw block device within a container.",
      "type": "object",
      "required": ["name", "devicePath"],
      "properties": {
        "devicePath": {
          "description": "devicePath is the path inside of the container that the device will be mapped to.",
          "type": "string"
        },
        "name": {
          "description": "name must match the name of a persistentVolumeClaim in the pod",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.VolumeMount": {
      "description": "VolumeMount describes a mounting of a Volume within a container.",
      "type": "object",
      "required": ["name", "mountPath"],
      "properties": {
        "mountPath": {
          "description": "Path within the container at which the volume should be mounted.  Must not contain ':'.",
          "type": "string"
        },
        "mountPropagation": {
          "description": "mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.",
          "type": "string"
        },
        "name": {
          "description": "This must match the Name of a Volume.",
          "type": "string"
        },
        "readOnly": {
          "description": "Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.",
          "type": "boolean"
        },
        "subPath": {
          "description": "Path within the volume from which the container's volume should be mounted. Defaults to \"\" (volume's root).",
          "type": "string"
        },
        "subPathExpr": {
          "description": "Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to \"\" (volume's root). SubPathExpr and SubPath are mutually exclusive.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.VolumeNodeAffinity": {
      "description": "VolumeNodeAffinity defines constraints that limit what nodes this volume can be accessed from.",
      "type": "object",
      "properties": {
        "required": {
          "description": "Required specifies hard node constraints that must be met.",
          "$ref": "#/definitions/io.k8s.api.core.v1.NodeSelector"
        }
      }
    },
    "io.k8s.api.core.v1.VolumeProjection": {
      "description": "Projection that may be projected along with other supported volume types",
      "type": "object",
      "properties": {
        "configMap": {
          "description": "information about the configMap data to project",
          "$ref": "#/definitions/io.k8s.api.core.v1.ConfigMapProjection"
        },
        "downwardAPI": {
          "description": "information about the downwardAPI data to project",
          "$ref": "#/definitions/io.k8s.api.core.v1.DownwardAPIProjection"
        },
        "secret": {
          "description": "information about the secret data to project",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretProjection"
        },
        "serviceAccountToken": {
          "description": "information about the serviceAccountToken data to project",
          "$ref": "#/definitions/io.k8s.api.core.v1.ServiceAccountTokenProjection"
        }
      }
    },
    "io.k8s.api.core.v1.VsphereVirtualDiskVolumeSource": {
      "description": "Represents a vSphere volume resource.",
      "type": "object",
      "required": ["volumePath"],
      "properties": {
        "fsType": {
          "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
          "type": "string"
        },
        "storagePolicyID": {
          "description": "Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.",
          "type": "string"
        },
        "storagePolicyName": {
          "description": "Storage Policy Based Management (SPBM) profile name.",
          "type": "string"
        },
        "volumePath": {
          "description": "Path that identifies vSphere volume vmdk",
          "type": "string"
        }
      }
    },
    "io.k8s.api.core.v1.WeightedPodAffinityTerm": {
      "description": "The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)",
      "type": "object",
      "required": ["weight", "podAffinityTerm"],
      "properties": {
        "podAffinityTerm": {
          "description": "Required. A pod affinity term, associated with the corresponding weight.",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodAffinityTerm"
        },
        "weight": {
          "description": "weight associated with matching the corresponding podAffinityTerm, in the range 1-100.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.core.v1.WindowsSecurityContextOptions": {
      "description": "WindowsSecurityContextOptions contain Windows-specific options and credentials.",
      "type": "object",
      "properties": {
        "gmsaCredentialSpec": {
          "description": "GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.",
          "type": "string"
        },
        "gmsaCredentialSpecName": {
          "description": "GMSACredentialSpecName is the name of the GMSA credential spec to use.",
          "type": "string"
        },
        "hostProcess": {
          "description": "HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.",
          "type": "boolean"
        },
        "runAsUserName": {
          "description": "The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.discovery.v1.Endpoint": {
      "description": "Endpoint represents a single logical \"backend\" implementing a service.",
      "type": "object",
      "required": ["addresses"],
      "properties": {
        "addresses": {
          "description": "addresses of this endpoint. The contents of this field are interpreted according to the corresponding EndpointSlice addressType field. Consumers must handle different types of addresses in the context of their own capabilities. This must contain at least one address but no more than 100.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-list-type": "set"
        },
        "conditions": {
          "description": "conditions contains information about the current status of the endpoint.",
          "$ref": "#/definitions/io.k8s.api.discovery.v1.EndpointConditions"
        },
        "deprecatedTopology": {
          "description": "deprecatedTopology contains topology information part of the v1beta1 API. This field is deprecated, and will be removed when the v1beta1 API is removed (no sooner than kubernetes v1.24).  While this field can hold values, it is not writable through the v1 API, and any attempts to write to it will be silently ignored. Topology information can be found in the zone and nodeName fields instead.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "hints": {
          "description": "hints contains information associated with how an endpoint should be consumed.",
          "$ref": "#/definitions/io.k8s.api.discovery.v1.EndpointHints"
        },
        "hostname": {
          "description": "hostname of this endpoint. This field may be used by consumers of endpoints to distinguish endpoints from each other (e.g. in DNS names). Multiple endpoints which use the same hostname should be considered fungible (e.g. multiple A values in DNS). Must be lowercase and pass DNS Label (RFC 1123) validation.",
          "type": "string"
        },
        "nodeName": {
          "description": "nodeName represents the name of the Node hosting this endpoint. This can be used to determine endpoints local to a Node. This field can be enabled with the EndpointSliceNodeName feature gate.",
          "type": "string"
        },
        "targetRef": {
          "description": "targetRef is a reference to a Kubernetes object that represents this endpoint.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        },
        "zone": {
          "description": "zone is the name of the Zone this endpoint exists in.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.discovery.v1.EndpointConditions": {
      "description": "EndpointConditions represents the current condition of an endpoint.",
      "type": "object",
      "properties": {
        "ready": {
          "description": "ready indicates that this endpoint is prepared to receive traffic, according to whatever system is managing the endpoint. A nil value indicates an unknown state. In most cases consumers should interpret this unknown state as ready. For compatibility reasons, ready should never be \"true\" for terminating endpoints.",
          "type": "boolean"
        },
        "serving": {
          "description": "serving is identical to ready except that it is set regardless of the terminating state of endpoints. This condition should be set to true for a ready endpoint that is terminating. If nil, consumers should defer to the ready condition. This field can be enabled with the EndpointSliceTerminatingCondition feature gate.",
          "type": "boolean"
        },
        "terminating": {
          "description": "terminating indicates that this endpoint is terminating. A nil value indicates an unknown state. Consumers should interpret this unknown state to mean that the endpoint is not terminating. This field can be enabled with the EndpointSliceTerminatingCondition feature gate.",
          "type": "boolean"
        }
      }
    },
    "io.k8s.api.discovery.v1.EndpointHints": {
      "description": "EndpointHints provides hints describing how an endpoint should be consumed.",
      "type": "object",
      "properties": {
        "forZones": {
          "description": "forZones indicates the zone(s) this endpoint should be consumed by to enable topology aware routing.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.discovery.v1.ForZone"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "io.k8s.api.discovery.v1.EndpointPort": {
      "description": "EndpointPort represents a Port used by an EndpointSlice",
      "type": "object",
      "properties": {
        "appProtocol": {
          "description": "The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and http://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol.",
          "type": "string"
        },
        "name": {
          "description": "The name of this port. All ports in an EndpointSlice must have a unique name. If the EndpointSlice is dervied from a Kubernetes service, this corresponds to the Service.ports[].name. Name must either be an empty string or pass DNS_LABEL validation: * must be no more than 63 characters long. * must consist of lower case alphanumeric characters or '-'. * must start and end with an alphanumeric character. Default is empty string.",
          "type": "string"
        },
        "port": {
          "description": "The port number of the endpoint. If this is not specified, ports are not restricted and must be interpreted in the context of the specific consumer.",
          "type": "integer",
          "format": "int32"
        },
        "protocol": {
          "description": "The IP protocol for this port. Must be UDP, TCP, or SCTP. Default is TCP.",
          "type": "string"
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.discovery.v1.EndpointSlice": {
      "description": "EndpointSlice represents a subset of the endpoints that implement a service. For a given service there may be multiple EndpointSlice objects, selected by labels, which must be joined to produce the full set of endpoints.",
      "type": "object",
      "required": ["addressType", "endpoints"],
      "properties": {
        "addressType": {
          "description": "addressType specifies the type of address carried by this EndpointSlice. All addresses in this slice must be the same type. This field is immutable after creation. The following address types are currently supported: * IPv4: Represents an IPv4 Address. * IPv6: Represents an IPv6 Address. * FQDN: Represents a Fully Qualified Domain Name.",
          "type": "string"
        },
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["discovery.k8s.io/v1"]
        },
        "endpoints": {
          "description": "endpoints is a list of unique endpoints in this slice. Each slice may include a maximum of 1000 endpoints.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.discovery.v1.Endpoint"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["EndpointSlice"]
        },
        "metadata": {
          "description": "Standard object's metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "ports": {
          "description": "ports specifies the list of network ports exposed by each endpoint in this slice. Each port must have a unique name. When ports is empty, it indicates that there are no defined ports. When a port is defined with a nil port value, it indicates \"all ports\". Each slice may include a maximum of 100 ports.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.discovery.v1.EndpointPort"
          },
          "x-kubernetes-list-type": "atomic"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "discovery.k8s.io",
          "kind": "EndpointSlice",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.discovery.v1.EndpointSliceList": {
      "description": "EndpointSliceList represents a list of endpoint slices",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["discovery.k8s.io/v1"]
        },
        "items": {
          "description": "List of endpoint slices",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.discovery.v1.EndpointSlice"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["EndpointSliceList"]
        },
        "metadata": {
          "description": "Standard list metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "discovery.k8s.io",
          "kind": "EndpointSliceList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.discovery.v1.ForZone": {
      "description": "ForZone provides information about which zones should consume this endpoint.",
      "type": "object",
      "required": ["name"],
      "properties": {
        "name": {
          "description": "name represents the name of the zone.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.discovery.v1beta1.Endpoint": {
      "description": "Endpoint represents a single logical \"backend\" implementing a service.",
      "type": "object",
      "required": ["addresses"],
      "properties": {
        "addresses": {
          "description": "addresses of this endpoint. The contents of this field are interpreted according to the corresponding EndpointSlice addressType field. Consumers must handle different types of addresses in the context of their own capabilities. This must contain at least one address but no more than 100.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-list-type": "set"
        },
        "conditions": {
          "description": "conditions contains information about the current status of the endpoint.",
          "$ref": "#/definitions/io.k8s.api.discovery.v1beta1.EndpointConditions"
        },
        "hints": {
          "description": "hints contains information associated with how an endpoint should be consumed.",
          "$ref": "#/definitions/io.k8s.api.discovery.v1beta1.EndpointHints"
        },
        "hostname": {
          "description": "hostname of this endpoint. This field may be used by consumers of endpoints to distinguish endpoints from each other (e.g. in DNS names). Multiple endpoints which use the same hostname should be considered fungible (e.g. multiple A values in DNS). Must be lowercase and pass DNS Label (RFC 1123) validation.",
          "type": "string"
        },
        "nodeName": {
          "description": "nodeName represents the name of the Node hosting this endpoint. This can be used to determine endpoints local to a Node. This field can be enabled with the EndpointSliceNodeName feature gate.",
          "type": "string"
        },
        "targetRef": {
          "description": "targetRef is a reference to a Kubernetes object that represents this endpoint.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        },
        "topology": {
          "description": "topology contains arbitrary topology information associated with the endpoint. These key/value pairs must conform with the label format. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels Topology may include a maximum of 16 key/value pairs. This includes, but is not limited to the following well known keys: * kubernetes.io/hostname: the value indicates the hostname of the node\n  where the endpoint is located. This should match the corresponding\n  node label.\n* topology.kubernetes.io/zone: the value indicates the zone where the\n  endpoint is located. This should match the corresponding node label.\n* topology.kubernetes.io/region: the value indicates the region where the\n  endpoint is located. This should match the corresponding node label.\nThis field is deprecated and will be removed in future api versions.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.discovery.v1beta1.EndpointConditions": {
      "description": "EndpointConditions represents the current condition of an endpoint.",
      "type": "object",
      "properties": {
        "ready": {
          "description": "ready indicates that this endpoint is prepared to receive traffic, according to whatever system is managing the endpoint. A nil value indicates an unknown state. In most cases consumers should interpret this unknown state as ready. For compatibility reasons, ready should never be \"true\" for terminating endpoints.",
          "type": "boolean"
        },
        "serving": {
          "description": "serving is identical to ready except that it is set regardless of the terminating state of endpoints. This condition should be set to true for a ready endpoint that is terminating. If nil, consumers should defer to the ready condition. This field can be enabled with the EndpointSliceTerminatingCondition feature gate.",
          "type": "boolean"
        },
        "terminating": {
          "description": "terminating indicates that this endpoint is terminating. A nil value indicates an unknown state. Consumers should interpret this unknown state to mean that the endpoint is not terminating. This field can be enabled with the EndpointSliceTerminatingCondition feature gate.",
          "type": "boolean"
        }
      }
    },
    "io.k8s.api.discovery.v1beta1.EndpointHints": {
      "description": "EndpointHints provides hints describing how an endpoint should be consumed.",
      "type": "object",
      "properties": {
        "forZones": {
          "description": "forZones indicates the zone(s) this endpoint should be consumed by to enable topology aware routing. May contain a maximum of 8 entries.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.discovery.v1beta1.ForZone"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "io.k8s.api.discovery.v1beta1.EndpointPort": {
      "description": "EndpointPort represents a Port used by an EndpointSlice",
      "type": "object",
      "properties": {
        "appProtocol": {
          "description": "The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and http://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol.",
          "type": "string"
        },
        "name": {
          "description": "The name of this port. All ports in an EndpointSlice must have a unique name. If the EndpointSlice is dervied from a Kubernetes service, this corresponds to the Service.ports[].name. Name must either be an empty string or pass DNS_LABEL validation: * must be no more than 63 characters long. * must consist of lower case alphanumeric characters or '-'. * must start and end with an alphanumeric character. Default is empty string.",
          "type": "string"
        },
        "port": {
          "description": "The port number of the endpoint. If this is not specified, ports are not restricted and must be interpreted in the context of the specific consumer.",
          "type": "integer",
          "format": "int32"
        },
        "protocol": {
          "description": "The IP protocol for this port. Must be UDP, TCP, or SCTP. Default is TCP.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.discovery.v1beta1.EndpointSlice": {
      "description": "EndpointSlice represents a subset of the endpoints that implement a service. For a given service there may be multiple EndpointSlice objects, selected by labels, which must be joined to produce the full set of endpoints.",
      "type": "object",
      "required": ["addressType", "endpoints"],
      "properties": {
        "addressType": {
          "description": "addressType specifies the type of address carried by this EndpointSlice. All addresses in this slice must be the same type. This field is immutable after creation. The following address types are currently supported: * IPv4: Represents an IPv4 Address. * IPv6: Represents an IPv6 Address. * FQDN: Represents a Fully Qualified Domain Name.",
          "type": "string"
        },
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["discovery.k8s.io/v1beta1"]
        },
        "endpoints": {
          "description": "endpoints is a list of unique endpoints in this slice. Each slice may include a maximum of 1000 endpoints.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.discovery.v1beta1.Endpoint"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["EndpointSlice"]
        },
        "metadata": {
          "description": "Standard object's metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "ports": {
          "description": "ports specifies the list of network ports exposed by each endpoint in this slice. Each port must have a unique name. When ports is empty, it indicates that there are no defined ports. When a port is defined with a nil port value, it indicates \"all ports\". Each slice may include a maximum of 100 ports.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.discovery.v1beta1.EndpointPort"
          },
          "x-kubernetes-list-type": "atomic"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "discovery.k8s.io",
          "kind": "EndpointSlice",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.api.discovery.v1beta1.EndpointSliceList": {
      "description": "EndpointSliceList represents a list of endpoint slices",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["discovery.k8s.io/v1beta1"]
        },
        "items": {
          "description": "List of endpoint slices",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.discovery.v1beta1.EndpointSlice"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["EndpointSliceList"]
        },
        "metadata": {
          "description": "Standard list metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "discovery.k8s.io",
          "kind": "EndpointSliceList",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.api.discovery.v1beta1.ForZone": {
      "description": "ForZone provides information about which zones should consume this endpoint.",
      "type": "object",
      "required": ["name"],
      "properties": {
        "name": {
          "description": "name represents the name of the zone.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.events.v1.Event": {
      "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system. Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data.",
      "type": "object",
      "required": ["eventTime"],
      "properties": {
        "action": {
          "description": "action is what action was taken/failed regarding to the regarding object. It is machine-readable. This field cannot be empty for new Events and it can have at most 128 characters.",
          "type": "string"
        },
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["events.k8s.io/v1"]
        },
        "deprecatedCount": {
          "description": "deprecatedCount is the deprecated field assuring backward compatibility with core.v1 Event type.",
          "type": "integer",
          "format": "int32"
        },
        "deprecatedFirstTimestamp": {
          "description": "deprecatedFirstTimestamp is the deprecated field assuring backward compatibility with core.v1 Event type.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "deprecatedLastTimestamp": {
          "description": "deprecatedLastTimestamp is the deprecated field assuring backward compatibility with core.v1 Event type.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "deprecatedSource": {
          "description": "deprecatedSource is the deprecated field assuring backward compatibility with core.v1 Event type.",
          "$ref": "#/definitions/io.k8s.api.core.v1.EventSource"
        },
        "eventTime": {
          "description": "eventTime is the time when this Event was first observed. It is required.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Event"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "note": {
          "description": "note is a human-readable description of the status of this operation. Maximal length of the note is 1kB, but libraries should be prepared to handle values up to 64kB.",
          "type": "string"
        },
        "reason": {
          "description": "reason is why the action was taken. It is human-readable. This field cannot be empty for new Events and it can have at most 128 characters.",
          "type": "string"
        },
        "regarding": {
          "description": "regarding contains the object this Event is about. In most cases it's an Object reporting controller implements, e.g. ReplicaSetController implements ReplicaSets and this event is emitted because it acts on some changes in a ReplicaSet object.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        },
        "related": {
          "description": "related is the optional secondary object for more complex actions. E.g. when regarding object triggers a creation or deletion of related object.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        },
        "reportingController": {
          "description": "reportingController is the name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`. This field cannot be empty for new Events.",
          "type": "string"
        },
        "reportingInstance": {
          "description": "reportingInstance is the ID of the controller instance, e.g. `kubelet-xyzf`. This field cannot be empty for new Events and it can have at most 128 characters.",
          "type": "string"
        },
        "series": {
          "description": "series is data about the Event series this event represents or nil if it's a singleton Event.",
          "$ref": "#/definitions/io.k8s.api.events.v1.EventSeries"
        },
        "type": {
          "description": "type is the type of this event (Normal, Warning), new types could be added in the future. It is machine-readable. This field cannot be empty for new Events.",
          "type": "string"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "events.k8s.io",
          "kind": "Event",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.events.v1.EventList": {
      "description": "EventList is a list of Event objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["events.k8s.io/v1"]
        },
        "items": {
          "description": "items is a list of schema objects.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.events.v1.Event"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["EventList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "events.k8s.io",
          "kind": "EventList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.events.v1.EventSeries": {
      "description": "EventSeries contain information on series of events, i.e. thing that was/is happening continuously for some time. How often to update the EventSeries is up to the event reporters. The default event reporter in \"k8s.io/client-go/tools/events/event_broadcaster.go\" shows how this struct is updated on heartbeats and can guide customized reporter implementations.",
      "type": "object",
      "required": ["count", "lastObservedTime"],
      "properties": {
        "count": {
          "description": "count is the number of occurrences in this series up to the last heartbeat time.",
          "type": "integer",
          "format": "int32"
        },
        "lastObservedTime": {
          "description": "lastObservedTime is the time when last Event from the series was seen before last heartbeat.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime"
        }
      }
    },
    "io.k8s.api.flowcontrol.v1beta1.FlowDistinguisherMethod": {
      "description": "FlowDistinguisherMethod specifies the method of a flow distinguisher.",
      "type": "object",
      "required": ["type"],
      "properties": {
        "type": {
          "description": "`type` is the type of flow distinguisher method The supported types are \"ByUser\" and \"ByNamespace\". Required.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.flowcontrol.v1beta1.FlowSchema": {
      "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\".",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["flowcontrol.apiserver.k8s.io/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["FlowSchema"]
        },
        "metadata": {
          "description": "`metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "`spec` is the specification of the desired behavior of a FlowSchema. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.FlowSchemaSpec"
        },
        "status": {
          "description": "`status` is the current status of a FlowSchema. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.FlowSchemaStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "flowcontrol.apiserver.k8s.io",
          "kind": "FlowSchema",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.api.flowcontrol.v1beta1.FlowSchemaCondition": {
      "description": "FlowSchemaCondition describes conditions for a FlowSchema.",
      "type": "object",
      "properties": {
        "lastTransitionTime": {
          "description": "`lastTransitionTime` is the last time the condition transitioned from one status to another.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "`message` is a human-readable message indicating details about last transition.",
          "type": "string"
        },
        "reason": {
          "description": "`reason` is a unique, one-word, CamelCase reason for the condition's last transition.",
          "type": "string"
        },
        "status": {
          "description": "`status` is the status of the condition. Can be True, False, Unknown. Required.",
          "type": "string"
        },
        "type": {
          "description": "`type` is the type of the condition. Required.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.flowcontrol.v1beta1.FlowSchemaList": {
      "description": "FlowSchemaList is a list of FlowSchema objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["flowcontrol.apiserver.k8s.io/v1beta1"]
        },
        "items": {
          "description": "`items` is a list of FlowSchemas.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.FlowSchema"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["FlowSchemaList"]
        },
        "metadata": {
          "description": "`metadata` is the standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "flowcontrol.apiserver.k8s.io",
          "kind": "FlowSchemaList",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.api.flowcontrol.v1beta1.FlowSchemaSpec": {
      "description": "FlowSchemaSpec describes how the FlowSchema's specification looks like.",
      "type": "object",
      "required": ["priorityLevelConfiguration"],
      "properties": {
        "distinguisherMethod": {
          "description": "`distinguisherMethod` defines how to compute the flow distinguisher for requests that match this schema. `nil` specifies that the distinguisher is disabled and thus will always be the empty string.",
          "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.FlowDistinguisherMethod"
        },
        "matchingPrecedence": {
          "description": "`matchingPrecedence` is used to choose among the FlowSchemas that match a given request. The chosen FlowSchema is among those with the numerically lowest (which we take to be logically highest) MatchingPrecedence.  Each MatchingPrecedence value must be ranged in [1,10000]. Note that if the precedence is not specified, it will be set to 1000 as default.",
          "type": "integer",
          "format": "int32"
        },
        "priorityLevelConfiguration": {
          "description": "`priorityLevelConfiguration` should reference a PriorityLevelConfiguration in the cluster. If the reference cannot be resolved, the FlowSchema will be ignored and marked as invalid in its status. Required.",
          "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfigurationReference"
        },
        "rules": {
          "description": "`rules` describes which requests will match this flow schema. This FlowSchema matches a request if and only if at least one member of rules matches the request. if it is an empty slice, there will be no requests matching the FlowSchema.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.PolicyRulesWithSubjects"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "io.k8s.api.flowcontrol.v1beta1.FlowSchemaStatus": {
      "description": "FlowSchemaStatus represents the current state of a FlowSchema.",
      "type": "object",
      "properties": {
        "conditions": {
          "description": "`conditions` is a list of the current states of FlowSchema.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.FlowSchemaCondition"
          },
          "x-kubernetes-list-map-keys": ["type"],
          "x-kubernetes-list-type": "map"
        }
      }
    },
    "io.k8s.api.flowcontrol.v1beta1.GroupSubject": {
      "description": "GroupSubject holds detailed information for group-kind subject.",
      "type": "object",
      "required": ["name"],
      "properties": {
        "name": {
          "description": "name is the user group that matches, or \"*\" to match all user groups. See https://github.com/kubernetes/apiserver/blob/master/pkg/authentication/user/user.go for some well-known group names. Required.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.flowcontrol.v1beta1.LimitResponse": {
      "description": "LimitResponse defines how to handle requests that can not be executed right now.",
      "type": "object",
      "required": ["type"],
      "properties": {
        "queuing": {
          "description": "`queuing` holds the configuration parameters for queuing. This field may be non-empty only if `type` is `\"Queue\"`.",
          "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.QueuingConfiguration"
        },
        "type": {
          "description": "`type` is \"Queue\" or \"Reject\". \"Queue\" means that requests that can not be executed upon arrival are held in a queue until they can be executed or a queuing limit is reached. \"Reject\" means that requests that can not be executed upon arrival are rejected. Required.",
          "type": "string"
        }
      },
      "x-kubernetes-unions": [
        {
          "discriminator": "type",
          "fields-to-discriminateBy": {
            "queuing": "Queuing"
          }
        }
      ]
    },
    "io.k8s.api.flowcontrol.v1beta1.LimitedPriorityLevelConfiguration": {
      "description": "LimitedPriorityLevelConfiguration specifies how to handle requests that are subject to limits. It addresses two issues:\n * How are requests for this priority level limited?\n * What should be done with requests that exceed the limit?",
      "type": "object",
      "properties": {
        "assuredConcurrencyShares": {
          "description": "`assuredConcurrencyShares` (ACS) configures the execution limit, which is a limit on the number of requests of this priority level that may be exeucting at a given time.  ACS must be a positive number. The server's concurrency limit (SCL) is divided among the concurrency-controlled priority levels in proportion to their assured concurrency shares. This produces the assured concurrency value (ACV) --- the number of requests that may be executing at a time --- for each such priority level:\n\n            ACV(l) = ceil( SCL * ACS(l) / ( sum[priority levels k] ACS(k) ) )\n\nbigger numbers of ACS mean more reserved concurrent requests (at the expense of every other PL). This field has a default value of 30.",
          "type": "integer",
          "format": "int32"
        },
        "limitResponse": {
          "description": "`limitResponse` indicates what to do with requests that can not be executed right now",
          "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.LimitResponse"
        }
      }
    },
    "io.k8s.api.flowcontrol.v1beta1.NonResourcePolicyRule": {
      "description": "NonResourcePolicyRule is a predicate that matches non-resource requests according to their verb and the target non-resource URL. A NonResourcePolicyRule matches a request if and only if both (a) at least one member of verbs matches the request and (b) at least one member of nonResourceURLs matches the request.",
      "type": "object",
      "required": ["verbs", "nonResourceURLs"],
      "properties": {
        "nonResourceURLs": {
          "description": "`nonResourceURLs` is a set of url prefixes that a user should have access to and may not be empty. For example:\n  - \"/healthz\" is legal\n  - \"/hea*\" is illegal\n  - \"/hea\" is legal but matches nothing\n  - \"/hea/*\" also matches nothing\n  - \"/healthz/*\" matches all per-component health checks.\n\"*\" matches all non-resource urls. if it is present, it must be the only entry. Required.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-list-type": "set"
        },
        "verbs": {
          "description": "`verbs` is a list of matching verbs and may not be empty. \"*\" matches all verbs. If it is present, it must be the only entry. Required.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-list-type": "set"
        }
      }
    },
    "io.k8s.api.flowcontrol.v1beta1.PolicyRulesWithSubjects": {
      "description": "PolicyRulesWithSubjects prescribes a test that applies to a request to an apiserver. The test considers the subject making the request, the verb being requested, and the resource to be acted upon. This PolicyRulesWithSubjects matches a request if and only if both (a) at least one member of subjects matches the request and (b) at least one member of resourceRules or nonResourceRules matches the request.",
      "type": "object",
      "required": ["subjects"],
      "properties": {
        "nonResourceRules": {
          "description": "`nonResourceRules` is a list of NonResourcePolicyRules that identify matching requests according to their verb and the target non-resource URL.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.NonResourcePolicyRule"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resourceRules": {
          "description": "`resourceRules` is a slice of ResourcePolicyRules that identify matching requests according to their verb and the target resource. At least one of `resourceRules` and `nonResourceRules` has to be non-empty.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.ResourcePolicyRule"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "subjects": {
          "description": "subjects is the list of normal user, serviceaccount, or group that this rule cares about. There must be at least one member in this slice. A slice that includes both the system:authenticated and system:unauthenticated user groups matches every request. Required.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.Subject"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfiguration": {
      "description": "PriorityLevelConfiguration represents the configuration of a priority level.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["flowcontrol.apiserver.k8s.io/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PriorityLevelConfiguration"]
        },
        "metadata": {
          "description": "`metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "`spec` is the specification of the desired behavior of a \"request-priority\". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfigurationSpec"
        },
        "status": {
          "description": "`status` is the current status of a \"request-priority\". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfigurationStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "flowcontrol.apiserver.k8s.io",
          "kind": "PriorityLevelConfiguration",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfigurationCondition": {
      "description": "PriorityLevelConfigurationCondition defines the condition of priority level.",
      "type": "object",
      "properties": {
        "lastTransitionTime": {
          "description": "`lastTransitionTime` is the last time the condition transitioned from one status to another.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "`message` is a human-readable message indicating details about last transition.",
          "type": "string"
        },
        "reason": {
          "description": "`reason` is a unique, one-word, CamelCase reason for the condition's last transition.",
          "type": "string"
        },
        "status": {
          "description": "`status` is the status of the condition. Can be True, False, Unknown. Required.",
          "type": "string"
        },
        "type": {
          "description": "`type` is the type of the condition. Required.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfigurationList": {
      "description": "PriorityLevelConfigurationList is a list of PriorityLevelConfiguration objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["flowcontrol.apiserver.k8s.io/v1beta1"]
        },
        "items": {
          "description": "`items` is a list of request-priorities.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfiguration"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PriorityLevelConfigurationList"]
        },
        "metadata": {
          "description": "`metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "flowcontrol.apiserver.k8s.io",
          "kind": "PriorityLevelConfigurationList",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfigurationReference": {
      "description": "PriorityLevelConfigurationReference contains information that points to the \"request-priority\" being used.",
      "type": "object",
      "required": ["name"],
      "properties": {
        "name": {
          "description": "`name` is the name of the priority level configuration being referenced Required.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfigurationSpec": {
      "description": "PriorityLevelConfigurationSpec specifies the configuration of a priority level.",
      "type": "object",
      "required": ["type"],
      "properties": {
        "limited": {
          "description": "`limited` specifies how requests are handled for a Limited priority level. This field must be non-empty if and only if `type` is `\"Limited\"`.",
          "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.LimitedPriorityLevelConfiguration"
        },
        "type": {
          "description": "`type` indicates whether this priority level is subject to limitation on request execution.  A value of `\"Exempt\"` means that requests of this priority level are not subject to a limit (and thus are never queued) and do not detract from the capacity made available to other priority levels.  A value of `\"Limited\"` means that (a) requests of this priority level _are_ subject to limits and (b) some of the server's limited capacity is made available exclusively to this priority level. Required.",
          "type": "string"
        }
      },
      "x-kubernetes-unions": [
        {
          "discriminator": "type",
          "fields-to-discriminateBy": {
            "limited": "Limited"
          }
        }
      ]
    },
    "io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfigurationStatus": {
      "description": "PriorityLevelConfigurationStatus represents the current state of a \"request-priority\".",
      "type": "object",
      "properties": {
        "conditions": {
          "description": "`conditions` is the current state of \"request-priority\".",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.PriorityLevelConfigurationCondition"
          },
          "x-kubernetes-list-map-keys": ["type"],
          "x-kubernetes-list-type": "map"
        }
      }
    },
    "io.k8s.api.flowcontrol.v1beta1.QueuingConfiguration": {
      "description": "QueuingConfiguration holds the configuration parameters for queuing",
      "type": "object",
      "properties": {
        "handSize": {
          "description": "`handSize` is a small positive number that configures the shuffle sharding of requests into queues.  When enqueuing a request at this priority level the request's flow identifier (a string pair) is hashed and the hash value is used to shuffle the list of queues and deal a hand of the size specified here.  The request is put into one of the shortest queues in that hand. `handSize` must be no larger than `queues`, and should be significantly smaller (so that a few heavy flows do not saturate most of the queues).  See the user-facing documentation for more extensive guidance on setting this field.  This field has a default value of 8.",
          "type": "integer",
          "format": "int32"
        },
        "queueLengthLimit": {
          "description": "`queueLengthLimit` is the maximum number of requests allowed to be waiting in a given queue of this priority level at a time; excess requests are rejected.  This value must be positive.  If not specified, it will be defaulted to 50.",
          "type": "integer",
          "format": "int32"
        },
        "queues": {
          "description": "`queues` is the number of queues for this priority level. The queues exist independently at each apiserver. The value must be positive.  Setting it to 1 effectively precludes shufflesharding and thus makes the distinguisher method of associated flow schemas irrelevant.  This field has a default value of 64.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.flowcontrol.v1beta1.ResourcePolicyRule": {
      "description": "ResourcePolicyRule is a predicate that matches some resource requests, testing the request's verb and the target resource. A ResourcePolicyRule matches a resource request if and only if: (a) at least one member of verbs matches the request, (b) at least one member of apiGroups matches the request, (c) at least one member of resources matches the request, and (d) least one member of namespaces matches the request.",
      "type": "object",
      "required": ["verbs", "apiGroups", "resources"],
      "properties": {
        "apiGroups": {
          "description": "`apiGroups` is a list of matching API groups and may not be empty. \"*\" matches all API groups and, if present, must be the only entry. Required.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-list-type": "set"
        },
        "clusterScope": {
          "description": "`clusterScope` indicates whether to match requests that do not specify a namespace (which happens either because the resource is not namespaced or the request targets all namespaces). If this field is omitted or false then the `namespaces` field must contain a non-empty list.",
          "type": "boolean"
        },
        "namespaces": {
          "description": "`namespaces` is a list of target namespaces that restricts matches.  A request that specifies a target namespace matches only if either (a) this list contains that target namespace or (b) this list contains \"*\".  Note that \"*\" matches any specified namespace but does not match a request that _does not specify_ a namespace (see the `clusterScope` field for that). This list may be empty, but only if `clusterScope` is true.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-list-type": "set"
        },
        "resources": {
          "description": "`resources` is a list of matching resources (i.e., lowercase and plural) with, if desired, subresource.  For example, [ \"services\", \"nodes/status\" ].  This list may not be empty. \"*\" matches all resources and, if present, must be the only entry. Required.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-list-type": "set"
        },
        "verbs": {
          "description": "`verbs` is a list of matching verbs and may not be empty. \"*\" matches all verbs and, if present, must be the only entry. Required.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-list-type": "set"
        }
      }
    },
    "io.k8s.api.flowcontrol.v1beta1.ServiceAccountSubject": {
      "description": "ServiceAccountSubject holds detailed information for service-account-kind subject.",
      "type": "object",
      "required": ["namespace", "name"],
      "properties": {
        "name": {
          "description": "`name` is the name of matching ServiceAccount objects, or \"*\" to match regardless of name. Required.",
          "type": "string"
        },
        "namespace": {
          "description": "`namespace` is the namespace of matching ServiceAccount objects. Required.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.flowcontrol.v1beta1.Subject": {
      "description": "Subject matches the originator of a request, as identified by the request authentication system. There are three ways of matching an originator; by user, group, or service account.",
      "type": "object",
      "required": ["kind"],
      "properties": {
        "group": {
          "description": "`group` matches based on user group name.",
          "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.GroupSubject"
        },
        "kind": {
          "description": "`kind` indicates which one of the other fields is non-empty. Required",
          "type": "string"
        },
        "serviceAccount": {
          "description": "`serviceAccount` matches ServiceAccounts.",
          "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.ServiceAccountSubject"
        },
        "user": {
          "description": "`user` matches based on username.",
          "$ref": "#/definitions/io.k8s.api.flowcontrol.v1beta1.UserSubject"
        }
      },
      "x-kubernetes-unions": [
        {
          "discriminator": "kind",
          "fields-to-discriminateBy": {
            "group": "Group",
            "serviceAccount": "ServiceAccount",
            "user": "User"
          }
        }
      ]
    },
    "io.k8s.api.flowcontrol.v1beta1.UserSubject": {
      "description": "UserSubject holds detailed information for user-kind subject.",
      "type": "object",
      "required": ["name"],
      "properties": {
        "name": {
          "description": "`name` is the username that matches, or \"*\" to match all usernames. Required.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.networking.v1.HTTPIngressPath": {
      "description": "HTTPIngressPath associates a path with a backend. Incoming urls matching the path are forwarded to the backend.",
      "type": "object",
      "required": ["pathType", "backend"],
      "properties": {
        "backend": {
          "description": "Backend defines the referenced service endpoint to which the traffic will be forwarded to.",
          "$ref": "#/definitions/io.k8s.api.networking.v1.IngressBackend"
        },
        "path": {
          "description": "Path is matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. Paths must begin with a '/' and must be present when using PathType with value \"Exact\" or \"Prefix\".",
          "type": "string"
        },
        "pathType": {
          "description": "PathType determines the interpretation of the Path matching. PathType can be one of the following values: * Exact: Matches the URL path exactly. * Prefix: Matches based on a URL path prefix split by '/'. Matching is\n  done on a path element by element basis. A path element refers is the\n  list of labels in the path split by the '/' separator. A request is a\n  match for path p if every p is an element-wise prefix of p of the\n  request path. Note that if the last element of the path is a substring\n  of the last element in request path, it is not a match (e.g. /foo/bar\n  matches /foo/bar/baz, but does not match /foo/barbaz).\n* ImplementationSpecific: Interpretation of the Path matching is up to\n  the IngressClass. Implementations can treat this as a separate PathType\n  or treat it identically to Prefix or Exact path types.\nImplementations are required to support all path types.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.networking.v1.HTTPIngressRuleValue": {
      "description": "HTTPIngressRuleValue is a list of http selectors pointing to backends. In the example: http://<host>/<path>?<searchpart> -> backend where where parts of the url correspond to RFC 3986, this resource will be used to match against everything after the last '/' and before the first '?' or '#'.",
      "type": "object",
      "required": ["paths"],
      "properties": {
        "paths": {
          "description": "A collection of paths that map requests to backends.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.networking.v1.HTTPIngressPath"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "io.k8s.api.networking.v1.IPBlock": {
      "description": "IPBlock describes a particular CIDR (Ex. \"192.168.1.1/24\",\"2001:db9::/64\") that is allowed to the pods matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs that should not be included within this rule.",
      "type": "object",
      "required": ["cidr"],
      "properties": {
        "cidr": {
          "description": "CIDR is a string representing the IP Block Valid examples are \"192.168.1.1/24\" or \"2001:db9::/64\"",
          "type": "string"
        },
        "except": {
          "description": "Except is a slice of CIDRs that should not be included within an IP Block Valid examples are \"192.168.1.1/24\" or \"2001:db9::/64\" Except values will be rejected if they are outside the CIDR range",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.networking.v1.Ingress": {
      "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Ingress"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec is the desired state of the Ingress. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.networking.v1.IngressSpec"
        },
        "status": {
          "description": "Status is the current state of the Ingress. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.networking.v1.IngressStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.k8s.io",
          "kind": "Ingress",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.networking.v1.IngressBackend": {
      "description": "IngressBackend describes all endpoints for a given service and port.",
      "type": "object",
      "properties": {
        "resource": {
          "description": "Resource is an ObjectRef to another Kubernetes resource in the namespace of the Ingress object. If resource is specified, a service.Name and service.Port must not be specified. This is a mutually exclusive setting with \"Service\".",
          "$ref": "#/definitions/io.k8s.api.core.v1.TypedLocalObjectReference"
        },
        "service": {
          "description": "Service references a Service as a Backend. This is a mutually exclusive setting with \"Resource\".",
          "$ref": "#/definitions/io.k8s.api.networking.v1.IngressServiceBackend"
        }
      }
    },
    "io.k8s.api.networking.v1.IngressClass": {
      "description": "IngressClass represents the class of the Ingress, referenced by the Ingress Spec. The `ingressclass.kubernetes.io/is-default-class` annotation can be used to indicate that an IngressClass should be considered default. When a single IngressClass resource has this annotation set to true, new Ingress resources without a class specified will be assigned this default class.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IngressClass"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec is the desired state of the IngressClass. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "$ref": "#/definitions/io.k8s.api.networking.v1.IngressClassSpec"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.k8s.io",
          "kind": "IngressClass",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.networking.v1.IngressClassList": {
      "description": "IngressClassList is a collection of IngressClasses.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.k8s.io/v1"]
        },
        "items": {
          "description": "Items is the list of IngressClasses.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.networking.v1.IngressClass"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IngressClassList"]
        },
        "metadata": {
          "description": "Standard list metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.k8s.io",
          "kind": "IngressClassList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.networking.v1.IngressClassParametersReference": {
      "description": "IngressClassParametersReference identifies an API object. This can be used to specify a cluster or namespace-scoped resource.",
      "type": "object",
      "required": ["kind", "name"],
      "properties": {
        "apiGroup": {
          "description": "APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.",
          "type": "string"
        },
        "kind": {
          "description": "Kind is the type of resource being referenced.",
          "type": "string"
        },
        "name": {
          "description": "Name is the name of resource being referenced.",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace is the namespace of the resource being referenced. This field is required when scope is set to \"Namespace\" and must be unset when scope is set to \"Cluster\".",
          "type": "string"
        },
        "scope": {
          "description": "Scope represents if this refers to a cluster or namespace scoped resource. This may be set to \"Cluster\" (default) or \"Namespace\". Field can be enabled with IngressClassNamespacedParams feature gate.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.networking.v1.IngressClassSpec": {
      "description": "IngressClassSpec provides information about the class of an Ingress.",
      "type": "object",
      "properties": {
        "controller": {
          "description": "Controller refers to the name of the controller that should handle this class. This allows for different \"flavors\" that are controlled by the same controller. For example, you may have different Parameters for the same implementing controller. This should be specified as a domain-prefixed path no more than 250 characters in length, e.g. \"acme.io/ingress-controller\". This field is immutable.",
          "type": "string"
        },
        "parameters": {
          "description": "Parameters is a link to a custom resource containing additional configuration for the controller. This is optional if the controller does not require extra parameters.",
          "$ref": "#/definitions/io.k8s.api.networking.v1.IngressClassParametersReference"
        }
      }
    },
    "io.k8s.api.networking.v1.IngressList": {
      "description": "IngressList is a collection of Ingress.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.k8s.io/v1"]
        },
        "items": {
          "description": "Items is the list of Ingress.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.networking.v1.Ingress"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["IngressList"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.k8s.io",
          "kind": "IngressList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.networking.v1.IngressRule": {
      "description": "IngressRule represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching IngressRuleValue.",
      "type": "object",
      "properties": {
        "host": {
          "description": "Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \"host\" part of the URI as defined in RFC 3986: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to\n   the IP in the Spec of the parent Ingress.\n2. The `:` delimiter is not respected because ports are not allowed.\n\t  Currently the port of an Ingress is implicitly :80 for http and\n\t  :443 for https.\nBoth these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue.\n\nHost can be \"precise\" which is a domain name without the terminating dot of a network host (e.g. \"foo.bar.com\") or \"wildcard\", which is a domain name prefixed with a single wildcard label (e.g. \"*.foo.com\"). The wildcard character '*' must appear by itself as the first DNS label and matches only a single label. You cannot have a wildcard label by itself (e.g. Host == \"*\"). Requests will be matched against the Host field in the following way: 1. If Host is precise, the request matches this rule if the http host header is equal to Host. 2. If Host is a wildcard, then the request matches this rule if the http host header is to equal to the suffix (removing the first label) of the wildcard rule.",
          "type": "string"
        },
        "http": {
          "$ref": "#/definitions/io.k8s.api.networking.v1.HTTPIngressRuleValue"
        }
      }
    },
    "io.k8s.api.networking.v1.IngressServiceBackend": {
      "description": "IngressServiceBackend references a Kubernetes Service as a Backend.",
      "type": "object",
      "required": ["name"],
      "properties": {
        "name": {
          "description": "Name is the referenced service. The service must exist in the same namespace as the Ingress object.",
          "type": "string"
        },
        "port": {
          "description": "Port of the referenced service. A port name or port number is required for a IngressServiceBackend.",
          "$ref": "#/definitions/io.k8s.api.networking.v1.ServiceBackendPort"
        }
      }
    },
    "io.k8s.api.networking.v1.IngressSpec": {
      "description": "IngressSpec describes the Ingress the user wishes to exist.",
      "type": "object",
      "properties": {
        "defaultBackend": {
          "description": "DefaultBackend is the backend that should handle requests that don't match any rule. If Rules are not specified, DefaultBackend must be specified. If DefaultBackend is not set, the handling of requests that do not match any of the rules will be up to the Ingress controller.",
          "$ref": "#/definitions/io.k8s.api.networking.v1.IngressBackend"
        },
        "ingressClassName": {
          "description": "IngressClassName is the name of the IngressClass cluster resource. The associated IngressClass defines which controller will implement the resource. This replaces the deprecated `kubernetes.io/ingress.class` annotation. For backwards compatibility, when that annotation is set, it must be given precedence over this field. The controller may emit a warning if the field and annotation have different values. Implementations of this API should ignore Ingresses without a class specified. An IngressClass resource may be marked as default, which can be used to set a default value for this field. For more information, refer to the IngressClass documentation.",
          "type": "string"
        },
        "rules": {
          "description": "A list of host rules used to configure the Ingress. If unspecified, or no rule matches, all traffic is sent to the default backend.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.networking.v1.IngressRule"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "tls": {
          "description": "TLS configuration. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.networking.v1.IngressTLS"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "io.k8s.api.networking.v1.IngressStatus": {
      "description": "IngressStatus describe the current state of the Ingress.",
      "type": "object",
      "properties": {
        "loadBalancer": {
          "description": "LoadBalancer contains the current status of the load-balancer.",
          "$ref": "#/definitions/io.k8s.api.core.v1.LoadBalancerStatus"
        }
      }
    },
    "io.k8s.api.networking.v1.IngressTLS": {
      "description": "IngressTLS describes the transport layer security associated with an Ingress.",
      "type": "object",
      "properties": {
        "hosts": {
          "description": "Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the tlsSecret. Defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress, if left unspecified.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "secretName": {
          "description": "SecretName is the name of the secret used to terminate TLS traffic on port 443. Field is left optional to allow TLS routing based on SNI hostname alone. If the SNI host in a listener conflicts with the \"Host\" header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.networking.v1.NetworkPolicy": {
      "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Specification of the desired behavior for this NetworkPolicy.",
          "$ref": "#/definitions/io.k8s.api.networking.v1.NetworkPolicySpec"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.k8s.io",
          "kind": "NetworkPolicy",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.networking.v1.NetworkPolicyEgressRule": {
      "description": "NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to. This type is beta-level in 1.8",
      "type": "object",
      "properties": {
        "ports": {
          "description": "List of destination ports for outgoing traffic. Each item in this list is combined using a logical OR. If this field is empty or missing, this rule matches all ports (traffic not restricted by port). If this field is present and contains at least one item, then this rule allows traffic only if the traffic matches at least one port in the list.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.networking.v1.NetworkPolicyPort"
          }
        },
        "to": {
          "description": "List of destinations for outgoing traffic of pods selected for this rule. Items in this list are combined using a logical OR operation. If this field is empty or missing, this rule matches all destinations (traffic not restricted by destination). If this field is present and contains at least one item, this rule allows traffic only if the traffic matches at least one item in the to list.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.networking.v1.NetworkPolicyPeer"
          }
        }
      }
    },
    "io.k8s.api.networking.v1.NetworkPolicyIngressRule": {
      "description": "NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from.",
      "type": "object",
      "properties": {
        "from": {
          "description": "List of sources which should be able to access the pods selected for this rule. Items in this list are combined using a logical OR operation. If this field is empty or missing, this rule matches all sources (traffic not restricted by source). If this field is present and contains at least one item, this rule allows traffic only if the traffic matches at least one item in the from list.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.networking.v1.NetworkPolicyPeer"
          }
        },
        "ports": {
          "description": "List of ports which should be made accessible on the pods selected for this rule. Each item in this list is combined using a logical OR. If this field is empty or missing, this rule matches all ports (traffic not restricted by port). If this field is present and contains at least one item, then this rule allows traffic only if the traffic matches at least one port in the list.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.networking.v1.NetworkPolicyPort"
          }
        }
      }
    },
    "io.k8s.api.networking.v1.NetworkPolicyList": {
      "description": "NetworkPolicyList is a list of NetworkPolicy objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["networking.k8s.io/v1"]
        },
        "items": {
          "description": "Items is a list of schema objects.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.networking.v1.NetworkPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NetworkPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "networking.k8s.io",
          "kind": "NetworkPolicyList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.networking.v1.NetworkPolicyPeer": {
      "description": "NetworkPolicyPeer describes a peer to allow traffic to/from. Only certain combinations of fields are allowed",
      "type": "object",
      "properties": {
        "ipBlock": {
          "description": "IPBlock defines policy on a particular IPBlock. If this field is set then neither of the other fields can be.",
          "$ref": "#/definitions/io.k8s.api.networking.v1.IPBlock"
        },
        "namespaceSelector": {
          "description": "Selects Namespaces using cluster-scoped labels. This field follows standard label selector semantics; if present but empty, it selects all namespaces.\n\nIf PodSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods matching PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "podSelector": {
          "description": "This is a label selector which selects Pods. This field follows standard label selector semantics; if present but empty, it selects all pods.\n\nIf NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods matching PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        }
      }
    },
    "io.k8s.api.networking.v1.NetworkPolicyPort": {
      "description": "NetworkPolicyPort describes a port to allow traffic on",
      "type": "object",
      "properties": {
        "endPort": {
          "description": "If set, indicates that the range of ports from port to endPort, inclusive, should be allowed by the policy. This field cannot be defined if the port field is not defined or if the port field is defined as a named (string) port. The endPort must be equal or greater than port. This feature is in Beta state and is enabled by default. It can be disabled using the Feature Gate \"NetworkPolicyEndPort\".",
          "type": "integer",
          "format": "int32"
        },
        "port": {
          "description": "The port on the given protocol. This can either be a numerical or named port on a pod. If this field is not provided, this matches all port names and numbers. If present, only traffic on the specified protocol AND port will be matched.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
        },
        "protocol": {
          "description": "The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this field defaults to TCP.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.networking.v1.NetworkPolicySpec": {
      "description": "NetworkPolicySpec provides the specification of a NetworkPolicy",
      "type": "object",
      "required": ["podSelector"],
      "properties": {
        "egress": {
          "description": "List of egress rules to be applied to the selected pods. Outgoing traffic is allowed if there are no NetworkPolicies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic matches at least one egress rule across all of the NetworkPolicy objects whose podSelector matches the pod. If this field is empty then this NetworkPolicy limits all outgoing traffic (and serves solely to ensure that the pods it selects are isolated by default). This field is beta-level in 1.8",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.networking.v1.NetworkPolicyEgressRule"
          }
        },
        "ingress": {
          "description": "List of ingress rules to be applied to the selected pods. Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod (and cluster policy otherwise allows the traffic), OR if the traffic source is the pod's local node, OR if the traffic matches at least one ingress rule across all of the NetworkPolicy objects whose podSelector matches the pod. If this field is empty then this NetworkPolicy does not allow any traffic (and serves solely to ensure that the pods it selects are isolated by default)",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.networking.v1.NetworkPolicyIngressRule"
          }
        },
        "podSelector": {
          "description": "Selects the pods to which this NetworkPolicy object applies. The array of ingress rules is applied to any pods selected by this field. Multiple network policies can select the same set of pods. In this case, the ingress rules for each are combined additively. This field is NOT optional and follows standard label selector semantics. An empty podSelector matches all pods in this namespace.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "policyTypes": {
          "description": "List of rule types that the NetworkPolicy relates to. Valid options are [\"Ingress\"], [\"Egress\"], or [\"Ingress\", \"Egress\"]. If this field is not specified, it will default based on the existence of Ingress or Egress rules; policies that contain an Egress section are assumed to affect Egress, and all policies (whether or not they contain an Ingress section) are assumed to affect Ingress. If you want to write an egress-only policy, you must explicitly specify policyTypes [ \"Egress\" ]. Likewise, if you want to write a policy that specifies that no egress is allowed, you must specify a policyTypes value that include \"Egress\" (since such a policy would not include an Egress section and would otherwise default to just [ \"Ingress\" ]). This field is beta-level in 1.8",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.networking.v1.ServiceBackendPort": {
      "description": "ServiceBackendPort is the service port being referenced.",
      "type": "object",
      "properties": {
        "name": {
          "description": "Name is the name of the port on the Service. This is a mutually exclusive setting with \"Number\".",
          "type": "string"
        },
        "number": {
          "description": "Number is the numerical port number (e.g. 80) on the Service. This is a mutually exclusive setting with \"Name\".",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.node.v1.Overhead": {
      "description": "Overhead structure represents the resource overhead associated with running a pod.",
      "type": "object",
      "properties": {
        "podFixed": {
          "description": "PodFixed represents the fixed resource overhead associated with running a pod.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          }
        }
      }
    },
    "io.k8s.api.node.v1.RuntimeClass": {
      "description": "RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass is used to determine which container runtime is used to run all containers in a pod. RuntimeClasses are manually defined by a user or cluster provisioner, and referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName reference before running the pod.  For more details, see https://kubernetes.io/docs/concepts/containers/runtime-class/",
      "type": "object",
      "required": ["handler"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["node.k8s.io/v1"]
        },
        "handler": {
          "description": "Handler specifies the underlying runtime and configuration that the CRI implementation will use to handle pods of this class. The possible values are specific to the node & CRI configuration.  It is assumed that all handlers are available on every node, and handlers of the same name are equivalent on every node. For example, a handler called \"runc\" might specify that the runc OCI runtime (using native Linux containers) will be used to run the containers in a pod. The Handler must be lowercase, conform to the DNS Label (RFC 1123) requirements, and is immutable.",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["RuntimeClass"]
        },
        "metadata": {
          "description": "More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "overhead": {
          "description": "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. For more details, see\n https://kubernetes.io/docs/concepts/scheduling-eviction/pod-overhead/\nThis field is in beta starting v1.18 and is only honored by servers that enable the PodOverhead feature.",
          "$ref": "#/definitions/io.k8s.api.node.v1.Overhead"
        },
        "scheduling": {
          "description": "Scheduling holds the scheduling constraints to ensure that pods running with this RuntimeClass are scheduled to nodes that support it. If scheduling is nil, this RuntimeClass is assumed to be supported by all nodes.",
          "$ref": "#/definitions/io.k8s.api.node.v1.Scheduling"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "node.k8s.io",
          "kind": "RuntimeClass",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.node.v1.RuntimeClassList": {
      "description": "RuntimeClassList is a list of RuntimeClass objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["node.k8s.io/v1"]
        },
        "items": {
          "description": "Items is a list of schema objects.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.node.v1.RuntimeClass"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["RuntimeClassList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "node.k8s.io",
          "kind": "RuntimeClassList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.node.v1.Scheduling": {
      "description": "Scheduling specifies the scheduling constraints for nodes supporting a RuntimeClass.",
      "type": "object",
      "properties": {
        "nodeSelector": {
          "description": "nodeSelector lists labels that must be present on nodes that support this RuntimeClass. Pods using this RuntimeClass can only be scheduled to a node matched by this selector. The RuntimeClass nodeSelector is merged with a pod's existing nodeSelector. Any conflicts will cause the pod to be rejected in admission.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "x-kubernetes-map-type": "atomic"
        },
        "tolerations": {
          "description": "tolerations are appended (excluding duplicates) to pods running with this RuntimeClass during admission, effectively unioning the set of nodes tolerated by the pod and the RuntimeClass.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "io.k8s.api.node.v1beta1.Overhead": {
      "description": "Overhead structure represents the resource overhead associated with running a pod.",
      "type": "object",
      "properties": {
        "podFixed": {
          "description": "PodFixed represents the fixed resource overhead associated with running a pod.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          }
        }
      }
    },
    "io.k8s.api.node.v1beta1.RuntimeClass": {
      "description": "RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass is used to determine which container runtime is used to run all containers in a pod. RuntimeClasses are (currently) manually defined by a user or cluster provisioner, and referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName reference before running the pod.  For more details, see https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
      "type": "object",
      "required": ["handler"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["node.k8s.io/v1beta1"]
        },
        "handler": {
          "description": "Handler specifies the underlying runtime and configuration that the CRI implementation will use to handle pods of this class. The possible values are specific to the node & CRI configuration.  It is assumed that all handlers are available on every node, and handlers of the same name are equivalent on every node. For example, a handler called \"runc\" might specify that the runc OCI runtime (using native Linux containers) will be used to run the containers in a pod. The Handler must be lowercase, conform to the DNS Label (RFC 1123) requirements, and is immutable.",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["RuntimeClass"]
        },
        "metadata": {
          "description": "More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "overhead": {
          "description": "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. For more details, see https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md This field is beta-level as of Kubernetes v1.18, and is only honored by servers that enable the PodOverhead feature.",
          "$ref": "#/definitions/io.k8s.api.node.v1beta1.Overhead"
        },
        "scheduling": {
          "description": "Scheduling holds the scheduling constraints to ensure that pods running with this RuntimeClass are scheduled to nodes that support it. If scheduling is nil, this RuntimeClass is assumed to be supported by all nodes.",
          "$ref": "#/definitions/io.k8s.api.node.v1beta1.Scheduling"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "node.k8s.io",
          "kind": "RuntimeClass",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.api.node.v1beta1.RuntimeClassList": {
      "description": "RuntimeClassList is a list of RuntimeClass objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["node.k8s.io/v1beta1"]
        },
        "items": {
          "description": "Items is a list of schema objects.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.node.v1beta1.RuntimeClass"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["RuntimeClassList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "node.k8s.io",
          "kind": "RuntimeClassList",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.api.node.v1beta1.Scheduling": {
      "description": "Scheduling specifies the scheduling constraints for nodes supporting a RuntimeClass.",
      "type": "object",
      "properties": {
        "nodeSelector": {
          "description": "nodeSelector lists labels that must be present on nodes that support this RuntimeClass. Pods using this RuntimeClass can only be scheduled to a node matched by this selector. The RuntimeClass nodeSelector is merged with a pod's existing nodeSelector. Any conflicts will cause the pod to be rejected in admission.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "x-kubernetes-map-type": "atomic"
        },
        "tolerations": {
          "description": "tolerations are appended (excluding duplicates) to pods running with this RuntimeClass during admission, effectively unioning the set of nodes tolerated by the pod and the RuntimeClass.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "io.k8s.api.policy.v1.Eviction": {
      "description": "Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["policy/v1"]
        },
        "deleteOptions": {
          "description": "DeleteOptions may be provided",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Eviction"]
        },
        "metadata": {
          "description": "ObjectMeta describes the pod that is being evicted.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "policy",
          "kind": "Eviction",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.policy.v1.PodDisruptionBudget": {
      "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["policy/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PodDisruptionBudget"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Specification of the desired behavior of the PodDisruptionBudget.",
          "$ref": "#/definitions/io.k8s.api.policy.v1.PodDisruptionBudgetSpec"
        },
        "status": {
          "description": "Most recently observed status of the PodDisruptionBudget.",
          "$ref": "#/definitions/io.k8s.api.policy.v1.PodDisruptionBudgetStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "policy",
          "kind": "PodDisruptionBudget",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.policy.v1.PodDisruptionBudgetList": {
      "description": "PodDisruptionBudgetList is a collection of PodDisruptionBudgets.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["policy/v1"]
        },
        "items": {
          "description": "Items is a list of PodDisruptionBudgets",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.policy.v1.PodDisruptionBudget"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PodDisruptionBudgetList"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "policy",
          "kind": "PodDisruptionBudgetList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.policy.v1.PodDisruptionBudgetSpec": {
      "description": "PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.",
      "type": "object",
      "properties": {
        "maxUnavailable": {
          "description": "An eviction is allowed if at most \"maxUnavailable\" pods selected by \"selector\" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with \"minAvailable\".",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
        },
        "minAvailable": {
          "description": "An eviction is allowed if at least \"minAvailable\" pods selected by \"selector\" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying \"100%\".",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
        },
        "selector": {
          "description": "Label query over pods whose evictions are managed by the disruption budget. A null selector will match no pods, while an empty ({}) selector will select all pods within the namespace.",
          "x-kubernetes-patch-strategy": "replace",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        }
      }
    },
    "io.k8s.api.policy.v1.PodDisruptionBudgetStatus": {
      "description": "PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget. Status may trail the actual state of a system.",
      "type": "object",
      "required": [
        "disruptionsAllowed",
        "currentHealthy",
        "desiredHealthy",
        "expectedPods"
      ],
      "properties": {
        "conditions": {
          "description": "Conditions contain conditions for PDB. The disruption controller sets the DisruptionAllowed condition. The following are known values for the reason field (additional reasons could be added in the future): - SyncFailed: The controller encountered an error and wasn't able to compute\n              the number of allowed disruptions. Therefore no disruptions are\n              allowed and the status of the condition will be False.\n- InsufficientPods: The number of pods are either at or below the number\n                    required by the PodDisruptionBudget. No disruptions are\n                    allowed and the status of the condition will be False.\n- SufficientPods: There are more pods than required by the PodDisruptionBudget.\n                  The condition will be True, and the number of allowed\n                  disruptions are provided by the disruptionsAllowed property.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Condition"
          },
          "x-kubernetes-list-map-keys": ["type"],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        },
        "currentHealthy": {
          "description": "current number of healthy pods",
          "type": "integer",
          "format": "int32"
        },
        "desiredHealthy": {
          "description": "minimum desired number of healthy pods",
          "type": "integer",
          "format": "int32"
        },
        "disruptedPods": {
          "description": "DisruptedPods contains information about pods whose eviction was processed by the API server eviction subresource handler but has not yet been observed by the PodDisruptionBudget controller. A pod will be in this map from the time when the API server processed the eviction request to the time when the pod is seen by PDB controller as having been marked for deletion (or after a timeout). The key in the map is the name of the pod and the value is the time when the API server processed the eviction request. If the deletion didn't occur and a pod is still there it will be removed from the list automatically by PodDisruptionBudget controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod deletions.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
          }
        },
        "disruptionsAllowed": {
          "description": "Number of pod disruptions that are currently allowed.",
          "type": "integer",
          "format": "int32"
        },
        "expectedPods": {
          "description": "total number of pods counted by this disruption budget",
          "type": "integer",
          "format": "int32"
        },
        "observedGeneration": {
          "description": "Most recent generation observed when updating this PDB status. DisruptionsAllowed and other status information is valid only if observedGeneration equals to PDB's object generation.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "io.k8s.api.policy.v1beta1.AllowedCSIDriver": {
      "description": "AllowedCSIDriver represents a single inline CSI Driver that is allowed to be used.",
      "type": "object",
      "required": ["name"],
      "properties": {
        "name": {
          "description": "Name is the registered name of the CSI driver",
          "type": "string"
        }
      }
    },
    "io.k8s.api.policy.v1beta1.AllowedFlexVolume": {
      "description": "AllowedFlexVolume represents a single Flexvolume that is allowed to be used.",
      "type": "object",
      "required": ["driver"],
      "properties": {
        "driver": {
          "description": "driver is the name of the Flexvolume driver.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.policy.v1beta1.AllowedHostPath": {
      "description": "AllowedHostPath defines the host volume conditions that will be enabled by a policy for pods to use. It requires the path prefix to be defined.",
      "type": "object",
      "properties": {
        "pathPrefix": {
          "description": "pathPrefix is the path prefix that the host volume must match. It does not support `*`. Trailing slashes are trimmed when validating the path prefix with a host path.\n\nExamples: `/foo` would allow `/foo`, `/foo/` and `/foo/bar` `/foo` would not allow `/food` or `/etc/foo`",
          "type": "string"
        },
        "readOnly": {
          "description": "when set to true, will allow host volumes matching the pathPrefix only if all volume mounts are readOnly.",
          "type": "boolean"
        }
      }
    },
    "io.k8s.api.policy.v1beta1.FSGroupStrategyOptions": {
      "description": "FSGroupStrategyOptions defines the strategy type and options used to create the strategy.",
      "type": "object",
      "properties": {
        "ranges": {
          "description": "ranges are the allowed ranges of fs groups.  If you would like to force a single fs group then supply a single range with the same start and end. Required for MustRunAs.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.policy.v1beta1.IDRange"
          }
        },
        "rule": {
          "description": "rule is the strategy that will dictate what FSGroup is used in the SecurityContext.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.policy.v1beta1.HostPortRange": {
      "description": "HostPortRange defines a range of host ports that will be enabled by a policy for pods to use.  It requires both the start and end to be defined.",
      "type": "object",
      "required": ["min", "max"],
      "properties": {
        "max": {
          "description": "max is the end of the range, inclusive.",
          "type": "integer",
          "format": "int32"
        },
        "min": {
          "description": "min is the start of the range, inclusive.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.policy.v1beta1.IDRange": {
      "description": "IDRange provides a min/max of an allowed range of IDs.",
      "type": "object",
      "required": ["min", "max"],
      "properties": {
        "max": {
          "description": "max is the end of the range, inclusive.",
          "type": "integer",
          "format": "int64"
        },
        "min": {
          "description": "min is the start of the range, inclusive.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "io.k8s.api.policy.v1beta1.PodDisruptionBudget": {
      "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["policy/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PodDisruptionBudget"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Specification of the desired behavior of the PodDisruptionBudget.",
          "$ref": "#/definitions/io.k8s.api.policy.v1beta1.PodDisruptionBudgetSpec"
        },
        "status": {
          "description": "Most recently observed status of the PodDisruptionBudget.",
          "$ref": "#/definitions/io.k8s.api.policy.v1beta1.PodDisruptionBudgetStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "policy",
          "kind": "PodDisruptionBudget",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.api.policy.v1beta1.PodDisruptionBudgetList": {
      "description": "PodDisruptionBudgetList is a collection of PodDisruptionBudgets.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["policy/v1beta1"]
        },
        "items": {
          "description": "items list individual PodDisruptionBudget objects",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.policy.v1beta1.PodDisruptionBudget"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PodDisruptionBudgetList"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "policy",
          "kind": "PodDisruptionBudgetList",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.api.policy.v1beta1.PodDisruptionBudgetSpec": {
      "description": "PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.",
      "type": "object",
      "properties": {
        "maxUnavailable": {
          "description": "An eviction is allowed if at most \"maxUnavailable\" pods selected by \"selector\" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with \"minAvailable\".",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
        },
        "minAvailable": {
          "description": "An eviction is allowed if at least \"minAvailable\" pods selected by \"selector\" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying \"100%\".",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
        },
        "selector": {
          "description": "Label query over pods whose evictions are managed by the disruption budget. A null selector selects no pods. An empty selector ({}) also selects no pods, which differs from standard behavior of selecting all pods. In policy/v1, an empty selector will select all pods in the namespace.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        }
      }
    },
    "io.k8s.api.policy.v1beta1.PodDisruptionBudgetStatus": {
      "description": "PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget. Status may trail the actual state of a system.",
      "type": "object",
      "required": [
        "disruptionsAllowed",
        "currentHealthy",
        "desiredHealthy",
        "expectedPods"
      ],
      "properties": {
        "conditions": {
          "description": "Conditions contain conditions for PDB. The disruption controller sets the DisruptionAllowed condition. The following are known values for the reason field (additional reasons could be added in the future): - SyncFailed: The controller encountered an error and wasn't able to compute\n              the number of allowed disruptions. Therefore no disruptions are\n              allowed and the status of the condition will be False.\n- InsufficientPods: The number of pods are either at or below the number\n                    required by the PodDisruptionBudget. No disruptions are\n                    allowed and the status of the condition will be False.\n- SufficientPods: There are more pods than required by the PodDisruptionBudget.\n                  The condition will be True, and the number of allowed\n                  disruptions are provided by the disruptionsAllowed property.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Condition"
          },
          "x-kubernetes-list-map-keys": ["type"],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        },
        "currentHealthy": {
          "description": "current number of healthy pods",
          "type": "integer",
          "format": "int32"
        },
        "desiredHealthy": {
          "description": "minimum desired number of healthy pods",
          "type": "integer",
          "format": "int32"
        },
        "disruptedPods": {
          "description": "DisruptedPods contains information about pods whose eviction was processed by the API server eviction subresource handler but has not yet been observed by the PodDisruptionBudget controller. A pod will be in this map from the time when the API server processed the eviction request to the time when the pod is seen by PDB controller as having been marked for deletion (or after a timeout). The key in the map is the name of the pod and the value is the time when the API server processed the eviction request. If the deletion didn't occur and a pod is still there it will be removed from the list automatically by PodDisruptionBudget controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod deletions.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
          }
        },
        "disruptionsAllowed": {
          "description": "Number of pod disruptions that are currently allowed.",
          "type": "integer",
          "format": "int32"
        },
        "expectedPods": {
          "description": "total number of pods counted by this disruption budget",
          "type": "integer",
          "format": "int32"
        },
        "observedGeneration": {
          "description": "Most recent generation observed when updating this PDB status. DisruptionsAllowed and other status information is valid only if observedGeneration equals to PDB's object generation.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "io.k8s.api.policy.v1beta1.PodSecurityPolicy": {
      "description": "PodSecurityPolicy governs the ability to make requests that affect the Security Context that will be applied to a pod and container. Deprecated in 1.21.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["policy/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PodSecurityPolicy"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "spec defines the policy enforced.",
          "$ref": "#/definitions/io.k8s.api.policy.v1beta1.PodSecurityPolicySpec"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "policy",
          "kind": "PodSecurityPolicy",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.api.policy.v1beta1.PodSecurityPolicyList": {
      "description": "PodSecurityPolicyList is a list of PodSecurityPolicy objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["policy/v1beta1"]
        },
        "items": {
          "description": "items is a list of schema objects.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.policy.v1beta1.PodSecurityPolicy"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PodSecurityPolicyList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "policy",
          "kind": "PodSecurityPolicyList",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.api.policy.v1beta1.PodSecurityPolicySpec": {
      "description": "PodSecurityPolicySpec defines the policy enforced.",
      "type": "object",
      "required": ["seLinux", "runAsUser", "supplementalGroups", "fsGroup"],
      "properties": {
        "allowPrivilegeEscalation": {
          "description": "allowPrivilegeEscalation determines if a pod can request to allow privilege escalation. If unspecified, defaults to true.",
          "type": "boolean"
        },
        "allowedCSIDrivers": {
          "description": "AllowedCSIDrivers is an allowlist of inline CSI drivers that must be explicitly set to be embedded within a pod spec. An empty value indicates that any CSI driver can be used for inline ephemeral volumes. This is a beta field, and is only honored if the API server enables the CSIInlineVolume feature gate.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.policy.v1beta1.AllowedCSIDriver"
          }
        },
        "allowedCapabilities": {
          "description": "allowedCapabilities is a list of capabilities that can be requested to add to the container. Capabilities in this field may be added at the pod author's discretion. You must not list a capability in both allowedCapabilities and requiredDropCapabilities.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "allowedFlexVolumes": {
          "description": "allowedFlexVolumes is an allowlist of Flexvolumes.  Empty or nil indicates that all Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes is allowed in the \"volumes\" field.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.policy.v1beta1.AllowedFlexVolume"
          }
        },
        "allowedHostPaths": {
          "description": "allowedHostPaths is an allowlist of host paths. Empty indicates that all host paths may be used.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.policy.v1beta1.AllowedHostPath"
          }
        },
        "allowedProcMountTypes": {
          "description": "AllowedProcMountTypes is an allowlist of allowed ProcMountTypes. Empty or nil indicates that only the DefaultProcMountType may be used. This requires the ProcMountType feature flag to be enabled.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "allowedUnsafeSysctls": {
          "description": "allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none. Each entry is either a plain sysctl name or ends in \"*\" in which case it is considered as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed. Kubelet has to allowlist all allowed unsafe sysctls explicitly to avoid rejection.\n\nExamples: e.g. \"foo/*\" allows \"foo/bar\", \"foo/baz\", etc. e.g. \"foo.*\" allows \"foo.bar\", \"foo.baz\", etc.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "defaultAddCapabilities": {
          "description": "defaultAddCapabilities is the default set of capabilities that will be added to the container unless the pod spec specifically drops the capability.  You may not list a capability in both defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly allowed, and need not be included in the allowedCapabilities list.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "defaultAllowPrivilegeEscalation": {
          "description": "defaultAllowPrivilegeEscalation controls the default setting for whether a process can gain more privileges than its parent process.",
          "type": "boolean"
        },
        "forbiddenSysctls": {
          "description": "forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none. Each entry is either a plain sysctl name or ends in \"*\" in which case it is considered as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.\n\nExamples: e.g. \"foo/*\" forbids \"foo/bar\", \"foo/baz\", etc. e.g. \"foo.*\" forbids \"foo.bar\", \"foo.baz\", etc.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "fsGroup": {
          "description": "fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.",
          "$ref": "#/definitions/io.k8s.api.policy.v1beta1.FSGroupStrategyOptions"
        },
        "hostIPC": {
          "description": "hostIPC determines if the policy allows the use of HostIPC in the pod spec.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.",
          "type": "boolean"
        },
        "hostPID": {
          "description": "hostPID determines if the policy allows the use of HostPID in the pod spec.",
          "type": "boolean"
        },
        "hostPorts": {
          "description": "hostPorts determines which host port ranges are allowed to be exposed.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.policy.v1beta1.HostPortRange"
          }
        },
        "privileged": {
          "description": "privileged determines if a pod can request to be run as privileged.",
          "type": "boolean"
        },
        "readOnlyRootFilesystem": {
          "description": "readOnlyRootFilesystem when set to true will force containers to run with a read only root file system.  If the container specifically requests to run with a non-read only root file system the PSP should deny the pod. If set to false the container may run with a read only root file system if it wishes but it will not be forced to.",
          "type": "boolean"
        },
        "requiredDropCapabilities": {
          "description": "requiredDropCapabilities are the capabilities that will be dropped from the container.  These are required to be dropped and cannot be added.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "runAsGroup": {
          "description": "RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set. If this field is omitted, the pod's RunAsGroup can take any value. This field requires the RunAsGroup feature gate to be enabled.",
          "$ref": "#/definitions/io.k8s.api.policy.v1beta1.RunAsGroupStrategyOptions"
        },
        "runAsUser": {
          "description": "runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.",
          "$ref": "#/definitions/io.k8s.api.policy.v1beta1.RunAsUserStrategyOptions"
        },
        "runtimeClass": {
          "description": "runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod. If this field is omitted, the pod's runtimeClassName field is unrestricted. Enforcement of this field depends on the RuntimeClass feature gate being enabled.",
          "$ref": "#/definitions/io.k8s.api.policy.v1beta1.RuntimeClassStrategyOptions"
        },
        "seLinux": {
          "description": "seLinux is the strategy that will dictate the allowable labels that may be set.",
          "$ref": "#/definitions/io.k8s.api.policy.v1beta1.SELinuxStrategyOptions"
        },
        "supplementalGroups": {
          "description": "supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.",
          "$ref": "#/definitions/io.k8s.api.policy.v1beta1.SupplementalGroupsStrategyOptions"
        },
        "volumes": {
          "description": "volumes is an allowlist of volume plugins. Empty indicates that no volumes may be used. To allow all volumes you may use '*'.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.policy.v1beta1.RunAsGroupStrategyOptions": {
      "description": "RunAsGroupStrategyOptions defines the strategy type and any options used to create the strategy.",
      "type": "object",
      "required": ["rule"],
      "properties": {
        "ranges": {
          "description": "ranges are the allowed ranges of gids that may be used. If you would like to force a single gid then supply a single range with the same start and end. Required for MustRunAs.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.policy.v1beta1.IDRange"
          }
        },
        "rule": {
          "description": "rule is the strategy that will dictate the allowable RunAsGroup values that may be set.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.policy.v1beta1.RunAsUserStrategyOptions": {
      "description": "RunAsUserStrategyOptions defines the strategy type and any options used to create the strategy.",
      "type": "object",
      "required": ["rule"],
      "properties": {
        "ranges": {
          "description": "ranges are the allowed ranges of uids that may be used. If you would like to force a single uid then supply a single range with the same start and end. Required for MustRunAs.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.policy.v1beta1.IDRange"
          }
        },
        "rule": {
          "description": "rule is the strategy that will dictate the allowable RunAsUser values that may be set.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.policy.v1beta1.RuntimeClassStrategyOptions": {
      "description": "RuntimeClassStrategyOptions define the strategy that will dictate the allowable RuntimeClasses for a pod.",
      "type": "object",
      "required": ["allowedRuntimeClassNames"],
      "properties": {
        "allowedRuntimeClassNames": {
          "description": "allowedRuntimeClassNames is an allowlist of RuntimeClass names that may be specified on a pod. A value of \"*\" means that any RuntimeClass name is allowed, and must be the only item in the list. An empty list requires the RuntimeClassName field to be unset.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "defaultRuntimeClassName": {
          "description": "defaultRuntimeClassName is the default RuntimeClassName to set on the pod. The default MUST be allowed by the allowedRuntimeClassNames list. A value of nil does not mutate the Pod.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.policy.v1beta1.SELinuxStrategyOptions": {
      "description": "SELinuxStrategyOptions defines the strategy type and any options used to create the strategy.",
      "type": "object",
      "required": ["rule"],
      "properties": {
        "rule": {
          "description": "rule is the strategy that will dictate the allowable labels that may be set.",
          "type": "string"
        },
        "seLinuxOptions": {
          "description": "seLinuxOptions required to run as; required for MustRunAs More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
          "$ref": "#/definitions/io.k8s.api.core.v1.SELinuxOptions"
        }
      }
    },
    "io.k8s.api.policy.v1beta1.SupplementalGroupsStrategyOptions": {
      "description": "SupplementalGroupsStrategyOptions defines the strategy type and options used to create the strategy.",
      "type": "object",
      "properties": {
        "ranges": {
          "description": "ranges are the allowed ranges of supplemental groups.  If you would like to force a single supplemental group then supply a single range with the same start and end. Required for MustRunAs.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.policy.v1beta1.IDRange"
          }
        },
        "rule": {
          "description": "rule is the strategy that will dictate what supplemental groups is used in the SecurityContext.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.rbac.v1.AggregationRule": {
      "description": "AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole",
      "type": "object",
      "properties": {
        "clusterRoleSelectors": {
          "description": "ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles and create the rules. If any of the selectors match, then the ClusterRole's permissions will be added",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
          }
        }
      }
    },
    "io.k8s.api.rbac.v1.ClusterRole": {
      "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.",
      "type": "object",
      "properties": {
        "aggregationRule": {
          "description": "AggregationRule is an optional field that describes how to build the Rules for this ClusterRole. If AggregationRule is set, then the Rules are controller managed and direct changes to Rules will be stomped by the controller.",
          "$ref": "#/definitions/io.k8s.api.rbac.v1.AggregationRule"
        },
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["rbac.authorization.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ClusterRole"]
        },
        "metadata": {
          "description": "Standard object's metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "rules": {
          "description": "Rules holds all the PolicyRules for this ClusterRole",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.rbac.v1.PolicyRule"
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "rbac.authorization.k8s.io",
          "kind": "ClusterRole",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.rbac.v1.ClusterRoleBinding": {
      "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject.",
      "type": "object",
      "required": ["roleRef"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["rbac.authorization.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ClusterRoleBinding"]
        },
        "metadata": {
          "description": "Standard object's metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "roleRef": {
          "description": "RoleRef can only reference a ClusterRole in the global namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.",
          "$ref": "#/definitions/io.k8s.api.rbac.v1.RoleRef"
        },
        "subjects": {
          "description": "Subjects holds references to the objects the role applies to.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.rbac.v1.Subject"
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "rbac.authorization.k8s.io",
          "kind": "ClusterRoleBinding",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.rbac.v1.ClusterRoleBindingList": {
      "description": "ClusterRoleBindingList is a collection of ClusterRoleBindings",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["rbac.authorization.k8s.io/v1"]
        },
        "items": {
          "description": "Items is a list of ClusterRoleBindings",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.rbac.v1.ClusterRoleBinding"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ClusterRoleBindingList"]
        },
        "metadata": {
          "description": "Standard object's metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "rbac.authorization.k8s.io",
          "kind": "ClusterRoleBindingList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.rbac.v1.ClusterRoleList": {
      "description": "ClusterRoleList is a collection of ClusterRoles",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["rbac.authorization.k8s.io/v1"]
        },
        "items": {
          "description": "Items is a list of ClusterRoles",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.rbac.v1.ClusterRole"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["ClusterRoleList"]
        },
        "metadata": {
          "description": "Standard object's metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "rbac.authorization.k8s.io",
          "kind": "ClusterRoleList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.rbac.v1.PolicyRule": {
      "description": "PolicyRule holds information that describes a policy rule, but does not contain information about who the rule applies to or which namespace the rule applies to.",
      "type": "object",
      "required": ["verbs"],
      "properties": {
        "apiGroups": {
          "description": "APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be allowed.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "nonResourceURLs": {
          "description": "NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding. Rules can either apply to API resources (such as \"pods\" or \"secrets\") or non-resource URL paths (such as \"/api\"),  but not both.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "resourceNames": {
          "description": "ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "resources": {
          "description": "Resources is a list of resources this rule applies to. '*' represents all resources.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "verbs": {
          "description": "Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions contained in this rule. '*' represents all verbs.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.rbac.v1.Role": {
      "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["rbac.authorization.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Role"]
        },
        "metadata": {
          "description": "Standard object's metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "rules": {
          "description": "Rules holds all the PolicyRules for this Role",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.rbac.v1.PolicyRule"
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "rbac.authorization.k8s.io",
          "kind": "Role",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.rbac.v1.RoleBinding": {
      "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace.",
      "type": "object",
      "required": ["roleRef"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["rbac.authorization.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["RoleBinding"]
        },
        "metadata": {
          "description": "Standard object's metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "roleRef": {
          "description": "RoleRef can reference a Role in the current namespace or a ClusterRole in the global namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.",
          "$ref": "#/definitions/io.k8s.api.rbac.v1.RoleRef"
        },
        "subjects": {
          "description": "Subjects holds references to the objects the role applies to.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.rbac.v1.Subject"
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "rbac.authorization.k8s.io",
          "kind": "RoleBinding",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.rbac.v1.RoleBindingList": {
      "description": "RoleBindingList is a collection of RoleBindings",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["rbac.authorization.k8s.io/v1"]
        },
        "items": {
          "description": "Items is a list of RoleBindings",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.rbac.v1.RoleBinding"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["RoleBindingList"]
        },
        "metadata": {
          "description": "Standard object's metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "rbac.authorization.k8s.io",
          "kind": "RoleBindingList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.rbac.v1.RoleList": {
      "description": "RoleList is a collection of Roles",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["rbac.authorization.k8s.io/v1"]
        },
        "items": {
          "description": "Items is a list of Roles",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.rbac.v1.Role"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["RoleList"]
        },
        "metadata": {
          "description": "Standard object's metadata.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "rbac.authorization.k8s.io",
          "kind": "RoleList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.rbac.v1.RoleRef": {
      "description": "RoleRef contains information that points to the role being used",
      "type": "object",
      "required": ["apiGroup", "kind", "name"],
      "properties": {
        "apiGroup": {
          "description": "APIGroup is the group for the resource being referenced",
          "type": "string"
        },
        "kind": {
          "description": "Kind is the type of resource being referenced",
          "type": "string"
        },
        "name": {
          "description": "Name is the name of resource being referenced",
          "type": "string"
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.rbac.v1.Subject": {
      "description": "Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names.",
      "type": "object",
      "required": ["kind", "name"],
      "properties": {
        "apiGroup": {
          "description": "APIGroup holds the API group of the referenced subject. Defaults to \"\" for ServiceAccount subjects. Defaults to \"rbac.authorization.k8s.io\" for User and Group subjects.",
          "type": "string"
        },
        "kind": {
          "description": "Kind of object being referenced. Values defined by this API group are \"User\", \"Group\", and \"ServiceAccount\". If the Authorizer does not recognized the kind value, the Authorizer should report an error.",
          "type": "string"
        },
        "name": {
          "description": "Name of the object being referenced.",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace of the referenced object.  If the object kind is non-namespace, such as \"User\" or \"Group\", and this value is not empty the Authorizer should report an error.",
          "type": "string"
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.scheduling.v1.PriorityClass": {
      "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer.",
      "type": "object",
      "required": ["value"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["scheduling.k8s.io/v1"]
        },
        "description": {
          "description": "description is an arbitrary string that usually provides guidelines on when this priority class should be used.",
          "type": "string"
        },
        "globalDefault": {
          "description": "globalDefault specifies whether this PriorityClass should be considered as the default priority for pods that do not have any priority class. Only one PriorityClass can be marked as `globalDefault`. However, if more than one PriorityClasses exists with their `globalDefault` field set to true, the smallest value of such global default PriorityClasses will be used as the default priority.",
          "type": "boolean"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PriorityClass"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "preemptionPolicy": {
          "description": "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is beta-level, gated by the NonPreemptingPriority feature-gate.",
          "type": "string"
        },
        "value": {
          "description": "The value of this priority class. This is the actual priority that pods receive when they have the name of this class in their pod spec.",
          "type": "integer",
          "format": "int32"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "scheduling.k8s.io",
          "kind": "PriorityClass",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.scheduling.v1.PriorityClassList": {
      "description": "PriorityClassList is a collection of priority classes.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["scheduling.k8s.io/v1"]
        },
        "items": {
          "description": "items is the list of PriorityClasses",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.scheduling.v1.PriorityClass"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PriorityClassList"]
        },
        "metadata": {
          "description": "Standard list metadata More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "scheduling.k8s.io",
          "kind": "PriorityClassList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.storage.v1.CSIDriver": {
      "description": "CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster. Kubernetes attach detach controller uses this object to determine whether attach is required. Kubelet uses this object to determine whether pod information needs to be passed on mount. CSIDriver objects are non-namespaced.",
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CSIDriver"]
        },
        "metadata": {
          "description": "Standard object metadata. metadata.Name indicates the name of the CSI driver that this object refers to; it MUST be the same name returned by the CSI GetPluginName() call for that driver. The driver name must be 63 characters or less, beginning and ending with an alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and alphanumerics between. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Specification of the CSI Driver.",
          "$ref": "#/definitions/io.k8s.api.storage.v1.CSIDriverSpec"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.k8s.io",
          "kind": "CSIDriver",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.storage.v1.CSIDriverList": {
      "description": "CSIDriverList is a collection of CSIDriver objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.k8s.io/v1"]
        },
        "items": {
          "description": "items is the list of CSIDriver",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.storage.v1.CSIDriver"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CSIDriverList"]
        },
        "metadata": {
          "description": "Standard list metadata More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.k8s.io",
          "kind": "CSIDriverList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.storage.v1.CSIDriverSpec": {
      "description": "CSIDriverSpec is the specification of a CSIDriver.",
      "type": "object",
      "properties": {
        "attachRequired": {
          "description": "attachRequired indicates this CSI volume driver requires an attach operation (because it implements the CSI ControllerPublishVolume() method), and that the Kubernetes attach detach controller should call the attach volume interface which checks the volumeattachment status and waits until the volume is attached before proceeding to mounting. The CSI external-attacher coordinates with CSI volume driver and updates the volumeattachment status when the attach operation is complete. If the CSIDriverRegistry feature gate is enabled and the value is specified to false, the attach operation will be skipped. Otherwise the attach operation will be called.\n\nThis field is immutable.",
          "type": "boolean"
        },
        "fsGroupPolicy": {
          "description": "Defines if the underlying volume supports changing ownership and permission of the volume before being mounted. Refer to the specific FSGroupPolicy values for additional details. This field is beta, and is only honored by servers that enable the CSIVolumeFSGroupPolicy feature gate.\n\nThis field is immutable.\n\nDefaults to ReadWriteOnceWithFSType, which will examine each volume to determine if Kubernetes should modify ownership and permissions of the volume. With the default policy the defined fsGroup will only be applied if a fstype is defined and the volume's access mode contains ReadWriteOnce.",
          "type": "string"
        },
        "podInfoOnMount": {
          "description": "If set to true, podInfoOnMount indicates this CSI volume driver requires additional pod information (like podName, podUID, etc.) during mount operations. If set to false, pod information will not be passed on mount. Default is false. The CSI driver specifies podInfoOnMount as part of driver deployment. If true, Kubelet will pass pod information as VolumeContext in the CSI NodePublishVolume() calls. The CSI driver is responsible for parsing and validating the information passed in as VolumeContext. The following VolumeConext will be passed if podInfoOnMount is set to true. This list might grow, but the prefix will be used. \"csi.storage.k8s.io/pod.name\": pod.Name \"csi.storage.k8s.io/pod.namespace\": pod.Namespace \"csi.storage.k8s.io/pod.uid\": string(pod.UID) \"csi.storage.k8s.io/ephemeral\": \"true\" if the volume is an ephemeral inline volume\n                                defined by a CSIVolumeSource, otherwise \"false\"\n\n\"csi.storage.k8s.io/ephemeral\" is a new feature in Kubernetes 1.16. It is only required for drivers which support both the \"Persistent\" and \"Ephemeral\" VolumeLifecycleMode. Other drivers can leave pod info disabled and/or ignore this field. As Kubernetes 1.15 doesn't support this field, drivers can only support one mode when deployed on such a cluster and the deployment determines which mode that is, for example via a command line parameter of the driver.\n\nThis field is immutable.",
          "type": "boolean"
        },
        "requiresRepublish": {
          "description": "RequiresRepublish indicates the CSI driver wants `NodePublishVolume` being periodically called to reflect any possible change in the mounted volume. This field defaults to false.\n\nNote: After a successful initial NodePublishVolume call, subsequent calls to NodePublishVolume should only update the contents of the volume. New mount points will not be seen by a running container.",
          "type": "boolean"
        },
        "storageCapacity": {
          "description": "If set to true, storageCapacity indicates that the CSI volume driver wants pod scheduling to consider the storage capacity that the driver deployment will report by creating CSIStorageCapacity objects with capacity information.\n\nThe check can be enabled immediately when deploying a driver. In that case, provisioning new volumes with late binding will pause until the driver deployment has published some suitable CSIStorageCapacity object.\n\nAlternatively, the driver can be deployed with the field unset or false and it can be flipped later when storage capacity information has been published.\n\nThis field is immutable.\n\nThis is a beta field and only available when the CSIStorageCapacity feature is enabled. The default is false.",
          "type": "boolean"
        },
        "tokenRequests": {
          "description": "TokenRequests indicates the CSI driver needs pods' service account tokens it is mounting volume for to do necessary authentication. Kubelet will pass the tokens in VolumeContext in the CSI NodePublishVolume calls. The CSI driver should parse and validate the following VolumeContext: \"csi.storage.k8s.io/serviceAccount.tokens\": {\n  \"<audience>\": {\n    \"token\": <token>,\n    \"expirationTimestamp\": <expiration timestamp in RFC3339>,\n  },\n  ...\n}\n\nNote: Audience in each TokenRequest should be different and at most one token is empty string. To receive a new token after expiry, RequiresRepublish can be used to trigger NodePublishVolume periodically.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.storage.v1.TokenRequest"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "volumeLifecycleModes": {
          "description": "volumeLifecycleModes defines what kind of volumes this CSI volume driver supports. The default if the list is empty is \"Persistent\", which is the usage defined by the CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism. The other mode is \"Ephemeral\". In this mode, volumes are defined inline inside the pod spec with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod. A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume. For more information about implementing this mode, see https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html A driver can support one or more of these modes and more modes may be added in the future. This field is beta.\n\nThis field is immutable.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-list-type": "set"
        }
      }
    },
    "io.k8s.api.storage.v1.CSINode": {
      "description": "CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need to create the CSINode object directly. As long as they use the node-driver-registrar sidecar container, the kubelet will automatically populate the CSINode object for the CSI driver as part of kubelet plugin registration. CSINode has the same name as a node. If the object is missing, it means either there are no CSI Drivers available on the node, or the Kubelet version is low enough that it doesn't create this object. CSINode has an OwnerReference that points to the corresponding node object.",
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CSINode"]
        },
        "metadata": {
          "description": "metadata.name must be the Kubernetes node name.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "spec is the specification of CSINode",
          "$ref": "#/definitions/io.k8s.api.storage.v1.CSINodeSpec"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.k8s.io",
          "kind": "CSINode",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.storage.v1.CSINodeDriver": {
      "description": "CSINodeDriver holds information about the specification of one CSI driver installed on a node",
      "type": "object",
      "required": ["name", "nodeID"],
      "properties": {
        "allocatable": {
          "description": "allocatable represents the volume resources of a node that are available for scheduling. This field is beta.",
          "$ref": "#/definitions/io.k8s.api.storage.v1.VolumeNodeResources"
        },
        "name": {
          "description": "This is the name of the CSI driver that this object refers to. This MUST be the same name returned by the CSI GetPluginName() call for that driver.",
          "type": "string"
        },
        "nodeID": {
          "description": "nodeID of the node from the driver point of view. This field enables Kubernetes to communicate with storage systems that do not share the same nomenclature for nodes. For example, Kubernetes may refer to a given node as \"node1\", but the storage system may refer to the same node as \"nodeA\". When Kubernetes issues a command to the storage system to attach a volume to a specific node, it can use this field to refer to the node name using the ID that the storage system will understand, e.g. \"nodeA\" instead of \"node1\". This field is required.",
          "type": "string"
        },
        "topologyKeys": {
          "description": "topologyKeys is the list of keys supported by the driver. When a driver is initialized on a cluster, it provides a set of topology keys that it understands (e.g. \"company.com/zone\", \"company.com/region\"). When a driver is initialized on a node, it provides the same topology keys along with values. Kubelet will expose these topology keys as labels on its own node object. When Kubernetes does topology aware provisioning, it can use this list to determine which labels it should retrieve from the node object and pass back to the driver. It is possible for different nodes to use different topology keys. This can be empty if driver does not support topology.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.api.storage.v1.CSINodeList": {
      "description": "CSINodeList is a collection of CSINode objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.k8s.io/v1"]
        },
        "items": {
          "description": "items is the list of CSINode",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.storage.v1.CSINode"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CSINodeList"]
        },
        "metadata": {
          "description": "Standard list metadata More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.k8s.io",
          "kind": "CSINodeList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.storage.v1.CSINodeSpec": {
      "description": "CSINodeSpec holds information about the specification of all CSI drivers installed on a node",
      "type": "object",
      "required": ["drivers"],
      "properties": {
        "drivers": {
          "description": "drivers is a list of information of all CSI Drivers existing on a node. If all drivers in the list are uninstalled, this can become empty.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.storage.v1.CSINodeDriver"
          },
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        }
      }
    },
    "io.k8s.api.storage.v1.StorageClass": {
      "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name.",
      "type": "object",
      "required": ["provisioner"],
      "properties": {
        "allowVolumeExpansion": {
          "description": "AllowVolumeExpansion shows whether the storage class allow volume expand",
          "type": "boolean"
        },
        "allowedTopologies": {
          "description": "Restrict the node topologies where volumes can be dynamically provisioned. Each volume plugin defines its own supported topology specifications. An empty TopologySelectorTerm list means there is no topology restriction. This field is only honored by servers that enable the VolumeScheduling feature.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.TopologySelectorTerm"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StorageClass"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "mountOptions": {
          "description": "Dynamically provisioned PersistentVolumes of this storage class are created with these mountOptions, e.g. [\"ro\", \"soft\"]. Not validated - mount of the PVs will simply fail if one is invalid.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "parameters": {
          "description": "Parameters holds the parameters for the provisioner that should create volumes of this storage class.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "provisioner": {
          "description": "Provisioner indicates the type of the provisioner.",
          "type": "string"
        },
        "reclaimPolicy": {
          "description": "Dynamically provisioned PersistentVolumes of this storage class are created with this reclaimPolicy. Defaults to Delete.",
          "type": "string"
        },
        "volumeBindingMode": {
          "description": "VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound.  When unset, VolumeBindingImmediate is used. This field is only honored by servers that enable the VolumeScheduling feature.",
          "type": "string"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.k8s.io",
          "kind": "StorageClass",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.storage.v1.StorageClassList": {
      "description": "StorageClassList is a collection of storage classes.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.k8s.io/v1"]
        },
        "items": {
          "description": "Items is the list of StorageClasses",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.storage.v1.StorageClass"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StorageClassList"]
        },
        "metadata": {
          "description": "Standard list metadata More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.k8s.io",
          "kind": "StorageClassList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.storage.v1.TokenRequest": {
      "description": "TokenRequest contains parameters of a service account token.",
      "type": "object",
      "required": ["audience"],
      "properties": {
        "audience": {
          "description": "Audience is the intended audience of the token in \"TokenRequestSpec\". It will default to the audiences of kube apiserver.",
          "type": "string"
        },
        "expirationSeconds": {
          "description": "ExpirationSeconds is the duration of validity of the token in \"TokenRequestSpec\". It has the same default value of \"ExpirationSeconds\" in \"TokenRequestSpec\".",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "io.k8s.api.storage.v1.VolumeAttachment": {
      "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced.",
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["VolumeAttachment"]
        },
        "metadata": {
          "description": "Standard object metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Specification of the desired attach/detach volume behavior. Populated by the Kubernetes system.",
          "$ref": "#/definitions/io.k8s.api.storage.v1.VolumeAttachmentSpec"
        },
        "status": {
          "description": "Status of the VolumeAttachment request. Populated by the entity completing the attach or detach operation, i.e. the external-attacher.",
          "$ref": "#/definitions/io.k8s.api.storage.v1.VolumeAttachmentStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.k8s.io",
          "kind": "VolumeAttachment",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.storage.v1.VolumeAttachmentList": {
      "description": "VolumeAttachmentList is a collection of VolumeAttachment objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.k8s.io/v1"]
        },
        "items": {
          "description": "Items is the list of VolumeAttachments",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.storage.v1.VolumeAttachment"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["VolumeAttachmentList"]
        },
        "metadata": {
          "description": "Standard list metadata More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.k8s.io",
          "kind": "VolumeAttachmentList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.api.storage.v1.VolumeAttachmentSource": {
      "description": "VolumeAttachmentSource represents a volume that should be attached. Right now only PersistenVolumes can be attached via external attacher, in future we may allow also inline volumes in pods. Exactly one member can be set.",
      "type": "object",
      "properties": {
        "inlineVolumeSpec": {
          "description": "inlineVolumeSpec contains all the information necessary to attach a persistent volume defined by a pod's inline VolumeSource. This field is populated only for the CSIMigration feature. It contains translated fields from a pod's inline VolumeSource to a PersistentVolumeSpec. This field is beta-level and is only honored by servers that enabled the CSIMigration feature.",
          "$ref": "#/definitions/io.k8s.api.core.v1.PersistentVolumeSpec"
        },
        "persistentVolumeName": {
          "description": "Name of the persistent volume to attach.",
          "type": "string"
        }
      }
    },
    "io.k8s.api.storage.v1.VolumeAttachmentSpec": {
      "description": "VolumeAttachmentSpec is the specification of a VolumeAttachment request.",
      "type": "object",
      "required": ["attacher", "source", "nodeName"],
      "properties": {
        "attacher": {
          "description": "Attacher indicates the name of the volume driver that MUST handle this request. This is the name returned by GetPluginName().",
          "type": "string"
        },
        "nodeName": {
          "description": "The node that the volume should be attached to.",
          "type": "string"
        },
        "source": {
          "description": "Source represents the volume that should be attached.",
          "$ref": "#/definitions/io.k8s.api.storage.v1.VolumeAttachmentSource"
        }
      }
    },
    "io.k8s.api.storage.v1.VolumeAttachmentStatus": {
      "description": "VolumeAttachmentStatus is the status of a VolumeAttachment request.",
      "type": "object",
      "required": ["attached"],
      "properties": {
        "attachError": {
          "description": "The last error encountered during attach operation, if any. This field must only be set by the entity completing the attach operation, i.e. the external-attacher.",
          "$ref": "#/definitions/io.k8s.api.storage.v1.VolumeError"
        },
        "attached": {
          "description": "Indicates the volume is successfully attached. This field must only be set by the entity completing the attach operation, i.e. the external-attacher.",
          "type": "boolean"
        },
        "attachmentMetadata": {
          "description": "Upon successful attach, this field is populated with any information returned by the attach operation that must be passed into subsequent WaitForAttach or Mount calls. This field must only be set by the entity completing the attach operation, i.e. the external-attacher.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "detachError": {
          "description": "The last error encountered during detach operation, if any. This field must only be set by the entity completing the detach operation, i.e. the external-attacher.",
          "$ref": "#/definitions/io.k8s.api.storage.v1.VolumeError"
        }
      }
    },
    "io.k8s.api.storage.v1.VolumeError": {
      "description": "VolumeError captures an error encountered during a volume operation.",
      "type": "object",
      "properties": {
        "message": {
          "description": "String detailing the error encountered during Attach or Detach operation. This string may be logged, so it should not contain sensitive information.",
          "type": "string"
        },
        "time": {
          "description": "Time the error was encountered.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        }
      }
    },
    "io.k8s.api.storage.v1.VolumeNodeResources": {
      "description": "VolumeNodeResources is a set of resource limits for scheduling of volumes.",
      "type": "object",
      "properties": {
        "count": {
          "description": "Maximum number of unique volumes managed by the CSI driver that can be used on a node. A volume that is both attached and mounted on a node is considered to be used once, not twice. The same rule applies for a unique volume that is shared among multiple pods on the same node. If this field is not specified, then the supported number of volumes on this node is unbounded.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.api.storage.v1beta1.CSIStorageCapacity": {
      "description": "CSIStorageCapacity stores the result of one CSI GetCapacity call. For a given StorageClass, this describes the available capacity in a particular topology segment.  This can be used when considering where to instantiate new PersistentVolumes.\n\nFor example this can express things like: - StorageClass \"standard\" has \"1234 GiB\" available in \"topology.kubernetes.io/zone=us-east1\" - StorageClass \"localssd\" has \"10 GiB\" available in \"kubernetes.io/hostname=knode-abc123\"\n\nThe following three cases all imply that no capacity is available for a certain combination: - no object exists with suitable topology and storage class name - such an object exists, but the capacity is unset - such an object exists, but the capacity is zero\n\nThe producer of these objects can decide which approach is more suitable.\n\nThey are consumed by the kube-scheduler if the CSIStorageCapacity beta feature gate is enabled there and a CSI driver opts into capacity-aware scheduling with CSIDriver.StorageCapacity.",
      "type": "object",
      "required": ["storageClassName"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.k8s.io/v1beta1"]
        },
        "capacity": {
          "description": "Capacity is the value reported by the CSI driver in its GetCapacityResponse for a GetCapacityRequest with topology and parameters that match the previous fields.\n\nThe semantic is currently (CSI spec 1.2) defined as: The available capacity, in bytes, of the storage that can be used to provision volumes. If not set, that information is currently unavailable and treated like zero capacity.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CSIStorageCapacity"]
        },
        "maximumVolumeSize": {
          "description": "MaximumVolumeSize is the value reported by the CSI driver in its GetCapacityResponse for a GetCapacityRequest with topology and parameters that match the previous fields.\n\nThis is defined since CSI spec 1.4.0 as the largest size that may be used in a CreateVolumeRequest.capacity_range.required_bytes field to create a volume with the same parameters as those in GetCapacityRequest. The corresponding value in the Kubernetes API is ResourceRequirements.Requests in a volume claim.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        },
        "metadata": {
          "description": "Standard object's metadata. The name has no particular meaning. It must be be a DNS subdomain (dots allowed, 253 characters). To ensure that there are no conflicts with other CSI drivers on the cluster, the recommendation is to use csisc-<uuid>, a generated name, or a reverse-domain name which ends with the unique CSI driver name.\n\nObjects are namespaced.\n\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "nodeTopology": {
          "description": "NodeTopology defines which nodes have access to the storage for which capacity was reported. If not set, the storage is not accessible from any node in the cluster. If empty, the storage is accessible from all nodes. This field is immutable.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        },
        "storageClassName": {
          "description": "The name of the StorageClass that the reported capacity applies to. It must meet the same requirements as the name of a StorageClass object (non-empty, DNS subdomain). If that object no longer exists, the CSIStorageCapacity object is obsolete and should be removed by its creator. This field is immutable.",
          "type": "string"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.k8s.io",
          "kind": "CSIStorageCapacity",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.api.storage.v1beta1.CSIStorageCapacityList": {
      "description": "CSIStorageCapacityList is a collection of CSIStorageCapacity objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["storage.k8s.io/v1beta1"]
        },
        "items": {
          "description": "Items is the list of CSIStorageCapacity objects.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.storage.v1beta1.CSIStorageCapacity"
          },
          "x-kubernetes-list-map-keys": ["name"],
          "x-kubernetes-list-type": "map"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CSIStorageCapacityList"]
        },
        "metadata": {
          "description": "Standard list metadata More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "storage.k8s.io",
          "kind": "CSIStorageCapacityList",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceColumnDefinition": {
      "description": "CustomResourceColumnDefinition specifies a column for server side printing.",
      "type": "object",
      "required": ["name", "type", "jsonPath"],
      "properties": {
        "description": {
          "description": "description is a human readable description of this column.",
          "type": "string"
        },
        "format": {
          "description": "format is an optional OpenAPI type definition for this column. The 'name' format is applied to the primary identifier column to assist in clients identifying column is the resource name. See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.",
          "type": "string"
        },
        "jsonPath": {
          "description": "jsonPath is a simple JSON path (i.e. with array notation) which is evaluated against each custom resource to produce the value for this column.",
          "type": "string"
        },
        "name": {
          "description": "name is a human readable name for the column.",
          "type": "string"
        },
        "priority": {
          "description": "priority is an integer defining the relative importance of this column compared to others. Lower numbers are considered higher priority. Columns that may be omitted in limited space scenarios should be given a priority greater than 0.",
          "type": "integer",
          "format": "int32"
        },
        "type": {
          "description": "type is an OpenAPI type definition for this column. See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.",
          "type": "string"
        }
      }
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceConversion": {
      "description": "CustomResourceConversion describes how to convert different versions of a CR.",
      "type": "object",
      "required": ["strategy"],
      "properties": {
        "strategy": {
          "description": "strategy specifies how custom resources are converted between versions. Allowed values are: - `None`: The converter only change the apiVersion and would not touch any other field in the custom resource. - `Webhook`: API Server will call to an external webhook to do the conversion. Additional information\n  is needed for this option. This requires spec.preserveUnknownFields to be false, and spec.conversion.webhook to be set.",
          "type": "string"
        },
        "webhook": {
          "description": "webhook describes how to call the conversion webhook. Required when `strategy` is set to `Webhook`.",
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.WebhookConversion"
        }
      }
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinition": {
      "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>.",
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["apiextensions.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CustomResourceDefinition"]
        },
        "metadata": {
          "description": "Standard object's metadata More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "spec describes how the user wants the resources to appear",
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionSpec"
        },
        "status": {
          "description": "status indicates the actual state of the CustomResourceDefinition",
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apiextensions.k8s.io",
          "kind": "CustomResourceDefinition",
          "version": "v1"
        }
      ]
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionCondition": {
      "description": "CustomResourceDefinitionCondition contains details for the current condition of this pod.",
      "type": "object",
      "required": ["type", "status"],
      "properties": {
        "lastTransitionTime": {
          "description": "lastTransitionTime last time the condition transitioned from one status to another.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "message is a human-readable message indicating details about last transition.",
          "type": "string"
        },
        "reason": {
          "description": "reason is a unique, one-word, CamelCase reason for the condition's last transition.",
          "type": "string"
        },
        "status": {
          "description": "status is the status of the condition. Can be True, False, Unknown.",
          "type": "string"
        },
        "type": {
          "description": "type is the type of the condition. Types include Established, NamesAccepted and Terminating.",
          "type": "string"
        }
      }
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionList": {
      "description": "CustomResourceDefinitionList is a list of CustomResourceDefinition objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["apiextensions.k8s.io/v1"]
        },
        "items": {
          "description": "items list individual CustomResourceDefinition objects",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinition"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["CustomResourceDefinitionList"]
        },
        "metadata": {
          "description": "Standard object's metadata More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apiextensions.k8s.io",
          "kind": "CustomResourceDefinitionList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionNames": {
      "description": "CustomResourceDefinitionNames indicates the names to serve this CustomResourceDefinition",
      "type": "object",
      "required": ["plural", "kind"],
      "properties": {
        "categories": {
          "description": "categories is a list of grouped resources this custom resource belongs to (e.g. 'all'). This is published in API discovery documents, and used by clients to support invocations like `kubectl get all`.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "kind": {
          "description": "kind is the serialized kind of the resource. It is normally CamelCase and singular. Custom resource instances will use this value as the `kind` attribute in API calls.",
          "type": "string"
        },
        "listKind": {
          "description": "listKind is the serialized kind of the list for this resource. Defaults to \"`kind`List\".",
          "type": "string"
        },
        "plural": {
          "description": "plural is the plural name of the resource to serve. The custom resources are served under `/apis/<group>/<version>/.../<plural>`. Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`). Must be all lowercase.",
          "type": "string"
        },
        "shortNames": {
          "description": "shortNames are short names for the resource, exposed in API discovery documents, and used by clients to support invocations like `kubectl get <shortname>`. It must be all lowercase.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "singular": {
          "description": "singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased `kind`.",
          "type": "string"
        }
      }
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionSpec": {
      "description": "CustomResourceDefinitionSpec describes how a user wants their resource to appear",
      "type": "object",
      "required": ["group", "names", "scope", "versions"],
      "properties": {
        "conversion": {
          "description": "conversion defines conversion settings for the CRD.",
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceConversion"
        },
        "group": {
          "description": "group is the API group of the defined custom resource. The custom resources are served under `/apis/<group>/...`. Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`).",
          "type": "string"
        },
        "names": {
          "description": "names specify the resource and kind names for the custom resource.",
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionNames"
        },
        "preserveUnknownFields": {
          "description": "preserveUnknownFields indicates that object fields which are not specified in the OpenAPI schema should be preserved when persisting to storage. apiVersion, kind, metadata and known fields inside metadata are always preserved. This field is deprecated in favor of setting `x-preserve-unknown-fields` to true in `spec.versions[*].schema.openAPIV3Schema`. See https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#pruning-versus-preserving-unknown-fields for details.",
          "type": "boolean"
        },
        "scope": {
          "description": "scope indicates whether the defined custom resource is cluster- or namespace-scoped. Allowed values are `Cluster` and `Namespaced`.",
          "type": "string"
        },
        "versions": {
          "description": "versions is the list of all API versions of the defined custom resource. Version names are used to compute the order in which served versions are listed in API discovery. If the version string is \"kube-like\", it will sort above non \"kube-like\" version strings, which are ordered lexicographically. \"Kube-like\" versions start with a \"v\", then are followed by a number (the major version), then optionally the string \"alpha\" or \"beta\" and another number (the minor version). These are sorted first by GA > beta > alpha (where GA is a version with no suffix such as beta or alpha), and then by comparing major version, then minor version. An example sorted list of versions: v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionVersion"
          }
        }
      }
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionStatus": {
      "description": "CustomResourceDefinitionStatus indicates the state of the CustomResourceDefinition",
      "type": "object",
      "properties": {
        "acceptedNames": {
          "description": "acceptedNames are the names that are actually being used to serve discovery. They may be different than the names in spec.",
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionNames"
        },
        "conditions": {
          "description": "conditions indicate state for particular aspects of a CustomResourceDefinition",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionCondition"
          },
          "x-kubernetes-list-map-keys": ["type"],
          "x-kubernetes-list-type": "map"
        },
        "storedVersions": {
          "description": "storedVersions lists all versions of CustomResources that were ever persisted. Tracking these versions allows a migration path for stored versions in etcd. The field is mutable so a migration controller can finish a migration to another version (ensuring no old objects are left in storage), and then remove the rest of the versions from this list. Versions may not be removed from `spec.versions` while they exist in this list.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionVersion": {
      "description": "CustomResourceDefinitionVersion describes a version for CRD.",
      "type": "object",
      "required": ["name", "served", "storage"],
      "properties": {
        "additionalPrinterColumns": {
          "description": "additionalPrinterColumns specifies additional columns returned in Table output. See https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables for details. If no columns are specified, a single column displaying the age of the custom resource is used.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceColumnDefinition"
          }
        },
        "deprecated": {
          "description": "deprecated indicates this version of the custom resource API is deprecated. When set to true, API requests to this version receive a warning header in the server response. Defaults to false.",
          "type": "boolean"
        },
        "deprecationWarning": {
          "description": "deprecationWarning overrides the default warning returned to API clients. May only be set when `deprecated` is true. The default warning indicates this version is deprecated and recommends use of the newest served version of equal or greater stability, if one exists.",
          "type": "string"
        },
        "name": {
          "description": "name is the version name, e.g. \u201cv1\u201d, \u201cv2beta1\u201d, etc. The custom resources are served under this version at `/apis/<group>/<version>/...` if `served` is true.",
          "type": "string"
        },
        "schema": {
          "description": "schema describes the schema used for validation, pruning, and defaulting of this version of the custom resource.",
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceValidation"
        },
        "served": {
          "description": "served is a flag enabling/disabling this version from being served via REST APIs",
          "type": "boolean"
        },
        "storage": {
          "description": "storage indicates this version should be used when persisting custom resources to storage. There must be exactly one version with storage=true.",
          "type": "boolean"
        },
        "subresources": {
          "description": "subresources specify what subresources this version of the defined custom resource have.",
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceSubresources"
        }
      }
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceSubresourceScale": {
      "description": "CustomResourceSubresourceScale defines how to serve the scale subresource for CustomResources.",
      "type": "object",
      "required": ["specReplicasPath", "statusReplicasPath"],
      "properties": {
        "labelSelectorPath": {
          "description": "labelSelectorPath defines the JSON path inside of a custom resource that corresponds to Scale `status.selector`. Only JSON paths without the array notation are allowed. Must be a JSON Path under `.status` or `.spec`. Must be set to work with HorizontalPodAutoscaler. The field pointed by this JSON path must be a string field (not a complex selector struct) which contains a serialized label selector in string form. More info: https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions#scale-subresource If there is no value under the given path in the custom resource, the `status.selector` value in the `/scale` subresource will default to the empty string.",
          "type": "string"
        },
        "specReplicasPath": {
          "description": "specReplicasPath defines the JSON path inside of a custom resource that corresponds to Scale `spec.replicas`. Only JSON paths without the array notation are allowed. Must be a JSON Path under `.spec`. If there is no value under the given path in the custom resource, the `/scale` subresource will return an error on GET.",
          "type": "string"
        },
        "statusReplicasPath": {
          "description": "statusReplicasPath defines the JSON path inside of a custom resource that corresponds to Scale `status.replicas`. Only JSON paths without the array notation are allowed. Must be a JSON Path under `.status`. If there is no value under the given path in the custom resource, the `status.replicas` value in the `/scale` subresource will default to 0.",
          "type": "string"
        }
      }
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceSubresourceStatus": {
      "description": "CustomResourceSubresourceStatus defines how to serve the status subresource for CustomResources. Status is represented by the `.status` JSON path inside of a CustomResource. When set, * exposes a /status subresource for the custom resource * PUT requests to the /status subresource take a custom resource object, and ignore changes to anything except the status stanza * PUT/POST/PATCH requests to the custom resource ignore changes to the status stanza",
      "type": "object"
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceSubresources": {
      "description": "CustomResourceSubresources defines the status and scale subresources for CustomResources.",
      "type": "object",
      "properties": {
        "scale": {
          "description": "scale indicates the custom resource should serve a `/scale` subresource that returns an `autoscaling/v1` Scale object.",
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceSubresourceScale"
        },
        "status": {
          "description": "status indicates the custom resource should serve a `/status` subresource. When enabled: 1. requests to the custom resource primary endpoint ignore changes to the `status` stanza of the object. 2. requests to the custom resource `/status` subresource ignore changes to anything other than the `status` stanza of the object.",
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceSubresourceStatus"
        }
      }
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceValidation": {
      "description": "CustomResourceValidation is a list of validation methods for CustomResources.",
      "type": "object",
      "properties": {
        "openAPIV3Schema": {
          "description": "openAPIV3Schema is the OpenAPI v3 schema to use for validation and pruning.",
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaProps"
        }
      }
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.ExternalDocumentation": {
      "description": "ExternalDocumentation allows referencing an external resource for extended documentation.",
      "type": "object",
      "properties": {
        "description": {
          "type": "string"
        },
        "url": {
          "type": "string"
        }
      }
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSON": {
      "description": "JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil."
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaProps": {
      "description": "JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/).",
      "type": "object",
      "properties": {
        "$ref": {
          "type": "string"
        },
        "$schema": {
          "type": "string"
        },
        "additionalItems": {
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaPropsOrBool"
        },
        "additionalProperties": {
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaPropsOrBool"
        },
        "allOf": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaProps"
          }
        },
        "anyOf": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaProps"
          }
        },
        "default": {
          "description": "default is a default value for undefined object fields. Defaulting is a beta feature under the CustomResourceDefaulting feature gate. Defaulting requires spec.preserveUnknownFields to be false.",
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSON"
        },
        "definitions": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaProps"
          }
        },
        "dependencies": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaPropsOrStringArray"
          }
        },
        "description": {
          "type": "string"
        },
        "enum": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSON"
          }
        },
        "example": {
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSON"
        },
        "exclusiveMaximum": {
          "type": "boolean"
        },
        "exclusiveMinimum": {
          "type": "boolean"
        },
        "externalDocs": {
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.ExternalDocumentation"
        },
        "format": {
          "description": "format is an OpenAPI v3 format string. Unknown formats are ignored. The following formats are validated:\n\n- bsonobjectid: a bson object ID, i.e. a 24 characters hex string - uri: an URI as parsed by Golang net/url.ParseRequestURI - email: an email address as parsed by Golang net/mail.ParseAddress - hostname: a valid representation for an Internet host name, as defined by RFC 1034, section 3.1 [RFC1034]. - ipv4: an IPv4 IP as parsed by Golang net.ParseIP - ipv6: an IPv6 IP as parsed by Golang net.ParseIP - cidr: a CIDR as parsed by Golang net.ParseCIDR - mac: a MAC address as parsed by Golang net.ParseMAC - uuid: an UUID that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid3: an UUID3 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?3[0-9a-f]{3}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid4: an UUID4 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?4[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - uuid5: an UUID5 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?5[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - isbn: an ISBN10 or ISBN13 number string like \"0321751043\" or \"978-0321751041\" - isbn10: an ISBN10 number string like \"0321751043\" - isbn13: an ISBN13 number string like \"978-0321751041\" - creditcard: a credit card number defined by the regex ^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$ with any non digit characters mixed in - ssn: a U.S. social security number following the regex ^\\d{3}[- ]?\\d{2}[- ]?\\d{4}$ - hexcolor: an hexadecimal color code like \"#FFFFFF: following the regex ^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$ - rgbcolor: an RGB color code like rgb like \"rgb(255,255,2559\" - byte: base64 encoded binary data - password: any kind of string - date: a date string like \"2006-01-02\" as defined by full-date in RFC3339 - duration: a duration string like \"22 ns\" as parsed by Golang time.ParseDuration or compatible with Scala duration format - datetime: a date time string like \"2014-12-15T19:30:20.000Z\" as defined by date-time in RFC3339.",
          "type": "string"
        },
        "id": {
          "type": "string"
        },
        "items": {
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaPropsOrArray"
        },
        "maxItems": {
          "type": "integer",
          "format": "int64"
        },
        "maxLength": {
          "type": "integer",
          "format": "int64"
        },
        "maxProperties": {
          "type": "integer",
          "format": "int64"
        },
        "maximum": {
          "type": "number",
          "format": "double"
        },
        "minItems": {
          "type": "integer",
          "format": "int64"
        },
        "minLength": {
          "type": "integer",
          "format": "int64"
        },
        "minProperties": {
          "type": "integer",
          "format": "int64"
        },
        "minimum": {
          "type": "number",
          "format": "double"
        },
        "multipleOf": {
          "type": "number",
          "format": "double"
        },
        "not": {
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaProps"
        },
        "nullable": {
          "type": "boolean"
        },
        "oneOf": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaProps"
          }
        },
        "pattern": {
          "type": "string"
        },
        "patternProperties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaProps"
          }
        },
        "properties": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaProps"
          }
        },
        "required": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "title": {
          "type": "string"
        },
        "type": {
          "type": "string"
        },
        "uniqueItems": {
          "type": "boolean"
        },
        "x-kubernetes-embedded-resource": {
          "description": "x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to further restrict the embedded object. kind, apiVersion and metadata are validated automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not have to be if the object is fully specified (up to kind, apiVersion, metadata).",
          "type": "boolean"
        },
        "x-kubernetes-int-or-string": {
          "description": "x-kubernetes-int-or-string specifies that this value is either an integer or a string. If this is true, an empty type is allowed and type as child of anyOf is permitted if following one of the following patterns:\n\n1) anyOf:\n   - type: integer\n   - type: string\n2) allOf:\n   - anyOf:\n     - type: integer\n     - type: string\n   - ... zero or more",
          "type": "boolean"
        },
        "x-kubernetes-list-map-keys": {
          "description": "x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by specifying the keys used as the index of the map.\n\nThis tag MUST only be used on lists that have the \"x-kubernetes-list-type\" extension set to \"map\". Also, the values specified for this attribute must be a scalar typed field of the child structure (no nesting is supported).\n\nThe properties specified must either be required or have a default value, to ensure those properties are present for all list items.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "x-kubernetes-list-type": {
          "description": "x-kubernetes-list-type annotates an array to further describe its topology. This extension must only be used on lists and may have 3 possible values:\n\n1) `atomic`: the list is treated as a single entity, like a scalar.\n     Atomic lists will be entirely replaced when updated. This extension\n     may be used on any type of list (struct, scalar, ...).\n2) `set`:\n     Sets are lists that must not have multiple items with the same value. Each\n     value must be a scalar, an object with x-kubernetes-map-type `atomic` or an\n     array with x-kubernetes-list-type `atomic`.\n3) `map`:\n     These lists are like maps in that their elements have a non-index key\n     used to identify them. Order is preserved upon merge. The map tag\n     must only be used on a list with elements of type object.\nDefaults to atomic for arrays.",
          "type": "string"
        },
        "x-kubernetes-map-type": {
          "description": "x-kubernetes-map-type annotates an object to further describe its topology. This extension must only be used when type is object and may have 2 possible values:\n\n1) `granular`:\n     These maps are actual maps (key-value pairs) and each fields are independent\n     from each other (they can each be manipulated by separate actors). This is\n     the default behaviour for all maps.\n2) `atomic`: the list is treated as a single entity, like a scalar.\n     Atomic maps will be entirely replaced when updated.",
          "type": "string"
        },
        "x-kubernetes-preserve-unknown-fields": {
          "description": "x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning fields which are not specified in the validation schema. This affects fields recursively, but switches back to normal pruning behaviour if nested properties or additionalProperties are specified in the schema. This can either be true or undefined. False is forbidden.",
          "type": "boolean"
        }
      }
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaPropsOrArray": {
      "description": "JSONSchemaPropsOrArray represents a value that can either be a JSONSchemaProps or an array of JSONSchemaProps. Mainly here for serialization purposes."
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaPropsOrBool": {
      "description": "JSONSchemaPropsOrBool represents JSONSchemaProps or a boolean value. Defaults to true for the boolean property."
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaPropsOrStringArray": {
      "description": "JSONSchemaPropsOrStringArray represents a JSONSchemaProps or a string array."
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.ServiceReference": {
      "description": "ServiceReference holds a reference to Service.legacy.k8s.io",
      "type": "object",
      "required": ["namespace", "name"],
      "properties": {
        "name": {
          "description": "name is the name of the service. Required",
          "type": "string"
        },
        "namespace": {
          "description": "namespace is the namespace of the service. Required",
          "type": "string"
        },
        "path": {
          "description": "path is an optional URL path at which the webhook will be contacted.",
          "type": "string"
        },
        "port": {
          "description": "port is an optional service port at which the webhook will be contacted. `port` should be a valid port number (1-65535, inclusive). Defaults to 443 for backward compatibility.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.WebhookClientConfig": {
      "description": "WebhookClientConfig contains the information to make a TLS connection with the webhook.",
      "type": "object",
      "properties": {
        "caBundle": {
          "description": "caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server certificate. If unspecified, system trust roots on the apiserver are used.",
          "type": "string",
          "format": "byte"
        },
        "service": {
          "description": "service is a reference to the service for this webhook. Either service or url must be specified.\n\nIf the webhook is running within the cluster, then you should use `service`.",
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.ServiceReference"
        },
        "url": {
          "description": "url gives the location of the webhook, in standard URL form (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.\n\nThe `host` should not refer to a service running in the cluster; use the `service` field instead. The host might be resolved via external DNS in some apiservers (e.g., `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation). `host` may also be an IP address.\n\nPlease note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take great care to run this webhook on all hosts which run an apiserver which might need to make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy to turn up in a new cluster.\n\nThe scheme must be \"https\"; the URL must begin with \"https://\".\n\nA path is optional, and if present may be any string permissible in a URL. You may use the path to pass an arbitrary string to the webhook, for example, a cluster identifier.\n\nAttempting to use a user or basic auth e.g. \"user:password@\" is not allowed. Fragments (\"#...\") and query parameters (\"?...\") are not allowed, either.",
          "type": "string"
        }
      }
    },
    "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.WebhookConversion": {
      "description": "WebhookConversion describes how to call a conversion webhook",
      "type": "object",
      "required": ["conversionReviewVersions"],
      "properties": {
        "clientConfig": {
          "description": "clientConfig is the instructions for how to call the webhook if strategy is `Webhook`.",
          "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.WebhookClientConfig"
        },
        "conversionReviewVersions": {
          "description": "conversionReviewVersions is an ordered list of preferred `ConversionReview` versions the Webhook expects. The API server will use the first version in the list which it supports. If none of the versions specified in this list are supported by API server, conversion will fail for the custom resource. If a persisted Webhook configuration specifies allowed versions and does not include any versions known to the API Server, calls to the webhook will fail.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.apimachinery.pkg.api.resource.Quantity": {
      "oneOf": [
        {
          "type": "string"
        },
        {
          "type": "number"
        }
      ]
    },
    "io.k8s.apimachinery.pkg.api.resource.Quantity_v2": {
      "description": "Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.\n\nThe serialization format is:\n\n<quantity>        ::= <signedNumber><suffix>\n  (Note that <suffix> may be empty, from the \"\" case in <decimalSI>.)\n<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= \"+\" | \"-\" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei\n  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)\n<decimalSI>       ::= m | \"\" | k | M | G | T | P | E\n  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)\n<decimalExponent> ::= \"e\" <signedNumber> | \"E\" <signedNumber>\n\nNo matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.\n\nWhen a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.\n\nBefore serializing, Quantity will be put in \"canonical form\". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:\n  a. No precision is lost\n  b. No fractional digits will be emitted\n  c. The exponent (or suffix) is as large as possible.\nThe sign will be omitted unless the number is negative.\n\nExamples:\n  1.5 will be serialized as \"1500m\"\n  1.5Gi will be serialized as \"1536Mi\"\n\nNote that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.\n\nNon-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)\n\nThis format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.",
      "type": "string"
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.APIGroup": {
      "description": "APIGroup contains the name, the supported versions, and the preferred version of a group.",
      "type": "object",
      "required": ["name", "versions"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["APIGroup"]
        },
        "name": {
          "description": "name is the name of the group.",
          "type": "string"
        },
        "preferredVersion": {
          "description": "preferredVersion is the version preferred by the API server, which probably is the storage version.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery"
        },
        "serverAddressByClientCIDRs": {
          "description": "a map of client CIDR to server address that is serving this group. This is to help clients reach servers in the most network-efficient way possible. Clients can use the appropriate server address as per the CIDR that they match. In case of multiple matches, clients should use the longest matching CIDR. The server returns only those CIDRs that it thinks that the client can match. For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP. Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR"
          }
        },
        "versions": {
          "description": "versions are the versions supported in this group.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery"
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "APIGroup",
          "version": "v1"
        }
      ]
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.APIGroupList": {
      "description": "APIGroupList is a list of APIGroup, to allow clients to discover the API at /apis.",
      "type": "object",
      "required": ["groups"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "groups": {
          "description": "groups is a list of APIGroup.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.APIGroup"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["APIGroupList"]
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "APIGroupList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.APIGroup_v2": {
      "description": "APIGroup contains the name, the supported versions, and the preferred version of a group.",
      "type": "object",
      "required": ["name", "versions"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["APIGroup"]
        },
        "name": {
          "description": "name is the name of the group.",
          "type": "string"
        },
        "preferredVersion": {
          "description": "preferredVersion is the version preferred by the API server, which probably is the storage version.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery"
        },
        "serverAddressByClientCIDRs": {
          "description": "a map of client CIDR to server address that is serving this group. This is to help clients reach servers in the most network-efficient way possible. Clients can use the appropriate server address as per the CIDR that they match. In case of multiple matches, clients should use the longest matching CIDR. The server returns only those CIDRs that it thinks that the client can match. For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP. Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR"
          }
        },
        "versions": {
          "description": "versions are the versions supported in this group.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery"
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "APIGroup",
          "version": "v1"
        }
      ]
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.APIResource": {
      "description": "APIResource specifies the name of a resource and whether it is namespaced.",
      "type": "object",
      "required": ["name", "singularName", "namespaced", "kind", "verbs"],
      "properties": {
        "categories": {
          "description": "categories is a list of the grouped resources this resource belongs to (e.g. 'all')",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "group": {
          "description": "group is the preferred group of the resource.  Empty implies the group of the containing resource list. For subresources, this may have a different value, for example: Scale\".",
          "type": "string"
        },
        "kind": {
          "description": "kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')",
          "type": "string"
        },
        "name": {
          "description": "name is the plural name of the resource.",
          "type": "string"
        },
        "namespaced": {
          "description": "namespaced indicates if a resource is namespaced or not.",
          "type": "boolean"
        },
        "shortNames": {
          "description": "shortNames is a list of suggested short names of the resource.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "singularName": {
          "description": "singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely. The singularName is more correct for reporting status on a single item and both singular and plural are allowed from the kubectl CLI interface.",
          "type": "string"
        },
        "storageVersionHash": {
          "description": "The hash value of the storage version, the version this resource is converted to when written to the data store. Value must be treated as opaque by clients. Only equality comparison on the value is valid. This is an alpha feature and may change or be removed in the future. The field is populated by the apiserver only if the StorageVersionHash feature gate is enabled. This field will remain optional even if it graduates.",
          "type": "string"
        },
        "verbs": {
          "description": "verbs is a list of supported kube verbs (this includes get, list, watch, create, update, patch, delete, deletecollection, and proxy)",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "version": {
          "description": "version is the preferred version of the resource.  Empty implies the version of the containing resource list For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)\".",
          "type": "string"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.APIResourceList": {
      "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced.",
      "type": "object",
      "required": ["groupVersion", "resources"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "groupVersion": {
          "description": "groupVersion is the group and version this APIResourceList is for.",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["APIResourceList"]
        },
        "resources": {
          "description": "resources contains the name of the resources and if they are namespaced.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.APIResource"
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "APIResourceList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.APIResourceList_v2": {
      "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced.",
      "type": "object",
      "required": ["groupVersion", "resources"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "groupVersion": {
          "description": "groupVersion is the group and version this APIResourceList is for.",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["APIResourceList"]
        },
        "resources": {
          "description": "resources contains the name of the resources and if they are namespaced.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.APIResource"
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "APIResourceList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.APIVersions": {
      "description": "APIVersions lists the versions that are available, to allow clients to discover the API at /api, which is the root path of the legacy v1 API.",
      "type": "object",
      "required": ["versions", "serverAddressByClientCIDRs"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["APIVersions"]
        },
        "serverAddressByClientCIDRs": {
          "description": "a map of client CIDR to server address that is serving this group. This is to help clients reach servers in the most network-efficient way possible. Clients can use the appropriate server address as per the CIDR that they match. In case of multiple matches, clients should use the longest matching CIDR. The server returns only those CIDRs that it thinks that the client can match. For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP. Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR"
          }
        },
        "versions": {
          "description": "versions are the api versions that are available.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "APIVersions",
          "version": "v1"
        }
      ]
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.Condition": {
      "description": "Condition contains details for one aspect of the current state of this API Resource.",
      "type": "object",
      "required": ["type", "status", "lastTransitionTime", "reason", "message"],
      "properties": {
        "lastTransitionTime": {
          "description": "lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "message is a human readable message indicating details about the transition. This may be an empty string.",
          "type": "string"
        },
        "observedGeneration": {
          "description": "observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.",
          "type": "integer",
          "format": "int64"
        },
        "reason": {
          "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.",
          "type": "string"
        },
        "status": {
          "description": "status of the condition, one of True, False, Unknown.",
          "type": "string"
        },
        "type": {
          "description": "type of condition in CamelCase or in foo.example.com/CamelCase.",
          "type": "string"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions": {
      "description": "DeleteOptions may be provided when deleting an API object.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": [
            "v1",
            "admission.k8s.io/v1",
            "admission.k8s.io/v1beta1",
            "admissionregistration.k8s.io/v1",
            "admissionregistration.k8s.io/v1beta1",
            "apiextensions.k8s.io/v1",
            "apiextensions.k8s.io/v1beta1",
            "apiregistration.k8s.io/v1",
            "apiregistration.k8s.io/v1beta1",
            "apps/v1",
            "apps/v1beta1",
            "apps/v1beta2",
            "authentication.k8s.io/v1",
            "authentication.k8s.io/v1beta1",
            "authorization.k8s.io/v1",
            "authorization.k8s.io/v1beta1",
            "autoscaling/v1",
            "autoscaling/v2beta1",
            "autoscaling/v2beta2",
            "batch/v1",
            "batch/v1beta1",
            "certificates.k8s.io/v1",
            "certificates.k8s.io/v1beta1",
            "coordination.k8s.io/v1",
            "coordination.k8s.io/v1beta1",
            "discovery.k8s.io/v1",
            "discovery.k8s.io/v1beta1",
            "events.k8s.io/v1",
            "events.k8s.io/v1beta1",
            "extensions/v1beta1",
            "flowcontrol.apiserver.k8s.io/v1alpha1",
            "flowcontrol.apiserver.k8s.io/v1beta1",
            "imagepolicy.k8s.io/v1alpha1",
            "internal.apiserver.k8s.io/v1alpha1",
            "networking.k8s.io/v1",
            "networking.k8s.io/v1beta1",
            "node.k8s.io/v1",
            "node.k8s.io/v1alpha1",
            "node.k8s.io/v1beta1",
            "policy/v1",
            "policy/v1beta1",
            "rbac.authorization.k8s.io/v1",
            "rbac.authorization.k8s.io/v1alpha1",
            "rbac.authorization.k8s.io/v1beta1",
            "scheduling.k8s.io/v1",
            "scheduling.k8s.io/v1alpha1",
            "scheduling.k8s.io/v1beta1",
            "storage.k8s.io/v1",
            "storage.k8s.io/v1alpha1",
            "storage.k8s.io/v1beta1"
          ]
        },
        "dryRun": {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "gracePeriodSeconds": {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "type": "integer",
          "format": "int64"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["DeleteOptions"]
        },
        "orphanDependents": {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "type": "boolean"
        },
        "preconditions": {
          "description": "Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be returned.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Preconditions"
        },
        "propagationPolicy": {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "type": "string"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "admission.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "admission.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "admissionregistration.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "admissionregistration.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "apiextensions.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "apiextensions.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "apiregistration.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "apiregistration.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "apps",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "apps",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "apps",
          "kind": "DeleteOptions",
          "version": "v1beta2"
        },
        {
          "group": "authentication.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "authentication.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "authorization.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "authorization.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "autoscaling",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "autoscaling",
          "kind": "DeleteOptions",
          "version": "v2beta1"
        },
        {
          "group": "autoscaling",
          "kind": "DeleteOptions",
          "version": "v2beta2"
        },
        {
          "group": "batch",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "batch",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "certificates.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "certificates.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "coordination.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "coordination.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "discovery.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "discovery.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "events.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "events.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "extensions",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "flowcontrol.apiserver.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1alpha1"
        },
        {
          "group": "flowcontrol.apiserver.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "imagepolicy.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1alpha1"
        },
        {
          "group": "internal.apiserver.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1alpha1"
        },
        {
          "group": "networking.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "networking.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "node.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "node.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1alpha1"
        },
        {
          "group": "node.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "policy",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "policy",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "rbac.authorization.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "rbac.authorization.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1alpha1"
        },
        {
          "group": "rbac.authorization.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "scheduling.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "scheduling.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1alpha1"
        },
        {
          "group": "scheduling.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        },
        {
          "group": "storage.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1"
        },
        {
          "group": "storage.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1alpha1"
        },
        {
          "group": "storage.k8s.io",
          "kind": "DeleteOptions",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions_v2": {
      "description": "DeleteOptions may be provided when deleting an API object.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "dryRun": {
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "gracePeriodSeconds": {
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
          "type": "integer",
          "format": "int64"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "orphanDependents": {
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
          "type": "boolean"
        },
        "preconditions": {
          "description": "Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be returned.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Preconditions"
        },
        "propagationPolicy": {
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
          "type": "string"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.Duration": {
      "description": "Duration is a wrapper around time.Duration which supports correct marshaling to YAML and JSON. In particular, it marshals into strings, which can be used as map keys in json.",
      "type": "string"
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.Fields": {
      "description": "Fields stores a set of fields in a data structure like a Trie. To understand how this is used, see: https://github.com/kubernetes-sigs/structured-merge-diff",
      "type": "object"
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.FieldsV1": {
      "description": "FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.\n\nEach key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:<name>', where <name> is the name of a field in a struct, or key in a map 'v:<value>', where <value> is the exact json formatted value of a list item 'i:<index>', where <index> is position of a item in a list 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.\n\nThe exact format is defined in sigs.k8s.io/structured-merge-diff",
      "type": "object"
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery": {
      "description": "GroupVersion contains the \"group/version\" and \"version\" string of a version. It is made a struct to keep extensibility.",
      "type": "object",
      "required": ["groupVersion", "version"],
      "properties": {
        "groupVersion": {
          "description": "groupVersion specifies the API group and version in the form \"group/version\"",
          "type": "string"
        },
        "version": {
          "description": "version specifies the version in the form of \"version\". This is to save the clients the trouble of splitting the GroupVersion.",
          "type": "string"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.Initializer": {
      "description": "Initializer is information about an initializer that has not yet completed.",
      "type": "object",
      "required": ["name"],
      "properties": {
        "name": {
          "description": "name of the process that is responsible for initializing this object.",
          "type": "string"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.Initializers": {
      "description": "Initializers tracks the progress of initialization.",
      "type": "object",
      "required": ["pending"],
      "properties": {
        "pending": {
          "description": "Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Initializer"
          },
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "result": {
          "description": "If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status_v3"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector": {
      "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
      "type": "object",
      "properties": {
        "matchExpressions": {
          "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement"
          }
        },
        "matchLabels": {
          "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement": {
      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      "type": "object",
      "required": ["key", "operator"],
      "properties": {
        "key": {
          "description": "key is the label key that the selector applies to.",
          "type": "string",
          "x-kubernetes-patch-merge-key": "key",
          "x-kubernetes-patch-strategy": "merge"
        },
        "operator": {
          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
          "type": "string"
        },
        "values": {
          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta": {
      "description": "ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.",
      "type": "object",
      "properties": {
        "continue": {
          "description": "continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.",
          "type": "string"
        },
        "remainingItemCount": {
          "description": "remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.",
          "type": "integer",
          "format": "int64"
        },
        "resourceVersion": {
          "description": "String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
          "type": "string"
        },
        "selfLink": {
          "description": "selfLink is a URL representing this object. Populated by the system. Read-only.\n\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release.",
          "type": "string"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta_v2": {
      "description": "ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.",
      "type": "object",
      "properties": {
        "continue": {
          "description": "continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.",
          "type": "string"
        },
        "resourceVersion": {
          "description": "String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency",
          "type": "string"
        },
        "selfLink": {
          "description": "selfLink is a URL representing this object. Populated by the system. Read-only.",
          "type": "string"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry": {
      "description": "ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the version of this resource that this field set applies to. The format is \"group/version\" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.",
          "type": "string"
        },
        "fieldsType": {
          "description": "FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: \"FieldsV1\"",
          "type": "string"
        },
        "fieldsV1": {
          "description": "FieldsV1 holds the first JSON version format as described in the \"FieldsV1\" type.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.FieldsV1"
        },
        "manager": {
          "description": "Manager is an identifier of the workflow managing these fields.",
          "type": "string"
        },
        "operation": {
          "description": "Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.",
          "type": "string"
        },
        "subresource": {
          "description": "Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.",
          "type": "string"
        },
        "time": {
          "description": "Time is timestamp of when these fields were set. It should always be empty if Operation is 'Apply'",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry_v2": {
      "description": "ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the version of this resource that this field set applies to. The format is \"group/version\" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.",
          "type": "string"
        },
        "fields": {
          "description": "Fields identifies a set of fields.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Fields"
        },
        "manager": {
          "description": "Manager is an identifier of the workflow managing these fields.",
          "type": "string"
        },
        "operation": {
          "description": "Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.",
          "type": "string"
        },
        "time": {
          "description": "Time is timestamp of when these fields were set. It should always be empty if Operation is 'Apply'",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime": {
      "description": "MicroTime is version of Time with microsecond level precision.",
      "type": "string",
      "format": "date-time"
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta": {
      "description": "ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.",
      "type": "object",
      "properties": {
        "annotations": {
          "description": "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "clusterName": {
          "description": "The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.",
          "type": "string"
        },
        "creationTimestamp": {
          "description": "CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.\n\nPopulated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "deletionGracePeriodSeconds": {
          "description": "Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.",
          "type": "integer",
          "format": "int64"
        },
        "deletionTimestamp": {
          "description": "DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.\n\nPopulated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "finalizers": {
          "description": "Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-patch-strategy": "merge"
        },
        "generateName": {
          "description": "GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\n\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\n\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency",
          "type": "string"
        },
        "generation": {
          "description": "A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.",
          "type": "integer",
          "format": "int64"
        },
        "labels": {
          "description": "Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "managedFields": {
          "description": "ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry"
          }
        },
        "name": {
          "description": "Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\n\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces",
          "type": "string"
        },
        "ownerReferences": {
          "description": "List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference"
          },
          "x-kubernetes-patch-merge-key": "uid",
          "x-kubernetes-patch-strategy": "merge"
        },
        "resourceVersion": {
          "description": "An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\n\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
          "type": "string"
        },
        "selfLink": {
          "description": "SelfLink is a URL representing this object. Populated by the system. Read-only.\n\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release.",
          "type": "string"
        },
        "uid": {
          "description": "UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\n\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
          "type": "string"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2": {
      "description": "ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.",
      "type": "object",
      "properties": {
        "annotations": {
          "description": "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "clusterName": {
          "description": "The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.",
          "type": "string"
        },
        "creationTimestamp": {
          "description": "CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.\n\nPopulated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "deletionGracePeriodSeconds": {
          "description": "Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.",
          "type": "integer",
          "format": "int64"
        },
        "deletionTimestamp": {
          "description": "DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.\n\nPopulated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "finalizers": {
          "description": "Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-patch-strategy": "merge"
        },
        "generateName": {
          "description": "GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\n\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\n\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#idempotency",
          "type": "string"
        },
        "generation": {
          "description": "A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.",
          "type": "integer",
          "format": "int64"
        },
        "initializers": {
          "description": "An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.\n\nWhen an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.\n\nDEPRECATED - initializers are an alpha field and will be removed in v1.15.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Initializers"
        },
        "labels": {
          "description": "Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "managedFields": {
          "description": "ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.\n\nThis field is alpha and can be changed or removed without notice.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry_v2"
          }
        },
        "name": {
          "description": "Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\n\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces",
          "type": "string"
        },
        "ownerReferences": {
          "description": "List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference_v2"
          },
          "x-kubernetes-patch-merge-key": "uid",
          "x-kubernetes-patch-strategy": "merge"
        },
        "resourceVersion": {
          "description": "An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\n\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency",
          "type": "string"
        },
        "selfLink": {
          "description": "SelfLink is a URL representing this object. Populated by the system. Read-only.",
          "type": "string"
        },
        "uid": {
          "description": "UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\n\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
          "type": "string"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference": {
      "description": "OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.",
      "type": "object",
      "required": ["apiVersion", "kind", "name", "uid"],
      "properties": {
        "apiVersion": {
          "description": "API version of the referent.",
          "type": "string"
        },
        "blockOwnerDeletion": {
          "description": "If true, AND if the owner has the \"foregroundDeletion\" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \"delete\" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.",
          "type": "boolean"
        },
        "controller": {
          "description": "If true, this reference points to the managing controller.",
          "type": "boolean"
        },
        "kind": {
          "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "name": {
          "description": "Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names",
          "type": "string"
        },
        "uid": {
          "description": "UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
          "type": "string"
        }
      },
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference_v2": {
      "description": "OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.",
      "type": "object",
      "required": ["apiVersion", "kind", "name", "uid"],
      "properties": {
        "apiVersion": {
          "description": "API version of the referent.",
          "type": "string"
        },
        "blockOwnerDeletion": {
          "description": "If true, AND if the owner has the \"foregroundDeletion\" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \"delete\" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.",
          "type": "boolean"
        },
        "controller": {
          "description": "If true, this reference points to the managing controller.",
          "type": "boolean"
        },
        "kind": {
          "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "type": "string"
        },
        "name": {
          "description": "Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names",
          "type": "string"
        },
        "uid": {
          "description": "UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
          "type": "string"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.Patch": {
      "description": "Patch is provided to give a concrete name and type to the Kubernetes PATCH request body.",
      "type": "object"
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.Preconditions": {
      "description": "Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.",
      "type": "object",
      "properties": {
        "resourceVersion": {
          "description": "Specifies the target ResourceVersion",
          "type": "string"
        },
        "uid": {
          "description": "Specifies the target UID.",
          "type": "string"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR": {
      "description": "ServerAddressByClientCIDR helps the client to determine the server address that they should use, depending on the clientCIDR that they match.",
      "type": "object",
      "required": ["clientCIDR", "serverAddress"],
      "properties": {
        "clientCIDR": {
          "description": "The CIDR with which clients can match their IP to figure out the server address that they should use.",
          "type": "string"
        },
        "serverAddress": {
          "description": "Address of this server, suitable for a client that matches the above CIDR. This can be a hostname, hostname:port, IP or IP:port.",
          "type": "string"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.Status": {
      "description": "Status is a return value for calls that don't return other objects.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "code": {
          "description": "Suggested HTTP return code for this status, 0 if not set.",
          "type": "integer",
          "format": "int32"
        },
        "details": {
          "description": "Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Status"]
        },
        "message": {
          "description": "A human-readable description of the status of this operation.",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        },
        "reason": {
          "description": "A machine-readable description of why this operation is in the \"Failure\" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.",
          "type": "string"
        },
        "status": {
          "description": "Status of the operation. One of: \"Success\" or \"Failure\". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "type": "string"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "Status",
          "version": "v1"
        }
      ]
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.StatusCause": {
      "description": "StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered.",
      "type": "object",
      "properties": {
        "field": {
          "description": "The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.\n\nExamples:\n  \"name\" - the field \"name\" on the current resource\n  \"items[0].name\" - the field \"name\" on the first array entry in \"items\"",
          "type": "string"
        },
        "message": {
          "description": "A human-readable description of the cause of the error.  This field may be presented as-is to a reader.",
          "type": "string"
        },
        "reason": {
          "description": "A machine-readable description of the cause of the error. If this value is empty there is no information available.",
          "type": "string"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails": {
      "description": "StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.",
      "type": "object",
      "properties": {
        "causes": {
          "description": "The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.StatusCause"
          }
        },
        "group": {
          "description": "The group attribute of the resource associated with the status StatusReason.",
          "type": "string"
        },
        "kind": {
          "description": "The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "name": {
          "description": "The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).",
          "type": "string"
        },
        "retryAfterSeconds": {
          "description": "If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.",
          "type": "integer",
          "format": "int32"
        },
        "uid": {
          "description": "UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
          "type": "string"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails_v2": {
      "description": "StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.",
      "type": "object",
      "properties": {
        "causes": {
          "description": "The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.StatusCause"
          }
        },
        "group": {
          "description": "The group attribute of the resource associated with the status StatusReason.",
          "type": "string"
        },
        "kind": {
          "description": "The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "name": {
          "description": "The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).",
          "type": "string"
        },
        "retryAfterSeconds": {
          "description": "If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.",
          "type": "integer",
          "format": "int32"
        },
        "uid": {
          "description": "UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
          "type": "string"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails_v3": {
      "description": "StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.",
      "type": "object",
      "properties": {
        "causes": {
          "description": "The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.StatusCause"
          }
        },
        "group": {
          "description": "The group attribute of the resource associated with the status StatusReason.",
          "type": "string"
        },
        "kind": {
          "description": "The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "type": "string"
        },
        "name": {
          "description": "The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).",
          "type": "string"
        },
        "retryAfterSeconds": {
          "description": "If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.",
          "type": "integer",
          "format": "int32"
        },
        "uid": {
          "description": "UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
          "type": "string"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.Status_v2": {
      "description": "Status is a return value for calls that don't return other objects.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "code": {
          "description": "Suggested HTTP return code for this status, 0 if not set.",
          "type": "integer",
          "format": "int32"
        },
        "details": {
          "description": "Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails_v2"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "message": {
          "description": "A human-readable description of the status of this operation.",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        },
        "reason": {
          "description": "A machine-readable description of why this operation is in the \"Failure\" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.",
          "type": "string"
        },
        "status": {
          "description": "Status of the operation. One of: \"Success\" or \"Failure\". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
          "type": "string"
        }
      }
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.Status_v3": {
      "description": "Status is a return value for calls that don't return other objects.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
          "type": "string",
          "enum": ["v1"]
        },
        "code": {
          "description": "Suggested HTTP return code for this status, 0 if not set.",
          "type": "integer",
          "format": "int32"
        },
        "details": {
          "description": "Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails_v3"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["Status"]
        },
        "message": {
          "description": "A human-readable description of the status of this operation.",
          "type": "string"
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta_v2"
        },
        "reason": {
          "description": "A machine-readable description of why this operation is in the \"Failure\" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.",
          "type": "string"
        },
        "status": {
          "description": "Status of the operation. One of: \"Success\" or \"Failure\". More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status",
          "type": "string"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "Status",
          "version": "v1"
        }
      ]
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.Time": {
      "description": "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
      "type": "string",
      "format": "date-time"
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent": {
      "description": "Event represents a single event to a watched resource.",
      "type": "object",
      "required": ["type", "object"],
      "properties": {
        "object": {
          "description": "Object is:\n * If Type is Added or Modified: the new state of the object.\n * If Type is Deleted: the state of the object immediately before deletion.\n * If Type is Error: *Status is recommended; other types may make sense\n   depending on context.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.runtime.RawExtension"
        },
        "type": {
          "type": "string"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "admission.k8s.io",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "admission.k8s.io",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "admissionregistration.k8s.io",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "admissionregistration.k8s.io",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "apiextensions.k8s.io",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "apiextensions.k8s.io",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "apiregistration.k8s.io",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "apiregistration.k8s.io",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "apps",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "apps",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "apps",
          "kind": "WatchEvent",
          "version": "v1beta2"
        },
        {
          "group": "authentication.k8s.io",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "authentication.k8s.io",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "authorization.k8s.io",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "authorization.k8s.io",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "autoscaling",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "autoscaling",
          "kind": "WatchEvent",
          "version": "v2beta1"
        },
        {
          "group": "autoscaling",
          "kind": "WatchEvent",
          "version": "v2beta2"
        },
        {
          "group": "batch",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "batch",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "certificates.k8s.io",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "certificates.k8s.io",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "coordination.k8s.io",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "coordination.k8s.io",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "discovery.k8s.io",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "discovery.k8s.io",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "events.k8s.io",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "events.k8s.io",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "extensions",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "flowcontrol.apiserver.k8s.io",
          "kind": "WatchEvent",
          "version": "v1alpha1"
        },
        {
          "group": "flowcontrol.apiserver.k8s.io",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "imagepolicy.k8s.io",
          "kind": "WatchEvent",
          "version": "v1alpha1"
        },
        {
          "group": "internal.apiserver.k8s.io",
          "kind": "WatchEvent",
          "version": "v1alpha1"
        },
        {
          "group": "networking.k8s.io",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "networking.k8s.io",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "node.k8s.io",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "node.k8s.io",
          "kind": "WatchEvent",
          "version": "v1alpha1"
        },
        {
          "group": "node.k8s.io",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "policy",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "policy",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "rbac.authorization.k8s.io",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "rbac.authorization.k8s.io",
          "kind": "WatchEvent",
          "version": "v1alpha1"
        },
        {
          "group": "rbac.authorization.k8s.io",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "scheduling.k8s.io",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "scheduling.k8s.io",
          "kind": "WatchEvent",
          "version": "v1alpha1"
        },
        {
          "group": "scheduling.k8s.io",
          "kind": "WatchEvent",
          "version": "v1beta1"
        },
        {
          "group": "storage.k8s.io",
          "kind": "WatchEvent",
          "version": "v1"
        },
        {
          "group": "storage.k8s.io",
          "kind": "WatchEvent",
          "version": "v1alpha1"
        },
        {
          "group": "storage.k8s.io",
          "kind": "WatchEvent",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.apimachinery.pkg.runtime.RawExtension": {
      "description": "RawExtension is used to hold extensions in external versions.\n\nTo use this, make a field which has RawExtension as its type in your external, versioned struct, and Object in your internal struct. You also need to register your various plugin types.\n\n// Internal package: type MyAPIObject struct {\n\truntime.TypeMeta `json:\",inline\"`\n\tMyPlugin runtime.Object `json:\"myPlugin\"`\n} type PluginA struct {\n\tAOption string `json:\"aOption\"`\n}\n\n// External package: type MyAPIObject struct {\n\truntime.TypeMeta `json:\",inline\"`\n\tMyPlugin runtime.RawExtension `json:\"myPlugin\"`\n} type PluginA struct {\n\tAOption string `json:\"aOption\"`\n}\n\n// On the wire, the JSON will look something like this: {\n\t\"kind\":\"MyAPIObject\",\n\t\"apiVersion\":\"v1\",\n\t\"myPlugin\": {\n\t\t\"kind\":\"PluginA\",\n\t\t\"aOption\":\"foo\",\n\t},\n}\n\nSo what happens? Decode first uses json or yaml to unmarshal the serialized data into your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked. The next step is to copy (using pkg/conversion) into the internal struct. The runtime package's DefaultScheme has conversion functions installed which will unpack the JSON stored in RawExtension, turning it into the correct object type, and storing it in the Object. (TODO: In the case where the object is of an unknown type, a runtime.Unknown object will be created and stored.)",
      "type": "object"
    },
    "io.k8s.apimachinery.pkg.util.intstr.IntOrString": {
      "oneOf": [
        {
          "type": "string"
        },
        {
          "type": "integer"
        }
      ]
    },
    "io.k8s.apimachinery.pkg.version.Info": {
      "description": "Info contains versioning information. how we'll want to distribute that information.",
      "type": "object",
      "required": [
        "major",
        "minor",
        "gitVersion",
        "gitCommit",
        "gitTreeState",
        "buildDate",
        "goVersion",
        "compiler",
        "platform"
      ],
      "properties": {
        "buildDate": {
          "type": "string"
        },
        "compiler": {
          "type": "string"
        },
        "gitCommit": {
          "type": "string"
        },
        "gitTreeState": {
          "type": "string"
        },
        "gitVersion": {
          "type": "string"
        },
        "goVersion": {
          "type": "string"
        },
        "major": {
          "type": "string"
        },
        "minor": {
          "type": "string"
        },
        "platform": {
          "type": "string"
        }
      }
    },
    "io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIService": {
      "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\".",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["apiregistration.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["APIService"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec contains information for locating and communicating with a server",
          "$ref": "#/definitions/io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceSpec"
        },
        "status": {
          "description": "Status contains derived information about an API server",
          "$ref": "#/definitions/io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apiregistration.k8s.io",
          "kind": "APIService",
          "version": "v1"
        }
      ]
    },
    "io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceCondition": {
      "description": "APIServiceCondition describes the state of an APIService at a particular point",
      "type": "object",
      "required": ["type", "status"],
      "properties": {
        "lastTransitionTime": {
          "description": "Last time the condition transitioned from one status to another.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "Human-readable message indicating details about last transition.",
          "type": "string"
        },
        "reason": {
          "description": "Unique, one-word, CamelCase reason for the condition's last transition.",
          "type": "string"
        },
        "status": {
          "description": "Status is the status of the condition. Can be True, False, Unknown.",
          "type": "string"
        },
        "type": {
          "description": "Type is the type of the condition.",
          "type": "string"
        }
      }
    },
    "io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceList": {
      "description": "APIServiceList is a list of APIService objects.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["apiregistration.k8s.io/v1"]
        },
        "items": {
          "description": "Items is the list of APIService",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIService"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["APIServiceList"]
        },
        "metadata": {
          "description": "Standard list metadata More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "apiregistration.k8s.io",
          "kind": "APIServiceList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceSpec": {
      "description": "APIServiceSpec contains information for locating and communicating with a server. Only https is supported, though you are able to disable certificate verification.",
      "type": "object",
      "required": ["groupPriorityMinimum", "versionPriority"],
      "properties": {
        "caBundle": {
          "description": "CABundle is a PEM encoded CA bundle which will be used to validate an API server's serving certificate. If unspecified, system trust roots on the apiserver are used.",
          "type": "string",
          "format": "byte",
          "x-kubernetes-list-type": "atomic"
        },
        "group": {
          "description": "Group is the API group name this server hosts",
          "type": "string"
        },
        "groupPriorityMinimum": {
          "description": "GroupPriorityMininum is the priority this group should have at least. Higher priority means that the group is preferred by clients over lower priority ones. Note that other versions of this group might specify even higher GroupPriorityMininum values such that the whole group gets a higher priority. The primary sort is based on GroupPriorityMinimum, ordered highest number to lowest (20 before 10). The secondary sort is based on the alphabetical comparison of the name of the object.  (v1.bar before v1.foo) We'd recommend something like: *.k8s.io (except extensions) at 18000 and PaaSes (OpenShift, Deis) are recommended to be in the 2000s",
          "type": "integer",
          "format": "int32"
        },
        "insecureSkipTLSVerify": {
          "description": "InsecureSkipTLSVerify disables TLS certificate verification when communicating with this server. This is strongly discouraged.  You should use the CABundle instead.",
          "type": "boolean"
        },
        "service": {
          "description": "Service is a reference to the service for this API server.  It must communicate on port 443. If the Service is nil, that means the handling for the API groupversion is handled locally on this server. The call will simply delegate to the normal handler chain to be fulfilled.",
          "$ref": "#/definitions/io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.ServiceReference"
        },
        "version": {
          "description": "Version is the API version this server hosts.  For example, \"v1\"",
          "type": "string"
        },
        "versionPriority": {
          "description": "VersionPriority controls the ordering of this API version inside of its group.  Must be greater than zero. The primary sort is based on VersionPriority, ordered highest to lowest (20 before 10). Since it's inside of a group, the number can be small, probably in the 10s. In case of equal version priorities, the version string will be used to compute the order inside a group. If the version string is \"kube-like\", it will sort above non \"kube-like\" version strings, which are ordered lexicographically. \"Kube-like\" versions start with a \"v\", then are followed by a number (the major version), then optionally the string \"alpha\" or \"beta\" and another number (the minor version). These are sorted first by GA > beta > alpha (where GA is a version with no suffix such as beta or alpha), and then by comparing major version, then minor version. An example sorted list of versions: v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceStatus": {
      "description": "APIServiceStatus contains derived information about an API server",
      "type": "object",
      "properties": {
        "conditions": {
          "description": "Current service state of apiService.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceCondition"
          },
          "x-kubernetes-list-map-keys": ["type"],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        }
      }
    },
    "io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.ServiceReference": {
      "description": "ServiceReference holds a reference to Service.legacy.k8s.io",
      "type": "object",
      "properties": {
        "name": {
          "description": "Name is the name of the service",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace is the namespace of the service",
          "type": "string"
        },
        "port": {
          "description": "If specified, the port on the service that hosting webhook. Default to 443 for backward compatibility. `port` should be a valid port number (1-65535, inclusive).",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.metrics.pkg.apis.metrics.v1beta1.ContainerMetrics": {
      "description": "ContainerMetrics sets resource usage metrics of a container.",
      "type": "object",
      "required": ["name", "usage"],
      "properties": {
        "name": {
          "description": "Container name corresponding to the one from pod.spec.containers.",
          "type": "string"
        },
        "usage": {
          "description": "The memory usage is the memory working set.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity_v2"
          }
        }
      }
    },
    "io.k8s.metrics.pkg.apis.metrics.v1beta1.NodeMetrics": {
      "description": "NodeMetrics sets resource usage metrics of a node.",
      "type": "object",
      "required": ["timestamp", "window", "usage"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
          "type": "string",
          "enum": ["metrics.k8s.io/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NodeMetrics"]
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "timestamp": {
          "description": "The following fields define time interval from which metrics were collected from the interval [Timestamp-Window, Timestamp].",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "usage": {
          "description": "The memory usage is the memory working set.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity_v2"
          }
        },
        "window": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "metrics.k8s.io",
          "kind": "NodeMetrics",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.metrics.pkg.apis.metrics.v1beta1.NodeMetricsList": {
      "description": "NodeMetricsList is a list of NodeMetrics.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
          "type": "string",
          "enum": ["metrics.k8s.io/v1beta1"]
        },
        "items": {
          "description": "List of node metrics.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.metrics.pkg.apis.metrics.v1beta1.NodeMetrics"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["NodeMetricsList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta_v2"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "metrics.k8s.io",
          "kind": "NodeMetricsList",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.metrics.pkg.apis.metrics.v1beta1.PodMetrics": {
      "description": "PodMetrics sets resource usage metrics of a pod.",
      "type": "object",
      "required": ["timestamp", "window", "containers"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
          "type": "string",
          "enum": ["metrics.k8s.io/v1beta1"]
        },
        "containers": {
          "description": "Metrics for all containers are collected within the same time window.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.metrics.pkg.apis.metrics.v1beta1.ContainerMetrics"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PodMetrics"]
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
        },
        "timestamp": {
          "description": "The following fields define time interval from which metrics were collected from the interval [Timestamp-Window, Timestamp].",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "window": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "metrics.k8s.io",
          "kind": "PodMetrics",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.metrics.pkg.apis.metrics.v1beta1.PodMetricsList": {
      "description": "PodMetricsList is a list of PodMetrics.",
      "type": "object",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
          "type": "string",
          "enum": ["metrics.k8s.io/v1beta1"]
        },
        "items": {
          "description": "List of pod metrics.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.metrics.pkg.apis.metrics.v1beta1.PodMetrics"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["PodMetricsList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta_v2"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "metrics.k8s.io",
          "kind": "PodMetricsList",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.migration.v1alpha1.StorageState": {
      "description": "The state of the storage of a specific resource.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["migration.k8s.io/v1alpha1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StorageState"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Specification of the storage state.",
          "type": "object",
          "properties": {
            "resource": {
              "description": "The resource this storageState is about.",
              "type": "object",
              "properties": {
                "group": {
                  "description": "The name of the group.",
                  "type": "string"
                },
                "resource": {
                  "description": "The name of the resource.",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "description": "Status of the storage state.",
          "type": "object",
          "properties": {
            "currentStorageVersionHash": {
              "description": "The hash value of the current storage version, as shown in the discovery document served by the API server. Storage Version is the version to which objects are converted to before persisted.",
              "type": "string"
            },
            "lastHeartbeatTime": {
              "description": "LastHeartbeatTime is the last time the storage migration triggering controller checks the storage version hash of this resource in the discovery document and updates this field.",
              "type": "string",
              "format": "date-time"
            },
            "persistedStorageVersionHashes": {
              "description": "The hash values of storage versions that persisted instances of spec.resource might still be encoded in. \"Unknown\" is a valid value in the list, and is the default value. It is not safe to upgrade or downgrade to an apiserver binary that does not support all versions listed in this field, or if \"Unknown\" is listed. Once the storage version migration for this resource has completed, the value of this field is refined to only contain the currentStorageVersionHash. Once the apiserver has changed the storage version, the new storage version is appended to the list.",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "migration.k8s.io",
          "kind": "StorageState",
          "version": "v1alpha1"
        }
      ]
    },
    "io.k8s.migration.v1alpha1.StorageStateList": {
      "description": "StorageStateList is a list of StorageState",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["migration.k8s.io/v1alpha1"]
        },
        "items": {
          "description": "List of storagestates. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.migration.v1alpha1.StorageState"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StorageStateList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "migration.k8s.io",
          "kind": "StorageStateList",
          "version": "v1alpha1"
        }
      ]
    },
    "io.k8s.migration.v1alpha1.StorageVersionMigration": {
      "description": "StorageVersionMigration represents a migration of stored data to the latest storage version.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["migration.k8s.io/v1alpha1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StorageVersionMigration"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Specification of the migration.",
          "type": "object",
          "required": ["resource"],
          "properties": {
            "continueToken": {
              "description": "The token used in the list options to get the next chunk of objects to migrate. When the .status.conditions indicates the migration is \"Running\", users can use this token to check the progress of the migration.",
              "type": "string"
            },
            "resource": {
              "description": "The resource that is being migrated. The migrator sends requests to the endpoint serving the resource. Immutable.",
              "type": "object",
              "properties": {
                "group": {
                  "description": "The name of the group.",
                  "type": "string"
                },
                "resource": {
                  "description": "The name of the resource.",
                  "type": "string"
                },
                "version": {
                  "description": "The name of the version.",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "description": "Status of the migration.",
          "type": "object",
          "properties": {
            "conditions": {
              "description": "The latest available observations of the migration's current state.",
              "type": "array",
              "items": {
                "description": "Describes the state of a migration at a certain point.",
                "type": "object",
                "required": ["status", "type"],
                "properties": {
                  "lastUpdateTime": {
                    "description": "The last time this condition was updated.",
                    "type": "string",
                    "format": "date-time"
                  },
                  "message": {
                    "description": "A human readable message indicating details about the transition.",
                    "type": "string"
                  },
                  "reason": {
                    "description": "The reason for the condition's last transition.",
                    "type": "string"
                  },
                  "status": {
                    "description": "Status of the condition, one of True, False, Unknown.",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type of the condition.",
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "migration.k8s.io",
          "kind": "StorageVersionMigration",
          "version": "v1alpha1"
        }
      ]
    },
    "io.k8s.migration.v1alpha1.StorageVersionMigrationList": {
      "description": "StorageVersionMigrationList is a list of StorageVersionMigration",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["migration.k8s.io/v1alpha1"]
        },
        "items": {
          "description": "List of storageversionmigrations. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.migration.v1alpha1.StorageVersionMigration"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["StorageVersionMigrationList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "migration.k8s.io",
          "kind": "StorageVersionMigrationList",
          "version": "v1alpha1"
        }
      ]
    },
    "io.k8s.storage.snapshot.v1.VolumeSnapshot": {
      "description": "VolumeSnapshot is a user's request for either creating a point-in-time snapshot of a persistent volume, or binding to a pre-existing snapshot.",
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["snapshot.storage.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["VolumeSnapshot"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "spec defines the desired characteristics of a snapshot requested by a user. More info: https://kubernetes.io/docs/concepts/storage/volume-snapshots#volumesnapshots Required.",
          "type": "object",
          "required": ["source"],
          "properties": {
            "source": {
              "description": "source specifies where a snapshot will be created from. This field is immutable after creation. Required.",
              "type": "object",
              "properties": {
                "persistentVolumeClaimName": {
                  "description": "persistentVolumeClaimName specifies the name of the PersistentVolumeClaim object representing the volume from which a snapshot should be created. This PVC is assumed to be in the same namespace as the VolumeSnapshot object. This field should be set if the snapshot does not exists, and needs to be created. This field is immutable.",
                  "type": "string"
                },
                "volumeSnapshotContentName": {
                  "description": "volumeSnapshotContentName specifies the name of a pre-existing VolumeSnapshotContent object representing an existing volume snapshot. This field should be set if the snapshot already exists and only needs a representation in Kubernetes. This field is immutable.",
                  "type": "string"
                }
              }
            },
            "volumeSnapshotClassName": {
              "description": "VolumeSnapshotClassName is the name of the VolumeSnapshotClass requested by the VolumeSnapshot. VolumeSnapshotClassName may be left nil to indicate that the default SnapshotClass should be used. A given cluster may have multiple default Volume SnapshotClasses: one default per CSI Driver. If a VolumeSnapshot does not specify a SnapshotClass, VolumeSnapshotSource will be checked to figure out what the associated CSI Driver is, and the default VolumeSnapshotClass associated with that CSI Driver will be used. If more than one VolumeSnapshotClass exist for a given CSI Driver and more than one have been marked as default, CreateSnapshot will fail and generate an event. Empty string is not allowed for this field.",
              "type": "string"
            }
          }
        },
        "status": {
          "description": "status represents the current information of a snapshot. Consumers must verify binding between VolumeSnapshot and VolumeSnapshotContent objects is successful (by validating that both VolumeSnapshot and VolumeSnapshotContent point at each other) before using this object.",
          "type": "object",
          "properties": {
            "boundVolumeSnapshotContentName": {
              "description": "boundVolumeSnapshotContentName is the name of the VolumeSnapshotContent object to which this VolumeSnapshot object intends to bind to. If not specified, it indicates that the VolumeSnapshot object has not been successfully bound to a VolumeSnapshotContent object yet. NOTE: To avoid possible security issues, consumers must verify binding between VolumeSnapshot and VolumeSnapshotContent objects is successful (by validating that both VolumeSnapshot and VolumeSnapshotContent point at each other) before using this object.",
              "type": "string"
            },
            "creationTime": {
              "description": "creationTime is the timestamp when the point-in-time snapshot is taken by the underlying storage system. In dynamic snapshot creation case, this field will be filled in by the snapshot controller with the \"creation_time\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"creation_time\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it. If not specified, it may indicate that the creation time of the snapshot is unknown.",
              "type": "string",
              "format": "date-time"
            },
            "error": {
              "description": "error is the last observed error during snapshot creation, if any. This field could be helpful to upper level controllers(i.e., application controller) to decide whether they should continue on waiting for the snapshot to be created based on the type of error reported. The snapshot controller will keep retrying when an error occurrs during the snapshot creation. Upon success, this error field will be cleared.",
              "type": "object",
              "properties": {
                "message": {
                  "description": "message is a string detailing the encountered error during snapshot creation if specified. NOTE: message may be logged, and it should not contain sensitive information.",
                  "type": "string"
                },
                "time": {
                  "description": "time is the timestamp when the error was encountered.",
                  "type": "string",
                  "format": "date-time"
                }
              }
            },
            "readyToUse": {
              "description": "readyToUse indicates if the snapshot is ready to be used to restore a volume. In dynamic snapshot creation case, this field will be filled in by the snapshot controller with the \"ready_to_use\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"ready_to_use\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it, otherwise, this field will be set to \"True\". If not specified, it means the readiness of a snapshot is unknown.",
              "type": "boolean"
            },
            "restoreSize": {
              "description": "restoreSize represents the minimum size of volume required to create a volume from this snapshot. In dynamic snapshot creation case, this field will be filled in by the snapshot controller with the \"size_bytes\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"size_bytes\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it. When restoring a volume from this snapshot, the size of the volume MUST NOT be smaller than the restoreSize if it is specified, otherwise the restoration will fail. If not specified, it indicates that the size is unknown.",
              "type": "string",
              "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
              "x-kubernetes-int-or-string": true
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "snapshot.storage.k8s.io",
          "kind": "VolumeSnapshot",
          "version": "v1"
        }
      ]
    },
    "io.k8s.storage.snapshot.v1.VolumeSnapshotClass": {
      "description": "VolumeSnapshotClass specifies parameters that a underlying storage system uses when creating a volume snapshot. A specific VolumeSnapshotClass is used by specifying its name in a VolumeSnapshot object. VolumeSnapshotClasses are non-namespaced",
      "type": "object",
      "required": ["deletionPolicy", "driver"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["snapshot.storage.k8s.io/v1"]
        },
        "deletionPolicy": {
          "description": "deletionPolicy determines whether a VolumeSnapshotContent created through the VolumeSnapshotClass should be deleted when its bound VolumeSnapshot is deleted. Supported values are \"Retain\" and \"Delete\". \"Retain\" means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are kept. \"Delete\" means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are deleted. Required.",
          "type": "string",
          "enum": ["Delete", "Retain"]
        },
        "driver": {
          "description": "driver is the name of the storage driver that handles this VolumeSnapshotClass. Required.",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["VolumeSnapshotClass"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "parameters": {
          "description": "parameters is a key-value map with storage driver specific parameters for creating snapshots. These values are opaque to Kubernetes.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "snapshot.storage.k8s.io",
          "kind": "VolumeSnapshotClass",
          "version": "v1"
        }
      ]
    },
    "io.k8s.storage.snapshot.v1.VolumeSnapshotClassList": {
      "description": "VolumeSnapshotClassList is a list of VolumeSnapshotClass",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["snapshot.storage.k8s.io/v1"]
        },
        "items": {
          "description": "List of volumesnapshotclasses. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.storage.snapshot.v1.VolumeSnapshotClass"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["VolumeSnapshotClassList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "snapshot.storage.k8s.io",
          "kind": "VolumeSnapshotClassList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.storage.snapshot.v1.VolumeSnapshotContent": {
      "description": "VolumeSnapshotContent represents the actual \"on-disk\" snapshot object in the underlying storage system",
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["snapshot.storage.k8s.io/v1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["VolumeSnapshotContent"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "spec defines properties of a VolumeSnapshotContent created by the underlying storage system. Required.",
          "type": "object",
          "required": [
            "deletionPolicy",
            "driver",
            "source",
            "volumeSnapshotRef"
          ],
          "properties": {
            "deletionPolicy": {
              "description": "deletionPolicy determines whether this VolumeSnapshotContent and its physical snapshot on the underlying storage system should be deleted when its bound VolumeSnapshot is deleted. Supported values are \"Retain\" and \"Delete\". \"Retain\" means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are kept. \"Delete\" means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are deleted. For dynamically provisioned snapshots, this field will automatically be filled in by the CSI snapshotter sidecar with the \"DeletionPolicy\" field defined in the corresponding VolumeSnapshotClass. For pre-existing snapshots, users MUST specify this field when creating the  VolumeSnapshotContent object. Required.",
              "type": "string",
              "enum": ["Delete", "Retain"]
            },
            "driver": {
              "description": "driver is the name of the CSI driver used to create the physical snapshot on the underlying storage system. This MUST be the same as the name returned by the CSI GetPluginName() call for that driver. Required.",
              "type": "string"
            },
            "source": {
              "description": "source specifies whether the snapshot is (or should be) dynamically provisioned or already exists, and just requires a Kubernetes object representation. This field is immutable after creation. Required.",
              "type": "object",
              "properties": {
                "snapshotHandle": {
                  "description": "snapshotHandle specifies the CSI \"snapshot_id\" of a pre-existing snapshot on the underlying storage system for which a Kubernetes object representation was (or should be) created. This field is immutable.",
                  "type": "string"
                },
                "volumeHandle": {
                  "description": "volumeHandle specifies the CSI \"volume_id\" of the volume from which a snapshot should be dynamically taken from. This field is immutable.",
                  "type": "string"
                }
              }
            },
            "volumeSnapshotClassName": {
              "description": "name of the VolumeSnapshotClass from which this snapshot was (or will be) created. Note that after provisioning, the VolumeSnapshotClass may be deleted or recreated with different set of values, and as such, should not be referenced post-snapshot creation.",
              "type": "string"
            },
            "volumeSnapshotRef": {
              "description": "volumeSnapshotRef specifies the VolumeSnapshot object to which this VolumeSnapshotContent object is bound. VolumeSnapshot.Spec.VolumeSnapshotContentName field must reference to this VolumeSnapshotContent's name for the bidirectional binding to be valid. For a pre-existing VolumeSnapshotContent object, name and namespace of the VolumeSnapshot object MUST be provided for binding to happen. This field is immutable after creation. Required.",
              "type": "object",
              "properties": {
                "apiVersion": {
                  "description": "API version of the referent.",
                  "type": "string"
                },
                "fieldPath": {
                  "description": "If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \"spec.containers{name}\" (where \"name\" refers to the name of the container that triggered the event) or if no container name is specified \"spec.containers[2]\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.",
                  "type": "string"
                },
                "kind": {
                  "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                },
                "resourceVersion": {
                  "description": "Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
                  "type": "string"
                },
                "uid": {
                  "description": "UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "description": "status represents the current information of a snapshot.",
          "type": "object",
          "properties": {
            "creationTime": {
              "description": "creationTime is the timestamp when the point-in-time snapshot is taken by the underlying storage system. In dynamic snapshot creation case, this field will be filled in by the CSI snapshotter sidecar with the \"creation_time\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"creation_time\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it. If not specified, it indicates the creation time is unknown. The format of this field is a Unix nanoseconds time encoded as an int64. On Unix, the command `date +%s%N` returns the current time in nanoseconds since 1970-01-01 00:00:00 UTC.",
              "type": "integer",
              "format": "int64"
            },
            "error": {
              "description": "error is the last observed error during snapshot creation, if any. Upon success after retry, this error field will be cleared.",
              "type": "object",
              "properties": {
                "message": {
                  "description": "message is a string detailing the encountered error during snapshot creation if specified. NOTE: message may be logged, and it should not contain sensitive information.",
                  "type": "string"
                },
                "time": {
                  "description": "time is the timestamp when the error was encountered.",
                  "type": "string",
                  "format": "date-time"
                }
              }
            },
            "readyToUse": {
              "description": "readyToUse indicates if a snapshot is ready to be used to restore a volume. In dynamic snapshot creation case, this field will be filled in by the CSI snapshotter sidecar with the \"ready_to_use\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"ready_to_use\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it, otherwise, this field will be set to \"True\". If not specified, it means the readiness of a snapshot is unknown.",
              "type": "boolean"
            },
            "restoreSize": {
              "description": "restoreSize represents the complete size of the snapshot in bytes. In dynamic snapshot creation case, this field will be filled in by the CSI snapshotter sidecar with the \"size_bytes\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"size_bytes\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it. When restoring a volume from this snapshot, the size of the volume MUST NOT be smaller than the restoreSize if it is specified, otherwise the restoration will fail. If not specified, it indicates that the size is unknown.",
              "type": "integer",
              "format": "int64",
              "minimum": 0
            },
            "snapshotHandle": {
              "description": "snapshotHandle is the CSI \"snapshot_id\" of a snapshot on the underlying storage system. If not specified, it indicates that dynamic snapshot creation has either failed or it is still in progress.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "snapshot.storage.k8s.io",
          "kind": "VolumeSnapshotContent",
          "version": "v1"
        }
      ]
    },
    "io.k8s.storage.snapshot.v1.VolumeSnapshotContentList": {
      "description": "VolumeSnapshotContentList is a list of VolumeSnapshotContent",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["snapshot.storage.k8s.io/v1"]
        },
        "items": {
          "description": "List of volumesnapshotcontents. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.storage.snapshot.v1.VolumeSnapshotContent"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["VolumeSnapshotContentList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "snapshot.storage.k8s.io",
          "kind": "VolumeSnapshotContentList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.storage.snapshot.v1.VolumeSnapshotList": {
      "description": "VolumeSnapshotList is a list of VolumeSnapshot",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["snapshot.storage.k8s.io/v1"]
        },
        "items": {
          "description": "List of volumesnapshots. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.storage.snapshot.v1.VolumeSnapshot"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["VolumeSnapshotList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "snapshot.storage.k8s.io",
          "kind": "VolumeSnapshotList",
          "version": "v1"
        }
      ]
    },
    "io.k8s.storage.snapshot.v1beta1.VolumeSnapshot": {
      "description": "VolumeSnapshot is a user's request for either creating a point-in-time snapshot of a persistent volume, or binding to a pre-existing snapshot.",
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["snapshot.storage.k8s.io/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["VolumeSnapshot"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "spec defines the desired characteristics of a snapshot requested by a user. More info: https://kubernetes.io/docs/concepts/storage/volume-snapshots#volumesnapshots Required.",
          "type": "object",
          "required": ["source"],
          "properties": {
            "source": {
              "description": "source specifies where a snapshot will be created from. This field is immutable after creation. Required.",
              "type": "object",
              "properties": {
                "persistentVolumeClaimName": {
                  "description": "persistentVolumeClaimName specifies the name of the PersistentVolumeClaim object representing the volume from which a snapshot should be created. This PVC is assumed to be in the same namespace as the VolumeSnapshot object. This field should be set if the snapshot does not exists, and needs to be created. This field is immutable.",
                  "type": "string"
                },
                "volumeSnapshotContentName": {
                  "description": "volumeSnapshotContentName specifies the name of a pre-existing VolumeSnapshotContent object representing an existing volume snapshot. This field should be set if the snapshot already exists and only needs a representation in Kubernetes. This field is immutable.",
                  "type": "string"
                }
              }
            },
            "volumeSnapshotClassName": {
              "description": "VolumeSnapshotClassName is the name of the VolumeSnapshotClass requested by the VolumeSnapshot. VolumeSnapshotClassName may be left nil to indicate that the default SnapshotClass should be used. A given cluster may have multiple default Volume SnapshotClasses: one default per CSI Driver. If a VolumeSnapshot does not specify a SnapshotClass, VolumeSnapshotSource will be checked to figure out what the associated CSI Driver is, and the default VolumeSnapshotClass associated with that CSI Driver will be used. If more than one VolumeSnapshotClass exist for a given CSI Driver and more than one have been marked as default, CreateSnapshot will fail and generate an event. Empty string is not allowed for this field.",
              "type": "string"
            }
          }
        },
        "status": {
          "description": "status represents the current information of a snapshot. Consumers must verify binding between VolumeSnapshot and VolumeSnapshotContent objects is successful (by validating that both VolumeSnapshot and VolumeSnapshotContent point at each other) before using this object.",
          "type": "object",
          "properties": {
            "boundVolumeSnapshotContentName": {
              "description": "boundVolumeSnapshotContentName is the name of the VolumeSnapshotContent object to which this VolumeSnapshot object intends to bind to. If not specified, it indicates that the VolumeSnapshot object has not been successfully bound to a VolumeSnapshotContent object yet. NOTE: To avoid possible security issues, consumers must verify binding between VolumeSnapshot and VolumeSnapshotContent objects is successful (by validating that both VolumeSnapshot and VolumeSnapshotContent point at each other) before using this object.",
              "type": "string"
            },
            "creationTime": {
              "description": "creationTime is the timestamp when the point-in-time snapshot is taken by the underlying storage system. In dynamic snapshot creation case, this field will be filled in by the snapshot controller with the \"creation_time\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"creation_time\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it. If not specified, it may indicate that the creation time of the snapshot is unknown.",
              "type": "string",
              "format": "date-time"
            },
            "error": {
              "description": "error is the last observed error during snapshot creation, if any. This field could be helpful to upper level controllers(i.e., application controller) to decide whether they should continue on waiting for the snapshot to be created based on the type of error reported. The snapshot controller will keep retrying when an error occurrs during the snapshot creation. Upon success, this error field will be cleared.",
              "type": "object",
              "properties": {
                "message": {
                  "description": "message is a string detailing the encountered error during snapshot creation if specified. NOTE: message may be logged, and it should not contain sensitive information.",
                  "type": "string"
                },
                "time": {
                  "description": "time is the timestamp when the error was encountered.",
                  "type": "string",
                  "format": "date-time"
                }
              }
            },
            "readyToUse": {
              "description": "readyToUse indicates if the snapshot is ready to be used to restore a volume. In dynamic snapshot creation case, this field will be filled in by the snapshot controller with the \"ready_to_use\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"ready_to_use\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it, otherwise, this field will be set to \"True\". If not specified, it means the readiness of a snapshot is unknown.",
              "type": "boolean"
            },
            "restoreSize": {
              "description": "restoreSize represents the minimum size of volume required to create a volume from this snapshot. In dynamic snapshot creation case, this field will be filled in by the snapshot controller with the \"size_bytes\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"size_bytes\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it. When restoring a volume from this snapshot, the size of the volume MUST NOT be smaller than the restoreSize if it is specified, otherwise the restoration will fail. If not specified, it indicates that the size is unknown.",
              "type": "string",
              "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
              "x-kubernetes-int-or-string": true
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "snapshot.storage.k8s.io",
          "kind": "VolumeSnapshot",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.storage.snapshot.v1beta1.VolumeSnapshotClass": {
      "description": "VolumeSnapshotClass specifies parameters that a underlying storage system uses when creating a volume snapshot. A specific VolumeSnapshotClass is used by specifying its name in a VolumeSnapshot object. VolumeSnapshotClasses are non-namespaced",
      "type": "object",
      "required": ["deletionPolicy", "driver"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["snapshot.storage.k8s.io/v1beta1"]
        },
        "deletionPolicy": {
          "description": "deletionPolicy determines whether a VolumeSnapshotContent created through the VolumeSnapshotClass should be deleted when its bound VolumeSnapshot is deleted. Supported values are \"Retain\" and \"Delete\". \"Retain\" means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are kept. \"Delete\" means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are deleted. Required.",
          "type": "string",
          "enum": ["Delete", "Retain"]
        },
        "driver": {
          "description": "driver is the name of the storage driver that handles this VolumeSnapshotClass. Required.",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["VolumeSnapshotClass"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "parameters": {
          "description": "parameters is a key-value map with storage driver specific parameters for creating snapshots. These values are opaque to Kubernetes.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "snapshot.storage.k8s.io",
          "kind": "VolumeSnapshotClass",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.storage.snapshot.v1beta1.VolumeSnapshotClassList": {
      "description": "VolumeSnapshotClassList is a list of VolumeSnapshotClass",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["snapshot.storage.k8s.io/v1beta1"]
        },
        "items": {
          "description": "List of volumesnapshotclasses. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.storage.snapshot.v1beta1.VolumeSnapshotClass"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["VolumeSnapshotClassList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "snapshot.storage.k8s.io",
          "kind": "VolumeSnapshotClassList",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.storage.snapshot.v1beta1.VolumeSnapshotContent": {
      "description": "VolumeSnapshotContent represents the actual \"on-disk\" snapshot object in the underlying storage system",
      "type": "object",
      "required": ["spec"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["snapshot.storage.k8s.io/v1beta1"]
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["VolumeSnapshotContent"]
        },
        "metadata": {
          "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "spec defines properties of a VolumeSnapshotContent created by the underlying storage system. Required.",
          "type": "object",
          "required": [
            "deletionPolicy",
            "driver",
            "source",
            "volumeSnapshotRef"
          ],
          "properties": {
            "deletionPolicy": {
              "description": "deletionPolicy determines whether this VolumeSnapshotContent and its physical snapshot on the underlying storage system should be deleted when its bound VolumeSnapshot is deleted. Supported values are \"Retain\" and \"Delete\". \"Retain\" means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are kept. \"Delete\" means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are deleted. For dynamically provisioned snapshots, this field will automatically be filled in by the CSI snapshotter sidecar with the \"DeletionPolicy\" field defined in the corresponding VolumeSnapshotClass. For pre-existing snapshots, users MUST specify this field when creating the  VolumeSnapshotContent object. Required.",
              "type": "string",
              "enum": ["Delete", "Retain"]
            },
            "driver": {
              "description": "driver is the name of the CSI driver used to create the physical snapshot on the underlying storage system. This MUST be the same as the name returned by the CSI GetPluginName() call for that driver. Required.",
              "type": "string"
            },
            "source": {
              "description": "source specifies whether the snapshot is (or should be) dynamically provisioned or already exists, and just requires a Kubernetes object representation. This field is immutable after creation. Required.",
              "type": "object",
              "properties": {
                "snapshotHandle": {
                  "description": "snapshotHandle specifies the CSI \"snapshot_id\" of a pre-existing snapshot on the underlying storage system for which a Kubernetes object representation was (or should be) created. This field is immutable.",
                  "type": "string"
                },
                "volumeHandle": {
                  "description": "volumeHandle specifies the CSI \"volume_id\" of the volume from which a snapshot should be dynamically taken from. This field is immutable.",
                  "type": "string"
                }
              }
            },
            "volumeSnapshotClassName": {
              "description": "name of the VolumeSnapshotClass from which this snapshot was (or will be) created. Note that after provisioning, the VolumeSnapshotClass may be deleted or recreated with different set of values, and as such, should not be referenced post-snapshot creation.",
              "type": "string"
            },
            "volumeSnapshotRef": {
              "description": "volumeSnapshotRef specifies the VolumeSnapshot object to which this VolumeSnapshotContent object is bound. VolumeSnapshot.Spec.VolumeSnapshotContentName field must reference to this VolumeSnapshotContent's name for the bidirectional binding to be valid. For a pre-existing VolumeSnapshotContent object, name and namespace of the VolumeSnapshot object MUST be provided for binding to happen. This field is immutable after creation. Required.",
              "type": "object",
              "properties": {
                "apiVersion": {
                  "description": "API version of the referent.",
                  "type": "string"
                },
                "fieldPath": {
                  "description": "If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \"spec.containers{name}\" (where \"name\" refers to the name of the container that triggered the event) or if no container name is specified \"spec.containers[2]\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.",
                  "type": "string"
                },
                "kind": {
                  "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                },
                "resourceVersion": {
                  "description": "Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
                  "type": "string"
                },
                "uid": {
                  "description": "UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids",
                  "type": "string"
                }
              }
            }
          }
        },
        "status": {
          "description": "status represents the current information of a snapshot.",
          "type": "object",
          "properties": {
            "creationTime": {
              "description": "creationTime is the timestamp when the point-in-time snapshot is taken by the underlying storage system. In dynamic snapshot creation case, this field will be filled in by the CSI snapshotter sidecar with the \"creation_time\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"creation_time\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it. If not specified, it indicates the creation time is unknown. The format of this field is a Unix nanoseconds time encoded as an int64. On Unix, the command `date +%s%N` returns the current time in nanoseconds since 1970-01-01 00:00:00 UTC.",
              "type": "integer",
              "format": "int64"
            },
            "error": {
              "description": "error is the last observed error during snapshot creation, if any. Upon success after retry, this error field will be cleared.",
              "type": "object",
              "properties": {
                "message": {
                  "description": "message is a string detailing the encountered error during snapshot creation if specified. NOTE: message may be logged, and it should not contain sensitive information.",
                  "type": "string"
                },
                "time": {
                  "description": "time is the timestamp when the error was encountered.",
                  "type": "string",
                  "format": "date-time"
                }
              }
            },
            "readyToUse": {
              "description": "readyToUse indicates if a snapshot is ready to be used to restore a volume. In dynamic snapshot creation case, this field will be filled in by the CSI snapshotter sidecar with the \"ready_to_use\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"ready_to_use\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it, otherwise, this field will be set to \"True\". If not specified, it means the readiness of a snapshot is unknown.",
              "type": "boolean"
            },
            "restoreSize": {
              "description": "restoreSize represents the complete size of the snapshot in bytes. In dynamic snapshot creation case, this field will be filled in by the CSI snapshotter sidecar with the \"size_bytes\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"size_bytes\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it. When restoring a volume from this snapshot, the size of the volume MUST NOT be smaller than the restoreSize if it is specified, otherwise the restoration will fail. If not specified, it indicates that the size is unknown.",
              "type": "integer",
              "format": "int64",
              "minimum": 0
            },
            "snapshotHandle": {
              "description": "snapshotHandle is the CSI \"snapshot_id\" of a snapshot on the underlying storage system. If not specified, it indicates that dynamic snapshot creation has either failed or it is still in progress.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "snapshot.storage.k8s.io",
          "kind": "VolumeSnapshotContent",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.storage.snapshot.v1beta1.VolumeSnapshotContentList": {
      "description": "VolumeSnapshotContentList is a list of VolumeSnapshotContent",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["snapshot.storage.k8s.io/v1beta1"]
        },
        "items": {
          "description": "List of volumesnapshotcontents. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.storage.snapshot.v1beta1.VolumeSnapshotContent"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["VolumeSnapshotContentList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "snapshot.storage.k8s.io",
          "kind": "VolumeSnapshotContentList",
          "version": "v1beta1"
        }
      ]
    },
    "io.k8s.storage.snapshot.v1beta1.VolumeSnapshotList": {
      "description": "VolumeSnapshotList is a list of VolumeSnapshot",
      "required": ["items"],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string",
          "enum": ["snapshot.storage.k8s.io/v1beta1"]
        },
        "items": {
          "description": "List of volumesnapshots. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.storage.snapshot.v1beta1.VolumeSnapshot"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string",
          "enum": ["VolumeSnapshotList"]
        },
        "metadata": {
          "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "snapshot.storage.k8s.io",
          "kind": "VolumeSnapshotList",
          "version": "v1beta1"
        }
      ]
    },
    "dev.kpt.v1.Function": {
      "properties": {
        "configMap": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "`ConfigMap` is a convenient way to specify a function config of kind ConfigMap.",
          "type": "object",
          "x-go-name": "ConfigMap"
        },
        "configPath": {
          "description": "`ConfigPath` specifies a slash-delimited relative path to a file in the current directory\ncontaining a KRM resource used as the function config. This resource is\nexcluded when resolving 'sources', and as a result cannot be operated on\nby the pipeline.",
          "type": "string",
          "x-go-name": "ConfigPath"
        },
        "exclude": {
          "description": "`Exclude` are used to specify resources on which the function should NOT be executed.\nIf not specified, all resources selected by `Selectors` are selected.",
          "items": {
            "$ref": "#/definitions/dev.kpt.v1.Selector"
          },
          "type": "array",
          "x-go-name": "Exclusions"
        },
        "exec": {
          "description": "Exec specifies the function binary executable.\nThe executable can be fully qualified or it must exists in the $PATH e.g:\n\nexec: set-namespace\nexec: /usr/local/bin/my-custom-fn",
          "type": "string",
          "x-go-name": "Exec"
        },
        "image": {
          "description": "`Image` specifies the function container image.\nIt can either be fully qualified, e.g.:\n\nimage: gcr.io/kpt-fn/set-labels\n\nOptionally, kpt can be configured to use a image\nregistry host-path that will be used to resolve the image path in case\nthe image path is missing (Defaults to gcr.io/kpt-fn).\ne.g. The following resolves to gcr.io/kpt-fn/set-labels:\n\nimage: set-labels",
          "type": "string",
          "x-go-name": "Image"
        },
        "name": {
          "description": "`Name` is used to uniquely identify the function declaration\nthis is primarily used for merging function declaration with upstream counterparts",
          "type": "string",
          "x-go-name": "Name"
        },
        "selectors": {
          "description": "`Selectors` are used to specify resources on which the function should be executed\nif not specified, all resources are selected",
          "items": {
            "$ref": "#/definitions/dev.kpt.v1.Selector"
          },
          "type": "array",
          "x-go-name": "Selectors"
        }
      },
      "title": "Function specifies a KRM function.",
      "type": "object",
      "x-go-package": "github.com/GoogleContainerTools/kpt-functions-sdk/go/api/kptfile/v1"
    },
    "dev.kpt.v1.Git": {
      "properties": {
        "directory": {
          "description": "Directory is the sub directory of the git repository.\ne.g. 'staging/cockroachdb'",
          "type": "string",
          "x-go-name": "Directory"
        },
        "ref": {
          "description": "Ref can be a Git branch, tag, or a commit SHA-1.",
          "type": "string",
          "x-go-name": "Ref"
        },
        "repo": {
          "description": "Repo is the git repository the package.\ne.g. 'https://github.com/kubernetes/examples.git'",
          "type": "string",
          "x-go-name": "Repo"
        }
      },
      "title": "Git is the user-specified locator for a package on Git.",
      "type": "object",
      "x-go-package": "github.com/GoogleContainerTools/kpt-functions-sdk/go/api/kptfile/v1"
    },
    "dev.kpt.v1.GitLock": {
      "properties": {
        "commit": {
          "description": "Commit is the SHA-1 for the last fetch of the package.\nThis is set by kpt for bookkeeping purposes.",
          "type": "string",
          "x-go-name": "Commit"
        },
        "directory": {
          "description": "Directory is the sub directory of the git repository that was fetched.\ne.g. 'staging/cockroachdb'",
          "type": "string",
          "x-go-name": "Directory"
        },
        "ref": {
          "description": "Ref can be a Git branch, tag, or a commit SHA-1 that was fetched.\ne.g. 'master'",
          "type": "string",
          "x-go-name": "Ref"
        },
        "repo": {
          "description": "Repo is the git repository that was fetched.\ne.g. 'https://github.com/kubernetes/examples.git'",
          "type": "string",
          "x-go-name": "Repo"
        }
      },
      "title": "GitLock is the resolved locator for a package on Git.",
      "type": "object",
      "x-go-package": "github.com/GoogleContainerTools/kpt-functions-sdk/go/api/kptfile/v1"
    },
    "dev.kpt.v1.Inventory": {
      "description": "All of the the parameters are required if any are set.",
      "properties": {
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "x-go-name": "Annotations"
        },
        "inventoryID": {
          "description": "Unique label to identify inventory resource in cluster.",
          "type": "string",
          "x-go-name": "InventoryID"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "x-go-name": "Labels"
        },
        "name": {
          "description": "Name of the inventory resource.",
          "type": "string",
          "x-go-name": "Name"
        },
        "namespace": {
          "description": "Namespace for the inventory resource.",
          "type": "string",
          "x-go-name": "Namespace"
        }
      },
      "title": "Inventory encapsulates the parameters for the inventory resource applied to a cluster.",
      "type": "object",
      "x-go-package": "github.com/GoogleContainerTools/kpt-functions-sdk/go/api/kptfile/v1"
    },
    "dev.kpt.v1.NameMeta": {
      "properties": {
        "name": {
          "description": "Name is the metadata.name field of a Resource",
          "type": "string",
          "x-go-name": "Name"
        },
        "namespace": {
          "description": "Namespace is the metadata.namespace field of a Resource",
          "type": "string",
          "x-go-name": "Namespace"
        }
      },
      "title": "NameMeta contains name information.",
      "type": "object",
      "x-go-package": "github.com/GoogleContainerTools/kpt-functions-sdk/go/api/kptfile/v1"
    },
    "dev.kpt.v1.ObjectMeta": {
      "description": "ObjectMeta contains metadata about a Resource",
      "properties": {
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Annotations is the metadata.annotations field of a Resource.",
          "type": "object",
          "x-go-name": "Annotations"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels is the metadata.labels field of a Resource",
          "type": "object",
          "x-go-name": "Labels"
        },
        "name": {
          "description": "Name is the metadata.name field of a Resource",
          "type": "string",
          "x-go-name": "Name"
        },
        "namespace": {
          "description": "Namespace is the metadata.namespace field of a Resource",
          "type": "string",
          "x-go-name": "Namespace"
        }
      },
      "type": "object",
      "x-go-package": "github.com/GoogleContainerTools/kpt-functions-sdk/go/api/kptfile/v1"
    },
    "dev.kpt.v1.OriginType": {
      "title": "OriginType defines the type of origin for a package.",
      "type": "string",
      "x-go-package": "github.com/GoogleContainerTools/kpt-functions-sdk/go/api/kptfile/v1"
    },
    "dev.kpt.v1.PackageInfo": {
      "description": "These fields are not consumed by any functionality in kpt and are simply passed through.\nNote that like any other KRM resource, humans and automation can also use `metadata.labels` and\n`metadata.annotations` as the extension mechanism.",
      "properties": {
        "description": {
          "description": "Description contains a short description of the package.",
          "type": "string",
          "x-go-name": "Description"
        },
        "emails": {
          "description": "Email is the list of emails for the package authors.",
          "items": {
            "type": "string"
          },
          "type": "array",
          "x-go-name": "Emails"
        },
        "keywords": {
          "description": "Keywords is a list of keywords for this package.",
          "items": {
            "type": "string"
          },
          "type": "array",
          "x-go-name": "Keywords"
        },
        "license": {
          "description": "SPDX license identifier (e.g. \"Apache-2.0\"). See: https://spdx.org/licenses/",
          "type": "string",
          "x-go-name": "License"
        },
        "licenseFile": {
          "description": "Relative slash-delimited path to the license file (e.g. LICENSE.txt)",
          "type": "string",
          "x-go-name": "LicenseFile"
        },
        "man": {
          "description": "Man is the path to documentation about the package",
          "type": "string",
          "x-go-name": "Man"
        },
        "site": {
          "description": "Site is the URL for package web page.",
          "type": "string",
          "x-go-name": "Site"
        }
      },
      "title": "PackageInfo contains optional information about the package such as license, documentation, etc.",
      "type": "object",
      "x-go-package": "github.com/GoogleContainerTools/kpt-functions-sdk/go/api/kptfile/v1"
    },
    "dev.kpt.v1.Pipeline": {
      "properties": {
        "mutators": {
          "description": "Mutators defines a list of of KRM functions that mutate resources.",
          "items": {
            "$ref": "#/definitions/dev.kpt.v1.Function"
          },
          "type": "array",
          "x-go-name": "Mutators"
        },
        "validators": {
          "description": "Validators defines a list of KRM functions that validate resources.\nValidators are not permitted to mutate resources.",
          "items": {
            "$ref": "#/definitions/dev.kpt.v1.Function"
          },
          "type": "array",
          "x-go-name": "Validators"
        }
      },
      "title": "Pipeline declares a pipeline of functions used to mutate or validate resources.",
      "type": "object",
      "x-go-package": "github.com/GoogleContainerTools/kpt-functions-sdk/go/api/kptfile/v1"
    },
    "dev.kpt.v1.ResourceMeta": {
      "properties": {
        "apiVersion": {
          "description": "APIVersion is the apiVersion field of a Resource",
          "type": "string",
          "x-go-name": "APIVersion"
        },
        "kind": {
          "description": "Kind is the kind field of a Resource",
          "type": "string",
          "x-go-name": "Kind"
        },
        "metadata": {
          "$ref": "#/definitions/dev.kpt.v1.ObjectMeta"
        }
      },
      "title": "ResourceMeta contains the metadata for a both Resource Type and Resource.",
      "type": "object",
      "x-go-package": "github.com/GoogleContainerTools/kpt-functions-sdk/go/api/kptfile/v1"
    },
    "dev.kpt.v1.Selector": {
      "description": "Selector specifies the selection criteria\nplease update IsEmpty method if more properties are added",
      "properties": {
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Annotations on the target resources",
          "type": "object",
          "x-go-name": "Annotations"
        },
        "apiVersion": {
          "description": "APIVersion of the target resources",
          "type": "string",
          "x-go-name": "APIVersion"
        },
        "kind": {
          "description": "Kind of the target resources",
          "type": "string",
          "x-go-name": "Kind"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels on the target resources",
          "type": "object",
          "x-go-name": "Labels"
        },
        "name": {
          "description": "Name of the target resources",
          "type": "string",
          "x-go-name": "Name"
        },
        "namespace": {
          "description": "Namespace of the target resources",
          "type": "string",
          "x-go-name": "Namespace"
        }
      },
      "type": "object",
      "x-go-package": "github.com/GoogleContainerTools/kpt-functions-sdk/go/api/kptfile/v1"
    },
    "dev.kpt.v1.TypeMeta": {
      "description": "TypeMeta partially copies apimachinery/pkg/apis/meta/v1.TypeMeta\nNo need for a direct dependence; the fields are stable.",
      "properties": {
        "apiVersion": {
          "description": "APIVersion is the apiVersion field of a Resource",
          "type": "string",
          "x-go-name": "APIVersion"
        },
        "kind": {
          "description": "Kind is the kind field of a Resource",
          "type": "string",
          "x-go-name": "Kind"
        }
      },
      "type": "object",
      "x-go-package": "github.com/GoogleContainerTools/kpt-functions-sdk/go/api/kptfile/v1"
    },
    "dev.kpt.v1.UpdateStrategyType": {
      "title": "UpdateStrategyType defines the strategy for updating a package from upstream.",
      "type": "string",
      "x-go-package": "github.com/GoogleContainerTools/kpt-functions-sdk/go/api/kptfile/v1"
    },
    "dev.kpt.v1.Upstream": {
      "properties": {
        "git": {
          "$ref": "#/definitions/dev.kpt.v1.Git"
        },
        "type": {
          "$ref": "#/definitions/dev.kpt.v1.OriginType"
        },
        "updateStrategy": {
          "$ref": "#/definitions/dev.kpt.v1.UpdateStrategyType"
        }
      },
      "title": "Upstream is a user-specified upstream locator for a package.",
      "type": "object",
      "x-go-package": "github.com/GoogleContainerTools/kpt-functions-sdk/go/api/kptfile/v1"
    },
    "dev.kpt.v1.UpstreamLock": {
      "properties": {
        "git": {
          "$ref": "#/definitions/dev.kpt.v1.GitLock"
        },
        "type": {
          "$ref": "#/definitions/dev.kpt.v1.OriginType"
        }
      },
      "title": "UpstreamLock is a resolved locator for the last fetch of the package.",
      "type": "object",
      "x-go-package": "github.com/GoogleContainerTools/kpt-functions-sdk/go/api/kptfile/v1"
    },
    "dev.kpt.v1.kptfile": {
      "properties": {
        "apiVersion": {
          "description": "APIVersion is the apiVersion field of a Resource",
          "type": "string",
          "x-go-name": "APIVersion",
          "enum": ["kpt.dev/v1"]
        },
        "info": {
          "$ref": "#/definitions/dev.kpt.v1.PackageInfo"
        },
        "inventory": {
          "$ref": "#/definitions/dev.kpt.v1.Inventory"
        },
        "kind": {
          "description": "Kind is the kind field of a Resource",
          "type": "string",
          "x-go-name": "Kind",
          "enum": ["Kptfile"]
        },
        "metadata": {
          "$ref": "#/definitions/dev.kpt.v1.ObjectMeta"
        },
        "pipeline": {
          "$ref": "#/definitions/dev.kpt.v1.Pipeline"
        },
        "upstream": {
          "$ref": "#/definitions/dev.kpt.v1.Upstream"
        },
        "upstreamLock": {
          "$ref": "#/definitions/dev.kpt.v1.UpstreamLock"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "kpt.dev",
          "kind": "Kptfile",
          "version": "v1"
        }
      ],
      "title": "KptFile contains information about a package managed with kpt.",
      "type": "object",
      "x-go-name": "KptFile",
      "x-go-package": "github.com/GoogleContainerTools/kpt-functions-sdk/go/api/kptfile/v1"
    }
  }
}
