package gcpdraw

import (
	"fmt"
	"io"
	"strings"

	svg "github.com/ajstarks/svgo"
)

const (
	svgScale                   = 2.0
	svgFontFamily              = "Roboto"
	svgPathStartId             = "path-arrow-start"
	svgPathEndId               = "path-arrow-end"
	svgDropShadowId            = "drop-shadow"
	svgLineArrowWidth          = 7.0
	svgLineArrowHeight         = 3.0
	svgHeaderTextOffsetX       = 24
	svgHeaderTextOffsetY       = 13
	svgHeaderTextFontSize      = 8.5
	svgGroupNameFontSize       = 7.5
	svgCardDisplayNameFontSize = 7.0
	svgCardNameFontSize        = 7.5
	svgCardDescriptionFontSize = 6.5
	svgCardDisplayNameHeight   = 8.0
	svgCardSeparatorSpace      = 3.0
	svgPathAnnotationFontSize  = 7.0
	svgCardBorderWidth         = 0.06
)

var (
	svgGcpIconSize         = Size{80.0, 30.0}
	svgGroupIconSize       = Size{10.0, 10.0}
	svgGroupIconOffset     = Offset{2.0, 5.0}
	svgCardSeparatorOffset = Offset{32, 28}
	svgCardSeparatorMargin = Margin{0, 0, 3.0, 0}
)

// svgStyle is a utility for composing style for SVG tag
type svgStyle struct {
	m map[string]string
}

func newSvgStyle() *svgStyle {
	return &svgStyle{
		m: make(map[string]string),
	}
}

func (s *svgStyle) fontFamily(family string) *svgStyle {
	s.m["font-family"] = family
	return s
}

func (s *svgStyle) fontSize(size float64) *svgStyle {
	s.m["font-size"] = fmt.Sprintf("%0.1fpx", size)
	return s
}

func (s *svgStyle) fill(color Color) *svgStyle {
	s.m["fill"] = color.ToCssRgb()
	return s
}

func (s *svgStyle) fillNone() *svgStyle {
	s.m["fill"] = "none"
	return s
}

func (s *svgStyle) stroke(color Color) *svgStyle {
	s.m["stroke"] = color.ToCssRgb()
	return s
}

func (s *svgStyle) strokeWidth(width float64) *svgStyle {
	s.m["stroke-Width"] = fmt.Sprintf("%0.2f", width)
	return s
}

func (s *svgStyle) dominantBaseline(baseline string) *svgStyle {
	s.m["dominant-baseline"] = baseline
	return s
}

func (s *svgStyle) strokeDashArray(array string) *svgStyle {
	s.m["stroke-dasharray"] = array
	return s
}

func (s *svgStyle) startPathArrow() *svgStyle {
	s.m["marker-start"] = fmt.Sprintf("url(#%s)", svgPathStartId)
	return s
}

func (s *svgStyle) endPathArrow() *svgStyle {
	s.m["marker-end"] = fmt.Sprintf("url(#%s)", svgPathEndId)
	return s
}

func (s *svgStyle) dropShadow() *svgStyle {
	s.m["filter"] = fmt.Sprintf("url(#%s)", svgDropShadowId)
	return s
}

func (s *svgStyle) toCSS() string {
	var css string
	for k, v := range s.m {
		css += fmt.Sprintf("%s:%s;", k, v)
	}
	return css
}

// SvgRenderer implements Renderer
type SvgRenderer struct {
	canvas *svg.SVG
	// disableDropShadow disables drop shadow for cards, which prevents Chrome from having high CPU usage: b/160386809.
	disableDropShadow bool
}

var _ Renderer = (*SvgRenderer)(nil)

func NewSvgRenderer(out io.Writer, size Size, diagramText string, disableDropShadow bool) *SvgRenderer {
	canvas := svg.New(out)

	// set size
	canvasSize := Size{size.Width, size.Height}
	canvas.Startview(int(canvasSize.Width)*svgScale, int(canvasSize.Height)*svgScale, 0, 0, int(canvasSize.Width), int(canvasSize.Height))

	canvas.Def()
	{
		// font
		canvas.Style("text/css", fmt.Sprintf("@import url('https://fonts.googleapis.com/css?family=%s');", svgFontFamily))

		// path arrow definition
		canvas.Marker(svgPathStartId, svgLineArrowWidth, svgLineArrowHeight, svgLineArrowWidth, svgLineArrowHeight*2, "orient='auto'")
		canvas.Path(fmt.Sprintf("M0,%d L%d,0 V%d Z", int(svgLineArrowHeight), int(svgLineArrowWidth), int(svgLineArrowHeight*2)), newSvgStyle().fill(pathColor).toCSS())
		canvas.MarkerEnd()
		canvas.Marker(svgPathEndId, 0, svgLineArrowHeight, svgLineArrowWidth, svgLineArrowHeight*2, "orient='auto'")
		canvas.Path(fmt.Sprintf("M0,0 V%d L%d,%d Z", int(svgLineArrowHeight*2), int(svgLineArrowWidth), int(svgLineArrowHeight)), newSvgStyle().fill(pathColor).toCSS())
		canvas.MarkerEnd()

		// drop shadow
		canvas.Filter(svgDropShadowId)
		canvas.FeGaussianBlur(svg.Filterspec{"SourceAlpha", "", "baseShadow"}, 0.7, 0.7)
		canvas.FeOffset(svg.Filterspec{"baseShadow", "", "offsetBlur"}, 0, 1)
		canvas.FeFlood(svg.Filterspec{"baseShadow", "", "shadowColor"}, "", 0, "flood-color='rgba(0,0,0,0.3)'")
		canvas.FeComposite(svg.Filterspec{"offsetBlur", "shadowColor", "dropShadow"}, "in", 0, 0, 0, 0)
		canvas.FeMerge([]string{"dropShadow", "SourceGraphic"})
		canvas.Fend()
	}
	canvas.DefEnd()

	// Embed diagram code into svg
	canvas.Desc(fmt.Sprintf("# Generated by go/gcpdraw\n%s", diagramText))

	return &SvgRenderer{
		canvas:            canvas,
		disableDropShadow: disableDropShadow,
	}
}

func (r *SvgRenderer) RenderHeader(offset Offset, size Size, title string) error {
	r.canvas.Rect(int(offset.X), int(offset.Y), int(size.Width), int(size.Height), newSvgStyle().fill(headerColor).dropShadow().toCSS())
	r.canvas.Text(int(offset.X+svgHeaderTextOffsetX), int(offset.Y+svgHeaderTextOffsetY), title,
		newSvgStyle().fontFamily(svgFontFamily).fontSize(svgHeaderTextFontSize).fill(headerTextColor).toCSS())
	return nil
}

func (r *SvgRenderer) RenderFooter(offset Offset, size Size) error {
	r.canvas.Rect(int(offset.X), int(offset.Y), int(size.Width), int(size.Height), newSvgStyle().fill(footerColor).toCSS())
	return nil
}

func (r *SvgRenderer) RenderGCPBackground(id string, offset Offset, size Size) error {
	iconOffset := offset.addOffset(gcpIconOffset)
	// render background rectangle
	r.canvas.Rect(int(offset.X), int(offset.Y), int(size.Width), int(size.Height),
		newSvgStyle().fill(gcpBackgroundColor).toCSS())
	// render icon
	r.canvas.Image(int(iconOffset.X), int(iconOffset.Y),
		int(svgGcpIconSize.Width), int(svgGcpIconSize.Height), GetCardConfig(gcpConfigId).IconUrl)
	return nil
}

func (r *SvgRenderer) RenderGroupBackground(id string, offset Offset, size Size, name, iconURL string, bgColor Color) error {
	nameOffset := offset.addOffset(groupNameOffset)
	// Render background rectangle
	r.canvas.Rect(int(offset.X), int(offset.Y), int(size.Width), int(size.Height), newSvgStyle().fill(bgColor).toCSS())

	// Render icon
	if iconURL != "" {
		iconOffset := offset.addOffset(svgGroupIconOffset)
		nameOffset = nameOffset.add(svgGroupIconSize.Width, 0)
		r.canvas.Image(int(iconOffset.X), int(iconOffset.Y), int(svgGroupIconSize.Width), int(svgGroupIconSize.Height), iconURL)
	}

	// Render text
	r.canvas.Text(int(nameOffset.X), int(nameOffset.Y), name,
		newSvgStyle().fontFamily(svgFontFamily).fontSize(svgGroupNameFontSize).fill(groupTextColor).dominantBaseline("central").toCSS())
	return nil
}

func (r *SvgRenderer) RenderStackedCard(id string, offset Offset, size Size) error {
	// render rectangle
	style := newSvgStyle().fill(cardColor).stroke(cardBorderColor).strokeWidth(svgCardBorderWidth)
	if !r.disableDropShadow {
		style.dropShadow()
	}
	r.canvas.Rect(int(offset.X), int(offset.Y), int(size.Width), int(size.Height), style.toCSS())
	return nil
}

func (r *SvgRenderer) RenderCard(id string, offset Offset, size Size, displayName, name, description, iconURL string) error {
	iconOffset := offset.add(cardIconMargin.Left, cardIconMargin.Top)

	// render rectangle
	style := newSvgStyle().fill(cardColor).stroke(cardBorderColor).strokeWidth(svgCardBorderWidth)
	if !r.disableDropShadow {
		style.dropShadow()
	}
	r.canvas.Rect(int(offset.X), int(offset.Y), int(size.Width), int(size.Height), style.toCSS())

	// render icon
	r.canvas.Image(int(iconOffset.X), int(iconOffset.Y),
		int(cardIconSize.Width), int(cardIconSize.Height), iconURL)

	if name != "" {
		// render name
		nameOffset := iconOffset.add(cardIconSize.Width+cardIconMargin.Right, cardNameMargin.Top)
		r.canvas.Text(int(nameOffset.X), int(nameOffset.Y), name,
			newSvgStyle().fontFamily(svgFontFamily).fontSize(svgCardNameFontSize).fill(cardNameColor).dominantBaseline("text-before-edge").toCSS())

		// render display name
		displayNameOffset := nameOffset.add(0, cardDisplayNameMargin.Top)
		r.canvas.Text(int(displayNameOffset.X), int(displayNameOffset.Y), displayName,
			newSvgStyle().fontFamily(svgFontFamily).fontSize(svgCardDisplayNameFontSize).fill(cardDisplayNameColor).dominantBaseline("text-before-edge").toCSS())
	} else {
		// render display name
		// Since SVG doesn't support multi-line textarea like <textarea>,
		// we need to separate the display name by appropriate length and render multiple lines one by one
		words := strings.Split(displayName, " ")
		offsetY := (size.Height - float64(len(words))*svgCardDisplayNameHeight) / 2.0
		for i, word := range words {
			// align center
			nameOffset := iconOffset.add(cardIconSize.Width+cardIconMargin.Right, 0)
			nameOffset.Y = offset.Y + offsetY + svgCardDisplayNameHeight*float64(i)
			r.canvas.Text(int(nameOffset.X), int(nameOffset.Y), word,
				newSvgStyle().fontFamily(svgFontFamily).fontSize(svgCardDisplayNameFontSize).fill(cardDisplayNameColor).dominantBaseline("text-before-edge").toCSS())
		}
	}

	if description != "" {
		// render separator
		separatorWidth := size.Width - (cardIconMargin.Left + cardIconSize.Width + cardIconMargin.Right) - svgCardSeparatorSpace
		separatorOffset := offset.addOffset(svgCardSeparatorOffset)
		r.canvas.Line(int(separatorOffset.X), int(separatorOffset.Y), int(separatorOffset.X+separatorWidth), int(separatorOffset.Y),
			newSvgStyle().stroke(cardSeparatorColor).strokeWidth(0.8).toCSS())

		// render description text
		descriptionOffset := separatorOffset.add(0, svgCardSeparatorMargin.Bottom)
		r.canvas.Text(int(descriptionOffset.X), int(descriptionOffset.Y), description,
			newSvgStyle().fontFamily(svgFontFamily).fontSize(svgCardDescriptionFontSize).fill(cardDescriptionColor).dominantBaseline("text-before-edge").toCSS())
	}
	return nil
}

func (r *SvgRenderer) RenderPath(path *Path, route Route, _, _ Element) error {
	style := newSvgStyle()

	// arrow
	if path.StartArrow == LineArrowFill {
		style.startPathArrow()
	}
	if path.EndArrow == LineArrowFill {
		style.endPathArrow()
	}

	// dotted-line
	if path.Dash == LineDashDot {
		style.strokeDashArray("1,2")
	}

	var xs, ys []int
	for i := 0; i < len(route.Points); i++ {
		p := route.Points[i]

		if i == 0 && path.StartArrow == LineArrowFill { // src point
			nextP := route.Points[i+1]
			if p.X == nextP.X {
				xs = append(xs, int(p.X))
				if p.Y < nextP.Y {
					ys = append(ys, int(p.Y+svgLineArrowWidth))
				} else {
					ys = append(ys, int(p.Y-svgLineArrowWidth))
				}
			} else {
				ys = append(ys, int(p.Y))
				if p.X < nextP.X {
					xs = append(xs, int(p.X+svgLineArrowWidth))
				} else {
					xs = append(xs, int(p.X-svgLineArrowWidth))
				}
			}
		} else if i == len(route.Points)-1 && path.EndArrow == LineArrowFill { // dst point
			prevP := route.Points[i-1]
			if p.X == prevP.X {
				xs = append(xs, int(p.X))
				if p.Y < prevP.Y {
					ys = append(ys, int(p.Y+svgLineArrowWidth))
				} else {
					ys = append(ys, int(p.Y-svgLineArrowWidth))
				}
			} else {
				ys = append(ys, int(p.Y))
				if p.X < prevP.X {
					xs = append(xs, int(p.X+svgLineArrowWidth))
				} else {
					xs = append(xs, int(p.X-svgLineArrowWidth))
				}
			}
		} else {
			xs = append(xs, int(p.X))
			ys = append(ys, int(p.Y))
		}
	}

	r.canvas.Polyline(xs, ys, style.fillNone().stroke(pathColor).toCSS())
	return nil
}

func (r *SvgRenderer) Finalize() error {
	r.canvas.End()
	return nil
}
