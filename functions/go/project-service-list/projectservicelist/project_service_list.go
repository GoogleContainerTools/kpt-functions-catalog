package projectservicelist

import (
	"fmt"

	"sigs.k8s.io/kustomize/kyaml/kio/kioutil"
	"sigs.k8s.io/kustomize/kyaml/yaml"
)

const (
	projectServiceListKind       = "ProjectServiceList"
	projectServiceListAPIVersion = "blueprints.cloud.google.com/v1alpha1"
	serviceUsageAPIVersion       = "serviceusage.cnrm.cloud.google.com/v1beta1"
	serviceUsageKind             = "Service"
	managedByAnnotation          = "blueprints.cloud.google.com/managed-by-project-services-list"
)

// ProjectServiceList is the functionConfig for generating services
type ProjectServiceList struct {
	yaml.ResourceMeta `json:",inline" yaml:",inline"`
	Spec              struct {
		Services  []string `json:"services" yaml:"services"`
		ProjectID string   `json:"projectID,omitempty" yaml:"projectID,omitempty"`
	} `json:"spec" yaml:"spec"`
	results []Result
}

// Result represents an action performed by ProjectServiceList on a resource
type Result struct {
	ResourceRef yaml.ResourceIdentifier
	FilePath    string
	Action      string
}

// Filter implements ProjectServiceList as a yaml.Filter
func (ps *ProjectServiceList) Filter(nodes []*yaml.RNode) ([]*yaml.RNode, error) {
	// validate ProjectServiceList
	err := ps.validate()
	if err != nil {
		return nodes, err
	}

	// prune any previously generated services
	nodes, err = ps.pruneGeneratedServices(nodes)
	if err != nil {
		return nodes, err
	}
	// newServiceNodes contains new services generated by ProjectServiceList
	newServiceNodes, err := ps.getServiceRNodes()
	if err != nil {
		return nil, err
	}

	// add any new generated serviceNodes
	return append(nodes, newServiceNodes...), nil
}

func (ps ProjectServiceList) validate() error {
	if ps.APIVersion != projectServiceListAPIVersion {
		return fmt.Errorf("invalid APIVersion: %s supported APIVersion: %s", ps.APIVersion, projectServiceListAPIVersion)
	}
	if ps.Kind != projectServiceListKind {
		return fmt.Errorf("invalid Kind: %s supported Kind: %s", ps.Kind, projectServiceListKind)
	}
	if len(ps.Spec.Services) < 1 {
		return fmt.Errorf("at least one service must be specified under spec.services[]")
	}
	return nil
}

// getServiceRNodes returns generated Service RNodes
func (ps *ProjectServiceList) getServiceRNodes() ([]*yaml.RNode, error) {
	var services []*yaml.RNode
	// get namespace
	ns := ps.GetIdentifier().Namespace
	name := ps.GetIdentifier().Name
	serviceList, err := getServicesList(name, ps.Spec.Services, ps.Spec.ProjectID)
	if err != nil {
		return nil, err
	}
	// generate service resources
	for _, s := range serviceList {
		svc, err := createService(s)
		if err != nil {
			return nil, err
		}
		// add annotations in ProjectServiceList to each service
		for k, v := range ps.ObjectMeta.Annotations {
			if _, err := svc.Pipe(yaml.SetAnnotation(k, v)); err != nil {
				return nil, err
			}
		}
		// add management annotation for state tracking
		if _, err := svc.Pipe(yaml.SetAnnotation(managedByAnnotation, name)); err != nil {
			return nil, err
		}
		// add namespace to service if present
		if ns != "" {
			if _, err := svc.Pipe(yaml.SetK8sNamespace(ns)); err != nil {
				return nil, err
			}
		}

		services = append(services, svc)
		err = ps.addResult("generated service", svc)
		if err != nil {
			return nil, err
		}
	}
	return services, nil
}

// addResult records the action performed on a resource
func (ps *ProjectServiceList) addResult(action string, r *yaml.RNode) error {
	meta, err := r.GetMeta()
	if err != nil {
		return err
	}
	fp, _, err := kioutil.GetFileAnnotations(r)
	if err != nil {
		return err
	}
	ps.results = append(ps.results, Result{meta.GetIdentifier(), fp, action})
	return nil
}

// GetResults returns operations performed by ProjectServiceList
func (ps *ProjectServiceList) GetResults() []Result {
	return ps.results
}

// isManaged checks is a resource is managed by a the ProjectServiceList
func (ps ProjectServiceList) isManaged(r *yaml.RNode) bool {
	anno := r.GetAnnotations()
	k, found := anno[managedByAnnotation]
	// if no managed annotation found it is not managed
	if !found {
		return false
	}
	return k == ps.Name
}

// pruneGeneratedServices removes resources managed by ProjectServiceList
func (ps *ProjectServiceList) pruneGeneratedServices(nodes []*yaml.RNode) ([]*yaml.RNode, error) {
	n := 0
	for i := range nodes {
		if !ps.isManaged(nodes[i]) {
			nodes[n] = nodes[i]
			n++
		} else {
			err := ps.addResult("pruned service", nodes[i])
			if err != nil {
				return nodes, err
			}
		}
	}
	return nodes[:n], nil
}
