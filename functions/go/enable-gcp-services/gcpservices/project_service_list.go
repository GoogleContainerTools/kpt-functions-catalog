package gcpservices

import (
	"fmt"
	"path"

	"sigs.k8s.io/kustomize/kyaml/kio/kioutil"
	"sigs.k8s.io/kustomize/kyaml/yaml"
)

const (
	projectServiceListKind       = "ProjectServiceList"
	projectServiceListAPIVersion = "blueprints.cloud.google.com/v1alpha1"
	serviceUsageAPIVersion       = "serviceusage.cnrm.cloud.google.com/v1beta1"
	serviceUsageKind             = "Service"
	managedByAnnotation          = "blueprints.cloud.google.com/managed-by-enable-gcp-services"
)

// ignoreAnnotations is used to ignore any annotation that should not be added to generated Service CRs
var ignoreAnnotations = map[string]bool{kioutil.PathAnnotation: true}

// ProjectServiceListRunner discovers ProjectServiceList CRs to generate Service CRs
type ProjectServiceListRunner struct {
	results []Result
}

// ProjectServiceList is the functionConfig for generating services
type ProjectServiceList struct {
	yaml.ResourceMeta `json:",inline" yaml:",inline"`
	Spec              struct {
		Services  []string `json:"services" yaml:"services"`
		ProjectID string   `json:"projectID,omitempty" yaml:"projectID,omitempty"`
	} `json:"spec" yaml:"spec"`
	results []Result
}

// Result represents an action performed by ProjectServiceList on a resource
type Result struct {
	ResourceRef yaml.ResourceIdentifier
	FilePath    string
	Action      string
}

// Filter implements ProjectServiceListRunner as a yaml.Filter
func (r *ProjectServiceListRunner) Filter(nodes []*yaml.RNode) ([]*yaml.RNode, error) {
	// discover all ProjectServiceList CRs
	psls, err := getProjectServiceLists(nodes)
	if err != nil {
		return nodes, err
	}
	generatedNodes := make([]*yaml.RNode, 0)
	for _, psl := range psls {
		// validate ProjectServiceList
		err = psl.validate()
		if err != nil {
			return nodes, err
		}

		// prune any previously generated services owned by this ProjectServiceList
		nodes, err = psl.pruneGeneratedServices(nodes)
		if err != nil {
			return nodes, err
		}
		// newServiceNodes contains new services generated by ProjectServiceList
		newServiceNodes, err := psl.getServiceRNodes()
		if err != nil {
			return nil, err
		}

		// add any new generated serviceNodes
		generatedNodes = append(generatedNodes, newServiceNodes...)
		r.results = append(r.results, psl.results...)
	}
	return append(nodes, generatedNodes...), nil
}

func (ps ProjectServiceList) validate() error {
	if len(ps.Spec.Services) < 1 {
		return fmt.Errorf("at least one service must be specified under spec.services[]")
	}
	return nil
}

// getProjectServiceLists returns a list of discovered ProjectServiceList CRs
func getProjectServiceLists(nodes []*yaml.RNode) ([]ProjectServiceList, error) {
	psls := make([]ProjectServiceList, 0)
	for _, r := range nodes {
		if isProjectServiceListGVK(r) {
			var psl ProjectServiceList
			rs, err := r.String()
			if err != nil {
				return nil, err
			}
			err = yaml.Unmarshal([]byte(rs), &psl)
			if err != nil {
				return nil, err
			}
			psls = append(psls, psl)
		}
	}
	return psls, nil
}

// isProjectServiceListGVK checks if a given RNode is a ProjectServiceList CR
func isProjectServiceListGVK(r *yaml.RNode) bool {
	if r.GetApiVersion() == projectServiceListAPIVersion && r.GetKind() == projectServiceListKind {
		return true
	}
	return false
}

// getServiceRNodes returns generated Service RNodes
func (ps *ProjectServiceList) getServiceRNodes() ([]*yaml.RNode, error) {
	var services []*yaml.RNode
	// get namespace
	ns := ps.GetIdentifier().Namespace
	name := ps.GetIdentifier().Name
	serviceList, err := getServicesList(name, ps.Spec.Services, ps.Spec.ProjectID)
	if err != nil {
		return nil, err
	}
	// generate service resources
	for _, s := range serviceList {
		svc, err := createService(s)
		if err != nil {
			return nil, err
		}
		// add annotations in ProjectServiceList to each service
		for k, v := range ps.ObjectMeta.Annotations {
			if ignoreAnnotation(k) {
				continue
			}
			if _, err := svc.Pipe(yaml.SetAnnotation(k, v)); err != nil {
				return nil, err
			}
		}
		// add management annotation for state tracking
		if _, err := svc.Pipe(yaml.SetAnnotation(managedByAnnotation, name)); err != nil {
			return nil, err
		}
		// add namespace to service if present
		if ns != "" {
			if _, err := svc.Pipe(yaml.SetK8sNamespace(ns)); err != nil {
				return nil, err
			}
		}
		// add path annotation to generate service in same dir as parent project service list
		svcMeta, err := svc.GetMeta()
		if err != nil {
			return nil, err
		}
		serviceFilePath := kioutil.CreatePathAnnotationValue(path.Dir(ps.ObjectMeta.Annotations[kioutil.PathAnnotation]), svcMeta)
		if _, err := svc.Pipe(yaml.SetAnnotation(kioutil.PathAnnotation, serviceFilePath)); err != nil {
			return nil, err
		}

		services = append(services, svc)
		err = ps.addResult("generated service", svc)
		if err != nil {
			return nil, err
		}
	}
	return services, nil
}

// ignoreAnnotation checks if an annotation on ProjectServiceList should be ignored
func ignoreAnnotation(k string) bool {
	_, ok := ignoreAnnotations[k]
	return ok
}

// addResult records the action performed on a resource
func (ps *ProjectServiceList) addResult(action string, r *yaml.RNode) error {
	meta, err := r.GetMeta()
	if err != nil {
		return err
	}
	fp, _, err := kioutil.GetFileAnnotations(r)
	if err != nil {
		return err
	}
	ps.results = append(ps.results, Result{meta.GetIdentifier(), fp, action})
	return nil
}

// GetResults returns operations performed by ProjectServiceListRunner
func (r *ProjectServiceListRunner) GetResults() []Result {
	return r.results
}

// isManaged checks is a resource is managed by a the ProjectServiceList
func (ps ProjectServiceList) isManaged(r *yaml.RNode) bool {
	anno := r.GetAnnotations()
	k, found := anno[managedByAnnotation]
	// if no managed annotation found it is not managed
	if !found {
		return false
	}
	return k == ps.Name
}

// pruneGeneratedServices removes resources managed by ProjectServiceList
func (ps *ProjectServiceList) pruneGeneratedServices(nodes []*yaml.RNode) ([]*yaml.RNode, error) {
	n := 0
	for i := range nodes {
		if !ps.isManaged(nodes[i]) {
			nodes[n] = nodes[i]
			n++
		} else {
			err := ps.addResult("pruned service", nodes[i])
			if err != nil {
				return nodes, err
			}
		}
	}
	return nodes[:n], nil
}
