package gcpservices

import (
	"fmt"
	"path"
	"strconv"

	"sigs.k8s.io/kustomize/kyaml/fn/framework"
	"sigs.k8s.io/kustomize/kyaml/kio/filters"
	"sigs.k8s.io/kustomize/kyaml/kio/kioutil"
	"sigs.k8s.io/kustomize/kyaml/resid"
	"sigs.k8s.io/kustomize/kyaml/yaml"
)

const (
	projectServiceSetKind       = "ProjectServiceSet"
	projectServiceSetGroup      = "blueprints.cloud.google.com"
	projectServiceSetVersion    = "v1alpha1"
	projectServiceSetAPIVersion = projectServiceSetGroup + "/" + projectServiceSetVersion
	serviceUsageAPIVersion      = "serviceusage.cnrm.cloud.google.com/v1beta1"
	serviceUsageKind            = "Service"
	managedByAnnotation         = "blueprints.cloud.google.com/ownerReference"
)

// ignoreAnnotations is used to ignore any annotation that should not be added to generated Service CRs
var ignoreAnnotations = map[string]bool{kioutil.PathAnnotation: true, filters.LocalConfigAnnotation: true}

// ProjectServiceSetRunner discovers ProjectServiceSet CRs to generate Service CRs
type ProjectServiceSetRunner struct {
	results []framework.ResultItem
}

// ProjectServiceSet is the functionConfig for generating services
type ProjectServiceSet struct {
	yaml.ResourceMeta `json:",inline" yaml:",inline"`
	Spec              projectServiceSetSpec `json:"spec" yaml:"spec"`
	prunedServices    map[string]framework.ResultItem
	generatedServices map[string]framework.ResultItem
}

type projectServiceSetSpec struct {
	Services  []string `json:"services" yaml:"services"`
	ProjectID string   `json:"projectID,omitempty" yaml:"projectID,omitempty"`
}

// actionType represents the action performed on a resource
type actionType string

func (a actionType) String() string {
	return string(a)
}

const (
	generateAction actionType = "generated service"
	pruneAction    actionType = "pruned service"
	recreateAction actionType = "recreated service"
)

// Filter implements ProjectServiceSetRunner as a yaml.Filter
func (r *ProjectServiceSetRunner) Filter(nodes []*yaml.RNode) ([]*yaml.RNode, error) {
	// discover all ProjectServiceSet CRs
	psls, err := getProjectServiceSets(nodes)
	if err != nil {
		return nodes, err
	}
	generatedNodes := make([]*yaml.RNode, 0)
	for _, psl := range psls {
		// validate ProjectServiceSet
		err = psl.validate()
		if err != nil {
			return nodes, err
		}

		// prune any previously generated services owned by this ProjectServiceSet
		nodes, err = psl.pruneGeneratedServices(nodes)
		if err != nil {
			return nodes, err
		}
		// newServiceNodes contains new services generated by ProjectServiceSet
		newServiceNodes, err := psl.getServiceRNodes()
		if err != nil {
			return nil, err
		}

		// add any new generated serviceNodes
		generatedNodes = append(generatedNodes, newServiceNodes...)
		r.results = append(r.results, psl.getResults()...)
	}
	return append(nodes, generatedNodes...), nil
}

func (ps ProjectServiceSet) validate() error {
	if len(ps.Spec.Services) < 1 {
		return fmt.Errorf("at least one service must be specified under spec.services[]")
	}
	val, found := ps.Annotations[filters.LocalConfigAnnotation]
	if !found {
		return fmt.Errorf("%s annotation must be set", filters.LocalConfigAnnotation)
	}
	v, err := strconv.ParseBool(val)
	if err != nil {
		return fmt.Errorf("error parsing %s annotation: %v", filters.LocalConfigAnnotation, err)
	}
	if !v {
		return fmt.Errorf("%s annotation must be set to true", filters.LocalConfigAnnotation)
	}
	return nil
}

// getProjectServiceSets returns a list of discovered ProjectServiceSet CRs
func getProjectServiceSets(nodes []*yaml.RNode) ([]ProjectServiceSet, error) {
	psls := make([]ProjectServiceSet, 0)
	for _, r := range nodes {
		if isProjectServiceSetGVK(r) {
			var psl ProjectServiceSet
			rs, err := r.String()
			if err != nil {
				return nil, err
			}
			err = yaml.Unmarshal([]byte(rs), &psl)
			if err != nil {
				return nil, err
			}
			psl.generatedServices = make(map[string]framework.ResultItem)
			psl.prunedServices = make(map[string]framework.ResultItem)
			psls = append(psls, psl)
		}
	}
	return psls, nil
}

// isProjectServiceSetGVK checks if a given RNode is a ProjectServiceSet CR
func isProjectServiceSetGVK(r *yaml.RNode) bool {
	if r.GetApiVersion() == projectServiceSetAPIVersion && r.GetKind() == projectServiceSetKind {
		return true
	}
	return false
}

// getServiceRNodes returns generated Service RNodes
func (ps *ProjectServiceSet) getServiceRNodes() ([]*yaml.RNode, error) {
	var services []*yaml.RNode
	// get namespace
	ns := ps.GetIdentifier().Namespace
	name := ps.GetIdentifier().Name
	serviceList, err := createServicesList(name, ps.Spec.Services, ps.Spec.ProjectID)
	if err != nil {
		return nil, err
	}
	// generate service resources
	for _, s := range serviceList {
		svc, err := createService(s)
		if err != nil {
			return nil, err
		}
		// add annotations in ProjectServiceSet to each service
		for k, v := range ps.ObjectMeta.Annotations {
			if ignoreAnnotation(k) {
				continue
			}
			if _, err := svc.Pipe(yaml.SetAnnotation(k, v)); err != nil {
				return nil, err
			}
		}
		// add management annotation for state tracking
		if _, err := svc.Pipe(yaml.SetAnnotation(managedByAnnotation, path.Join(projectServiceSetGroup, projectServiceSetKind, name))); err != nil {
			return nil, err
		}
		// add namespace to service if present
		if ns != "" {
			if _, err := svc.Pipe(yaml.SetK8sNamespace(ns)); err != nil {
				return nil, err
			}
		}
		// add path annotation to generate service in same dir as parent project service list
		svcMeta, err := svc.GetMeta()
		if err != nil {
			return nil, err
		}
		serviceFilePath := kioutil.CreatePathAnnotationValue(path.Dir(ps.ObjectMeta.Annotations[kioutil.PathAnnotation]), svcMeta)
		if _, err := svc.Pipe(yaml.SetAnnotation(kioutil.PathAnnotation, serviceFilePath)); err != nil {
			return nil, err
		}

		services = append(services, svc)
		err = ps.addResult(generateAction, svc)
		if err != nil {
			return nil, err
		}
	}
	return services, nil
}

// ignoreAnnotation checks if an annotation on ProjectServiceSet should be ignored
func ignoreAnnotation(k string) bool {
	_, ok := ignoreAnnotations[k]
	return ok
}

// addResult records the action performed on a resource
func (ps *ProjectServiceSet) addResult(action actionType, r *yaml.RNode) error {
	meta, err := r.GetMeta()
	if err != nil {
		return err
	}
	fp, _, err := kioutil.GetFileAnnotations(r)
	if err != nil {
		return err
	}

	resID := resid.NewResIdWithNamespace(resid.GvkFromNode(r), meta.Name, meta.Namespace).String()
	result := framework.ResultItem{
		ResourceRef: meta.GetIdentifier(),
		File:        framework.File{Path: fp},
		Message:     action.String(),
		Severity:    framework.Info,
	}
	switch action {
	case pruneAction:
		ps.prunedServices[resID] = result
	case generateAction:
		ps.generatedServices[resID] = result
	}
	return nil
}

// getResults returns operations performed by ProjectServiceSet
func (ps *ProjectServiceSet) getResults() []framework.ResultItem {
	collapsedResults := make([]framework.ResultItem, 0)
	for resid, result := range ps.prunedServices {
		g, recreated := ps.generatedServices[resid]
		// check if a resource was pruned and recreated
		if recreated {
			result.Message = recreateAction.String()
			result.File = g.File
			// delete resource from generated results map
			delete(ps.generatedServices, resid)
		}
		collapsedResults = append(collapsedResults, result)
	}
	for _, result := range ps.generatedServices {
		collapsedResults = append(collapsedResults, result)
	}
	return collapsedResults
}

// GetResults returns operations performed by ProjectServiceSetRunner
func (r *ProjectServiceSetRunner) GetResults() []framework.ResultItem {
	return r.results
}

// isManaged checks is a resource is managed by the ProjectServiceSet
func (ps ProjectServiceSet) isManaged(r *yaml.RNode) bool {
	anno := r.GetAnnotations()
	k, found := anno[managedByAnnotation]
	// if no managed annotation found it is not managed
	if !found {
		return false
	}
	// annotation will be of form Group/Kind/Name
	return k == path.Join(projectServiceSetGroup, projectServiceSetKind, ps.Name)
}

// pruneGeneratedServices removes resources managed by ProjectServiceSet
func (ps *ProjectServiceSet) pruneGeneratedServices(nodes []*yaml.RNode) ([]*yaml.RNode, error) {
	n := 0
	for i := range nodes {
		if !ps.isManaged(nodes[i]) {
			nodes[n] = nodes[i]
			n++
		} else {
			err := ps.addResult(pruneAction, nodes[i])
			if err != nil {
				return nodes, err
			}
		}
	}
	return nodes[:n], nil
}
